// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
/* Author : havep at Thu Apr  2 10:29:37 2009
 * Generated by createNew
 */

#include "ArcGeoSim/Utils/Utils.h"
#include "ArcGeoSim/Appli/AppService.h"
#include "ArcGeoSim/Physics/Units/IUnitsSystem.h"
#include "ArcGeoSim/Time/ITimeLine.h"
#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"
#include "ArcGeoSim/Numerics/Expressions/IExpressionMng.h"
#include "ArcGeoSim/Time/ITimeStepComputer.h"

#include "DemonstratorModule.h"

#include <arcane/ITimeLoopMng.h>
#include <arcane/ITimeLoop.h>
#include <arcane/utils/PlatformUtils.h>
#include <arcane/Connectivity.h>
#include <arcane/IMesh.h>
#include <arcane/IInitialPartitioner.h>
#include <arcane/IMeshPartitioner.h>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

DemonstratorModule::DemonstratorModule(const Arcane::ModuleBuildInfo& mbi)
: ArcaneDemonstratorObject(mbi)
, IAppServiceMng()
, m_initialized(false)
, m_forecast_compute(false)
, m_max_iteration(-1)
, m_geometry_mng(NULL)
, m_geometry_policy(NULL)
, m_post_processing(mbi.m_sub_domain,"Demonstrator") {}

/*---------------------------------------------------------------------------*/

DemonstratorModule::~DemonstratorModule()
{
  delete m_geometry_policy;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
DemonstratorModule::initializeAppServiceMng()
{
  if (m_initialized)
    return;
  info() << "Initializing Demonstrator";

  addOptionalService(options()->timeManager,"Time Line");
  addOptionalService(options()->timeStepPolicy,"Time Step Policy");
  addOptionalService(options()->geometry,"Geometry");
  addOptionalService(options()->unitsSystem,"Units system");
  addOptionalService(options()->expressionMng,"Expression Manager");

  m_max_iteration = options()->maxIteration();

  m_initialized = true;
}

/*---------------------------------------------------------------------------*/

void
DemonstratorModule::build()
{
  // For tests using evolutive mesh in parallel
  // prepare mesh distribution with forecast mode
  ITimeLoopMng* tlm = subDomain()->timeLoopMng();
  ITimeLoop * time_loop = tlm->usedTimeLoop();
  m_forecast_compute = (time_loop->name() == "ForecastCompute");
  if (m_forecast_compute || options()->hasEdges() )
    {
      // Prepare connectivity info for worst case : edges included. Can be needed later on
      Arcane::Connectivity c(mesh()->connectivity());
      c.enableConnectivity(Connectivity::CT_HasEdge);
    }
  if ( m_forecast_compute )
  	{
      if (subDomain()->nbSubDomain() > 1)
        fatal() << "Cannot use Forecast mode in a parallel run";
      else
        info() << "Starting Forecast mode";
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
DemonstratorModule::prepareInit()
{
  initializeAppServiceMng();

  m_geometry_mng = IAppServiceMng::find<IGeometryMng>(false);
  if (m_geometry_mng)
    {
      m_geometry_policy = new NoOptimizationGeometryPolicy;
      m_geometry_mng->setPolicyTolerance(true); // Lazy policy :(
    }

  // Le init est fait si le service est trouv�
}

/*---------------------------------------------------------------------------*/

void
DemonstratorModule::init()
{
  initializeAppServiceMng();

  // Initial geometry update
  if (m_geometry_mng != NULL)
    m_geometry_mng->update(m_geometry_policy);

  postProcessingInit();

  // Validators
  for(CaseOptionMultiServiceT<IServiceValidator>::iterator iv = options()->validator.begin();
      iv != options()->validator.end(); ++iv) {
    (*iv)->init();
  }


}

/*---------------------------------------------------------------------------*/

void
DemonstratorModule::
endInit()
{
  CaseOptionsDemonstrator::CaseOptionPostProcessing & post_processing = options()->postProcessing;
  if (post_processing.size() == 0) return;

  if (post_processing[0].saveInit())
    {
      Real current_time = subDomain()->commonVariables().globalTime();
      m_post_processing.saveAtTime(current_time);
    }
}

/*---------------------------------------------------------------------------*/

void
DemonstratorModule::continueInit()
{
  initializeAppServiceMng();
}

/*---------------------------------------------------------------------------*/

void
DemonstratorModule::beginTimeStep()
{
  ARCANE_ASSERT((m_initialized),("Demonstrator not initialized"));
}

/*---------------------------------------------------------------------------*/

void
DemonstratorModule::endTimeStep()
{
  ARCANE_ASSERT((m_initialized),("Demonstrator not initialized"));

  { // Post-processing
    Real current_time = subDomain()->commonVariables().globalTime();
    bool do_output = false;
    if (m_next_iteration() == subDomain()->commonVariables().globalIteration())
      {
        do_output = true;
        if (_hasPostProcessing())
          m_next_iteration = m_next_iteration() + options()->postProcessing[0].outputPeriod();
      }
    if (do_output)
      m_post_processing.saveAtTime(current_time);
  }

  ArcGeoSim::OptionalAppService<ArcGeoSim::ITimeLine> time;
  if ((m_max_iteration > 0 and globalIteration() >= m_max_iteration) 
      or (not time.isAvailable() and m_max_iteration <= 0)) {
    info() << "STOP PERFECT";
    subDomain()->timeLoopMng()->stopComputeLoop(true);
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
DemonstratorModule::updateGeometry()
{
  m_geometry_mng->update(m_geometry_policy);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
DemonstratorModule::
endSimulation()
{
  postProcessingExit();

  _validate();
}

/*---------------------------------------------------------------------------*/

void
DemonstratorModule::
_validate()
{
	 bool hasError = false;

    const Integer count = options()->validator.size();
    for(Integer i=0;i<count;++i) {
      if (options()->validator[i]->validate() != 0) {
        hasError = true;
        perror() << "Demonstrator validator #" << i << " failed";
      }
    }

    if (hasError)
      {
        fatal() << "ArcTem validation failure : read details above";
        info()<<"STOP FAILED";
        subDomain()->timeLoopMng()->stopComputeLoop(false,true);
      }
    else
      {
        info()<<"STOP PERFECT";
        subDomain()->timeLoopMng()->stopComputeLoop(true);
      }

}

/*---------------------------------------------------------------------------*/
/************************ Gestion du post-processing *************************/
/*---------------------------------------------------------------------------*/

void DemonstratorModule::
postProcessingInit()
{
  // Initialisation du post-processing
  CaseOptionsDemonstrator::CaseOptionPostProcessing & post_processing = options()->postProcessing;
  if (post_processing.size() == 0) return;
  // Pas de post-processing si pas de p�riode de sortie
  if (post_processing[0].outputPeriod() <= 0) return;

  String output_path = options()->postProcessing[0].outputPath();
  if (output_path.empty())
    output_path = subDomain()->caseName();
  String full_output_path = ArcGeoSim::getOuputRootPath()+"/"+output_path;
  m_post_processing.init(full_output_path);

  info() << " -------------------------------------------";
  info() << "|         ARCANEDEMO POST TRAITEMENT        |";
  info() << " -------------------------------------------";
  info() << " ";

  info() << "Sorties pour les variables:";
  const CaseOptionsDemonstrator::CaseOptionPostProcessor & post_processors = post_processing[0].postProcessor;
  for(Integer ip=0,np=post_processors.size();ip<np;++ip)
    {
      const CaseOptionsDemonstrator::CaseOptionPostProcessorValue & post_processor = post_processors[ip];
      const CaseOptionsDemonstrator::CaseOptionVariables & variables = post_processor.variables;
      m_post_processing.addPostProcessing(post_processor.format(), variables.variable);
    }
  m_next_iteration = m_next_iteration() + options()->postProcessing[0].outputPeriod();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
DemonstratorModule::
postProcessingStartInit()
{
  m_next_iteration = 0;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

bool
DemonstratorModule::
_hasPostProcessing() const
{
  return (options()->postProcessing().size() > 0);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*!
 * \brief Informations de d�pouillement en sortie de la boucle de calcul.
 *
 * Effectue une sortie pour le d�pouillement si on est au temps final.
 * Cette sortie ne se fait qu'au temps final et garanti que le fichier
 * de d�pouillement sera le m�me quel que soit le nombre de protections
 * reprises effectu�es.
 */
void
DemonstratorModule::
postProcessingExit()
{
  Real current_time = subDomain()->commonVariables().globalTime();
  m_post_processing.saveAtTime(current_time);

  // Affiche statistiques d'ex�cutions
  m_post_processing.stats();

  CaseOptionsDemonstrator::CaseOptionPostProcessing & post_processing = options()->postProcessing;
  if (post_processing.size() == 0) return;
  const CaseOptionsDemonstrator::CaseOptionPostProcessor & post_processors = post_processing[0].postProcessor;
  for(Integer ip=0,np=post_processors.size();ip<np;++ip)
    {
      const CaseOptionsDemonstrator::CaseOptionPostProcessorValue & post_processor = post_processors[ip];
      IPostProcessorWriter* writer = post_processor.format();
      writer->close();
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
DemonstratorModule::
timeStepInformation(Arcane::Integer nb_loop)
{
  Arcane::Integer precision = FloatInfo<Real>::maxDigit();
  Arcane::Integer digit = precision + 5;

  Arcane::CommonVariables cv(*this);

  info(0) << "********************************************************* Time report ***";
  info(0) << "*** Iteration          n� " << Arcane::Trace::Width(8) << cv.m_global_iteration() << " "
          << "--- Loop               n� " << Arcane::Trace::Width(8) << nb_loop << " ***";
  info(0) << "*** T(n)   = " << Arcane::Trace::Width(digit)
    << Arcane::Trace::Precision(precision,cv.m_global_old_time(),true) << " ==> "
          << "T(n+1) = " << Arcane::Trace::Width(digit)
    << Arcane::Trace::Precision(precision,cv.m_global_time(),true)     << " ***";
  info(0) << "***                                    DT     = "
          << Arcane::Trace::Width(digit) << Arcane::Trace::Precision(precision,cv.m_global_deltat(),true)
          << " ***";
  info(0) << "*************************************************************************";
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_MODULE_DEMONSTRATOR(DemonstratorModule);
