#include "ExaDiBenchModule.h"
/* Author : havep at Wed Nov 14 13:29:24 2007
 * Generated by createNew
 */

#include "ArcGeoSim/Mesh/Geometry/IGeometry.h"
#include "ArcGeoSim/Mesh/Geometry/PolytopicMesh/Geom3D/PolyhedralGeometry.h"
#include "ArcGeoSim/Utils/ItemGroupBuilder.h"

#include <arcane/ITimeLoopMng.h>
#include <arcane/IParallelMng.h>
#include <arcane/utils/Limits.h>
#include <arcane/ArcaneVersion.h>
#include <arcane/IMeshSubMeshTransition.h>

#include <stdlib.h> // pour *rand48

/* Petite note indicative
 * Arcane a quelques probl�mes avec les variables partielles
 * - Si m_cell_group and utilise des RealVariable => pb (dans volumeCompute)
 * - Si groupe isOwn possible probl�me d'enregistrement interne (Arcane) de
 *   de la variable (avec version >= 1.4.0, semble etre de meme)
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
ExaDiBenchModule::
init()
{
  m_cell_group = ownCells();
  // m_cell_group = allCells();

  ItemGroupBuilder<Node> nodeBuilder(mesh(),"BorderNodes");
  ItemGroupBuilder<Face> faceBuilder(mesh(),"BorderFaces");
  
  ENUMERATE_FACE(iface,ownFaces()) {
    const Face face = *iface;
    if (face.isSubDomainBoundary()) { // bord physique car own
      nodeBuilder.add(face.nodes());
      faceBuilder.add(face);

      // Check isSubDomainBoundaryOutside
      if (face.isSubDomainBoundaryOutside() and face.backCell().null())
        fatal() << "Test failed : Bad face boundary";
    }
  }

  m_border_node_group = nodeBuilder.buildGroup();
  m_border_node_checker.init(m_border_node_group);
#if (ARCANE_VERSION<10600)
  m_border_face_group = mesh()->faceFamily()->findGroup("OuterFaces").own();
#else /* ARCANE_VERSION */
  m_border_face_group = outerFaces().own();
#endif /* ARCANE_VERSION */

  FaceGroup border_face_group_test = faceBuilder.buildGroup();
  info() << "Border Node Number = " << m_border_node_group.size();
  info() << "Border Face Number = " << m_border_face_group.size();
  if (m_border_face_group.size() != border_face_group_test.size())
    fatal() << "Test failed : Bad OuterFaces group";

  //// 
  IGeometryMng * geom = options()->geometry();
  geom->init();
  geom->setPolicyTolerance(false);
  m_geometry_policy = new NoOptimizationGeometryPolicy;
  geom->addItemGroupProperty(allFaces(), IGeometryProperty::PArea,IGeometryProperty::PVariable);

  geom->addItemGroupProperty(allCells(), IGeometryProperty::PCenter,IGeometryProperty::PVariable);

  if (options()->useExternalStorage()) 
    {
      geom->addItemGroupProperty(m_cell_group, IGeometryProperty::PVolume,m_volumes);
      geom->addItemGroupProperty(m_border_face_group, IGeometryProperty::PArea,m_surfaces);
      geom->addItemGroupProperty(m_cell_group, IGeometryProperty::PCenter,m_centers);
    }
  else
    {
      geom->addItemGroupProperty(m_cell_group, IGeometryProperty::PVolume,IGeometryProperty::PVariable);
      geom->addItemGroupProperty(m_border_face_group, IGeometryProperty::PArea,IGeometryProperty::PVariable);
      geom->addItemGroupProperty(m_cell_group, IGeometryProperty::PCenter,IGeometryProperty::PVariable);
    }

//  geom->update(m_geometry_policy);
  geom->update(defaultMesh(),m_geometry_policy);

  Real area = surfaceCompute();
  area = subDomain()->parallelMng()->reduce(Parallel::ReduceSum,area);
  Real volume = volumeCompute();
  volume = subDomain()->parallelMng()->reduce(Parallel::ReduceSum,volume);

  pinfo() << "Initial Total measure : volume = " << volume << ", area = " << area;
  m_global_deltat = 1.;

  Real3 center = centerCompute();
  center = subDomain()->parallelMng()->reduce(Parallel::ReduceSum,center);
  pinfo() << "Initial Total center =  " << center[0] << " " << center[1] << " " << center[2];

  ENUMERATE_CELL(icell,allCells()) {
    m_localId[icell] = icell->localId();
  }

}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
ExaDiBenchModule::
compute()
{
  if(!m_border_node_checker.isValid())
     m_border_node_checker.init(m_border_node_group);
  const Real factor = options()->factor();
  const Real twopi = 2. * 3.141592653589;

  VariableNodeReal3 & coords = PRIMARYMESH_CAST(mesh())->nodesCoordinates();
  ENUMERATE_NODE(inode,ownNodes()) {
    if (not m_border_node_checker.hasKey(*inode)) {
#ifdef WIN32
	  const Real r = rand()*factor;
	  const Real theta = twopi*rand();
      const Real phi = twopi*rand();
#else
	  const Real r = drand48()*factor;
	  const Real theta = twopi*drand48();
      const Real phi = twopi*drand48();
#endif
      coords[inode] += r*Real3(cos(theta),sin(theta)*cos(phi),sin(theta)*sin(phi));
    }
  }
  
  coords.synchronize();

  options()->geometry()->update(m_geometry_policy);

//   ENUMERATE_NODE(inode,ownNodes()) {
//     if (m_border_node_checker.hasKey(*inode)) {
//       info() << "Border node " << (*inode).localId() << " " << coords[inode];
//     }
//   }

//   ENUMERATE_NODE(inode,ownNodes()) {
//     if (not m_border_node_checker.hasKey(*inode)) {
//       info() << "Inner node " << (*inode).localId() << " " << coords[inode];
//     }
//   }

  Real area = surfaceCompute();
  area = subDomain()->parallelMng()->reduce(Parallel::ReduceSum,area);
  Real volume = volumeCompute();
  volume = subDomain()->parallelMng()->reduce(Parallel::ReduceSum,volume);
  pinfo() << "Total measure : volume = " << volume << ", area = " << area;
  Real3 center = centerCompute();
  center = subDomain()->parallelMng()->reduce(Parallel::ReduceSum,center);
  pinfo() << "Total center = " << center[0] << " " << center[1] << " " << center[2];
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
ExaDiBenchModule::
restore()
{
  info() << "restore";
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

Real
ExaDiBenchModule::
volumeCompute()
{
  IGeometryMng * geomMng = options()->geometry();
  IGeometry * geom = geomMng->geometry();

  const IGeometryMng::RealVariable & measures = geomMng->getRealVariableProperty(m_cell_group,IGeometryProperty::PVolume);
  // const IGeometryMng::RealGroupMap & measures = geom->getRealGroupMapProperty(m_cell_group,IGeometryProperty::PVolume);
  Real volume = 0;
  Real maxlVolume = -FloatInfo<Real>::maxValue();
  Real minlVolume = +FloatInfo<Real>::maxValue();
  ENUMERATE_CELL(icell,ownCells()) {
    const Real lVolume = measures[*icell];
    if (not math::isNearlyZero(lVolume - geom->computeMeasure(*icell))) {
      fatal() << "Conflicting Volume measure : " << lVolume << " vs " << geom->computeMeasure(*icell) << " : diff=" << lVolume - geom->computeMeasure(*icell);
    }
    minlVolume = math::min(minlVolume,lVolume);
    maxlVolume = math::max(maxlVolume,lVolume);
    volume += lVolume;
  }

  if (minlVolume < maxlVolume)
    info() << "Local volume amplitude : " << minlVolume << " -> " << maxlVolume;
  return volume;
}


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/


Real3
ExaDiBenchModule::
centerCompute()
{
  IGeometryMng * geomMng = options()->geometry();
  IGeometry * geom = geomMng->geometry();

  const IGeometryMng::Real3Variable & centers = geomMng->getReal3VariableProperty(m_cell_group,IGeometryProperty::PCenter);
  Real3 center(0,0,0);
  Real3 centerCell(0,0,0);

  ENUMERATE_CELL(icell,ownCells()) {
    centerCell = geom->computeCenter(*icell);
    const Real3 lcenter = centers[*icell];
    if (not math::isNearlyZero(lcenter[0] - centerCell[0])
        && not math::isNearlyZero(lcenter[1] - centerCell[1])
        && not math::isNearlyZero(lcenter[2] - centerCell[2])
        ) {
      fatal() << "Conflicting Center measure : " << lcenter << " vs " << centerCell << " : diff=" << lcenter - centerCell;
    }
    center += lcenter;
  }

  return center/ownCells().size();
}




Real
ExaDiBenchModule::
surfaceCompute()
{
  IGeometryMng * geomMng = options()->geometry();
  IGeometry * geom = geomMng->geometry();

  const IGeometryMng::RealVariable & measures = geomMng->getRealVariableProperty(m_border_face_group,IGeometryProperty::PArea);
  // const IGeometryMng::RealGroupMap & measures = geom->getRealGroupMapProperty(m_border_face_group,IGeometryProperty::PArea);
  Real area = 0;
  Real maxlArea = -FloatInfo<Real>::maxValue();
  Real minlArea = +FloatInfo<Real>::maxValue();
  ENUMERATE_FACE(iface,m_border_face_group) {
    const Real lArea = measures[*iface];
    if (not math::isNearlyZero(lArea - geom->computeArea(*iface)))
      fatal() << "Conflicting Area measure : " << lArea << " vs " << geom->computeArea(*iface) << " : diff=" << lArea - geom->computeArea(*iface);
    minlArea = math::min(minlArea,lArea);
    maxlArea = math::max(maxlArea,lArea);
    area += lArea;
  }

  if (minlArea < maxlArea)
    info() << "Local area amplitude : " << minlArea << " -> " << maxlArea;
  return area;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
using namespace Arcane;
ARCANE_REGISTER_MODULE_EXADIBENCH(ExaDiBenchModule);
