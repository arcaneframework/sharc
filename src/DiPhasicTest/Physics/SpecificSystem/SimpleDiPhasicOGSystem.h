// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef SIMPLESYSTEM_H
#define SIMPLESYSTEM_H
/* Author : desrozis at Tue Dec  8 17:58:16 2009
 * Generated by createNew
 */

// Cas Diphasique OG immiscible incompressible
// avec un seul composant par phase  
//
// Le syst���me se r���sume ��� deux ���quations de conservation des composants.
// La conservation des volumes est pr������limin���e.
// Les inconnues sont la pression et la saturation d'huile
//
// Les puits injectent du gaz

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "ArcGeoSim/Utils/ItemGroupMap.h"

#include <alien/ref/AlienRefSemantic.h>
#include <alien/arcane_tools/IIndexManager.h>
#include <alien/arcane_tools/indexManager/BasicIndexManager.h>
#include <alien/arcane_tools/accessors/ItemVectorAccessor.h>
#include <alien/arcane_tools/distribution/DistributionFabric.h>

#include "DiPhasicTest/Solver/INonLinearSystem.h"
#include "DiPhasicTest/Solver/IEquationSystem.h"
#include "DiPhasicTest/Well/IWell.h"

#include "ArcGeoSim/Physics/Law2/VariableManager.h"
#include "ArcGeoSim/Physics/Law2/FunctionManager.h"


#include <arcane/MeshVariable.h>
#include <arcane/VariableBuildInfo.h>
#include <arcane/VariableTypedef.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/IMesh.h>
#include <arcane/IMeshModifier.h> // AMR

#include <list>
#include <cmath>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class SimpleDiPhasicOGSystem
  : public INonLinearSystem
{
public:
  
  SimpleDiPhasicOGSystem(Law::VariableManager& variable_mng,
                         Law::FunctionManager& law_mng,
                         Arcane::IMesh* mesh,
                         Arcane::ITraceMng* trace_mng,
                         std::list<IWell*>& wells,
                         Arcane::VariableCellReal& pressure,
                         Arcane::VariableCellReal& oil_saturation);
  
  ~SimpleDiPhasicOGSystem();

private:
  
  // Syst���me d'���quations 
  // Deux ���quations consid���r���es
  class EquationSystem
    : public INonLinearEquationSystem
  {
  private:
    // Pas de check de variation et contrainte => pression
    struct NoEvent : public IVariationCheckEvent, public IConstraintEvent {
      Real apply(const Arcane::VariableCellReal& variable, Real factor) const { return factor; }
      void apply(Arcane::VariableCellReal& variable) const {}
    };
    // Controle sur les variations max => saturations
    struct MaxVariation : public IVariationCheckEvent {
      Real apply(const Arcane::VariableCellReal& variable, Real factor) const {
        CellGroup group = variable.itemGroup();
        Real max = factor;
        ENUMERATE_CELL(iCell,group) {
          if(std::abs(variable[iCell]) > max) max = std::abs(variable[iCell]);
        }
        return max;
      }
    };
    // Contrainte => 0 < saturation < 1
    struct UnitConstraint : public IConstraintEvent {
      void apply(Arcane::VariableCellReal& variable) const {
        CellGroup group = variable.itemGroup();
        ENUMERATE_CELL(iCell,group) {
          Real var = variable[iCell];
          if(var < 0.) variable[iCell] = 0.;
          if(var > 1.) variable[iCell] = 1.;
        }
      }
    };
  public:
    EquationSystem(Arcane::VariableCellReal& residual_1,
                   Arcane::VariableCellReal& residual_2,
                   Arcane::VariableCellReal& solution_1,
                   Arcane::VariableCellReal& solution_2) {
      // R���sidus
      m_residual[0] = &residual_1;
      m_residual[1] = &residual_2;
      // Solutions
      m_solution[0] = &solution_1;
      m_solution[1] = &solution_2;
      // Deriv���e des solutions
      m_deriv_solution[0] = NULL;
      m_deriv_solution[1] = NULL;
      // Nom des inconnues
      m_unknown_names[0] = "Unknown1";
      m_unknown_names[1] = "Unknown2";
      // Nom des ���quations
      m_equation_names[0] = "Equation1";
      m_equation_names[1] = "Equation2";
      // Controle
      m_control[0] = new MaxVariation;
      m_control[1] = new MaxVariation;
      // Contrainte
      m_constraint[0] = new NoEvent;
      m_constraint[1] = new UnitConstraint;
    }
    ~EquationSystem() {
      delete m_control[0];
      delete m_control[1];
      delete m_constraint[0];
      delete m_constraint[1];
    }
    void setCacheIndex(IntegerSharedArray allIndex_1, IntegerSharedArray allIndex_2) {
      // Index
      m_allIndex[0] = allIndex_1;
      m_allIndex[1] = allIndex_2;
    }
    Integer size() const { return 2; }
    String unknownName(Integer i) const { return m_unknown_names[i]; }
    String equationName(Integer i) const { return m_equation_names[i]; }
    IntegerSharedArray cacheIndex(Integer i) const { return m_allIndex[i]; }
    IVariationCheckEvent * variationCheckEvent(Integer i) const { return m_control[i]; }
    IConstraintEvent * constraintEvent(Integer i) const { return m_constraint[i]; }
    Arcane::VariableCellReal& residual(Arcane::Integer i) {
      return *m_residual[i];
    }
    Arcane::VariableCellReal& solution(Arcane::Integer i) {
      return *m_solution[i];
    }
    void setDerivSolution(Arcane::Integer i, Arcane::VariableCellReal& deriv) {
      m_deriv_solution[i] = &deriv;
    }
    Arcane::VariableCellReal& derivSolution(Arcane::Integer i) {
      return *m_deriv_solution[i];
    }
  private:
    Arcane::VariableCellReal * m_residual[2];
    Arcane::VariableCellReal * m_solution[2];
    Arcane::VariableCellReal * m_deriv_solution[2];
    // Index
    IntegerSharedArray m_allIndex[2];
    String m_unknown_names[2];
    String m_equation_names[2];
    IVariationCheckEvent * m_control[2];
    IConstraintEvent * m_constraint[2];
  };

  // Classe de stockage des puits
  class WellData {
  public:
    WellData(IWell * well)
      : m_well(well) {
      m_flux.init(well->perforatedCells());
    }
    IWell * well() { return m_well; }
    ItemGroupMapT<Cell,Real>& flux() { return m_flux; }
  private:
    // Puits
    IWell * m_well;
    // Flux
    ItemGroupMapT<Cell,Real> m_flux;
  };
  
public:

  // Initialisation
  void init();
  
  // Lin���arise le syst���me
  void linearize();
  
  // Coefficient des sch���mas
  void setDiscreteOperatorCoefficients(boost::shared_ptr<CoefficientArrayT<Cell> >& transmissivity);
  
  void setDiscreteOperatorCoefficients(boost::shared_ptr<DiscretizationCoefficientArrayT<Arcane::DoF>>& transmissivity){ }
  // Calcul du profil de la matrice
  void buildMatrixProfil();
 
  // Calcul des flux et des mailles amont
  void buildFlux();

  // Calcul des r���sidus
  void buildResidual();

  // Calcul de la jacobienne
  void buildJacobian();

  // Assemble le syst���me lin���aire
  void assemble();

  // Donne le syst���me d'���quations(/inconnues)
  INonLinearEquationSystem * equationSystem() { return m_equation_system.get(); }
  
  Alien::Matrix const & getJacobian() { return *m_jacobian; }

  Alien::Vector & getDelta() { return *m_delta; }

  Alien::Vector & getResidual() { return *m_residual; }

  Alien::ArcaneTools::IIndexManager::ScalarIndexSet const & getIndexSet(Integer i)
  {
    if(i==0)
      return m_index_set_0;
    else
      return m_index_set_1;
  }

private:

  void _computeLaws();

private:

  bool m_initialized = false;
  
  // Pas de temps
  Arcane::VariableScalarReal m_deltat;

  // Gestionnaire de variables des lois
  Law::VariableManager& m_variable_mng;

  // Gestionnaire des lois
  Law::FunctionManager& m_law_mng;

  // Maillage
  Arcane::IMesh* m_mesh = nullptr;
  
  // Coefficients sur les mailles
  boost::shared_ptr<CoefficientArrayT<Cell> > * m_transmissivity = nullptr;
  
  // Nombre max d'���l���ments des stencils
  Integer m_max_stencil_size = 0 ;

  // Faces internes
  FaceGroup m_internal_faces;

  // Ensembles des mailles
  CellGroup m_all_cells;

  // Ensembles des mailles du processeur
  CellGroup m_own_cells;
  
  // Syst���me d'���quations
  std::unique_ptr<EquationSystem> m_equation_system ;
  
  // Gestionnaire d'indice du syst���me lin���aire
  std::unique_ptr<Alien::ArcaneTools::BasicIndexManager> m_index_manager;
  Alien::ArcaneTools::IIndexManager::ScalarIndexSet m_index_set_0;
  Alien::ArcaneTools::IIndexManager::ScalarIndexSet m_index_set_1;

  // Outils pour l'alg���bre

  std::unique_ptr<Alien::Matrix> m_jacobian ;
  std::unique_ptr<Alien::Vector> m_residual ;
  std::unique_ptr<Alien::Vector> m_delta ;
  Arcane::IntegerSharedArray m_all_index_0;
  Arcane::IntegerSharedArray m_all_index_1;

  // Donn���es puits
  SharedArray<WellData*> m_well_data;

  // R���sidus
  Arcane::VariableCellReal m_residual_1;
  Arcane::VariableCellReal m_residual_2;

  // Gestionnaire de traces
  Arcane::ITraceMng * m_trace_mng         = nullptr;

  // Flux
  ItemGroupMapT<Face,Real> * m_flux_p     = nullptr;

  // Amont
  ItemGroupMapT<Face,Cell> * m_up_cells_p = nullptr;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* SIMPLESYSTEM_H */
