// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "SimpleDiPhasicOGSystem.h"
/* Author : desrozis at Tue Dec  8 17:58:16 2009
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "ArcGeoSim/Appli/AppService.h"

#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"

#include "ArcGeoSim/Numerics/DiscreteOperator/CoefficientArray.h"

#include "DiPhasicTest/Physics/Properties.h"

#include "ArcGeoSim/Physics/Law2/FunctionEvaluator.h"
#include "ArcGeoSim/Physics/Law2/EvaluationResults.h"
#include "ArcGeoSim/Physics/Law2/Variable.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

SimpleDiPhasicOGSystem::
SimpleDiPhasicOGSystem(Law::VariableManager& variable_mng,
                       Law::FunctionManager& law_mng,
                       Arcane::IMesh* mesh,
                       Arcane::ITraceMng* trace_mng,
                       std::list<IWell*>& wells,
                       Arcane::VariableCellReal& pressure,
                       Arcane::VariableCellReal& oil_saturation)
  : m_initialized(false)
  , m_deltat(Arcane::VariableBuildInfo(mesh->subDomain(),"GlobalDeltaT"))
  , m_variable_mng(variable_mng)
  , m_law_mng(law_mng)
  , m_mesh(mesh)
  , m_residual_1(VariableBuildInfo(m_mesh, "ResidualEquation1"))
  , m_residual_2(VariableBuildInfo(m_mesh, "ResidualEquation2"))
  , m_trace_mng(trace_mng)
{
  m_well_data.resize(wells.size());
  Integer i=0;
  for(std::list<IWell*>::iterator it=wells.begin(); it!=wells.end(); ++it) {
    m_well_data[i++] = new WellData(*it);
  }

  // On cr���e le syst���me d'���quations
  m_equation_system.reset(new EquationSystem(m_residual_1,
                                         m_residual_2,
                                         pressure,
                                         oil_saturation));
}

/*---------------------------------------------------------------------------*/

SimpleDiPhasicOGSystem::
~SimpleDiPhasicOGSystem() 
{
  for(Arcane::Integer i=0; i<m_well_data.size(); ++i) {
    delete m_well_data[i];
  }
}

/*---------------------------------------------------------------------------*/
 
void
SimpleDiPhasicOGSystem::
init()
{
  if(m_initialized) return;

  // Syst���me diphasique
  // On connait le nom et le type des propri���t���s
  // Donc pas de contr���le de coh���rence pour ce proto
  // Dans la r���alit���, on doit abstraire

  m_all_cells = m_mesh->allActiveCells(); // AMR
  m_own_cells = m_mesh->ownActiveCells(); // AMR

  // Groupe des faces internes
  m_internal_faces = m_mesh->allCells().innerActiveFaceGroup(); // AMR
  
  m_initialized = true;
}

/*---------------------------------------------------------------------------*/

void
SimpleDiPhasicOGSystem::
buildFlux()
{
  if (m_flux_p == 0) {
    m_flux_p = new ItemGroupMapT<Face,Real>(m_internal_faces);
    m_up_cells_p = new ItemGroupMapT<Face,Cell>(m_internal_faces);
  }
  else{
    if(!m_flux_p->isValid())
      m_flux_p->init(m_internal_faces);
    if(!m_up_cells_p->isValid())
      m_up_cells_p->init(m_internal_faces);
  }
  ItemGroupMapT<Face,Real> & m_flux = *m_flux_p;
  ItemGroupMapT<Face,Cell> & m_up_cells = *m_up_cells_p;

  Law::VariableAccessorT<Cell> accessor = m_variable_mng.variables<Arcane::Cell>();
    
  Arcane::VariableCellReal pressure(accessor.values(DiPhasic::Pressure));

  CoefficientArrayT<Cell>& transmissivity = **m_transmissivity;

  ENUMERATE_FACE(iFace,m_internal_faces) {
    const Face& face = *iFace;
    const ItemVectorView& cells = transmissivity.stencil(face);
    const ArrayView<Real>& coefficients = transmissivity.coefficients(face);
    Real flux = 0.;
    ENUMERATE_CELL(iCell,cells) {
      flux += coefficients[iCell.index()] * pressure[*iCell];
    }
    m_flux[iFace] = - flux;
    // D���centrage amont
    if(flux >= 0.) {
      m_up_cells[iFace] = iFace->backCell();
    } else {
      m_up_cells[iFace] = iFace->frontCell();
    }
  }

  // Puits
  for(Integer i=0; i<m_well_data.size(); ++i) {
    IWell * well = m_well_data[i]->well();
    const ItemGroupMapT<Cell,Real>& productivity_index = well->productivityIndex();
    ItemGroupMapT<Cell,Real>& flux = m_well_data[i]->flux();
    CellGroup perforated_cells = well->perforatedCells();
    const Real well_pressure = well->pressure();
    if(!flux.isValid())
      flux.init(perforated_cells);
    ENUMERATE_CELL(iCell,perforated_cells) {
      const Cell cell = *iCell;
      const Real pi= productivity_index[cell];
      const Real dp= ( pressure[cell] - well_pressure );
      flux[cell] = pi * dp;
    }
  }
}

/*---------------------------------------------------------------------------*/

void 
SimpleDiPhasicOGSystem::
setDiscreteOperatorCoefficients(boost::shared_ptr<CoefficientArrayT<Cell> >& transmissivity)
{
  m_transmissivity = &transmissivity;
}

/*---------------------------------------------------------------------------*/

void
SimpleDiPhasicOGSystem::
buildMatrixProfil()
{ 
  ARCANE_ASSERT((m_transmissivity),("Discrete operator coefficients must be set"));

  // Pour la construction des entr���es du syst���me
  // Variation provenant du Newton

  m_index_manager.reset(new Alien::ArcaneTools::BasicIndexManager(m_mesh->parallelMng()));

  m_index_set_0 = m_index_manager->buildScalarIndexSet("Equation1", m_all_cells);
  m_index_set_1 = m_index_manager->buildScalarIndexSet("Equation2", m_all_cells);


  m_index_manager->prepare();
  auto global_size = m_index_manager->globalSize();
  auto local_size = m_index_manager->localSize();

  auto space = Alien::ArcaneTools::Space(m_index_manager.get(), "TestSpace");
  auto mdist = Alien::ArcaneTools::createMatrixDistribution(space);
  auto vdist = Alien::ArcaneTools::createVectorDistribution(space);
  m_jacobian.reset(new Alien::Matrix(mdist));
  m_residual.reset(new Alien::Vector(vdist));
  m_delta.reset(new Alien::Vector(vdist));

  m_all_index_0 = m_index_manager->getIndexes(m_index_set_0);
  m_all_index_1 = m_index_manager->getIndexes(m_index_set_1);

  m_equation_system->setCacheIndex(m_all_index_0, m_all_index_1);

  CoefficientArrayT<Cell>& transmissivity = **m_transmissivity;

  // Calcul de la taille max des stencils
  m_max_stencil_size = 0;
  ENUMERATE_FACE(iFace, m_internal_faces)
  {
    m_max_stencil_size = math::max(m_max_stencil_size, transmissivity.stencilSize(*iFace));
  }

  // Cache d'index de l'���quation 1 / entr���e 1
  IntegerSharedArray cacheIndex_1 = m_equation_system->cacheIndex(0);
  // Cache d'index de l'���quation 2 / entr���e 2
  IntegerSharedArray cacheIndex_2 = m_equation_system->cacheIndex(1);

  SharedArray<Integer> entry_1_indices(m_max_stencil_size);
  SharedArray<Integer> entry_2_indices(m_max_stencil_size);

  {
    Alien::MatrixProfiler profiler(*m_jacobian);

    // D���finition du profil de la matrice
    ENUMERATE_FACE(iFace, m_internal_faces)
    {
      const Face& face = *iFace;

      const Cell& cell_i  = face.backCell();
      const Cell& cell_j  = face.frontCell();

      const ItemVectorView& cells = transmissivity.stencil(face);

      const Integer stencil_size = transmissivity.stencilSize(face);

      ArrayView<Integer> view_entry_1_indices = entry_1_indices.view().subView(0,stencil_size);

      // Indices des mailles du stencil
      ENUMERATE_CELL(iCell,cells)
      {
        view_entry_1_indices[iCell.index()] = cacheIndex_1[iCell->localId()];
      }

      const Integer id_i = cell_i.localId();
      const Integer id_j = cell_j.localId();
 
      if(cell_i.isOwn())
      {
        ENUMERATE_CELL(iCell,cells)
	    {
          profiler.addMatrixEntry(cacheIndex_1[id_i], cacheIndex_1[iCell->localId()]);
          profiler.addMatrixEntry(cacheIndex_2[id_i], cacheIndex_1[iCell->localId()]);
	    }
        profiler.addMatrixEntry(cacheIndex_1[id_i], cacheIndex_2[id_i]);
        profiler.addMatrixEntry(cacheIndex_1[id_i], cacheIndex_2[id_j]);
        profiler.addMatrixEntry(cacheIndex_2[id_i], cacheIndex_2[id_j]);
        profiler.addMatrixEntry(cacheIndex_2[id_i], cacheIndex_2[id_i]);
      }
      
      if(cell_j.isOwn())
      {
        ENUMERATE_CELL(iCell,cells)
	      {
          profiler.addMatrixEntry(cacheIndex_1[id_j], cacheIndex_1[iCell->localId()]);
          profiler.addMatrixEntry(cacheIndex_2[id_j], cacheIndex_1[iCell->localId()]);
	      }
        profiler.addMatrixEntry(cacheIndex_1[id_j], cacheIndex_2[id_i]);
        profiler.addMatrixEntry(cacheIndex_1[id_j], cacheIndex_2[id_j]);
        profiler.addMatrixEntry(cacheIndex_2[id_j], cacheIndex_2[id_i]);
        profiler.addMatrixEntry(cacheIndex_2[id_j], cacheIndex_2[id_j]);
      }
    }
  }
}

/*---------------------------------------------------------------------------*/

void
SimpleDiPhasicOGSystem::
_computeLaws()
{
  // Evaluation des lois 
  Law::VariableAccessorT<Cell> accessor = m_variable_mng.variables<Arcane::Cell>();
  
  Arcane::IntegerSharedArray ids(2);
  ids[0] = DiPhasic::OilRelativePermeabilityId;
  ids[1] = DiPhasic::GasRelativePermeabilityId;
  
  Law::FunctionEvaluator evaluator(m_law_mng, ids);

  evaluator.evaluateWithDerivatives(accessor, m_all_cells);
}

/*---------------------------------------------------------------------------*/

void
SimpleDiPhasicOGSystem::
buildResidual()
{
  ItemGroupMapT<Face,Real> & m_flux = *m_flux_p;
  ItemGroupMapT<Face,Cell> & m_up_cells = *m_up_cells_p;

  // Calcul des lois
  _computeLaws();

  // Pas de temps courant
  const Real dt = m_deltat();

  Law::VariableAccessorT<Cell> accessor = m_variable_mng.variables<Arcane::Cell>();
  
  Arcane::VariableCellReal porosity(accessor.values(DiPhasic::Porosity));
  Arcane::VariableCellReal saturation_1(accessor.values(DiPhasic::OilSaturation));
  Arcane::VariableCellReal saturation_1_tn(accessor.values(DiPhasic::OilSaturationTN));
  Arcane::VariableCellReal density_1(accessor.values(DiPhasic::OilDensity));
  Arcane::VariableCellReal density_2(accessor.values(DiPhasic::GasDensity));
  Arcane::VariableCellReal viscosity_1(accessor.values(DiPhasic::OilViscosity));
  Arcane::VariableCellReal viscosity_2(accessor.values(DiPhasic::GasViscosity));
  Arcane::VariableCellReal relative_permeability_1(accessor.values(DiPhasic::OilRelativePermeability));
  Arcane::VariableCellReal relative_permeability_2(accessor.values(DiPhasic::GasRelativePermeability));

  const Real inv_dt = 1. / dt;

  ArcGeoSim::AppService<IGeometryMng> geometry;
  
  const IGeometryMng::RealVariable& cell_volume 
    = geometry->getRealVariableProperty(m_all_cells,IGeometryProperty::PMeasure);

  // Accumulation
  ENUMERATE_CELL(iCell,m_all_cells) {
    const Arcane::Cell cell = *iCell;
    const Real tmp = porosity[cell] * cell_volume[cell] * (saturation_1[cell] - saturation_1_tn[cell]);
    // Calcul des r���sidus de l'accumulation
    m_residual_1[iCell] =   density_1[cell] * inv_dt * tmp;
    m_residual_2[iCell] = - density_2[cell] * inv_dt * tmp;
  }

  // Flux
  ENUMERATE_FACE(iFace,m_internal_faces) {
    Cell cell_i = iFace->frontCell();
    Cell cell_j = iFace->backCell();
    Cell up_cell = m_up_cells[iFace];

    const Real s1 = m_flux[iFace] * density_1[up_cell] / viscosity_1[up_cell] * relative_permeability_1[up_cell];
    const Real s2 = m_flux[iFace] * density_2[up_cell] / viscosity_2[up_cell] * relative_permeability_2[up_cell];

    m_residual_1[cell_i] += s1;
    m_residual_2[cell_i] += s2;
    m_residual_1[cell_j] -= s1;
    m_residual_2[cell_j] -= s2;
  }

  // Puits
  for(Integer i=0; i<m_well_data.size(); ++i) {
    // Donn���es de puits
    WellData * well_data = m_well_data[i];
    // Puits
    IWell * well = well_data->well();
    // Flux
    ItemGroupMapT<Cell,Real>& flux = well_data->flux();
    // Mailles perfor���es
    CellGroup perforated_cells = well->perforatedCells();
    if(well->type() == WT_Injector) {
      ENUMERATE_CELL(iCell,perforated_cells.own()) {
        const Arcane::Cell cell = *iCell;
        const Arcane::Real perforation_flux = flux[cell];
        if(perforation_flux < 0.) {
	  m_residual_2[cell] += perforation_flux * density_2[cell] / viscosity_2[cell];
        }
      }
    } else {
      ENUMERATE_CELL(iCell,perforated_cells.own()) {
        const Arcane::Cell cell = *iCell;
        const Arcane::Real perforation_flux = flux[cell];
        m_residual_1[cell] += perforation_flux * density_1[cell] / viscosity_1[cell] * relative_permeability_1[cell];
        m_residual_2[cell] += perforation_flux * density_2[cell] / viscosity_2[cell] * relative_permeability_2[cell];
      }
    }
  }

  ENUMERATE_CELL(iCell,m_own_cells) {
    // Somme de la conservation de l'huile et du gaz
    m_residual_1[iCell] += m_residual_2[iCell];
  }
}

/*---------------------------------------------------------------------------*/

void
SimpleDiPhasicOGSystem::
buildJacobian()
{
  ItemGroupMapT<Face,Real> & m_flux = *m_flux_p;
  ItemGroupMapT<Face,Cell> & m_up_cells = *m_up_cells_p;

  // Pas de temps courant
  const Arcane::Real dt = m_deltat();

  Law::VariableAccessorT<Cell> accessor = m_variable_mng.variables<Arcane::Cell>();
 
  Arcane::VariableCellReal porosity(accessor.values(DiPhasic::Porosity));
  Arcane::VariableCellReal density_1(accessor.values(DiPhasic::OilDensity));
  Arcane::VariableCellReal density_2(accessor.values(DiPhasic::GasDensity));
  Arcane::VariableCellReal viscosity_1(accessor.values(DiPhasic::OilViscosity));
  Arcane::VariableCellReal viscosity_2(accessor.values(DiPhasic::GasViscosity));
  
  // On demande les d���riv���es par rapport ��� la pression (inutile mais pour tester) et ��� la saturation d'huile
  //m_variable_mng.setUnknownMng(m_u_mng) ;

  Law::EvaluationResults results(m_law_mng, m_variable_mng);
  results << DiPhasic::OilSaturation;
  results << DiPhasic::Pressure;
  
  Law::ScalarVariableCellReal relative_permeability_1(results[DiPhasic::OilRelativePermeability]);
  Law::ScalarVariableCellReal relative_permeability_2(results[DiPhasic::GasRelativePermeability]);

  // relative_permeability_1.values(cell) est un tableau dimensionn��� au nombre de d���riv���es souhait���es + 1 pour l'item cell
  // arrray[0] => la valeur de la loi
  // arrray[1] => valeur de la d���riv���e souhait���e de la loi (ici OilSaturation)
  // arrray[2] => valeur de la d���riv���e souhait���e de la loi (ici Pressure)

  const Arcane::Real inv_dt = 1. / dt;

  ArcGeoSim::AppService<IGeometryMng> geometry;
  
  const IGeometryMng::RealVariable& cell_volume 
    = geometry->getRealVariableProperty(m_all_cells,IGeometryProperty::PMeasure);

  // Cache d'index de l'���quation 1 / entr���e 1
  Arcane::IntegerSharedArray cacheIndex_1 = m_equation_system->cacheIndex(0);
  // Cache d'index de l'���quation 2 / entr���e 2
  Arcane::IntegerSharedArray cacheIndex_2 = m_equation_system->cacheIndex(1);

  Alien::ProfiledMatrixBuilder jacobian(*m_jacobian, Alien::ProfiledMatrixBuilder::ResetFlag::eResetValues);

  // Accumulation
  ENUMERATE_CELL(iCell,m_own_cells) {
    Arcane::Cell cell = *iCell;
    const Arcane::Integer id = cell.localId();
    const Arcane::Integer cell_1 = cacheIndex_1[id];
    const Arcane::Integer cell_2 = cacheIndex_2[id];
    const Arcane::Real tmp = porosity[cell] * cell_volume[cell];
    jacobian(cell_1,cell_2) += density_1[cell] * inv_dt * tmp - density_2[cell] * inv_dt * tmp;
    jacobian(cell_2,cell_2) += - density_2[cell] * inv_dt * tmp;
  }

  Arcane::IntegerSharedArray entry_1_indices(m_max_stencil_size);
  Arcane::RealSharedArray equation_1_values(m_max_stencil_size);
  Arcane::RealSharedArray equation_2_values(m_max_stencil_size);

  CoefficientArrayT<Cell>& transmissivity = **m_transmissivity;

  // Flux
  ENUMERATE_FACE(iFace,m_internal_faces) {
    const Arcane::Face& face = *iFace;
    Arcane::Cell cell_i = iFace->frontCell();
    Arcane::Cell cell_j = iFace->backCell();
    const Arcane::Integer id_i = cell_i.localId();
    const Arcane::Integer id_j = cell_j.localId();
    const Arcane::Integer cell_i_1 = cacheIndex_1[id_i];
    const Arcane::Integer cell_i_2 = cacheIndex_2[id_i];
    const Arcane::Integer cell_j_1 = cacheIndex_1[id_j];
    const Arcane::Integer cell_j_2 = cacheIndex_2[id_j];

    Cell up_cell = m_up_cells[iFace];
    const Arcane::ItemVectorView& cells = transmissivity.stencil(face);
    const Arcane::ArrayView<Real>& coefficients = transmissivity.coefficients(face);
    const Arcane::Integer stencil_size = transmissivity.stencilSize(face);
    Arcane::ArrayView<Integer> view_entry_1_indices = entry_1_indices.view().subView(0,stencil_size);
    Arcane::ArrayView<Real> view_equation_1_values = equation_1_values.view().subView(0,stencil_size);
    Arcane::ArrayView<Real> view_equation_2_values = equation_2_values.view().subView(0,stencil_size);

    ENUMERATE_CELL(iCell,cells) {
      const Arcane::Integer count = iCell.index();
      view_entry_1_indices[count] = cacheIndex_1[iCell->localId()];
      const Arcane::Real dF1dP = - coefficients[count] * density_1[up_cell] / viscosity_1[up_cell] * relative_permeability_1[up_cell];
      const Arcane::Real dF2dP = - coefficients[count] * density_2[up_cell] / viscosity_2[up_cell] * relative_permeability_2[up_cell];
      view_equation_1_values[count] = dF1dP + dF2dP;
      view_equation_2_values[count] = dF2dP;
    }

    if(cell_i.isOwn())
    {
      ENUMERATE_CELL(iCell,cells)
      {
        const Arcane::Integer count = iCell.index();
        jacobian(cell_i_1, view_entry_1_indices[count]) += view_equation_1_values[count];
        jacobian(cell_i_2, view_entry_1_indices[count]) += view_equation_2_values[count];
      }
    }
    if(cell_j.isOwn())
    {
      ENUMERATE_CELL(iCell,cells)
      {
        const Arcane::Integer count = iCell.index();
        jacobian(cell_j_1, view_entry_1_indices[count]) -= view_equation_1_values[count];
        jacobian(cell_j_2, view_entry_1_indices[count]) -= view_equation_2_values[count];
      }
    }

    const Arcane::Integer up_cell_2 = cacheIndex_2[up_cell.localId()];
    // Deriv���e des Kr par rapport ��� OilSaturation
    const Arcane::Real dF1dS =   m_flux[iFace] * density_1[up_cell] / viscosity_1[up_cell] * relative_permeability_1.values(up_cell)[1];
    const Arcane::Real dF2dS = - m_flux[iFace] * density_2[up_cell] / viscosity_2[up_cell] * relative_permeability_2.values(up_cell)[1];

    if(cell_i.isOwn())
    {
      jacobian(cell_i_1,up_cell_2) += dF1dS - dF2dS;
      jacobian(cell_i_2,up_cell_2) += - dF2dS;
    }
    if(cell_j.isOwn())
    {
      jacobian(cell_j_1,up_cell_2) += - dF1dS + dF2dS;
      jacobian(cell_j_2,up_cell_2) += dF2dS;
    }
  }

  // Puits
  for(Integer i=0; i<m_well_data.size(); ++i) {
    // Donn���es de puits
    WellData * well_data = m_well_data[i];
    // Puits
    IWell* well = well_data->well();
    // Indice de productivit���
    const ItemGroupMapT<Cell,Real>& productivity_index = well->productivityIndex();
    // Flux
    ItemGroupMapT<Cell,Real>& flux = well_data->flux();
    // Mailles perfor���es
    Arcane::CellGroup perforated_cells = well->perforatedCells();
    if(well->type() == WT_Injector) {
      ENUMERATE_CELL(iCell,perforated_cells.own()) {
        Arcane::Cell cell = *iCell;
        const Arcane::Real well_flux = flux[cell];
        if(well_flux < 0.) {
          const Arcane::Integer id = cell.localId();
          const Arcane::Integer cell_1 = cacheIndex_1[id];
          const Arcane::Integer cell_2 = cacheIndex_2[id];
          const Arcane::Real dFdP = productivity_index[cell] * density_2[cell] / viscosity_2[cell];
          jacobian(cell_2,cell_1) += dFdP;
          // Somme de la conservation de l'huile et du gaz
          jacobian(cell_1, cell_1) += dFdP;
        }
      }
    } else {
      ENUMERATE_CELL(iCell,perforated_cells.own()) {
        Arcane::Cell cell = *iCell;
        const Arcane::Real perforation_flux = flux[cell];
        const Arcane::Integer id = cell.localId();
        const Arcane::Integer cell_1 = cacheIndex_1[id];
        const Arcane::Integer cell_2 = cacheIndex_2[id];
        const Arcane::Real dF1dP = productivity_index[cell] * density_1[cell] / viscosity_1[cell] * relative_permeability_1[cell];
        const Arcane::Real dF2dP = productivity_index[cell] * density_2[cell] / viscosity_2[cell] * relative_permeability_2[cell];
        // Deriv���e des Kr par rapport ��� OilSaturation
        const Arcane::Real dF1dS =   perforation_flux * density_1[cell] / viscosity_1[cell] * relative_permeability_1.values(cell)[1];
        const Arcane::Real dF2dS = - perforation_flux * density_2[cell] / viscosity_2[cell] * relative_permeability_2.values(cell)[1];

        jacobian(cell_1, cell_1) += dF1dP + dF2dP;
        jacobian(cell_2, cell_1) += dF2dP;
        jacobian(cell_1, cell_2) += dF1dS - dF2dS;
        jacobian(cell_2, cell_2) += -dF2dS;
      }
    }
  }
}

/*---------------------------------------------------------------------------*/

void
SimpleDiPhasicOGSystem::
assemble()
{
  // Cache d'index de l'���quation 1 / entr���e 1
  Arcane::IntegerSharedArray cacheIndex_1 = m_equation_system->cacheIndex(0);
  // Cache d'index de l'���quation 2 / entr���e 2
  Arcane::IntegerSharedArray cacheIndex_2 = m_equation_system->cacheIndex(1);


  Alien::VectorWriter v(*m_residual);

  ENUMERATE_CELL(iCell,m_own_cells) {
    Arcane::Cell cell = *iCell;
    const Arcane::Integer id = cell.localId();
    const Arcane::Integer cell_1 = cacheIndex_1[id];
    const Arcane::Integer cell_2 = cacheIndex_2[id];
    v[cell_1] = - m_residual_1[iCell];
    v[cell_2] = - m_residual_2[iCell];
  }
  // Matrice is ok!!
  //m_linear_system_builder->dumpToMatlab("LinearSystem.m");
  //exit(-1);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
