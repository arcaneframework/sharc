// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
/* Author : desrozis at Tue Dec  8 10:54:05 2009
 * Generated by createNew
 */

// Demonstrateur di-phasique

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
#include <arcane/ArcaneVersion.h>
#include "ArcGeoSim/Utils/Utils.h"
#include "ArcGeoSim/Utils/ArrayUtils.h"
#include "arcane/ISubDomain.h"
#include "arcane/IMesh.h"
#include "arcane/IParallelMng.h"

#include "DiPhasicTest/Model/ILawConfig.h"
#include "DiPhasicTest/Well/IWell.h"
#include "DiPhasicTest/Solver/INewtonSolver.h"

#include "ArcGeoSim/Numerics/DiscreteOperator/IDivKGradDiscreteOperator.h"
#include "ArcGeoSim/Physics/Law2/FunctionEvaluator.h"
#include "ArcGeoSim/Mesh/MeshAdapter/IMeshAdapter.h" // AMR
#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"
#include "ArcGeoSim/Mesh/Geometry/ManualUpdateGeometryPolicy.h"
#include "ArcGeoSim/Time/ITimeLine.h"
#include "ArcGeoSim/Time/ITimeStepComputer.h"
#include "ArcGeoSim/Time/Activity/ReplayTimeStep.h"

#include "ArcGeoSim/Appli/AppService.h"

#include "DiPhasicTest/Physics/Properties.h"

#include "DiPhasicTest/Physics/SpecificSystem/SimpleDiPhasicOGSystem.h"

#include <boost/shared_ptr.hpp>

#include <list>


class DiPhasicErrorIndicator
{
public :
  typedef enum {
    P,
    So,
    Sg
  } eVarType ;
};

#include "DiPhasic_axl.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

//class IMeshAdapter;

class DiPhasicModule
  : public ArcaneDiPhasicObject
{
public:

  DiPhasicModule(const Arcane::ModuleBuildInfo& mbi)
    : ArcaneDiPhasicObject(mbi)
    , m_initialized(false)
    , m_variable_mng(mesh(),traceMng())
    , m_law_mng()
    , m_discrete_operator(NULL)
    , m_operator_is_formed(false)
    , m_non_linear_system(NULL)
    , m_newton_solver(NULL)
    , m_pressure_tn(VariableBuildInfo(mesh(), "PressureTn"))
    , m_oil_saturation_tn(VariableBuildInfo(mesh(), "OilSaturationTn"))
    , m_gas_saturation_tn(VariableBuildInfo(mesh(), "GasSaturationTn"))
    , m_oil_density_tn(VariableBuildInfo(mesh(), "OilDensityTn"))
    , m_mesh_adapter(NULL)
    , m_mesh_changed(false) {} // AMR
  
  ~DiPhasicModule() {}
  
public:
  
  void init();

  void compute();

  void on_mesh_changed();

  void updateAMRStuff(); // AMR

  /** Retourne le numero de version du module */
  virtual Arcane::VersionInfo versionInfo() const { return Arcane::VersionInfo(1,0,0); }

  Integer getZoneSize(Integer iwell) {
    return m_zones_sizes[iwell];
  }

private:

  void _initializeLawVariableManager();
  void _initializeLaws();
  void _computeInitialState();
  void _initializeWell();
  void _updateWell();  // AMR
  void _initializeNumericalTools();
  void _initializeAMRManager(); // AMR
  void _initializeAMR(); // AMR
  void _initializeDiscreteOperator();
  void _prepareDiscreteOperator();
  void _formDiscreteOperator();
  void _geometryUpdate();
  void _computeLinearizedSystem();
  void _solveNonLinearSystem();

private:

  bool m_initialized;

  // Gestionnaire des variables
  Law::VariableManager m_variable_mng;

  // Gestionnaire des lois
  Law::FunctionManager m_law_mng;

  // Puits
  std::list<IWell*> m_wells;

  // Coefficients sur les mailles
  boost::shared_ptr<CoefficientArrayT<Cell> > m_cell_coefficients;

  // Coefficients sur les faces
  boost::shared_ptr<CoefficientArrayT<Face> > m_face_coefficients;

  // Operateur discret Div K Grad
  IDivKGradDiscreteOperator * m_discrete_operator;

  // Operateur forme?
  bool m_operator_is_formed;

  // Systeme immiscible incompressible (diphasique)
  INonLinearSystem * m_non_linear_system;

  // Solveur Newton specifique
  INewtonSolver * m_newton_solver;

  // Proprietes au pas de temps precedent
  VariableCellReal m_pressure_tn;
  VariableCellReal m_oil_saturation_tn;
  VariableCellReal m_gas_saturation_tn;
  VariableCellReal m_oil_density_tn;

  // Interface de l'Adaptateur de Maillage
  IMeshAdapter * m_mesh_adapter;    // AMR
  bool m_mesh_changed ;             // AMR
  SharedArray<Integer>    m_zones_sizes ; // AMR
};

using namespace Arcane;
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
DiPhasicModule::
init()
{
	if(m_initialized) return;

	info() << "init entry point";

	_initializeLawVariableManager();
	_initializeLaws();
	_computeInitialState();
	_initializeWell();
	_initializeNumericalTools();
	// AMR begins
	_initializeAMRManager();
	_initializeAMR();
	// AMR ends
	_geometryUpdate();
	m_initialized = true;
}

/*---------------------------------------------------------------------------*/

void
DiPhasicModule::
_initializeLawVariableManager()
{
  info() << "initialize law variables";

  // Fluid
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::Pressure, m_pressure);
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::Temperature, m_temperature);

  // Water phase
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::GasSaturation, m_gas_saturation);
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::GasDensity, m_gas_density, m_deriv_gas_density);
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::GasViscosity, m_gas_viscosity, m_deriv_gas_viscosity);
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::GasRelativePermeability, m_gas_relative_permeability,
                                                m_deriv_gas_relative_permeability);

  // Oil phase
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::OilSaturation, m_oil_saturation);
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::OilDensity, m_oil_density, m_deriv_oil_density);
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::OilViscosity, m_oil_viscosity, m_deriv_oil_viscosity);
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::OilRelativePermeability, m_oil_relative_permeability,
                                                m_deriv_oil_relative_permeability);

  // Rock
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::Porosity, m_porosity);
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::Permeability, m_permeability);

  // Variables aux pas de temps precedent
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::PressureTN, m_pressure_tn);
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::GasSaturationTN, m_gas_saturation_tn);
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::OilSaturationTN, m_oil_saturation_tn);
  m_variable_mng << Law::variable<Arcane::Cell>(DiPhasic::OilDensityTN, m_oil_density_tn);
  
  info() << m_variable_mng;
}
/*---------------------------------------------------------------------------*/

void
DiPhasicModule::
_initializeAMRManager()
{
	if ( mesh()->isAmrActivated() ) {
		if ( options()->meshAdapter.size() > 0 ) {
			m_mesh_adapter = options()->meshAdapter[0];
			m_mesh_adapter->init(mesh());
		}
		else {
			fatal() << "The mesh adapter service is missing ... ERROR";
		}
	}
}
/*---------------------------------------------------------------------------*/

void
DiPhasicModule::
_initializeAMR()
{
	// Transport des proprietes

	if ( mesh()->isAmrActivated() ) {
		m_mesh_adapter->addDataToRegister("pressure",m_pressure);
		m_mesh_adapter->addDataToRegister("temperature",m_temperature);

		m_mesh_adapter->addDataToRegister("gas_saturation",m_gas_saturation);
		m_mesh_adapter->addDataToRegister("gas_density",m_gas_density);
		m_mesh_adapter->addDataToRegister("deriv_gas_density",m_deriv_gas_density);
		m_mesh_adapter->addDataToRegister("gas_viscosity",m_gas_viscosity);
		m_mesh_adapter->addDataToRegister("deriv_gas_viscosity",m_deriv_gas_viscosity);
		m_mesh_adapter->addDataToRegister("gas_relative_permeability",m_gas_relative_permeability);
		m_mesh_adapter->addDataToRegister("deriv_gas_relative_permeability",m_deriv_gas_relative_permeability);

		m_mesh_adapter->addDataToRegister("oil_saturation",m_oil_saturation);
		m_mesh_adapter->addDataToRegister("oil_density",m_oil_density);
		m_mesh_adapter->addDataToRegister("deriv_oil_density",m_deriv_oil_density);
		m_mesh_adapter->addDataToRegister("oil_viscosity",m_oil_viscosity);
		m_mesh_adapter->addDataToRegister("deriv_oil_viscosity",m_deriv_oil_viscosity);
		m_mesh_adapter->addDataToRegister("oil_relative_permeability",m_oil_relative_permeability);
		m_mesh_adapter->addDataToRegister("deriv_oil_relative_permeability",m_deriv_oil_relative_permeability);

		m_mesh_adapter->addDataToRegister("porosity",m_porosity);
		m_mesh_adapter->addDataToRegister("permeability",m_permeability);

		m_mesh_adapter->addDataToRegister("AMRError",m_amr_error);

		m_mesh_adapter->registerTransportFunctor();

		// Sauvegarde des mailles perforees pour mise a jour
		m_zones_sizes.resize(m_wells.size()) ;
		UInt32 iwell = 0;
		for(std::list<IWell*>::iterator it = m_wells.begin(); it != m_wells.end(); ++it)
      {
        m_zones_sizes[iwell] = (*it)->perforatedCells().size();
        iwell++;
      }
	}
}
/*---------------------------------------------------------------------------*/

void 
DiPhasicModule::
compute()
{
	// AMR begins
	if (mesh()->isAmrActivated() && m_mesh_changed) {
    updateAMRStuff();
	}
  else
    {
      for(std::list<IWell*>::iterator it = m_wells.begin(); it != m_wells.end(); ++it)
        {
          IWell* well = (*it);
          if(!well->productivityIndex().isValid())
            well->reinit(m_permeability, PRIMARYMESH_CAST(mesh())->nodesCoordinates());
        }
    }
	// AMR ends

  // Si l'operateur n'est pas forme, on le forme
  // En particulier, les proprietes geometriques necessaires sont calculees
  if(not m_operator_is_formed) {
    _formDiscreteOperator();
  }

  // On recupere le pas de temps courant
  Arcane::Real dt = m_global_deltat();

  bool solved = false;

  // Resolution du Newton
  {
    //Timer::Sentry sentry(&timer);
    solved = m_newton_solver->solve();
  }

  //const Real newton_part_time = parallelMng()->reduce(Parallel::ReduceSum, timer.lastActivationTime());
  //info() << "Area Tracking/Newton part time : " << fake_part_time << " / " << newton_part_time << " ratio: " << fake_part_time / newton_part_time;

  // Si la resolution est ok
  if(solved) {

	  // Calcul de la saturation en gas
	  ENUMERATE_CELL	(iCell,mesh()->ownActiveCells()) {
		  m_gas_saturation[iCell] = 1. - m_oil_saturation[iCell];
	  }
	  // AMR begins
	  if ( mesh()->isAmrActivated() ) // une option qui active ou desactive AMR
      {
        info() << "USE AMR";
		    switch(options()->amrError())
          {
		      case DiPhasicErrorIndicator::P :
		        m_mesh_changed = m_mesh_adapter->compute(m_pressure, m_pressure_tn, m_amr_error,dt);
		        break ;
		      case DiPhasicErrorIndicator::So :
		        m_mesh_changed = m_mesh_adapter->compute(m_oil_saturation,m_oil_saturation_tn, m_amr_error, dt);
		        break ;
		      case DiPhasicErrorIndicator::Sg :
		        m_mesh_changed = m_mesh_adapter->compute(m_gas_saturation,m_gas_saturation_tn, m_amr_error, dt);
		        break ;
          }
		    if(m_mesh_adapter->needMeshAdaptation()){
          m_mesh_adapter->adapt() ;
          _geometryUpdate();
		    }
      }
	  // AMR ends
   
	  // Sauvegarde des proprietes courantes
	  // ENUMERATE_CELL(iCell,ownCells()) {
	  ENUMERATE_CELL	(iCell,mesh()->ownActiveCells()) {  // AMR
		  m_pressure_tn[iCell] = m_pressure[iCell];
		  m_oil_saturation_tn[iCell] = m_oil_saturation[iCell];
		  m_oil_density_tn[iCell] = m_oil_density[iCell];
		  m_gas_saturation_tn[iCell] = m_gas_saturation[iCell];
	  }


  } else {
    
    // On rejoue l'iteration
    ArcGeoSim::TimeStep::Replay(options()->numerics().timeStepPolicy());

    // Reinitialisation des proprietes courantes
    // ENUMERATE_CELL(iCell,ownCells()) {
    ENUMERATE_CELL	(iCell,mesh()->ownActiveCells()) { // AMR
      m_pressure[iCell] = m_pressure_tn[iCell];
      m_oil_saturation[iCell] = m_oil_saturation_tn[iCell];
      m_gas_saturation[iCell] = m_gas_saturation_tn[iCell];
    }
  }
}

/*---------------------------------------------------------------------------*/

void 
DiPhasicModule::
on_mesh_changed()
{
  info() << "OnMeshChanged entry point";

  //  // Preparation de l'operateur discret
  //  _prepareDiscreteOperator();
  //
  //  // Calcul de l'operateur discret
  //  _formDiscreteOperator();
  //
  //  // Newton
  //  m_newton_solver->reinit();
  //
  //  // Reinitialisation des puits
  //  for(std::list<Well*>::iterator it = m_wells.begin(); it != m_wells.end(); ++it)
  //    {
  //      (*it)->reinit();
  //    }
  //
  //  // Synchronisation des variables
  //  m_pressure.synchronize();
  //  m_oil_saturation.synchronize();
  //  m_gas_saturation.synchronize();
  //  m_pressure_tn.synchronize();
  //  m_oil_saturation_tn.synchronize();
  //  m_gas_saturation_tn.synchronize();
}


//////==============================================================================================
//////                       Adaptation du maillage
//////==============================================================================================
void
DiPhasicModule::updateAMRStuff()
{
	info() << "UpdateAMRStuff entry point";
  
  	ArcGeoSim::AppService<IGeometryMng> geometry_mng;

	IGeometryPolicy * geometry_policy = new NoOptimizationGeometryPolicy;

	geometry_mng->update(geometry_policy);

	// Preparation de l'operateur discret
	_prepareDiscreteOperator();

	// Calcul de l'operateur discret
	_formDiscreteOperator();

	// Newton
	m_newton_solver->reinit();

	// Reinitialisation des puits
	_updateWell();

	// Synchronisation des variables
	m_pressure.synchronize();
	m_temperature.synchronize();

	m_gas_saturation.synchronize();
	m_gas_density.synchronize();
	m_gas_viscosity.synchronize();
	m_gas_relative_permeability.synchronize();
	m_deriv_gas_relative_permeability.synchronize();

	m_oil_saturation.synchronize();
	m_oil_density.synchronize();
	m_oil_viscosity.synchronize();
	m_oil_relative_permeability.synchronize();
	m_deriv_oil_relative_permeability.synchronize();

	m_pressure_tn.synchronize();
	m_gas_saturation_tn.synchronize();
	m_oil_saturation_tn.synchronize();
	m_oil_density_tn.synchronize();

}


/*---------------------------------------------------------------------------*/

void
DiPhasicModule::
_initializeLaws()
{
  info() << "initialize laws";

  // Oil phase
  options()->laws().oilDensity()->initialize(DiPhasic::OilDensity,m_law_mng);
  options()->laws().oilViscosity()->initialize(DiPhasic::OilViscosity,m_law_mng);
  options()->laws().oilRelativePermeability()->initialize(DiPhasic::OilRelativePermeability,m_law_mng);
  
  // Gas phase
  options()->laws().gasDensity()->initialize(DiPhasic::GasDensity,m_law_mng);
  options()->laws().gasViscosity()->initialize(DiPhasic::GasViscosity,m_law_mng);
  options()->laws().gasRelativePermeability()->initialize(DiPhasic::GasRelativePermeability,m_law_mng);

  // Rock
  options()->laws().permeability()->initialize(DiPhasic::Permeability,m_law_mng);
  options()->laws().porosity()->initialize(DiPhasic::Porosity,m_law_mng);

  info() << m_law_mng;
}

/*---------------------------------------------------------------------------*/

void
DiPhasicModule::
_computeInitialState()
{
  if (not IAppServiceMng::instance(subDomain()->serviceMng())->isContinue()) {
    // Etat initial
    const Real initial_pressure = options()->initialState().initialPressure();
    const Real initial_temperature = options()->initialState().initialTemperature();
    const Real initial_oil_saturation = options()->initialState().initialOilSaturation();
    if(initial_oil_saturation < 0. && initial_oil_saturation > 1.)
      fatal() << "initial oil saturation value not well defined (<0 or >1)";
    const Real initial_gas_saturation = 1. - initial_oil_saturation;
    // Initialisation sur toutes les mailles
    // (economie de communication)
    // ENUMERATE_CELL(iCell,allCells()) {
    ENUMERATE_CELL(iCell,mesh()->allActiveCells())	{ // AMR
      m_pressure[iCell] = m_pressure_tn[iCell] = initial_pressure;
      m_temperature[iCell] = initial_temperature;
      m_oil_saturation[iCell] = m_oil_saturation_tn[iCell] = initial_oil_saturation;
      m_gas_saturation[iCell] = m_gas_saturation_tn[iCell] = initial_gas_saturation;
    }
    
    // Evaluation des lois 
    Law::VariableAccessorT<Cell> accessor = m_variable_mng.variables<Arcane::Cell>();
    Law::FunctionEvaluator(m_law_mng).evaluate(accessor, allCells());

    // initialisation loi e tn
    ENUMERATE_CELL(iCell,mesh()->allActiveCells()) { // AMR
      m_oil_density_tn[iCell] = m_oil_density[iCell];
    }
  }
}


/*---------------------------------------------------------------------------*/

void
DiPhasicModule::
_initializeDiscreteOperator()
{
  m_discrete_operator = options()->numerics().discreteOperator();
  m_discrete_operator->init();

  if (not IAppServiceMng::instance(subDomain()->serviceMng())->isContinue()) {
    mesh()->faceFamily()->createGroup("CellUnknownsSupportInternalFaces");
    mesh()->faceFamily()->createGroup("BothCellAndFaceUnknownsSupportInternalFaces");
  }

  _prepareDiscreteOperator();

  ArcGeoSim::AppService<IGeometryMng> geometry_manager;

  geometry_manager->addItemGroupProperty(m_discrete_operator->cells(),
                                         m_discrete_operator->getCellGeometricProperties(),
                                         IGeometryProperty::PVariable);
  geometry_manager->addItemGroupProperty(m_discrete_operator->faces(),
                                         m_discrete_operator->getFaceGeometricProperties(),
                                         IGeometryProperty::PVariable);
}

/*---------------------------------------------------------------------------*/

void
DiPhasicModule::
_prepareDiscreteOperator()
{
  if ( mesh()->isAmrActivated() ) {
    FaceGroup cell_support_group          = mesh()->faceFamily()->findGroup("CellUnknownsSupportInternalFaces");
    FaceGroup cell_and_face_support_group = mesh()->faceFamily()->findGroup("BothCellAndFaceUnknownsSupportInternalFaces");

   // // Coefficients
    m_cell_coefficients.reset(new CoefficientArrayT<Cell>(mesh()->allActiveFaces(), mesh()->allActiveCells()));
    m_face_coefficients.reset(new CoefficientArrayT<Face>(mesh()->allActiveFaces(),allCells().outerActiveFaceGroup()));

   // // Preparation de l'operateur
    m_discrete_operator->prepare(allCells().innerActiveFaceGroup(),
                                 allCells().outerActiveFaceGroup(),
                                 cell_support_group,
                                 cell_and_face_support_group,
                                 m_cell_coefficients.get(),
                                 m_face_coefficients.get());
   // AMR ends
  }
  else {
    m_cell_coefficients.reset(new CoefficientArrayT<Cell>(allFaces(), allCells()));
    m_face_coefficients.reset(new CoefficientArrayT<Face>(allFaces(), allCells().outerFaceGroup()));
    m_discrete_operator->prepare(mesh(),
                                 m_cell_coefficients.get(),
                                 m_face_coefficients.get());
  }
}

/*---------------------------------------------------------------------------*/

void
DiPhasicModule::
_formDiscreteOperator()
{
  m_discrete_operator->formDiscreteOperator(m_permeability);
  m_operator_is_formed = true;
}

/*---------------------------------------------------------------------------*/

void
DiPhasicModule::
_initializeNumericalTools()
{
  ArcGeoSim::TimeStep::IComputer* policy = options()->numerics().timeStepPolicy();

  policy->init();

  ArcGeoSim::AppService<ArcGeoSim::ITimeLine> time;

  time->evolution().registerTimeStepComputer(policy);

  _initializeDiscreteOperator();

  m_non_linear_system = new SimpleDiPhasicOGSystem(m_variable_mng,
                                                   m_law_mng,
                                                   mesh(),
                                                   traceMng(),
                                                   m_wells,
                                                   m_pressure,
                                                   m_oil_saturation);

  // Initialisation
  m_non_linear_system->init();

  // On donne les coefficients des schemas
  m_non_linear_system->setDiscreteOperatorCoefficients(m_cell_coefficients);

  // Solveur non lineaire de type Newton
  m_newton_solver = options()->numerics().newtonSolver();

  // On donne le systeme non lineaire
  m_newton_solver->setNonLinearSystem(m_non_linear_system);

  // Initialisation
  m_newton_solver->init();
}

/*---------------------------------------------------------------------------*/

void
DiPhasicModule::
_initializeWell()
{
  const Integer nb_well = options()->wellNetwork().well().size();
  for(Integer i = 0; i < nb_well; ++i) {
    IWell* well = options()->wellNetwork().well[i];
    well->init(m_permeability,
               PRIMARYMESH_CAST(mesh())->nodesCoordinates());
    m_wells.push_back(well);
  }
}


//======================================================================================================
// reinitialisation des puits
//======================================================================================================
void
DiPhasicModule::_updateWell()
{

	bool raffined = false;
	bool deraffined = false;
	bool reinit = false;

  // Reinitialisation des puits

	Integer i = 0;
	for(std::list<IWell*>::iterator it = m_wells.begin(); it != m_wells.end(); ++it)
    {
      IWell* well = (*it);
	    const CellGroup & zone = well->perforatedCells();
	    raffined = false;
	    ENUMERATE_CELL(icell,zone){
        const Cell& cell = *icell;
        if (cell.hasHChildren()){
          raffined= true;
          break;
        }
      }

	    deraffined = false;
	    if ( zone.size() != getZoneSize(i) ) {
        deraffined = true;
	    }

	    // Premiere possibilite: on a des mailles deraffinees
	    // Mise a jour du groupe des mailles perforees actives en rajoutant
	    // les mailles parentes devenues actives
	    // Parallelement, le groupe des parents inactifs est mis a jour en enlevant
	    // les mailles parentes devenues actives
	    if(deraffined){
	    	well->update_PerforatedCells_After_Coarsening(well->parentCells());
	    }

	    // Deuxieme possibilite (cumulable avec la premiere): on a des mailles raffinees
      // Mise a jour du groupe des mailles perforees actives en rajoutant
	    // les enfants eventuellement crees et en enlevant les mailles parentes devenues inactives
	    // Parallelement, le groupe des parents inactifs est mis a jour en rajoutant
	    // les mailles parentes devenues inactives
      if(raffined){
        // mise a jour du groupe de mailles perforees
        well->update_PerforatedCells_After_Refinement(zone);
      }

      // mise a jour de la taille du groupe de mailles perforees
      // pour en conserver la trace de maniere e pouvoir la comparer
      // avec la nouvelle taille qui peut dimunuer en cas de deraffinement
      // (en effet, dans ce cas, les mailles raffinees disparaissent d'elles-memes)
      m_zones_sizes[i] = well->perforatedCells().size();

      reinit = raffined || deraffined || !well->productivityIndex().isValid() ;

      if( reinit ){
        //Re-Initialisation
        well->reinit(m_permeability, PRIMARYMESH_CAST(mesh())->nodesCoordinates());
      }
      i++;
    }
}

/*---------------------------------------------------------------------------*/

void
DiPhasicModule::
_geometryUpdate()
{
  ArcGeoSim::AppService<IGeometryMng> geometry_mng;
  IGeometryPolicy * geometry_policy = new ManualUpdateGeometryPolicy;
  geometry_mng->setPolicyTolerance(true);

  // AMR geometry groups for scheme calculations
  {
    geometry_mng->addItemGroupProperty(allCells(),
                                       IGeometryProperty::PCenter,
                                       IGeometryProperty::PVariable);
    geometry_mng->addItemGroupProperty(allFaces(),
                                       IGeometryProperty::PCenter,
                                       IGeometryProperty::PVariable);

    geometry_mng->addItemGroupProperty(mesh()->allActiveCells(),
                                       IGeometryProperty::PCenter,
                                       IGeometryProperty::PVariable);
    geometry_mng->addItemGroupProperty(mesh()->allActiveFaces(),
                                       IGeometryProperty::PCenter,
                                       IGeometryProperty::PVariable);

    geometry_mng->addItemGroupProperty(mesh()->allActiveCells(),
                                       IGeometryProperty::PMeasure,
                                       IGeometryProperty::PVariable);
    geometry_mng->addItemGroupProperty(mesh()->allActiveFaces(),
                                       IGeometryProperty::PMeasure,
                                       IGeometryProperty::PVariable);
    geometry_mng->addItemGroupProperty(mesh()->allActiveFaces(),
                                       IGeometryProperty::PNormal,
                                       IGeometryProperty::PVariable);
  }
  info() << "Geometric properties computation : ";
  info() << "  -- Cell centers";
  info() << "  -- Face centers";
  info() << "  -- Cell volume";
  info() << "  -- Face surface";
  geometry_mng->update(geometry_policy);
  delete geometry_policy;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_MODULE_DIPHASIC(DiPhasicModule);
