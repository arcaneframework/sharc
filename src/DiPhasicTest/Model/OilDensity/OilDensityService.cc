// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
/* Author : ricois at Thu Jun  9 13:23:26 2011
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

// Interface du service 
#include <arcane/IMesh.h>
#include <arcane/utils/ITraceMng.h>
#include "DiPhasicTest/Physics/Properties.h"

#include "ArcGeoSim/Numerics/Expressions/IFunctionR1vR1.h"
#include "ArcGeoSim/Numerics/Expressions/IFunctionR2vR1.h"
#include "ArcGeoSim/Numerics/Expressions/IFunction.h"
#include "DiPhasicTest/Model/ILawConfig.h"

// generated from OilDensity.law
#include "OilDensity_law.h"

#include "OilDensity_axl.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class OilDensityService 
  : public ArcaneOilDensityObject
{
public:
  struct Algo
  { 
  public:

   void compute(const Arcane::Real pression, const Arcane::Real temperature, Arcane::Real& oilDensity,
    		Arcane::Real& deriv_oilDensity_p, Arcane::Real& deriv_oilDensity_t) const
    {
      Arcane::Real oilcompressibility, dPoilcompressibility,
          dToilcompressibility;
      m_coco->eval(pression, temperature, oilcompressibility,
          dPoilcompressibility, dToilcompressibility);
      Arcane::Real oilThermalExpension, doilThermalExpension;
      m_etco->eval(temperature, oilThermalExpension, doilThermalExpension);

      oilDensity = m_rooRef * (1 + oilcompressibility * (pression
          - m_pRef) + oilThermalExpension * (temperature - m_tRef));

      deriv_oilDensity_p = m_rooRef * (dPoilcompressibility * (pression - m_pRef)
          + oilcompressibility);
      deriv_oilDensity_t = m_rooRef * (dToilcompressibility * (pression - m_pRef)
          + +doilThermalExpension * (temperature - m_tRef)
          + oilThermalExpension);
    }
    // en attendant les tables a deux abcisses
    IFunctionR2vR1* m_coco;
    IFunctionR1vR1* m_etco;
    Arcane::Real m_rooRef;
    Arcane::Real m_pRef;
    Arcane::Real m_tRef;
  };

  
  OilDensityService(const Arcane::ServiceBuildInfo & sbi) 
    : ArcaneOilDensityObject(sbi){}
  
  ~OilDensityService() {}
  
public:

  void initialize(const Law::ScalarRealProperty& p, Law::FunctionManager& law_register); 

private:
  Algo m_algo;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
OilDensityService::
initialize(const Law::ScalarRealProperty& p, Law::FunctionManager& law_register)
{
  m_algo.m_coco = options()->coco();
  m_algo.m_coco->init();
  m_algo.m_etco = options()->etco();
  m_algo.m_etco->init();

  m_algo.m_rooRef = options()->rooRef();
  m_algo.m_pRef = options()->pRef();
  m_algo.m_tRef = options()->tRef();

  OilDensity::Signature s;
  s.press = DiPhasic::Pressure;
  s.temp = DiPhasic::Temperature;
  s.rhoo = p;
  auto f = std::make_shared<OilDensity::Function>(s, m_algo, &Algo::compute);
  law_register << f;
}


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_OILDENSITY(OilDensity,OilDensityService);
