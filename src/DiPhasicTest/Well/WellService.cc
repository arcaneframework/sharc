// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
/* Author : desrozis at Tue Dec  8 16:30:09 2009
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "DiPhasicTest/Well/IWell.h"

#include "Well_axl.h"

#include <cmath>

#include <arcane/utils/Real3.h>
#include <arcane/MeshVariable.h>
#include <arcane/utils/Math.h>
#include "arcane/IMesh.h"
#include "arcane/BasicService.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

// Puits pression impos�e
// Pas de perte de charge

class WellService
  : public ArcaneWellObject
{
public:
  WellService(const Arcane::ServiceBuildInfo & sbi)
    : ArcaneWellObject(sbi)
    , m_initialized(false)
    , m_time_stamp(-1) {}
  ~WellService() {}

public:

  // Calcul de l'indice de productivit�
  void init(const Arcane::VariableCellReal& permeability,
            const Arcane::VariableNodeReal3& node_coordinates,
            const bool useDefaultFormula=true);

  // Type de puits
  eWellType type() const { return m_type; }

  // Donne les mailles perfor�es actives
  Arcane::CellGroup perforatedCells() const { return m_perforated_cells; }

  // Donne les mailles parentes inactives des mailles perfor�es actives
  Arcane::CellGroup parentCells() const { return m_parent_cells; }

  // Mise � jour des cellules perfor�es actives pour l'AMR en cas de raffinement
  void update_PerforatedCells_After_Refinement(const Arcane::CellGroup & old_pc );

  // Mise � jour des cellules perfor�es actives pour l'AMR en cas de d�raffinement
  void update_PerforatedCells_After_Coarsening(const Arcane::CellGroup & old_parents );

  // Recalcul de l'indice de productivit� si la maillage a chang�
  void reinit(const Arcane::VariableCellReal& permeability,
              const Arcane::VariableNodeReal3& node_coordinates,
              const bool useDefaultFormula=true);

  // Donne l'indice de productivit�
  const ItemGroupMapT<Cell,Real>& productivityIndex() const { return m_productivity_index; }

  // Donne la pression du puits
  Arcane::Real pressure() const { return m_bottom_pressure; }

  Arcane::Real refZ() const { return m_ref_z; }

private:

  // Initialisation des puits
  void _initialize(const Arcane::VariableCellReal& permeability,
                   const Arcane::VariableNodeReal3& node_coordinates,
                   const bool useDefaultFormula);

  // Calcul de l'�paisseur de la maille
  Arcane::Real3 _computeCellThickness(Arcane::Cell cell,
                                      const Arcane::VariableNodeReal3& node_coordinates) const;

private:

  bool m_initialized;

  // Type de puits
  eWellType m_type;

  // Pression de fond
  Arcane::Real m_bottom_pressure;

  Arcane::Real m_ref_z;
  // Rayon du puits
  Arcane::Real m_radius;

  // Mailles perfor�es actives
  Arcane::CellGroup m_perforated_cells;

  // Mailles parentes inactives
  Arcane::CellGroup m_parent_cells;

  // Indice de productivit�
  ItemGroupMapT<Cell,Real> m_productivity_index;

  // Time stamp du groupe pour le recalcul quand le maillage a chang�
  Arcane::Int64 m_time_stamp;

};

/*---------------------------------------------------------------------------*/

void
WellService::
init(const Arcane::VariableCellReal& permeability,
     const Arcane::VariableNodeReal3& node_coordinates,
     const bool useDefaultFormula)
{
  if(m_initialized) return;
  m_perforated_cells = mesh() -> cellFamily() -> findGroup(options()->perforatedCells(), true);
  //m_parent_cells = NULL;
  m_time_stamp = m_perforated_cells.timestamp();

  //m_active_perforated_cells = options()->perforatedCells();

  //m_active_perforated_cells = CellFamily::createGroup();
  //m_active_perforated_cells = CellGroup();

  //computeActivePerforatedCells(); // AMR

  m_productivity_index.init(m_perforated_cells); // AMR
  m_type = options()->type();
  m_bottom_pressure = options()->bottomPressure();
  m_ref_z = options()->refZ();
  m_radius = options()->radius();
  _initialize(permeability, node_coordinates, useDefaultFormula);
  m_initialized = true;
}


/*---------------------------------------------------------------------------*/

void
WellService::
_initialize(const Arcane::VariableCellReal& permeability,
            const Arcane::VariableNodeReal3& node_coordinates,
            const bool useDefaultFormula)
{
  ItemGroupMapT<Cell,Real3> cell_thickness;
  cell_thickness.init(m_perforated_cells) ; // AMR
  
  const Real pi = std::acos(-1.);

  if(useDefaultFormula) {
    const Real tmp_radius = 0.5 / m_radius;
    ENUMERATE_CELL(iCell,m_perforated_cells) {
      Cell cell = *iCell;
      
      cell_thickness[iCell] = _computeCellThickness(cell,node_coordinates);
      const Real& dx = cell_thickness[cell].x;
      const Real& dy = cell_thickness[cell].y;
      const Real tmp = permeability[iCell] * 2. * pi;
      // Formule IP de Peaceman
      m_productivity_index[iCell]= tmp / Arcane::math::log( tmp_radius * Arcane::math::sqrt(dx * dy));
    }
  } else {
    ENUMERATE_CELL(iCell,m_perforated_cells) {
      Cell cell = *iCell;      
      cell_thickness[iCell] = _computeCellThickness(cell,node_coordinates);
      const Real dx = cell_thickness[cell].x;
      const Real dy = cell_thickness[cell].y;
      const Real dz = cell_thickness[cell].z;
      const Real tmp = permeability[iCell] * 2. * pi * dz ;
      // Formule IP de Peaceman
      m_productivity_index[iCell]= tmp / Arcane::math::log( Arcane::math::sqrt(dx * dx + dy * dy) / m_radius);

      /*info() << Arcane::String::format("IP = {0}, IP2 = {1}, dx = {2},  dy = {3},  dz = {4}, perm = {5}, rw={6}", m_productivity_index[iCell],
	tmp / Arcane::math::log( 0.20788 * Arcane::math::sqrt(dx * dx + dy * dy) / m_radius), dx, dy, dz, permeability[iCell], m_radius);*/
    }
  }
}


/*-------------------------------------------------------------------------------------*/
void WellService::update_PerforatedCells_After_Coarsening(const Arcane::CellGroup & old_parents )
{

	Arcane::Int32SharedArray new_lids;

	// Parcours des cellules de l'ancien groupe des parents

		ENUMERATE_CELL(icell,old_parents)
		{
			const Cell & cell = *icell;
			if ( cell.isActive() )
			{
				new_lids.add(cell.localId()) ;
			}
		}

		m_perforated_cells.addItems(new_lids,true);
		m_parent_cells.removeItems(new_lids,true);
}

/*--------------------------------------------------------------------------------*/
void WellService::update_PerforatedCells_After_Refinement(const Arcane::CellGroup & old_pc )
{
	Arcane::Int32SharedArray active_lids; // �l�ments actifs: feuilles de l'arbre
	Arcane::Int32SharedArray parent_lids; // parents devenus inactifs

	bool group_changed = false;

	// Parcours des cellules de l'ancien groupe des mailles actives

	ENUMERATE_CELL(icell,old_pc)
	{
		const Cell & cell = *icell;
		// Si la maille a �t� raffin�e
		if (cell.hasHChildren()){
			group_changed = true;

			// 1. On stocke dans active_lids les mailles filles
			for(Integer j=0,js=cell.nbHChildren();j<js;j++){
				Item child= cell.hChild(j);
				active_lids.add(child.localId()) ;
			}

			// 2. On stocke dans parent_lids la maille parente
			parent_lids.add(cell.localId());
		}
		else {
			 // la cellule n'est pas raffin�e, elle reste active
			 active_lids.add(cell.localId()) ;
		}
	}


    // si le groupe est constitu� de mailles diff�rentes, on le met � jour
	// en rajoutant sans r�p�tition les nouvelles cellules filles

	if(group_changed)
	{
		m_perforated_cells.setItems(active_lids);

		// on met � jour la liste des parents inactifs
		if (m_parent_cells.null() == true)
		   m_parent_cells = mesh()->cellFamily()->createGroup("Parents", parent_lids, true);
		else
			m_parent_cells.addItems(parent_lids,true);
	}

	return ;
}

/*---------------------------------------------------------------------------*/

void
WellService::
reinit(const Arcane::VariableCellReal& permeability,
       const Arcane::VariableNodeReal3& node_coordinates,
       const bool useDefaultFormula)
{

  m_productivity_index.init(m_perforated_cells);

  if (not m_initialized) {
    init(permeability,node_coordinates);
    return;
  }
  Arcane::Int64 time_stamp = m_perforated_cells.timestamp();
  // Le groupe a chang�, il faut recalculer
  if(m_time_stamp != time_stamp) {
    _initialize(permeability,node_coordinates, useDefaultFormula);
    m_time_stamp = time_stamp;
  }
}

/*---------------------------------------------------------------------------*/

Arcane::Real3
WellService::
_computeCellThickness(Cell cell, const Arcane::VariableNodeReal3& node_coordinates) const
{
  Arcane::Real3 min_coord, max_coord;
  min_coord = max_coord = node_coordinates[cell.node(0)];
  ENUMERATE_NODE(iNode,cell.nodes()) {
    const Real3& node_coord = node_coordinates[iNode];
    min_coord.x = std::min(min_coord.x,node_coord.x);
    max_coord.x = std::max(max_coord.x,node_coord.x);
    min_coord.y = std::min(min_coord.y,node_coord.y);
    max_coord.y = std::max(max_coord.y,node_coord.y);
    min_coord.z = std::min(min_coord.z,node_coord.z);
    max_coord.z = std::max(max_coord.z,node_coord.z);
  }
  return max_coord - min_coord;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_WELL(Well,WellService);
