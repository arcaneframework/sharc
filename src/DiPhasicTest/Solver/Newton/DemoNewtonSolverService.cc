// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
/* Author : desrozis at Thu Dec 10 08:52:17 2009
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include <alien/ref/AlienRefSemantic.h>
#include <alien/arcane_tools/accessors/ItemVectorAccessor.h>
#include <alien/expression/solver/ILinearSolver.h>

#include "DiPhasicTest/Solver/INewtonSolver.h"
#include "DiPhasicTest/Solver/IEquationSystem.h"

#include "DemoNewtonSolver_axl.h"

#include <arcane/IParallelMng.h>
#include <arcane/IMesh.h>
#include <cmath>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class DemoNewtonSolverService
  : public ArcaneDemoNewtonSolverObject
{
public:
  DemoNewtonSolverService(const Arcane::ServiceBuildInfo & sbi)
    : ArcaneDemoNewtonSolverObject(sbi)
    , m_initialized(false)
    , m_parallel_mng(NULL)
    , m_nb_iteration_max(0)
    , m_tolerance(0)
    , m_relative_tolerance(0)
    , m_control_factor(0)
    , m_linear_solver(NULL)
    , m_non_linear_system(NULL)
    {}

  ~DemoNewtonSolverService() {
    const Arcane::Integer size = m_delta_unknown.size();
    for(Arcane::Integer i = 0; i<size; ++i) {
      delete m_delta_unknown[i];
    }
  }

public:

  // Initialisation
  void init();

  // Re-Initialisation
  void reinit();

  // Donne le syst�me non lin�aire � r�soudre
  void setNonLinearSystem(INonLinearSystem * non_linear_system) {
    m_non_linear_system = non_linear_system;
  }

  // Resolution du probl�me non lin�aire
  bool solve();

private:

  // Calcul de l'erreur sur les r�sidus
  Arcane::Real _computeError() const;

  // Mise � jour de la solution
  void _updateSolution();

private:

  bool m_initialized;

  // Gestionnaire de parall�lisme
  Arcane::IParallelMng * m_parallel_mng;

  // Nombre d'it�ration
  Arcane::Integer m_nb_iteration_max;

  // Tol�rance
  Arcane::Real m_tolerance;

  // Tol�rance relative
  Arcane::Real m_relative_tolerance;

  // Facteur de controle
  Arcane::Real m_control_factor;

  // Solveur lin�aire
  Alien::ILinearSolver * m_linear_solver;

  // Syst�me non lin�aire
  INonLinearSystem * m_non_linear_system;

  // R�sidus
  Arcane::SharedArray<Arcane::VariableCellReal*> m_residual_equation;

  // Solutions du syst�me lin�aire
  Arcane::SharedArray<Arcane::VariableCellReal*> m_delta_unknown;

  // Solutions du syst�me non lin�aire
  Arcane::SharedArray<Arcane::VariableCellReal*> m_solution;

  // Controle des variations de la solution
  Arcane::SharedArray<IVariationCheckEvent*> m_control;

  // Contrainte de la solution
  Arcane::SharedArray<IConstraintEvent*> m_constraint;
};

//#include "DiPhasicTest/Property/PropertyHandler.h"
//#include "DiPhasicTest/System/INonLinearSystem.h"
//#include "DiPhasicTest/System/IEquationSystem.h"
//
//#include "Numerics/LinearSolver/ILinearSolver.h"
//#include "Numerics/LinearSolver/ILinearSystemBuilder.h"
//
//#include <arcane/VariableBuildInfo.h>
//
//#include <cmath>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
DemoNewtonSolverService::
init()
{
  if(m_initialized) return;

  info() << A_FUNCINFO;

  if(not m_non_linear_system) {
    fatal() << "Set non linear system before newton initialisation";
  }
  
  m_parallel_mng = subDomain()->parallelMng();
  m_nb_iteration_max = options()->iterationMax();
  m_tolerance = options()->tolerance();
  m_relative_tolerance = options()->relativeTolerance();
  m_control_factor = options()->controlFactor();

  INonLinearEquationSystem * equation_system = m_non_linear_system->equationSystem();
  const Arcane::Integer size = equation_system->size();
  m_residual_equation.resize(size);
  m_delta_unknown.resize(size);
  m_solution.resize(size);
  m_control.resize(size);
  m_constraint.resize(size);



  for(Arcane::Integer i = 0; i<size; ++i) {
    // Convention
    Arcane::String residual_equation_name = "Residual" + equation_system->equationName(i);
    // Residu de l'�quation
    Arcane::VariableCellReal& residual_equation = equation_system->residual(i);
    // On stocke le r�sidu
    m_residual_equation[i] = &residual_equation;
    // Solution
    Arcane::VariableCellReal& solution = equation_system->solution(i);
    // On stocke la solution
    m_solution[i] = &solution;
    // Convention
    Arcane::String delta_unknown_name = "Delta" + equation_system->unknownName(i);
    // On cr�e la variable
    m_delta_unknown[i] = new Arcane::VariableCellReal(Arcane::VariableBuildInfo(mesh(),delta_unknown_name));
    (*m_delta_unknown[i]).fill(0.);
    // Ajout de la propri�t� dans le gestionnaire
    equation_system->setDerivSolution(i,*m_delta_unknown[i]);
    // Controle de variations de la solution
    m_control[i] = equation_system->variationCheckEvent(i);
    // Contrainte de la solution
    m_constraint[i] = equation_system->constraintEvent(i);
  }
  
  m_linear_solver = options()->linearSolver();
  
  // Initialisation du solveur
  m_linear_solver->init();
 
  // Calcul du profil de la matrice
  m_non_linear_system->buildMatrixProfil();
  
  m_initialized = true;
}

/*---------------------------------------------------------------------------*/

void 
DemoNewtonSolverService::
reinit()
{
  if (not m_initialized) {
    init();
    return;
  }

  m_linear_solver->init();
  m_non_linear_system->buildMatrixProfil();
}

/*---------------------------------------------------------------------------*/

Real
DemoNewtonSolverService::
_computeError() const
{
  // Nombre de residus
  const Integer size = m_residual_equation.size();
  // Norme des r�sidus
  Real error = 0.;
  // Erreur en norme L2
  for(Integer i = 0; i<size; ++i) {
    const Arcane::VariableCellReal& residual = *(m_residual_equation[i]);
    ENUMERATE_CELL(iCell,mesh()->ownCells()) {
      error += residual[iCell] * residual[iCell];
    }
  }
  // R�duction
  error = m_parallel_mng->reduce(Arcane::Parallel::ReduceSum,error);
  return std::sqrt(error);
}

/*---------------------------------------------------------------------------*/

void
DemoNewtonSolverService::
_updateSolution()
{
  // Nombre de residus
  const Integer size = m_residual_equation.size();

  auto& alienDelta = m_non_linear_system->getDelta();

  // Check des variations
  Real max_variation = 0. ;
  for(Integer i = 0; i<size; ++i) {
    max_variation = 0.; // BIZARRE JE PENSE QUE C EST UN BUG (JMG)
    Arcane::VariableCellReal& variation = *(m_delta_unknown[i]);
    
    const auto& index_set = m_non_linear_system->getIndexSet(i);
      
    Alien::ArcaneTools::ItemVectorAccessor v(alienDelta);
    Alien::ArcaneTools::Variable(variation) = v(index_set);

    max_variation = m_control[i]->apply(variation,max_variation);
    info() << "Max variation unknown " << i << " = "<< max_variation;
  }
  // Synchronisation
  max_variation = m_parallel_mng->reduce(Arcane::Parallel::ReduceMax,max_variation);
  // Param�tre de relaxation
  //Real alpha(1.0);
  //if(max_variation > m_control_factor) {
  //alpha = m_control_factor * max_variation;
    //} else {
    //alpha = 1.;
    //}
  // Construction de la solution
  for(Integer i = 0; i<size; ++i) {
    Arcane::VariableCellReal& solution = *(m_solution[i]);
    const Arcane::VariableCellReal& delta = *(m_delta_unknown[i]);
    // Reconstruction et troncature de la solution
    if(i == 0) {
      ENUMERATE_CELL(iCell,mesh()->ownCells()) {
        solution[iCell] += delta[iCell];
      }
    } else {
      ENUMERATE_CELL(iCell,mesh()->ownCells()) {
        const Arcane::Real var(delta[iCell]) ;
        const Arcane::Real signVar((var > 0.) ? 1.0 : -1.0) ;

        const Arcane::Real varEff(std::min(std::fabs(var), 0.1)) ;
        solution[iCell] += signVar * varEff;
      }
    }

    // Contrainte sur la solution
    m_constraint[i]->apply(solution);
    // Synchronisation
    solution.synchronize();
  }
}

/*---------------------------------------------------------------------------*/

bool
DemoNewtonSolverService::
solve()
{
  // Construction des flux
  m_non_linear_system->buildFlux();
  
  // Construction des r�sidus
  m_non_linear_system->buildResidual();
  
  Real normr, normr0;
  
  // Norme des r�sidus
  normr0 = normr = _computeError();

  Integer iteration = 1;

  info() << " *** Newton : ";
  info() << " ** Initial residual Norm L2 = " << std::setprecision(10) << normr0;

  if(normr0 < m_tolerance) 
    {
      info() << " * Initial guess is good solution";
      
      return true;
    }

  info() << " ** relative  initial residual Norm L2 = " << std::setprecision(10) << normr / normr0;
   
  while( (normr / normr0 > m_relative_tolerance) && (iteration < m_nb_iteration_max) )
    {
      iteration ++;

      // Construction de la jacobienne
      m_non_linear_system->buildJacobian(); 
      
      // Assemblage du syst�me lin�aire
      m_non_linear_system->assemble(); 

      // R�solution du syst�me lin�aris�
      bool succes = m_linear_solver->solve(m_non_linear_system->getJacobian(),
                                           m_non_linear_system->getResidual(),
                                           m_non_linear_system->getDelta());
      
      if(not succes)
        {
          fatal() << " *** Linear system resolution error ... Oups!";
        }
      
      // Mise � jour de la solution
      _updateSolution();
  
      // Construction des flux
      m_non_linear_system->buildFlux();

      // Construction des r�sidus
      m_non_linear_system->buildResidual();
    
      // Norme des r�sidus
      normr = _computeError();
      
      info() << " * Relative residual Norm L2 = " << std::setprecision(10) << normr / normr0;
  
      if(normr < m_tolerance)
        {
          info() << " * Residual Norm L2 = " << std::setprecision(10) << normr;

          info() << " --- Newton converged ---";
          
          return true;
        }
    }
  
  if(iteration == m_nb_iteration_max) 
    {
      info() << " --- Newton not converged ERROR Max iteration reached ---";
      
      return false;
    }

  info() << " --- Newton converged ---";

  return true;
}
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_DEMONEWTONSOLVER(NewtonSolver,DemoNewtonSolverService);
