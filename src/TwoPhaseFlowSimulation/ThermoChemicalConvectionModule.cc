// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
/* Author : S.Y. at Fri Mar 21 12:10:47 2023
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
//#define SPARSE_AUDI
// generated by gump
#include "ArcRes/Entities/System.h"
#include "ArcRes/Properties.h"

#include "BoundaryCondition/IBoundaryManager.h"
#include "InitialCondition/IInitialCondition.h"

#include "PhysicalSystem/IPhysicalSystem.h"
#include "PhysicalSystem/IVariableManager.h"

#include "PhysicalLaws/ILawConfigurator.h"

#include "ArcGeoSim/Numerics/DiscreteOperator/IDivKGradDiscreteOperator.h"

#include "ArcGeoSim/Physics/Law2/VariableManager.h"
#include "ArcGeoSim/Physics/Law2/FunctionManager.h"
#include "ArcGeoSim/Physics/Law2/FunctionEvaluator.h"
#include "ArcGeoSim/Physics/Law2/EvaluationResults.h"
#include "ArcGeoSim/Physics/Law2/Contribution/ContributionAccessor.h"
#include "ArcGeoSim/Physics/Law2/Contribution/VariableFolderAccessor.h"

#include "ArcGeoSim/Numerics/Discretization/Schemes/TwoPointsScheme/TwoPointsTransmissivity.h"
#include "ArcGeoSim/Numerics/Discretization/Schemes/TwoPointsStencil.h"
#include "ArcGeoSim/Numerics/ArcNumTools/LinearAlgebra/Vector.h"
#include "ArcGeoSim/Numerics/ArcNumTools/LinearAlgebra/Matrix.h"
#include "ArcGeoSim/Numerics/ArcNumTools/Solver/INewtonSolver.h"

#include "ArcGeoSim/Appli/AppService.h"
#include "ArcGeoSim/Appli/ITimeLoopSnapshotManager.h"
#include "ArcGeoSim/Time/Activity/ReplayTimeStep.h"

#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"
#include "ArcGeoSim/Mesh/Geometry/ManualUpdateGeometryPolicy.h"

#include "ArcGeoSim/Numerics/GroupCreator/IGroupCreator.h"

#include "ThermoChemicalConvection_axl.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class ThermoChemicalConvectionModule
        : public ArcaneThermoChemicalConvectionObject
                , public ArcNum::INonLinearSystem
{
public:

    ThermoChemicalConvectionModule(const Arcane::ModuleBuildInfo & sbi)
            : ArcaneThermoChemicalConvectionObject(sbi)
    {}

    ~ThermoChemicalConvectionModule() {}

public:

    // Methode du module
    void init();
    void compute();

    // Interface Systeme non lineaire
    Integer nbEquations() const { return m_unknown_manager.size() ; }

    Domain const& systemDomain() const {  return m_domain ; }

    void initLinearSystemProfile(Arcane::CellGroup cells,
                               Alien::MatrixProfiler& blockProfiler,
                               Arcane::ConstArray2View<Arcane::Integer> indexes,
                               Arcane::Integer block_size) ;

    void setSolutionVariables(Arcane::SharedArray<Arcane::VariableCellReal*>& solutions) ;

    const Law::PropertyVector& equationSystem() const { return m_unknown_manager; }
    void build(ArcNum::Vector& residual, ArcNum::Matrix& jacobian);
    const Law::VariableCellFolder& folder() const { return m_folder->domain(); }

private:

    // system gump
    ArcRes::System& system() { return m_system; }
    // unknowns as Law::PropertyVector!
    const Law::PropertyVector& unknownsManager() const { return m_unknown_manager; }
    // law function manager
    Law::FunctionManager& functionMng() { return m_funcs; }
    // domain for contributions
    Law::VariableCellFolder& domain() { return m_folder->domain(); }
    Law::VariableCellFolder& domainT0() { return m_folder->domainT0(); }
    Law::VariableCellFolder& domainTn() { return m_folder->domainTn(); }
    // init functions
    void _addTimeVariable(const Gump::ScalarRealProperty& property);
    void _initPhysicalSystem();
    void _initGeometry();
    void _initGroup() ;
    void _initDomainVariableMng();
    void _initBoundaryVariableMng();
    void _initTimeVariableMng();
    void _initTransmissivity();
    void _initEquationSystem();
    void _initRestore();
    void _initLaws();
    void _initNewton();
    // build functions
    template<typename Folder>
    void _evaluateLaws(Folder& folder, Law::EvaluationMode derivability);
    void _buildAccumulation(ArcNum::Vector& residual, ArcNum::Matrix& jacobian);
    void _buildFluxInternal(ArcNum::Vector& residual, ArcNum::Matrix& jacobian);
    void _buildFluxBoundary(ArcNum::Vector& residual, ArcNum::Matrix& jacobian);

    void _twoPointsProfiler(Arcane::CellGroup cells,
                            Alien::MatrixProfiler& blockProfiler,
                            Arcane::ConstArray2View<Arcane::Integer> indexes,
                            Arcane::Integer block_size) const
    {
      Arcane::CellGroup group = cells;
      info() << "Define profil on group '" << group.name() << "' size = " << group.size();

      ENUMERATE_CELL(icell, group.own()) {
        const Arcane::Integer lid = icell->localId();
        blockProfiler.addMatrixEntry(indexes[lid][0]/block_size, indexes[lid][0]/block_size);
      }

      ENUMERATE_FACE(iface, group.innerActiveFaceGroup()) {
        const Arcane::Cell back_cell = iface->backCell();
        const Arcane::Integer back_lid = back_cell.localId();
        const Arcane::Cell front_cell = iface->frontCell();
        const Arcane::Integer front_lid = front_cell.localId();
        if(back_cell->isOwn())
          blockProfiler.addMatrixEntry(indexes[back_lid][0]/block_size, indexes[front_lid][0]/block_size);
        if(front_cell->isOwn())
          blockProfiler.addMatrixEntry(indexes[front_lid][0]/block_size, indexes[back_lid][0]/block_size);
      }

      info() << "OK Define profil";
    }

    void _multiPointsProfiler(Arcane::CellGroup cells,
                              Alien::MatrixProfiler& blockProfiler,
                              Arcane::ConstArray2View<Arcane::Integer> indexes,
                              Arcane::Integer block_size) const {
      Arcane::CellGroup group = cells;

      info() << "Define profil on group '" << group.name() << "' size = " << group.size();

      ENUMERATE_CELL(icell, group.own()) {
        const Arcane::Integer lid = icell->localId();
        //profiler(indexes[lid], indexes[lid]);
        blockProfiler.addMatrixEntry(indexes[lid][0]/block_size,indexes[lid][0]/block_size);
      }

      ENUMERATE_FACE(iface, group.innerActiveFaceGroup()) {
        m_schemeStencil -> init(iface) ;

        const Arcane::Cell backCell(iface->backCell()) ;

        if(backCell.isOwn()) {
          const Arcane::Integer backLid(backCell.localId()) ;
          for(m_schemeStencil -> begin() ; ! m_schemeStencil -> end() ; m_schemeStencil -> next()) {
            const auto& lawCell(m_schemeStencil->cell()) ;
            const auto cellLId(lawCell.localId()) ;
            //profiler(indexes[backLid], indexes[cellLId]);
            blockProfiler.addMatrixEntry(indexes[backLid][0]/block_size, indexes[cellLId][0]/block_size);
          }
        }

        const Arcane::Cell frontCell(iface->frontCell()) ;

        if(frontCell.isOwn()) {
          const Arcane::Integer frontLid(frontCell.localId()) ;
          for(m_schemeStencil -> begin() ; ! m_schemeStencil -> end() ; m_schemeStencil -> next()) {
            const auto& lawCell(m_schemeStencil->cell()) ;
            const auto cellLId(lawCell.localId()) ;
            //profiler(indexes[frontLid], indexes[cellLId]);
            blockProfiler.addMatrixEntry(indexes[frontLid][0]/block_size, indexes[cellLId][0]/block_size);
          }
        }
      }

      ENUMERATE_FACE(iface, group.outerActiveFaceGroup()) {
        m_schemeStencil -> init(iface) ;

        const Arcane::Cell boundaryCell(iface->boundaryCell()) ;

        if(boundaryCell.isOwn()) {
          const Arcane::Integer boundLid(boundaryCell.localId()) ;
          for(m_schemeStencil -> begin() ; ! m_schemeStencil -> end() ; m_schemeStencil -> next()) {
            const auto& lawCell(m_schemeStencil->cell()) ;
            const auto cellLId(lawCell.localId()) ;
            //profiler(indexes[boundLid], indexes[cellLId]);
            blockProfiler.addMatrixEntry(indexes[boundLid][0]/block_size, indexes[cellLId][0]/block_size);
          }
        }
      }

      //TODO : Create the group of contacts from the connections and complete the profiling of the matrix

      info() << "Multi-points profile defined";
    }

private:

    ArcNum::TwoPointsTransmissivity m_transmissivities;
    std::shared_ptr<ArcNum::MultiPointsStencil> m_schemeStencil ;

    // unknowns as Law::PropertyVector!
    Law::PropertyVector m_unknown_manager;

    // system instance based on gump
    ArcRes::System m_system;

    // evolutive variable management restart newtown
    ArcGeoSim::AppService<ArcGeoSim::ITimeLoopSnapshotManager> m_snapshots;

    // law function manager and evaluator
    Law::FunctionManager m_funcs;
    Arcane::SharedArray<Gump::ScalarRealProperty> m_properties_to_evaluate;

    // acces domain for contributions
    ArcGeoSim::AppService<IVariableManager> m_folder;
    ArcNum::INonLinearSystem::Domain        m_domain ;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

// restart management
void
ThermoChemicalConvectionModule::
_addTimeVariable(const Gump::ScalarRealProperty& property)
{
    domainTn().addVariable(property);
    auto v   = Law::values(domain(), property);
    auto vTn = Law::values(domainTn(), property);
    m_snapshots->snap(v, vTn);
}

// load system as service
void
ThermoChemicalConvectionModule::
_initPhysicalSystem()
{
    if(m_system == NULL) {
        ArcGeoSim::AppService<IPhysicalSystem> physical_system;
        m_system = physical_system->system();
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
ThermoChemicalConvectionModule::
init()
{

    info() << "create physical solver";
    _initPhysicalSystem();

    info() << "create function manager";
    ArcRes::FluidSubSystem fluid = system().fluidSubSystem();
    ArcRes::SolidSubSystem solid = system().solidSubSystem();

    if(fluid.phases().size() != 1)
        fatal() << "fluid-system should have exactly one phases";

    if(solid.phases().size() != 1)
        fatal() << "solid-system should have exactly one phases";

    _initGeometry();
    _initGroup() ;
    _initDomainVariableMng();
    _initBoundaryVariableMng();
    _initTransmissivity();
    _initTimeVariableMng();
    _initLaws();
    _initRestore();
    _initEquationSystem();
    _initNewton();
}

void
ThermoChemicalConvectionModule::
initLinearSystemProfile(Arcane::CellGroup cells,
                        Alien::MatrixProfiler& blockProfiler,
                        Arcane::ConstArray2View<Arcane::Integer> indexes,
                        Integer block_size)
{

  if(m_schemeStencil == nullptr)
    _twoPointsProfiler(cells, blockProfiler, indexes, block_size);
  else
    _multiPointsProfiler(cells, blockProfiler, indexes, block_size) ;
}

void
ThermoChemicalConvectionModule::
setSolutionVariables(Arcane::SharedArray<Arcane::VariableCellReal*>& solutions)
{
  auto accessor = folder().lawVariableAccessor();
  for(Integer i =0; i< m_unknown_manager.size(); ++i)
  {
    const Law::ScalarRealProperty& property = m_unknown_manager[i];
    solutions.add(new Arcane::VariableCellReal(accessor.values(property)));
  }
}
/*---------------------------------------------------------------------------*/

void
ThermoChemicalConvectionModule::
compute()
{
    info() << "solve non linear problem at iteration " << m_global_iteration();
    bool r = options()->numerics().newton()->solve();
    if(not r) {
        // snapped evolutive variables go back to initial time step value
        throw ArcGeoSim::TimeStep::ReplayException("Error in computation - go backward!");
    }
}

/*---------------------------------------------------------------------------*/

void
ThermoChemicalConvectionModule::
build(ArcNum::Vector& residual, ArcNum::Matrix& jacobian)
{
    residual = 0.;

    _evaluateLaws(domain(), Law::eWithDerivative);

    _buildAccumulation(residual, jacobian);
    _buildFluxInternal(residual, jacobian);
    _buildFluxBoundary(residual, jacobian);
}

/*---------------------------------------------------------------------------*/

void
ThermoChemicalConvectionModule::
_initGeometry()
{
    info() << "register geometric properties";

    IAppServiceMng* app_service_mng = IAppServiceMng::instance(subDomain()->serviceMng());
    IGeometryMng* geometry_mng = app_service_mng->find<IGeometryMng>(true);
    geometry_mng->setPolicyTolerance(true);

    geometry_mng->addItemGroupProperty(allCells(),
                                       IGeometryProperty::PMeasure,
                                       IGeometryProperty::PVariable);

    geometry_mng->addItemGroupProperty(allCells(),
                                       IGeometryProperty::PCenter,
                                       IGeometryProperty::PVariable);

    geometry_mng->addItemGroupProperty(allFaces(),
                                       IGeometryProperty::PMeasure,
                                       IGeometryProperty::PVariable);

    geometry_mng->addItemGroupProperty(allFaces(),
                                       IGeometryProperty::PCenter,
                                       IGeometryProperty::PVariable);

    geometry_mng->addItemGroupProperty(allFaces(),
                                       IGeometryProperty::PNormal,
                                       IGeometryProperty::PVariable);

    info() << "force update of geometric properties";

    IGeometryPolicy* geometry_policy = new ManualUpdateGeometryPolicy;
    geometry_mng->update(mesh(), geometry_policy);
    delete geometry_policy;
}

/*---------------------------------------------------------------------------*/

void
ThermoChemicalConvectionModule::
_initGroup()
{    auto groupCreator(options() -> groupCreator()) ;
    groupCreator -> init() ;
    groupCreator -> prepare() ;
    groupCreator -> apply() ;
}

/*---------------------------------------------------------------------------*/

void
ThermoChemicalConvectionModule::
_initDomainVariableMng()
{
    info() << "define domain containers for properties";
    m_domain.init(domain().key(),domain().support()) ;

    ArcRes::FluidSubSystem fluid = system().fluidSubSystem();
    ArcRes::SolidSubSystem solid = system().solidSubSystem();

    domain().addVariable(ArcRes::Pressure(system()));
    domain().addVariable(ArcRes::Concentration(system()));
    domain().addVariable(ArcRes::Temperature(system()));

    domain().addVariable(ArcRes::Permeability(fluid));
    domain().addVariable(ArcRes::XPermeability(fluid));
    domain().addVariable(ArcRes::YPermeability(fluid));
    domain().addVariable(ArcRes::ZPermeability(fluid));
    domain().addVariable(ArcRes::VolumeFraction(fluid));

    domain().addVariable(ArcRes::MolecularDiffusivity(solid));


    ENUMERATE_PHASE(iphase, fluid.phases()) {
        domain().addVariable(ArcRes::Density(iphase), Law::WithDerivative);
        domain().addVariable(ArcRes::FluidDensity(iphase), Law::WithDerivative);
        domain().addVariable(ArcRes::Viscosity(iphase), Law::WithDerivative);
        domain().addVariable(ArcRes::RelativePermeability(iphase), Law::WithDerivative);
        domain().addVariable(ArcRes::HeatCapacity(iphase), Law::WithDerivative);
        domain().addVariable(ArcRes::HeatConductivity(iphase), Law::WithDerivative);
    }
    ENUMERATE_PHASE(iphase, solid.phases()) {
        domain().addVariable(ArcRes::Density(iphase), Law::WithDerivative);
        domain().addVariable(ArcRes::HeatCapacity(iphase), Law::WithDerivative);
        domain().addVariable(ArcRes::HeatConductivity(iphase), Law::WithDerivative);
    }

    info() << "initialize domain properties";

    for(Arcane::Integer i = 0; i < options()->initialCondition.size(); ++i) {
        options()->initialCondition[i]->init(system(),domain());
    }
}

/*---------------------------------------------------------------------------*/

void
ThermoChemicalConvectionModule::
_initBoundaryVariableMng()
{
    ArcRes::FluidSubSystem fluid = system().fluidSubSystem();
    ArcRes::SolidSubSystem solid = system().solidSubSystem();

    info() << "initialize boundary properties";
    options()->boundaryCondition()->init(system());

    info() << "define boundary containers for others properties";
    ENUMERATE_BOUNDARY(bound,options()->boundaryCondition()->boundaryEnumerator()) {

        Law::PartialVariableFaceFolder& bound_vars = bound.folder();

        ENUMERATE_PHASE(iphase,fluid.phases()) {
            bound_vars.addVariable(ArcRes::Density(iphase));
            bound_vars.addVariable(ArcRes::FluidDensity(iphase));
            bound_vars.addVariable(ArcRes::Viscosity(iphase));
            bound_vars.addVariable(ArcRes::RelativePermeability(iphase));
            bound_vars.addVariable(ArcRes::HeatCapacity(iphase));
            bound_vars.addVariable(ArcRes::HeatConductivity(iphase));
        }
        ENUMERATE_PHASE(iphase,solid.phases()) {
            bound_vars.addVariable(ArcRes::Density(iphase));
            bound_vars.addVariable(ArcRes::HeatCapacity(iphase));
            bound_vars.addVariable(ArcRes::HeatConductivity(iphase));
        }
    }

}

/*---------------------------------------------------------------------------*/

void
ThermoChemicalConvectionModule::
_initTimeVariableMng()
{
    info() << "register containers of property to restore if failure";
    _addTimeVariable(ArcRes::Pressure(system()));
    _addTimeVariable(ArcRes::Concentration(system()));
    _addTimeVariable(ArcRes::Temperature(system()));

    ArcRes::FluidSubSystem fluid = system().fluidSubSystem();
    //ArcRes::SolidSubSystem solid = system().solidSubSystem();

    ENUMERATE_PHASE(iphase, fluid.phases()) {
        _addTimeVariable(ArcRes::Density(iphase));
        _addTimeVariable(ArcRes::FluidDensity(iphase));
    }
}

/*---------------------------------------------------------------------------*/

void
ThermoChemicalConvectionModule::
_initLaws()
{
    info() << "prepare laws for evaluations";

    for (Arcane::Integer i = 0; i < options()->law.size(); ++i) {
        options()->law[i]->configure(m_funcs, system());
    }

    ArcRes::FluidSubSystem fluid = system().fluidSubSystem();
    ENUMERATE_PHASE(iphase, fluid.phases()) {
        m_properties_to_evaluate.add(ArcRes::Density(iphase));
        m_properties_to_evaluate.add(ArcRes::FluidDensity(iphase));
        m_properties_to_evaluate.add(ArcRes::Viscosity(iphase));
        m_properties_to_evaluate.add(ArcRes::RelativePermeability(iphase));
        m_properties_to_evaluate.add(ArcRes::HeatCapacity(iphase));
        m_properties_to_evaluate.add(ArcRes::HeatConductivity(iphase));
    }
    ArcRes::SolidSubSystem solid = system().solidSubSystem();
    ENUMERATE_PHASE(iphase, solid.phases()) {
        m_properties_to_evaluate.add(ArcRes::Density(iphase));
        m_properties_to_evaluate.add(ArcRes::HeatCapacity(iphase));
        m_properties_to_evaluate.add(ArcRes::HeatConductivity(iphase));
    }


    if(options()->hasBoundaryCondition()){
        info() << "evaluate laws on boundary";
        ENUMERATE_BOUNDARY(bound,options()->boundaryCondition()->boundaryEnumerator())
        {
            _evaluateLaws(bound.folder(), Law::eWithoutDerivative);
        }
    }


    info() << "evaluate laws in domain";
    _evaluateLaws(domain(), Law::eWithoutDerivative);
}

/*---------------------------------------------------------------------------*/

void
ThermoChemicalConvectionModule::
_initRestore()
{
    info() << "compute law containers a first time step ";

    ArcRes::FluidSubSystem fluid = system().fluidSubSystem();

    auto rho = Law::values<ArcRes::Density>(domain(),fluid.phases());
    auto rho_tn = Law::values<ArcRes::Density>(domainTn(),fluid.phases());

    auto rhof = Law::values<ArcRes::FluidDensity>(domain(),fluid.phases());
    auto rhof_tn = Law::values<ArcRes::FluidDensity>(domainTn(),fluid.phases());

    info() << "Enumerate system phases";

    ENUMERATE_PHASE(iphase, fluid.phases()) {
        rho_tn[iphase].copy(rho[iphase]);
        rhof_tn[iphase].copy(rhof[iphase]);
    }

    info() << "End enumerate ";
 }

/*---------------------------------------------------------------------------*/

void
ThermoChemicalConvectionModule::
_initTransmissivity()
{
    // In order to use thr transmissivity for the three equations we compute it with a Permeability tensor = 1
    info() << "compute transmissivities ";
    m_transmissivities.addOperator("T", options()->numerics().twoPointsScheme());

    ArcRes::FluidSubSystem fluid = system().fluidSubSystem();

    auto T = Law::values<ArcRes::Permeability>(domain(),fluid);
    m_transmissivities.computeOperator( "T", T);

}

/*---------------------------------------------------------------------------*/

void
ThermoChemicalConvectionModule::
_initEquationSystem()
{
    info() << "create equations / unknowns system";

    m_unknown_manager << ArcRes::Pressure(system());
    m_unknown_manager << ArcRes::Concentration(system());
    m_unknown_manager << ArcRes::Temperature(system());

}

/*---------------------------------------------------------------------------*/

void
ThermoChemicalConvectionModule::
_initNewton()
{
    info() << "initialize newton solver";
    auto problem = ArcGeoSim::makeDelegatedSharedPtr<INonLinearSystem>(this);
    options()->numerics().newton()->init(problem);
}

/*---------------------------------------------------------------------------*/

template<typename Folder>
void
ThermoChemicalConvectionModule::
_evaluateLaws(Folder& folder, Law::EvaluationMode derivability)
{
    Arcane::IntegerUniqueArray ids(m_properties_to_evaluate.size());
    std::transform(m_properties_to_evaluate.begin(), m_properties_to_evaluate.end(),
                   ids.begin(), [](const Gump::Property& p) { return p.id(); });
    Law::FunctionEvaluator evaluator(m_funcs,ids);
    evaluator.evaluate(folder.lawVariableAccessor(),
                       folder.support(), derivability);
}

/*---------------------------------------------------------------------------*/

void ThermoChemicalConvectionModule::
_buildAccumulation(ArcNum::Vector& residual, ArcNum::Matrix& jacobian)
{
    info() << "build accumulation";
    // Get Geoxim Entities

    ArcRes::FluidSubSystem fluid = system().fluidSubSystem();
    ArcRes::SolidSubSystem solid = system().solidSubSystem();

    // Get Geometry Variables
    ArcGeoSim::AppService<IGeometryMng> geometry_mng;

    const IGeometryMng::RealVariable& volume =
            geometry_mng->getRealVariableProperty(allCells(), IGeometryProperty::PMeasure);

    // Get Geoxim Domain Explicit Variables

    auto phi = Law::values<ArcRes::VolumeFraction>(domain(),fluid);

    // Get Geoxim Domain Implicit Variables at Time Tn

    auto rho_tn = Law::values<ArcRes::Density>(domainTn(),fluid.phases());
    auto rhof_tn = Law::values<ArcRes::FluidDensity>(domainTn(),fluid.phases());
    auto Concentration_tn = Law::values<ArcRes::Concentration>(domainTn(),system());
    auto Temperature_tn = Law::values<ArcRes::Temperature>(domainTn(),system());

    // Get Geoxim Domain Implicit Variables

    const auto& um = unknownsManager();
    auto rho = Law::contribution<ArcRes::Density>(domain(),functionMng(),um,fluid.phases());
    auto rhof = Law::contribution<ArcRes::FluidDensity>(domain(),functionMng(),um,fluid.phases());
    auto Concentration = Law::contribution<ArcRes::Concentration>(domain(),functionMng(),um,system());
    auto Temperature = Law::contribution<ArcRes::Temperature>(domain(),functionMng(),um,system());

    auto c_f = Law::contribution<ArcRes::HeatCapacity>(domain(),functionMng(),um,fluid.phases());

    auto rho_s = Law::contribution<ArcRes::Density>(domain(),functionMng(),um,solid.phases());
    auto c_s   = Law::contribution<ArcRes::HeatCapacity>(domain(),functionMng(),um,solid.phases());

    const Arcane::Real deltat = m_global_deltat();

    // Build Term

    ENUMERATE_CELL(icell, ownCells()) {

        const Arcane::Real pore_volume = phi[icell] * volume[icell] ;
        const Arcane::Real cell_factor = pore_volume / deltat;

        auto f_phase = fluid.phase(0);
        auto s_phase = solid.phase(0);

        const auto C_f = cell_factor  * (  rho[f_phase][icell] - rho_tn[f_phase][icell] ) ;
        const Arcane::Integer f_equation = 0;
        residual[f_equation][icell]        += C_f;
        jacobian[f_equation][icell][icell] += C_f;

        const auto C_s = cell_factor  * (  Concentration[icell] - Concentration_tn[icell] ) ;
        const Arcane::Integer s_equation = 1;
        residual[s_equation][icell]        += C_s;
        jacobian[s_equation][icell][icell] += C_s;

        const auto eta = (1.0-phi[icell]) * rho_s[s_phase][icell] * c_s[s_phase][icell] / c_f[f_phase][icell];
        const auto eta_factor = volume[icell] * eta / deltat;
        const auto C_t = (eta_factor + cell_factor*rho[f_phase][icell]) * Temperature[icell] -
                         (eta_factor + cell_factor*rho_tn[f_phase][icell]) * Temperature_tn[icell];
        const Arcane::Integer t_equation = 2;
        residual[t_equation][icell]        += C_t;
        jacobian[t_equation][icell][icell] += C_t;

    }
}

/*---------------------------------------------------------------------------*/

void ThermoChemicalConvectionModule::
_buildFluxInternal(ArcNum::Vector& residual, ArcNum::Matrix& jacobian)
{
    info() << "build internal flux";

    // Get Geoxim Entities
    ArcRes::FluidSubSystem fluid = system().fluidSubSystem();
    ArcRes::SolidSubSystem solid = system().solidSubSystem();

    // Get Discrete Operator Transmissibility
    const Arcane::VariableFaceReal& tau = m_transmissivities["T"][ArcNum::Classical];

    const auto& um = unknownsManager();

    // Get Geoxim Domain Implicit Variables
    auto P = Law::contribution<ArcRes::Pressure>(domain(),functionMng(),2,um,system());
    auto C = Law::contribution<ArcRes::Concentration>(domain(),functionMng(),2,um,system());
    auto T = Law::contribution<ArcRes::Temperature>(domain(),functionMng(),2,um,system());

    auto kr = Law::contribution<ArcRes::RelativePermeability>(domain(),functionMng(),2,um,fluid.phases());
    auto mu = Law::contribution<ArcRes::Viscosity>(domain(),functionMng(),2,um,fluid.phases());
    auto rho = Law::contribution<ArcRes::Density>(domain(),functionMng(),2,um,fluid.phases());
    auto rhof = Law::contribution<ArcRes::FluidDensity>(domain(),functionMng(),2,um,fluid.phases());

    auto phi = Law::values<ArcRes::VolumeFraction>(domain(),fluid);
    auto c_f = Law::contribution<ArcRes::HeatCapacity>(domain(),functionMng(), 2, um,fluid.phases());
    auto lambda_f = Law::contribution<ArcRes::HeatConductivity>(domain(),functionMng(), 2, um,fluid.phases());

    info()<<"lambda s";
    auto lambda_s = Law::contribution<ArcRes::HeatConductivity>(domain(),functionMng(), 2,um,solid.phases());
    // Get Geometry Variables
    ArcGeoSim::AppService<IGeometryMng> geometry_mng;

    const IGeometryMng::Real3Variable & cell_center =
            geometry_mng->getReal3VariableProperty(allCells(), IGeometryProperty::PCenter);

    info()<<"build terms";
    // Build Term
    Arcane::FaceGroup inner_faces = mesh()->allCells().innerFaceGroup();
    const Arcane::Integer f_equation = 0;
    const Arcane::Integer s_equation = 1;
    const Arcane::Integer t_equation = 2;
    const auto permeability = 1.e-13; //  to be modified (tau is without permeability)
    const auto molecular_diff = 1.e-7; // to be modified (waiting to have the right value from G.E.)
    const Arcane::Real g = 9.81; // m_gravity ;

    ENUMERATE_FACE(iface,inner_faces) {

        ArcNum::TwoPointsStencil stencil(iface);

        auto const& cell_k = stencil.back();
        auto const& cell_l = stencil.front();

        const Arcane::Cell& K = cell_k.cell();
        const Arcane::Cell& L = cell_l.cell();

        const Arcane::Real zk = cell_center[K].z;
        const Arcane::Real zl = cell_center[L].z;

        // Term Gravity
        const Arcane::Real dgz_kl = - g * ( zk - zl );
        const auto rho_kl =
                (   audi::one(dgz_kl >= 0) * rhof[fluid.phase(0)][cell_k]
                                 + audi::one(dgz_kl <  0) * rhof[fluid.phase(0)][cell_l] );

        const auto grad_kl = (permeability / mu[fluid.phase(0)][cell_k])
                * tau[iface] * (P[cell_k] - P[cell_l] + rho_kl * dgz_kl);

        const ArcNum::Contribution flux_kl =
                    (   audi::one(grad_kl >= 0) * rho[fluid.phase(0)][cell_k]
                        + audi::one(grad_kl <  0) * rho[fluid.phase(0)][cell_l] ) * grad_kl;

        const auto flux_s_kl =
                ( audi::one(grad_kl >= 0) * C[cell_k]
                  + audi::one(grad_kl <  0) * C[cell_l] ) * grad_kl
                + phi[K] * molecular_diff * tau[iface] * (C[cell_k] - C[cell_l]);

        const auto cond_s = ( (1.0-phi[K]) * lambda_s[solid.phase(0)][cell_k] +
                phi[K] * lambda_f[fluid.phase(0)][cell_k] ) / c_f[fluid.phase(0)][cell_k];

        const auto flux_t_kl =
                ( audi::one(grad_kl >= 0) * T[cell_k] * rho[fluid.phase(0)][cell_k]
                + audi::one(grad_kl <  0) * T[cell_l] * rho[fluid.phase(0)][cell_l] ) * grad_kl
                + cond_s * tau[iface] * (T[cell_k] - T[cell_l]);

        if (cell_k.isOwn()) {
            residual[f_equation][cell_k]          += flux_kl;
            jacobian[f_equation][cell_k][stencil] += flux_kl;

            residual[s_equation][cell_k]          += flux_s_kl;
            jacobian[s_equation][cell_k][stencil] += flux_s_kl;

            residual[t_equation][cell_k]          += flux_t_kl;
            jacobian[t_equation][cell_k][stencil] += flux_t_kl;
        }
        if (cell_l.isOwn()) {
            residual[f_equation][cell_l]          -= flux_kl;
            jacobian[f_equation][cell_l][stencil] -= flux_kl;

            residual[s_equation][cell_l]          -= flux_s_kl;
            jacobian[s_equation][cell_l][stencil] -= flux_s_kl;

            residual[t_equation][cell_l]          -= flux_t_kl;
            jacobian[t_equation][cell_l][stencil] -= flux_t_kl;
        }

    }

}

/*---------------------------------------------------------------------------*/

void ThermoChemicalConvectionModule::
_buildFluxBoundary(ArcNum::Vector& residual, ArcNum::Matrix& jacobian)
{
    info() << "build boundary flux";

    // Get Geoxim Entities
    ArcRes::FluidSubSystem fluid = system().fluidSubSystem();
    ArcRes::SolidSubSystem solid = system().solidSubSystem();

    // Get Discrete Operator Transmissibility
    const Arcane::VariableFaceReal& tau = m_transmissivities["T"][ArcNum::Classical];

    const auto& um = unknownsManager();

    // Get Geoxim Domain Implicit Variables
    auto P = Law::contribution<ArcRes::Pressure>(domain(),functionMng(),um,system());
    auto C = Law::contribution<ArcRes::Concentration>(domain(),functionMng(),um,system());
    auto T = Law::contribution<ArcRes::Temperature>(domain(),functionMng(),um,system());

    auto kr = Law::contribution<ArcRes::RelativePermeability>(domain(),functionMng(),um,fluid.phases());
    auto mu = Law::contribution<ArcRes::Viscosity>(domain(),functionMng(),um,fluid.phases());
    auto rho = Law::contribution<ArcRes::Density>(domain(),functionMng(),um,fluid.phases());
    auto rhof = Law::contribution<ArcRes::FluidDensity>(domain(),functionMng(),um,fluid.phases());

    auto c_f = Law::contribution<ArcRes::HeatCapacity>(domain(),functionMng(),um,fluid.phases());
    auto lambda_f = Law::contribution<ArcRes::HeatConductivity>(domain(),functionMng(),um,fluid.phases());

    auto lambda_s = Law::contribution<ArcRes::HeatConductivity>(domain(),functionMng(),um,solid.phases());

    // Get Geometry Variables
    ArcGeoSim::AppService<IGeometryMng> geometry_mng;

    const IGeometryMng::Real3Variable & cell_center =
            geometry_mng->getReal3VariableProperty(allCells(), IGeometryProperty::PCenter);
    const IGeometryMng::Real3Variable & face_center =
            geometry_mng->getReal3VariableProperty(allFaces(), IGeometryProperty::PCenter);

    info()<<"boundary cond";
    ENUMERATE_BOUNDARY(bound,options()->boundaryCondition()->boundaryEnumerator()) {

        Law::PartialVariableFaceFolder& bound_folder = bound.folder();

        // Get Geoxim Boundary Variables
        auto b_P = Law::values<ArcRes::Pressure>(bound_folder,system());
        info()<<"b_C";
        auto b_C = Law::values<ArcRes::Concentration>(bound_folder,system());
        info()<<"b_T";
        auto b_T = Law::values<ArcRes::Temperature>(bound_folder,system());

        auto b_kr = Law::values<ArcRes::RelativePermeability>(bound_folder,fluid.phases());
        auto b_mu = Law::values<ArcRes::Viscosity>(bound_folder,fluid.phases());
        auto b_rho = Law::values<ArcRes::Density>(bound_folder,fluid.phases());
        auto b_rhof = Law::values<ArcRes::FluidDensity>(bound_folder,fluid.phases());

        auto phi = Law::values<ArcRes::VolumeFraction>(domain(),fluid);
        // Build Term

        Arcane::FaceGroup boundary_faces = bound_folder.support();
        const Arcane::Integer f_equation = 0;
        const Arcane::Integer s_equation = 1;
        const Arcane::Integer t_equation = 2;
        const auto permeability = 1.e-13; //  to be modified (tau is with out permeability)
        const auto molecular_diff = 1.e-7; // to be modified (waiting to have the right value from G.E.)
        const Arcane::Real g = 9.81; //m_gravity ;

        // Darcy velocity is zero on all the boundaries
        ENUMERATE_FACE(iFace, boundary_faces) {

            const Arcane::Cell& cell_k = iFace->boundaryCell();

            // Term Gravity Potential
            const Arcane::Real zk = cell_center[cell_k].z;
            const Arcane::Real zb = face_center[iFace].z;

            // Term Gravity
            const Arcane::Real dgz_kl = - g * ( zk - zb );
            const auto rho_kl = 
                    (   audi::one(dgz_kl >= 0) * rhof[fluid.phase(0)][cell_k]
                                     + audi::one(dgz_kl <  0) * b_rhof[fluid.phase(0)][iFace] );

            const auto grad_kb = (permeability/mu[fluid.phase(0)][cell_k]) * tau[iFace] *
                    (P[cell_k]  - b_P[iFace] + rho_kl * dgz_kl);

            const ArcNum::Contribution flux_kb =
                   (   audi::one(grad_kb >= 0) * rho[fluid.phase(0)][cell_k]
                       + audi::one(grad_kb <  0) * b_rho[fluid.phase(0)][iFace] ) * grad_kb * 0.0;

            const auto flux_s_kb =
                    ( audi::one(grad_kb >= 0) * C[cell_k]
                      + audi::one(grad_kb <  0) * b_C[iFace] ) * grad_kb  * 0.0
                    + phi[cell_k] * molecular_diff * tau[iFace] * (C[cell_k] - b_C[iFace]);

            const auto cond_s = ( (1.0-phi[cell_k]) * lambda_s[solid.phase(0)][cell_k] +
                    phi[cell_k] * lambda_f[fluid.phase(0)][cell_k] ) / c_f[fluid.phase(0)][cell_k];

            const auto flux_t_kb =
                    ( audi::one(grad_kb >= 0) * T[cell_k] * rho[fluid.phase(0)][cell_k]
                    + audi::one(grad_kb <  0) * b_T[iFace] * b_rho[fluid.phase(0)][iFace] ) * grad_kb  * 0.0
                    + cond_s* tau[iFace] * (T[cell_k] - b_T[iFace]);

            if(cell_k.isOwn()) {
                residual[f_equation][cell_k]         += flux_kb;
                jacobian[f_equation][cell_k][cell_k] += flux_kb;

                residual[s_equation][cell_k]         += flux_s_kb;
                jacobian[s_equation][cell_k][cell_k] += flux_s_kb;

                residual[t_equation][cell_k]         += flux_t_kb;
                jacobian[t_equation][cell_k][cell_k] += flux_t_kb;
            }
        }
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_MODULE_THERMOCHEMICALCONVECTION(ThermoChemicalConvectionModule);
