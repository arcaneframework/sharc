// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
/* Author : desrozis at Thu Aug 23 15:26:34 2012
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "../IBoundaryManager.h"

#include "ArcGeoSim/Numerics/Expressions/ExpressionBuilder/ExpressionBuilderR4vR1Core.h"

#include "DirichletManager_axl.h"

// gump
#include "ArcRes/XPath.h"

#include "ArcGeoSim/Appli/AppService.h"

#include "ArcGeoSim/Physics/Law2/Contribution/VariableFolderAccessor.h"

#include "ArcGeoSim/Numerics/Expressions/FunctionParser/FunctionParser.h"
#include "ArcGeoSim/Numerics/Expressions/IExpressionMng.h"
#include "ArcGeoSim/Numerics/Expressions/ExpressionBuilder/ExpressionBuilderR3vR1Core.h"

#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"

#include <arcane/IMesh.h>
#include <arcane/ItemVector.h>
#include <arcane/utils/StringBuilder.h>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class DirichletManagerService 
  : public ArcaneDirichletManagerObject
{
public:
  
  DirichletManagerService(const Arcane::ServiceBuildInfo & sbi) 
    : ArcaneDirichletManagerObject(sbi) 
    , m_initialized(false) {}
  
  ~DirichletManagerService()
  {
    for(Arcane::Integer i = 0; i < m_boundaries.size(); ++i)
      delete m_boundaries[i];
  }
  
public:

  void init(ArcRes::System& system);

  void update(ArcRes::System& system);

  bool exists() const { return options()->boundary.size() > 0; }

  IBoundaryManager::BoundaryEnumerator boundaryEnumerator() const
  {
    return IBoundaryManager::BoundaryEnumerator(m_boundaries, m_boundary_names);
  }

private:

  void _checkSizeMulti();

  void _fatalIfNotInitialized() const;

  void _compute(ArcRes::System& system);

private:

  bool m_initialized;

  Arcane::UniqueArray<Law::PartialVariableFaceFolder*> m_boundaries;
  Arcane::UniqueArray<Arcane::String> m_boundary_names;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
DirichletManagerService::
_checkSizeMulti()
{
  for(Arcane::Integer i = 0; i < options()->boundary.size(); ++i) {

    for(Arcane::Integer j = 0; j < options()->boundary[i]->multiLimitCondition.size(); ++j) {

      Arcane::Integer num_prop  = options()->boundary[i]->multiLimitCondition[j]->property.size();
      Arcane::Integer num_value = options()->boundary[i]->multiLimitCondition[j]->value.size();

      // Check Size

      if ( num_value != num_prop )
      {
        fatal() << " Error DirichletManager"
            << " Boundary = " << i
            << " MultiLimitCondition = " << j
            << " zone = " << options()->boundary[i]->faceGroup()
            << " Number of values = "     << num_value
            << " Number of properties = " << num_prop;
      }
    }
  }
}

/*---------------------------------------------------------------------------*/


void 
DirichletManagerService::
_fatalIfNotInitialized() const
{
  if(not m_initialized)
    fatal() << "Dirichlet service is not initialized, call beginInit and endInit method before";
}

/*---------------------------------------------------------------------------*/

void
DirichletManagerService::
init(ArcRes::System& system)
{
  if(m_initialized) return;

  _checkSizeMulti();

  for(Arcane::Integer i = 0; i < options()->boundary.size(); ++i) {

    auto model_name = Arcane::String::format("Dirichlet_{0}",i);

    const Arcane::String face_group_name = options()->boundary[i].faceGroup();
    ItemGroup group = mesh()->faceFamily()->findGroup(face_group_name);
    if(group.null()) {
      fatal() << "Dirichlet model cell zone "<<face_group_name<<" not exist";
    }
    auto name = Arcane::String::format("{0}_{1}",model_name,group.name());
    auto* folder = new Law::PartialVariableFaceFolder(name,mesh());
    m_boundaries.add(folder);
    folder->setSupport(group);
    if(options()->boundary[i]->name.isPresent()) {
      m_boundary_names.add(options()->boundary[i]->name());
    } else {
      m_boundary_names.add(model_name);
    }

    //==================
    // Add Darcy Velocity
    //==================

    ENUMERATE_PHASE(iphase, system.fluidSubSystem().phases()) {
      const ArcRes::Phase & phase = *iphase;
      folder->addVariable(ArcRes::DarcyVelocity(phase));
    }

    //==================
    // Space-time
    //==================

    for(Arcane::Integer j = 0; j < options()->boundary[i].spaceTimeLimitCondition.size(); ++j) {
      auto& condition(options()->boundary[i].spaceTimeLimitCondition[j]) ;
      auto p = ArcRes::XPath::scalarRealProperty(system, condition.property());
      folder->addVariable(p);
      condition->function()->init() ;
    }

    //==================
    // Single
    //==================

    for(Arcane::Integer j = 0; j < options()->boundary[i].limitCondition.size(); ++j) {
      auto p = ArcRes::XPath::scalarRealProperty(system, options()->boundary[i].limitCondition[j].property());
      folder->addVariable(p);
    }

    //==================
    // Multi
    //==================

    for(Arcane::Integer j = 0; j < options()->boundary[i].multiLimitCondition.size(); ++j) {

      Arcane::Integer num_prop  = options()->boundary[i]->multiLimitCondition[j]->property.size();

      for ( Arcane::Integer iprop = 0 ; iprop < num_prop; iprop++ )
      {
        auto p = ArcRes::XPath::scalarRealProperty(system, options()->boundary[i].multiLimitCondition[j]->property[iprop]);
        folder->addVariable(p);
      }
    }
  }

  _compute(system);

  m_initialized = true;
}

/*---------------------------------------------------------------------------*/

void 
DirichletManagerService::
_compute(ArcRes::System& system)
{
  ArcGeoSim::AppService<IExpressionMng> expression_mng;
  ArcGeoSim::AppService<IGeometryMng> geometry_mng;

  IGeometryMng::Real3Variable face_centers
      = geometry_mng->getReal3VariableProperty(allFaces(),IGeometryProperty::PCenter);

  for(Arcane::Integer i = 0; i < options()->boundary.size(); ++i) {

    auto& boundary = *(m_boundaries[i]);

    auto group = boundary.support();

    //==================
    // Space-time
    //==================
    for(Arcane::Integer j = 0; j < options()->boundary[i]->spaceTimeLimitCondition.size(); ++j) {
      auto& condition(options()->boundary[i].spaceTimeLimitCondition[j]) ;
      auto bp = ArcRes::XPath::scalarRealProperty(system, condition->property());

      auto variable = Law::values(boundary,bp);
      ENUMERATE_FACE(iface, group) {
        Arcane::Real3 center = face_centers[iface];
        variable[iface] = condition ->function()->eval(center[0],center[1],
                                                       center[2], m_global_time());
      }
    }

    //==================
    // Single
    //==================

    for(Arcane::Integer j = 0; j < options()->boundary[i]->limitCondition.size(); ++j) {
      auto bp = ArcRes::XPath::scalarRealProperty(system, options()->boundary[i]->limitCondition[j]->property());

      // Creation de l'expression
      FunctionParser parser;
      parser.init(expression_mng, NULL, traceMng());
      parser.parseString("(x,y,z;t)->" + options()->boundary[i]->limitCondition[j].value());
      ExpressionBuilderR3vR1Core expression(&parser);
      expression.setParameter("t",m_global_time());

      // Remplissage
      auto variable = Law::values(boundary,bp);
      ENUMERATE_FACE(iface, group) {
        Arcane::Real3 center = face_centers[iface];
        variable[iface] = expression.eval(center[0],center[1],center[2]);
      }
    }

    //==================
    // Multi
    //==================

    for(Arcane::Integer j = 0; j < options()->boundary[i]->multiLimitCondition.size(); ++j) {

      Arcane::Integer num_prop  = options()->boundary[i]->multiLimitCondition[j]->property.size();

      for ( Arcane::Integer iprop = 0 ; iprop < num_prop; iprop++ )
      {
        auto bp = ArcRes::XPath::scalarRealProperty(system, options()->boundary[i]->multiLimitCondition[j]->property[iprop]);

        // Creation de l'expression
        FunctionParser parser;
        parser.init(expression_mng, NULL, traceMng());
        parser.parseString("(x,y,z;t)->" + options()->boundary[i]->multiLimitCondition[j].value[iprop]);
        ExpressionBuilderR3vR1Core expression(&parser);
        expression.setParameter("t",m_global_time());

        // Remplissage
        auto variable = Law::values(boundary,bp);
        ENUMERATE_FACE(iface, group) {
          Arcane::Real3 center = face_centers[iface];
          variable[iface] = expression.eval(center[0],center[1],center[2]);
        }
      }
    }
  }
}

/*---------------------------------------------------------------------------*/

void
DirichletManagerService::
update(ArcRes::System& system)
{
  _fatalIfNotInitialized();

  _compute(system);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_DIRICHLETMANAGER(DirichletManager,DirichletManagerService);
