// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#ifndef ARCGEOSIM_UTILS_MESHVARIABLEARRAY2NONUNIFORMREFT_H
#define ARCGEOSIM_UTILS_MESHVARIABLEARRAY2NONUNIFORMREFT_H
/* Author : desrozis at Tue Jan  6 15:22:05 2009
 * Generated by createNew
 */

/*
 * Classe permettant d'�muler les objets MeshVariableArray2RefT issus d'Arcane
 * (ie variable dim=2 dans .axl) qui ne sont pas encore dispos dans le cadre d'un
 * tableau 2D non uniforme 
 * 
 * Pour chaque entit� de maillage, la premi�re dimension du tableau est la m�me.
 * La deuxi�me dimension varie en fonction de la premi�re dimension.
 * La variation est la m�me pour chaque entit�.
 *
 * Ajout de la fonctionnalit� par le CEA/DAM?
 */

namespace Arcane {}
using namespace Arcane;

#include <arcane/MeshVariable.h>

template<typename ItemType,typename DataType>
class MeshVariableArray2NoUniformRefT
{
public:
  
  /** Constructeur de la classe */
  MeshVariableArray2NoUniformRefT(MeshVariableArrayRefT<ItemType,DataType>& variable) :
    m_view(variable)
    {
      ;
    }
  
  /** Destructeur de la classe */
  virtual ~MeshVariableArray2NoUniformRefT() {}
  
public:
  
  void resize(Integer size_x, const Array<Integer>& size_y)
  {
    if(size_y.size() != size_x)
    {
      throw FatalErrorException("Sizes not consistent");
    }
    
    m_offset.resize(size_x);

    // Remplissage de l'offset
    m_offset[0] = 0;
    
    for(Integer i=1; i<size_x; ++i)
    {
      m_offset[i] = m_offset[i-1] + size_y[i-1];
    }
    
    const Integer size = m_offset[size_x-1] + size_y[size_x-1];
    
    m_view.resize(size_x*size);
  }
  
  void fill(const DataType& data)
  {
    m_view.fill(data);
  }
  
  const DataType& at(const ItemType& item,
                     Integer i, 
                     Integer j) const
    { return this->m_view[item.localId()][m_offset[i]+j]; }
  
  DataType& at(const ItemType& item,
               Integer i, 
               Integer j)
    { return this->m_view[item.localId()][m_offset[i]+j]; }
  
  const DataType& at(const ItemGroupRangeIteratorT<ItemType>& item,
                     Integer i, 
                     Integer j) const
    { return this->m_view[item.itemLocalId()][m_offset[i]+j]; }
  
  DataType& at(const ItemGroupRangeIteratorT<ItemType>& item,
               Integer i, 
               Integer j)
    { return this->m_view[item.itemLocalId()][m_offset[i]+j]; }
  
  const DataType& at(const ItemPairEnumeratorSubT<ItemType>& item,
                     Integer i, 
                     Integer j) const
    { return this->m_view[item.itemLocalId()][m_offset[i]+j]; }
  
  DataType& at(const ItemPairEnumeratorSubT<ItemType>& item,
               Integer i, 
               Integer j)
    { return this->m_view[item.itemLocalId()][m_offset[i]+j]; }
  
  const DataType& at(const ItemEnumeratorT<ItemType>& item,
                     Integer i, 
                     Integer j) const
    { return this->m_view[item.localId()][m_offset[i]+j]; }
  
  DataType& at(const ItemEnumeratorT<ItemType>& item,
               Integer i, 
               Integer j)
    { return this->m_view[item.localId()][m_offset[i]+j]; }
  
private:
  
  //! size x
  Integer m_size_x;
  
  //! non uniform offset
  SharedArray<Integer> m_offset;
  
  //! Inner 1D view
  MeshVariableArrayRefT<ItemType,DataType>& m_view;
};

#endif /* ARCGEOSIM_UTILS_MESHVARIABLEARRAY2NONUNIFORMREFT_H */
