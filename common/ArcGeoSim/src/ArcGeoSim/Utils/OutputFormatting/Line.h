// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCTEMREFACTORING_ARCTEMUTILS_OUTPUTFORMATTING_LINE_H
#define ARCTEMREFACTORING_ARCTEMUTILS_OUTPUTFORMATTING_LINE_H
/* Author : desrozis at Mon Jan 13 09:37:26 2014
 * Generated by createNew
 */

#include "ArcGeoSim/Utils/OutputFormatting/MultiColumn.h"
#include "ArcGeoSim/Utils/OutputFormatting/HLine.h"
#include "ArcGeoSim/Utils/OutputFormatting/Endl.h"

#include <arcane/utils/Array.h>
#include <arcane/utils/StringBuilder.h>

namespace OutputFormatting {

  class Line
  {
  public:

    Line(const Arcane::SharedArray<Indentation>& column_indentations)
      : m_is_hline(false)
      , m_current(0)
      , m_is_finalized(false)
    {
      m_column_indentations = column_indentations.clone();
      const Arcane::Integer ncols = m_column_indentations.size();
      m_values.resize(ncols);
      m_multi.resize(ncols);
      for(Arcane::Integer i = 0 ; i < ncols; ++i)
        m_multi[i] = 1;
    }

    Line& operator<<(const Endl& l)
    {
      _finalize();
      return *this;
    }

    Line& operator<<(const Sep& s)
    {
      m_current += m_multi[m_current];
      return *this;
    }

    Line& operator<<(const HLine& l)
    {
      m_is_hline = true;
      m_values[0] = l.separator();
      m_multi[0] = m_values.size();
      for(Arcane::Integer i = 1; i < m_values.size(); ++i)
        m_multi[i] = 0;
      return *this;
    }

    Line& operator<<(const MultiColumn& m)
    {
      m_multi[m_current] = m.numberOfColumns();
      m_column_indentations[m_current] = m.indentation();
      return *this;
    }

    Line& operator<<(const char* c)
    {
      return operator<<(std::string(c));
    }

    template <typename T>
    Line& operator<<(const T& t)
    {
      Arcane::StringBuilder sb(m_values[m_current]);
      sb += t;
      m_values[m_current] = sb.toString();
      return *this;
    }

    bool isHLine() const { return m_is_hline; }

    const Arcane::String& operator[](int i) const
    {
      return m_values[i];
    }

    int multi(int i) const { return m_multi[i]; }

    const Indentation& indentation(int i) const { return m_column_indentations[i]; }

    bool isFinalized() const { return m_is_finalized; }

private:

    void _finalize()
    {
      m_is_finalized = true;
      if(m_is_hline) return;
      for(Arcane::Integer i = 0; i < m_values.size(); ++i) {
        if(m_values.size() > 0) {
          Arcane::StringBuilder sb(" ");
          sb += m_values[i];
          sb += " ";
          m_values[i] = sb.toString();
        }
      }
    }

  private:

    Arcane::SharedArray<Indentation> m_column_indentations;

    bool m_is_hline;

    Arcane::SharedArray<Arcane::String> m_values;

    Arcane::IntegerSharedArray m_multi;

    Arcane::Integer m_current;

    bool m_is_finalized;
  };

}

#endif /* ARCTEMREFACTORING_ARCTEMUTILS_OUTPUTFORMATTING_LINE_H */
