// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCTEMREFACTORING_ARCTEMUTILS_OUTPUTFORMATTING_ARRAY_H
#define ARCTEMREFACTORING_ARCTEMUTILS_OUTPUTFORMATTING_ARRAY_H
/* Author : desrozis at Mon Jan 13 09:38:07 2014
 * Generated by createNew
 */

#include "ArcGeoSim/Utils/OutputFormatting/Line.h"
#include "ArcGeoSim/Utils/OutputFormatting/Endl.h"

#include <arcane/ISubDomain.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/utils/SharedPtr.h>

extern "C" Arcane::ISubDomain* _arcaneGetDefaultSubDomain();

namespace OutputFormatting {

  class Array
  {
  private:

    class InternalTraceSizer
        : public Arcane::ITraceMessageListener
    {
    public:
      InternalTraceSizer(Arcane::Integer& m) : m_size(m) {}
    public:
      bool visitMessage(const Arcane::TraceMessageListenerArgs &args)
      {
        Arcane::ConstArrayView<char> input = args.buffer();
        m_size = input.size();
        return true;
      }
    private:
      Arcane::Integer& m_size;
    };

  public:

    Array(Arcane::String columns, bool do_prefix=true)
      : m_number_of_columns(0)
      , m_prefix_size(0)
    {
      std::string c = columns.localstr();

      m_column_indentations.reserve(columns.length());

      for(Arcane::Integer i = 0; i < columns.length(); ++i) {
        if(c[i] == 'l' || c[i] == 'r' || c[i] == 'c') {
          m_number_of_columns++;
          char cc = c[i];
          Indentation i(cc);
          m_column_indentations.add(i);
        }
      }

      m_separators.resize(m_number_of_columns+1);
      for(Arcane::Integer i = 0; i < m_number_of_columns+1; ++i) {
        m_separators[i] = " ";
      }

      Arcane::Integer ncols = 0;
      for(Arcane::Integer i = 0; i < columns.length(); ++i) {
        char cc = c[i];
        if((cc == 'l') || (cc == 'r') || (cc == 'c')) {
          ncols++;
        } else {
          std::stringstream b;
          b << cc;
          m_separators[ncols] = b.str();
        }
      }

      m_current_line = Arcane::SPtr(new Line(m_column_indentations));

      Arcane::ITraceMng* trace = _arcaneGetDefaultSubDomain()->traceMng();

      if(do_prefix) {
        InternalTraceSizer sizer(m_prefix_size);
        trace->addListener(&sizer);
        trace->info() << " ";
        trace->removeListener(&sizer);
        if(m_prefix_size>0)
          m_prefix_size -= 2;
      }
    }

    template<typename T>
    Array& operator<<(const T& t)
    {
      *m_current_line << t;
      return *this;
    }

    Array& operator<<(Endl e)
    {
      *m_current_line << e;
      m_lines.add(m_current_line);
      m_current_line = Arcane::SPtr(new Line(m_column_indentations));
      return *this;
    }

    Arcane::String separator(int i) const { return m_separators[i]; }

    const Indentation& indentation(int i) const { return m_column_indentations[i]; }

    const Line& line(int i) const { return *m_lines[i]; }

    Arcane::Integer numberOfColumns() const { return m_number_of_columns; }

    Arcane::Integer numberOfLines() const { return m_lines.size(); }

    Arcane::Integer prefixSize() const { return m_prefix_size; }

  private:

    Arcane::Integer m_number_of_columns;

    Arcane::SharedArray<std::string> m_separators;

    Arcane::SharedArray<Indentation> m_column_indentations;

    Arcane::SharedArray< Arcane::SharedPtrT<Line> > m_lines;

    Arcane::SharedPtrT<Line> m_current_line;

    Arcane::Integer m_prefix_size;
  };

  inline std::ostream& operator<<(std::ostream& nout, const Array& f)
  {
    Arcane::Integer nx = 0;
    Arcane::Integer ny = f.numberOfColumns();
    Arcane::SharedArray<Arcane::IntegerSharedArray> M;
    M.reserve(f.numberOfLines());
    for(Arcane::Integer i = 0; i < f.numberOfLines(); ++i) {
        const Line& line = f.line(i);
        if(line.isHLine()) continue;
        nx++;
        Arcane::IntegerSharedArray v(ny);
        v.fill(0);
        for(Arcane::Integer j = 0; j < ny; ++j) {
          const Arcane::Integer multi = line.multi(j);
          for(Arcane::Integer k = 0; k < line[j].length()-multi+1; ++k)
            v[j+k%multi]++;
          j += multi - 1;
        }
        M.add(v);
    }

    Arcane::IntegerSharedArray max(ny);
    max.fill(0);
    for(Arcane::Integer j = 0; j < ny; ++j) {
      max[j] = 0;
      for(Arcane::Integer i = 0; i < nx; ++i) {
        max[j] = max[j] > M[i][j] ? max[j] : M[i][j];
      }
    }

    Arcane::Integer line_size = 0;
    for(Arcane::Integer j = 0; j < f.numberOfColumns(); ++j) {
        line_size += max[j];
    }

    for(Arcane::Integer j = 1; j < f.numberOfColumns(); ++j) {
        line_size += f.separator(j).length();
    }
    std::string prefix(f.prefixSize(), ' ');
    const Arcane::Integer nrows = f.numberOfLines();
    for(Arcane::Integer i = 0; i < nrows; ++i) {
        if(i != 0) nout << prefix;
        const Line& line = f.line(i);
        if(line.isHLine()) {
            nout << f.separator(0);
            for(Arcane::Integer i = 0; i < line_size; ++i)
                nout << line[0];
            nout << f.separator(f.numberOfColumns());
        } else {
            for(Arcane::Integer j = 0; j < f.numberOfColumns(); ++j) {
                const Arcane::Integer multi = line.multi(j);
                if(multi > 1) {
                    nout << f.separator(j);
                    Arcane::Integer size = 0;
                    for(Arcane::Integer k = 0; k < multi; ++k)
                        size += max[j+k];
                    line.indentation(j)(nout,size+multi-1,line[j]);
                    j += multi - 1;
                } else {
                    nout << f.separator(j);
                    line.indentation(j)(nout,max[j],line[j]);
                }
            }
            nout << f.separator(f.numberOfColumns());
        }
        if(i != nrows-1) nout << "\n";
    }
    return nout;
  }

}

#endif /* ARCTEMREFACTORING_ARCTEMUTILS_OUTPUTFORMATTING_ARRAY_H */
