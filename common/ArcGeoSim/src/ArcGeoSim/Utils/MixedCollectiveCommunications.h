// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_UTILS_MIXEDCOLLECTIVECOMMUNICATIONS_H
#define ARCGEOSIM_UTILS_MIXEDCOLLECTIVECOMMUNICATIONS_H
/* Author : havep at Mon Jul 25 16:55:54 2011
 * Generated by createNew
 */

#include <arcane/IParallelMng.h>

struct MixedCollective {
private:
  template<bool Cond, typename DestT, typename SrcT>
  static void copyCastIf(DestT * dest, const SrcT * src) { if (Cond) *dest = static_cast<DestT>(*src); }

public:
  // Le type DataT est dimensionne au cas max et wrappe dans le pseudo constructeur Data pour son int
  template<int N = 0, typename T0 = int, typename T1 = int, typename T2 = int, typename T3 = int, typename T4 = int, typename T5 = int, typename T6 = int> 
  class DataT
  {
  public:
    DataT(T0 * t0 = 0, T1 * t1 = 0, T2 * t2 = 0, T3 * t3 = 0, T4 * t4 = 0, T5 * t5 = 0, T6 * t6 = 0)
      :   v0(t0)     , v1(t1)     , v2(t2)     , v3(t3)     , v4(t4)     , v5(t5)     , v6(t6)       { }
  public:
    template<typename T> void serializeData(Array<T> & compacted_data)
    {
      compacted_data.resize(N);
      copyCastIf<(N > 0), T, T0>(compacted_data.unguardedBasePointer()+0, v0);
      copyCastIf<(N > 1), T, T1>(compacted_data.unguardedBasePointer()+1, v1);
      copyCastIf<(N > 2), T, T2>(compacted_data.unguardedBasePointer()+2, v2);
      copyCastIf<(N > 3), T, T3>(compacted_data.unguardedBasePointer()+3, v3);
      copyCastIf<(N > 4), T, T4>(compacted_data.unguardedBasePointer()+4, v4);
      copyCastIf<(N > 5), T, T5>(compacted_data.unguardedBasePointer()+5, v5);
      copyCastIf<(N > 6), T, T6>(compacted_data.unguardedBasePointer()+6, v6);
    }
  
    template<typename T> void deserializeData(Array<T> & compacted_data)
    {
      copyCastIf<(N > 0), T0, T>(v0, compacted_data.unguardedBasePointer()+0);
      copyCastIf<(N > 1), T1, T>(v1, compacted_data.unguardedBasePointer()+1);
      copyCastIf<(N > 2), T2, T>(v2, compacted_data.unguardedBasePointer()+2);
      copyCastIf<(N > 3), T3, T>(v3, compacted_data.unguardedBasePointer()+3);
      copyCastIf<(N > 4), T4, T>(v4, compacted_data.unguardedBasePointer()+4);
      copyCastIf<(N > 5), T5, T>(v5, compacted_data.unguardedBasePointer()+5);
      copyCastIf<(N > 6), T6, T>(v6, compacted_data.unguardedBasePointer()+6);
    }
  private:
    T0 * v0;
    T1 * v1;
    T2 * v2;
    T3 * v3;
    T4 * v4;
    T5 * v5;
    T6 * v6;
  };

  template<typename T0> 
  DataT<1,T0>
  static Data(T0 & t0) { return DataT<1,T0>(&t0); }
  template<typename T0, typename T1> 
  DataT<2,T0,T1>
  static Data(T0 & t0, T1 & t1) { return DataT<2,T0,T1>(&t0,&t1); }
  template<typename T0, typename T1, typename T2> 
  DataT<3,T0,T1,T2>
  static Data(T0 & t0, T1 & t1, T2 & t2) { return DataT<3,T0,T1,T2>(&t0,&t1,&t2); }
  template<typename T0, typename T1, typename T2, typename T3> 
  DataT<4,T0,T1,T2,T3>
  static Data(T0 & t0, T1 & t1, T2 & t2, T3 & t3) { return DataT<4,T0,T1,T2,T3>(&t0,&t1,&t2,&t3); }
  template<typename T0, typename T1, typename T2, typename T3, typename T4> 
  DataT<5,T0,T1,T2,T3,T4>
  static Data(T0 & t0, T1 & t1, T2 & t2, T3 & t3, T4 & t4) { return DataT<5,T0,T1,T2,T3,T4>(&t0,&t1,&t2,&t3,&t4); }
  template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5> 
  DataT<6,T0,T1,T2,T3,T4,T5>
  static Data(T0 & t0, T1 & t1, T2 & t2, T3 & t3, T4 & t4, T5 & t5) { return DataT<6,T0,T1,T2,T3,T4,T5>(&t0,&t1,&t2,&t3,&t4,&t5); }
  template<typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6> 
  DataT<7,T0,T1,T2,T3,T4,T5,T6>
  static Data(T0 & t0, T1 & t1, T2 & t2, T3 & t3, T4 & t4, T5 & t5, T6 & t6) { return DataT<7,T0,T1,T2,T3,T4,T5,T6>(&t0,&t1,&t2,&t3,&t4,&t5,&t6); }


  template<typename MaxType>
  struct Comm
  {
    template<typename MixedData>
    static void broadcast(Arcane::IParallelMng * parallel_mng, const Integer master_id, MixedData v) {
      SharedArray<MaxType> compacted_data;
      v.serializeData(compacted_data);
      parallel_mng->broadcast(compacted_data,master_id);
      v.deserializeData(compacted_data);
    }

    template<typename MixedData>
    static void reduce(Arcane::IParallelMng * parallel_mng, Arcane::Parallel::eReduceType rt, MixedData v) {
      SharedArray<MaxType> compacted_data;
      v.serializeData(compacted_data);
      parallel_mng->reduce(rt,compacted_data);
      v.deserializeData(compacted_data);
    }
  };
};

#endif /* ARCGEOSIM_UTILS_MIXEDCOLLECTIVECOMMUNICATIONS_H */
