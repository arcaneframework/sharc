// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include <arcane/ArcaneVersion.h>

#include <boost/bind.hpp>

#include <algorithm>

#include "GraphBuilder.h"

/* Author : dipietrd at Thu Nov 15 11:28:20 2007
 * Generated by createNew
 */

#if (ARCANE_VERSION <= 30003)
void GraphBuilder::addLinkDescriptor(const LinkDescriptor& ld) {
  m_descriptors.insert(ld);
}

////////////////////////////////////////////////////////////

#if (ARCANE_VERSION <= 30003)
void GraphBuilder::addLink(const LinkData& L) {
  descriptor_set::iterator i = std::find_if(m_descriptors.begin(), 
                                       m_descriptors.end(), 
                                       boost::bind<bool>(LinkDescriptorComparator::IdEqualTo(), _1, L.getDescriptorUniqueId()));
  if(i == m_descriptors.end()) // The descriptor had not been defined
    throw(Error("Descriptor not defined while inserting link"));
  else                         // The descriptor had been defined
    m_links[L.getDescriptorUniqueId()].push_back(L);
}
#endif
////////////////////////////////////////////////////////////
#if (ARCANE_VERSION<11602)
void GraphBuilder::build(Arcane::mesh::DynamicGraph* graph) {
#else
void GraphBuilder::build(Arcane::IGraph* graph) {  
#endif
  // Compute array size
  Integer n_item_types = 0;
  for(descriptor_set::iterator i = m_descriptors.begin(); i != m_descriptors.end(); i++)
    n_item_types += i->getItemNumber();
  Integer headline_size = 1 + m_descriptors.size() + n_item_types;
  
  Integer body_size = 1 + 2 * m_links.size();
  for(descriptor2link_map::iterator i = m_links.begin(); i != m_links.end(); i++) {
    const descriptor_set::iterator descriptor_it = find_if(m_descriptors.begin(),
                                                           m_descriptors.end(),
                                                           boost::bind<bool>(LinkDescriptorComparator::IdEqualTo(), _1, i->first));
    const link_list& links = i->second;
    body_size += descriptor_it->getItemNumber() * links.size();
  }
  Int64SharedArray graph_info(headline_size + body_size);
  std::cout << "Graph info table size = " << headline_size + body_size;

  // Headline
  graph_info[0] = m_descriptors.size(); // The number of descriptors
  Integer index = 1;
  for(descriptor_set::const_iterator i = m_descriptors.begin(); i != m_descriptors.end(); i++) {
    const LinkDescriptor& ld = *i;
    graph_info[index++] = ld.getItemNumber();
    for(LinkDescriptor::item_type_vector::const_iterator j = ld.item_types.begin(); j != ld.item_types.end(); j++) {
      graph_info[index++] = *j;
    }
  }

  // Body
  graph_info[index++] = m_descriptors.size(); // The number of link groups (equal to the number of descriptors)
  for(descriptor_set::const_iterator i = m_descriptors.begin(); i != m_descriptors.end(); i++) {
    Integer descriptor_uid = i->uniqueId();
    const link_list& links = m_links[descriptor_uid];

    graph_info[index++] = links.size();   // The number of links in the group
    graph_info[index++] = descriptor_uid; // The corresponding descriptor

    for(link_list::const_iterator iL = links.begin(); iL != links.end(); iL++) {
      for(LinkData::item_uid_vector::const_iterator j = iL->item_uids.begin(); j != iL->item_uids.end(); j++)
        graph_info[index++] = *j;
    }
  }
}
#endif

