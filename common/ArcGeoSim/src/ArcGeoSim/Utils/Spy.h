// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_UTILS_SPY_H
#define ARCGEOSIM_ARCGEOSIM_UTILS_SPY_H
/* Author : desrozis at Mon Nov 17 11:48:10 2014
 * Generated by createNew
 */

#ifdef WIN32
#include <ciso646>
#endif

#include "ArcGeoSim/Utils/ArcGeoSim.h"

#include <arcane/VariableRefScalar.h>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_ARCGEOSIM_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<typename T>
struct SpyTraits
{
  typedef T saved_type;
  static void copy(const T& from, T& to) { to = from; }
  static bool equals(const T& from, const T& to) { return from == to; }
  static Arcane::String name(const T&) { return Arcane::String(); }
};

template<typename T>
struct SpyTraits< Arcane::VariableRefScalarT<T> >
{
  typedef T saved_type;
  static void copy(const Arcane::VariableRefScalarT<T>& from, T& to)
    { to = from(); }
  static void copy(const T& from, Arcane::VariableRefScalarT<T>& to)
    { to = from; }
  static bool equals(const Arcane::VariableRefScalarT<T>& u, const T& v)
    { return u() == v; }
  static bool equals(const T& u, const Arcane::VariableRefScalarT<T>& v)
    { return u == v(); }
  static Arcane::String name(const Arcane::VariableRefScalarT<T>& v)
    { return v.name(); }
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

struct SpyPolicy
{
  enum ePolicy
  {
    FatalIfChanged   = 1,
    RestoreIfChanged = 2,
    NothingIfChanged = 4
  };
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<typename T>
class Spy
{
public:
  
  Spy(T& t)
    : m_value(t)
    , m_saved(0)
    , m_is_locked(false) {}
  
public:

  void lock()
  {
    ARCANE_ASSERT((not m_is_locked),("Spy is already locked"));
    SpyTraits<T>::copy(m_value, m_saved);
  }

  void unlock(SpyPolicy::ePolicy policy)
  {
    m_is_locked = false;
    const bool has_changed = hasChanged();
    if(not has_changed) return;
    if(policy & SpyPolicy::FatalIfChanged) {
      Arcane::String message =
          Arcane::String::format("Spy fatal error : value {0} has changed",
                                 SpyTraits<T>::name(m_value));
      throw Arcane::FatalErrorException(message);
    }
    if(policy & SpyPolicy::RestoreIfChanged) {
      SpyTraits<T>::copy(m_saved, m_value);
    }
  }

  T& operator()()
  {
    ARCANE_ASSERT((not m_is_locked),("Spy is locked"));
    return m_value;
  }

  bool hasChanged() const { return not SpyTraits<T>::equals(m_saved, m_value); }

private:

  T& m_value;
  typename SpyTraits<T>::saved_type m_saved;
  bool m_is_locked;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_ARCGEOSIM_NAMESPACE;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_ARCGEOSIM_UTILS_SPY_H */
