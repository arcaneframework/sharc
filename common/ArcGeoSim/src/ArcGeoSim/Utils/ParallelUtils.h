// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_UTILS_PARALLELUTILS_H
#define ARCGEOSIM_ARCGEOSIM_UTILS_PARALLELUTILS_H
/* Author : dechaiss at Fri Jul 13 09:57:52 2012
 * Generated by createNew
 */

#include <arcane/IParallelMng.h>

#include "ArcGeoSim/Utils/ArcGeoSim.h"

BEGIN_ARCGEOSIM_NAMESPACE

// TODO : faire un test unitaire pour cette classe

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class ParallelUtils
{
  /*!
   * Classe d'outils pour le parallelisme complementaires des outils arcane.
   */
public:
  
  /** Constructeur de la classe */
  ParallelUtils(Arcane::IParallelMng* parallel_mng)
    : m_parallel_mng(parallel_mng){}
  
  /** Destructeur de la classe */
  virtual ~ParallelUtils() {}
  
public:

  Arcane::IParallelMng* parallelMng() {return m_parallel_mng;}

  //! Operateur logique Ou parallele. Renseigne si la valeur du booleen est vrai sur au moins un processus
  bool collectiveOr(const bool value);

  //! Operation de broadcast du booleen \a value. Renvoie sur tous les processus la valeur prise par \a value sur le maitre.
  bool collectiveOrder(const bool value, const Arcane::Integer master);

  //! Operation de broadcast : la methode decoupe \a v en tableau de 1000 octets.
  template<typename T>
  inline void multiBroadcast(Arcane::Array<T> & v,const Arcane::Integer master_id);

  //! Rang du processur maitre en lecture
  Arcane::Integer masterId() const { return m_parallel_mng->masterIORank();}

  //! Bouleen indiquant le processus maitre
  bool isMaster() {return (m_parallel_mng->commRank() == masterId());}

private:
  Arcane::IParallelMng* m_parallel_mng;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
// Template implementation

template<typename T>
void
ArcGeoSim::ParallelUtils::
multiBroadcast(Arcane::Array<T> & v,const Arcane::Integer master_id)
{
  const Arcane::Integer byte_packet_size = 1000000;
  const Arcane::Integer packet_size = byte_packet_size / sizeof(T);

  Arcane::Integer full_size = v.size();
  m_parallel_mng->broadcast(IntegerArrayView(1,&full_size),master_id);
  v.resize(full_size);

  Arcane::Integer phase_count = 0;
  phase_count = full_size / packet_size;
  if (full_size % packet_size != 0) ++phase_count;

  for(Arcane::Integer i_phase=0;i_phase<phase_count;++i_phase)
    {
      Arcane::Integer lower_bound = packet_size*i_phase;
      Arcane::Integer this_packet_size = Arcane::math::min(packet_size,full_size-lower_bound);
      Arcane::ArrayView<T> packet_view = v.view().subView(lower_bound,this_packet_size);
      m_parallel_mng->broadcast(packet_view, master_id);
    }
}


END_ARCGEOSIM_NAMESPACE

#endif /* ARCGEOSIM_ARCGEOSIM_UTILS_PARALLELUTILS_H */
