// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "TimeLineForcedByEvents.h"
/* Author : desrozis at Wed May 27 14:30:02 2015
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_ARCGEOSIM_NAMESPACE
 
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

TimeLineForcedByEvents::
TimeLineForcedByEvents(Arcane::ISubDomain* sub_domain)
  : Arcane::TraceAccessor(sub_domain->traceMng())
  , ArcGeoSim::SpiedTimeVariables(sub_domain)
  , m_initialized(false)
  , m_sub_domain(sub_domain)
  , m_calendar(m_sub_domain)
  , m_evolution(m_sub_domain)
  , m_final_time_is_reached(Arcane::VariableBuildInfo(m_sub_domain,"PrivateFinalTimeIsReached"))
  , m_next_time(Arcane::VariableBuildInfo(m_sub_domain,"PrivateNextTime"))
  , m_dt_n(Arcane::VariableBuildInfo(m_sub_domain,"PrivateOldDt"))
  , m_observers(this)
{
  claimDelegation();

  m_final_time_is_reached = false;
  m_next_time = 0.;
  m_dt_n = -1;
}

/*---------------------------------------------------------------------------*/

void 
TimeLineForcedByEvents::
init()
{
  if(m_initialized) return;

  attachObserver(&m_calendar);
 
  m_initial_time = 0.;
  m_time         = 0.;
  m_time_n       = 0.;
  m_final_time   = 0.;
  
  m_iteration = 0;
  
  m_dt = Arcane::FloatInfo<Arcane::Real>::maxValue();
  m_dt_n = m_dt();

  lock();

  m_initialized = true;
}

/*---------------------------------------------------------------------------*/

void
TimeLineForcedByEvents::
_computeTimeStep()
{
  ARCANE_ASSERT((m_initialized),(" not initialized, call init method first"));

  unlock();

  if( m_final_time_is_reached() ) {
    info() << "Final time is reached!!";
    m_sub_domain->timeLoopMng()->stopComputeLoop(true);
    m_time_n = m_next_time();
    return;
  }
  
  m_next_time = math::min(m_final_time(), m_calendar.nextEventTime());
  
  m_dt = m_next_time() - m_time();
  
  m_dt_n = m_dt();

  m_final_time_is_reached = 
    Arcane::math::abs(m_next_time() - m_final_time()) < 1.e-14;
  
  lock();
}

/*---------------------------------------------------------------------------*/

void 
TimeLineForcedByEvents::
notify(const TimeStep::EntryPoint& entry_point)
{
  if(entry_point == TimeStep::Begin()) 
    fatal() << "ArcGeoSim::TimeStep::Begin enty points shouldn't be notify by user";
  if(entry_point == TimeStep::End()) 
    fatal() << "ArcGeoSim::TimeStep::End enty points shouldn't be notify by user";
  if(entry_point == TimeStep::BeforeRestoreSave()) 
    fatal() << "ArcGeoSim::TimeStep::BeforeRestoreSave enty points shouldn't be notify by user";

  m_observers.notifyObservers(entry_point);
}
  
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineForcedByEvents::
timeIncrementation()
{ 
  unlock();

  // Old time saving
  m_time_n = m_time();
  
  // Next time should have been computed due to events
  m_time = m_next_time();

  lock();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineForcedByEvents::
firstInit()
{
  init();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineForcedByEvents::
lastInit()
{
  unlock(ArcGeoSim::SpyPolicy::NothingIfChanged);

  m_initial_time = m_calendar.minTime();
  m_final_time   = m_calendar.maxTime();
  
  if(m_iteration() == 0)
    m_time = m_initial_time();
  
  lock();

  m_observers.notifyObservers(TimeStep::BeforeRestoreSave());
  
  _computeTimeStep();

  using namespace OutputFormatting;
  OutputFormatting::Array out("|r:l|");
  
  out << hline('-') << endl()
      << multicolumn(2,'c') << "Time parameters" << endl()
      << hline('-') << endl();
  out << "initial time" << sep() << m_initial_time() << endl();
  out <<   "final time" << sep() <<   m_final_time() << endl();
  out << hline('-') << endl()
      << multicolumn(2,'c') << "Time step control" << endl()
      << hline('-') << endl();
  out << "min time step" << sep() << m_min_dt() << endl();
  out << "max time step" << sep() << m_max_dt() << endl();
  out << hline('-') << endl();
  out << "initial time step" << sep() << m_dt() << endl();
  out << hline('-') << endl();
  info() << out;

  m_calendar.print();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineForcedByEvents::
firstComputeLoop()
{
  m_observers.notifyObservers(TimeStep::Begin());
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineForcedByEvents::
lastComputeLoop()
{
  m_observers.notifyObservers(TimeStep::End());
  m_observers.notifyObservers(TimeStep::BeforeRestoreSave());
  
  m_observers.notifyObservers(TimeStepIsFinished);

  _computeTimeStep();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineForcedByEvents::
firstContinueInit()
{
  if(m_initialized)
    fatal() << "Time line forced by events should be initialized first...";

  m_observers.attachObserver(&m_calendar);
  
  m_iteration = m_iteration() + 1;

  lock();

  m_initialized = true;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineForcedByEvents::
firstRestore()
{
  fatal() << "Time line forced by events can't be restored";
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
TimeLineForcedByEvents::
attachObserver(TimeStep::IObserver* observer)
{
  m_observers.attachObserver(observer);
}
  
/*---------------------------------------------------------------------------*/

void 
TimeLineForcedByEvents::
detachObserver(TimeStep::IObserver* observer)
{
  m_observers.detachObserver(observer);
}
   
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_ARCGEOSIM_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
