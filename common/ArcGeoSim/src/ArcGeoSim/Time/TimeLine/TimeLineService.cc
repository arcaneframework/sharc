// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
/* Author : desrozis at Fri Oct 24 17:57:30 2014
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "ArcGeoSim/Time/ITimeLine.h"
#include "ArcGeoSim/Physics/Units/IUnitsSystem.h"

#include "TimeLine_axl.h"

#include "ArcGeoSim/Time/TimeLine/SpiedTimeVariables.h"
#include "ArcGeoSim/Time/TimeLine/EventCalendar.h"
#include "ArcGeoSim/Time/TimeLine/TimeEvolution.h"
#include "ArcGeoSim/Time/Defaults/TimeStepModifier.h"
#include "ArcGeoSim/Time/Observer/ObserverSet.h"

#include "ArcGeoSim/Physics/Units/SIUnitsConverter.h"

#include "ArcGeoSim/Appli/AppService.h"
#include "ArcGeoSim/Appli/Architecture/Delegate.h"
#include "ArcGeoSim/Appli/Architecture/INextTimeComputer.h"
#include "ArcGeoSim/Appli/Architecture/IExtraEntryPoints.h"

#include "ArcGeoSim/Utils/Optional.h"
#include "ArcGeoSim/Utils/Spy.h"
#include "ArcGeoSim/Utils/OutputFormatting/OutputFormatting.h"

#include <arcane/ITimeLoopMng.h>

#include <set>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_ARCGEOSIM_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class TimeLineService
  : public ArcaneTimeLineObject
  , public SpiedTimeVariables
  , public Delegate<INextTimeComputer>
  , public Delegate<IExtraEntryPoints>
{
public:
 
  TimeLineService(const Arcane::ServiceBuildInfo & sbi)
    : ArcaneTimeLineObject(sbi)
    , SpiedTimeVariables(sbi.subDomain())
    , m_initialized(false)
    , m_calendar(sbi.subDomain())
    , m_evolution(sbi.subDomain())
    , m_final_time_is_reached(Arcane::VariableBuildInfo(sbi.subDomain(),"PrivateFinalTimeIsReached"))
    , m_next_time(Arcane::VariableBuildInfo(sbi.subDomain(),"PrivateNextTime"))
    , m_infinite_dt(Arcane::VariableBuildInfo(sbi.subDomain(),"PrivateInfiniteDt"))
    , m_time_step_has_to_be_restored(Arcane::VariableBuildInfo(sbi.subDomain(),"PrivateNeedRestore"))
    , m_time_step_before_truncation(Arcane::VariableBuildInfo(sbi.subDomain(),"PrivateRestoreDt"))
    , m_dt_n(Arcane::VariableBuildInfo(sbi.subDomain(),"PrivateOldDt"))
    , m_next_step_is_replayed(Arcane::VariableBuildInfo(sbi.subDomain(),"PrivateIsReplayed"))
    , m_observers(this)
  {
  }

  ~TimeLineService() {}
  
public:

  void init();

  //!@{ ITimeLine
  bool isStepReplayed() const { return m_next_step_is_replayed(); }
   
  ITimeEvolution& evolution() { return m_evolution; }
  
  IEventCalendar& calendar() { return m_calendar; }
  //!}

  //!@{ Delegate<INextTimeComputer>
  TimeStep::EntryPoints& userEntryPoints() { return m_entry_points; }
  
  void notify(const TimeStep::EntryPoint& entry_point);
  
  // Delegation of time incrementation of arcane time loop
  void timeIncrementation();
  //!}

  //!@{ Delegate<IExtraEntryPoints>
  // Delegation of extra entry points
  // ie automatic position of time tools in
  // arcane time loop
  void firstInit();
  void lastInit();
  void firstComputeLoop();
  void lastComputeLoop();
  void firstContinueInit();
  void firstRestore();
  //!}
  
  //!@{ IObservable
  void attachObserver(TimeStep::IObserver* observer);
  
  void detachObserver(TimeStep::IObserver* observer);
  //!}

private:

  void _computeTimeStep();

  void _computeRestoredTimeStep();

  void _loadEvents();

private:

  bool m_initialized;

  EventCalendar m_calendar;
  TimeEvolution m_evolution;

  Arcane::VariableScalarByte m_final_time_is_reached;

  Arcane::VariableScalarReal m_next_time;

  Arcane::VariableScalarByte m_infinite_dt;

  Arcane::VariableScalarByte m_time_step_has_to_be_restored;
  Arcane::VariableScalarReal m_time_step_before_truncation;

  Arcane::VariableScalarReal m_dt_n;

  Arcane::VariableScalarByte m_next_step_is_replayed;

  TimeStep::EntryPoints m_entry_points;

  TimeStep::ObserverSet m_observers;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
TimeLineService::
init()
{
  if(m_initialized) return;

  m_observers.attachObserver(&m_calendar);

  m_calendar.setVerbosity(options()->verbose());

  SIUnitsConverter si(options()->unitsSystem);
  si[IUnitsSystemProperty::Time];

  m_final_time_is_reached = false;
  m_next_time = 0.;
  m_infinite_dt = false;
  m_time_step_has_to_be_restored = false;
  m_time_step_before_truncation = 0.;
  m_dt_n = -1;
  m_next_step_is_replayed = false;

  m_initial_time = si[options()->initTime()];
  m_time         = si[m_initial_time()];
  m_time_n       = m_time();
  m_final_time   = si[options()->endTime()];
  
  m_iteration = 0;

  m_min_dt = si[options()->minTimeStep()];
  m_max_dt = si[options()->maxTimeStep()];
  m_init_dt = si[options()->initTimeStep()];

  m_dt   = m_init_dt();
  m_dt_n = m_dt();

  m_forced_dt = Arcane::FloatInfo<Arcane::Real>::maxValue();

  if(m_dt() == std::numeric_limits<Arcane::Real>::infinity()) {
    m_infinite_dt = true;
  }

  if(m_dt() < m_min_dt()) {
    fatal() << "Initial time step less than min time step bound";
  }

  if(options()->verbose()) {

    using namespace OutputFormatting;
    OutputFormatting::Array out("|r:l|");

    out << hline('-') << endl()
        << multicolumn(2,'c') << "Time parameters" << endl()
        << hline('-') << endl();
    out << "initial time" << sep() << m_initial_time() << endl();
    out <<   "final time" << sep() <<   m_final_time() << endl();
    out << hline('-') << endl()
        << multicolumn(2,'c') << "Time step control" << endl()
        << hline('-') << endl();
    out << "min time step" << sep() << m_min_dt() << endl();
    out << "max time step" << sep() << m_max_dt() << endl();
    out << hline('-') << endl();
    out << "initial time step" << sep() << m_init_dt() << endl();
    out << hline('-') << endl();
    info() << out;
  }

  _loadEvents();

  lock();

  m_initialized = true;
}

/*---------------------------------------------------------------------------*/

void 
TimeLineService::
_loadEvents()
{
  const Arcane::Integer nb_events = options()->dateEvent.size();

  SIUnitsConverter si(options()->unitsSystem);
  si[IUnitsSystemProperty::Time];

  for(Arcane::Integer i = 0; i < nb_events; ++i) {
    const CaseOptionsTimeLine::CaseOptionDateEventValue& option = options()->dateEvent[i];
    const Arcane::String name = Arcane::String::format("Change time parameters event {0}",i);
    Optional<Arcane::Real> min_time_step(option.minTimeStep);
    Optional<Arcane::Real> max_time_step(option.maxTimeStep);
    Optional<Arcane::Real> initial_time_step(option.initTimeStep);

    if(si[option.date()] < m_time_n()) continue;

    IEvent* date =
      new TimeStepModifier(name,
                           si[option.date()],
                           si[min_time_step],
                           si[max_time_step],
                           si[initial_time_step]);

    m_calendar.schedule(date);
  }
}

/*---------------------------------------------------------------------------*/

void
TimeLineService::
_computeTimeStep()
{
  ARCANE_ASSERT((m_initialized),(" not initialized, call init method first"));

  unlock();

  if( m_final_time_is_reached() ) {
    info() << " *** Final time is reached ***";
    subDomain()->timeLoopMng()->stopComputeLoop(true);
    m_time_n = m_next_time();
    return;
  }

  Arcane::Real dt = m_dt();

  if(m_infinite_dt()) {

    dt = Arcane::FloatInfo<Arcane::Real>::maxValue();

    m_time_step_has_to_be_restored = false;

  } else if(m_iteration() != 0) {

    dt = m_evolution.suggestedNextTimeStep();

  }
  
  if( m_time_step_has_to_be_restored() && (not m_infinite_dt()) && (dt >= m_dt_n()) ) {

    dt = Arcane::math::max(m_time_step_before_truncation(), dt);

    pwarning() << "Time step is restored after a truncation";

    // should be here!!!
    //m_time_step_has_to_be_restored = false;
  }

  m_time_step_has_to_be_restored = false;

  if(m_spied_forced_dt.hasChanged()) {

    if(m_iteration() == 0)
      dt = m_forced_dt();
    else
      dt = Arcane::math::min(m_forced_dt(), dt);

    pwarning() << "Next time step is forced";
  }
  
  m_forced_dt = Arcane::FloatInfo<Arcane::Real>::maxValue();

  const Arcane::Real   final_time = m_final_time();
  const Arcane::Real current_time = m_time();
  
  if(dt < m_min_dt())
    dt = m_min_dt();
  
  dt = Arcane::math::min(dt, m_max_dt());
 
  if(dt < m_min_dt()) {
    fatal() << "Min time step bound reached";
  }

  m_next_time = current_time + dt;
  m_dt = dt;

  const Arcane::Real next_event_time = math::min(m_global_final_time(), m_calendar.nextEventTime());

  if(m_next_time() >= next_event_time) { // > should be the good test
    m_time_step_before_truncation = dt;
    m_next_time = next_event_time;
    m_dt = m_next_time() - current_time;
    if(options()->restoreTimeStepAfterEventTruncation()) {
      m_time_step_has_to_be_restored = true;
    }
    pwarning() << "Next time step is truncated due to next event time";
  } else if (m_next_time() > next_event_time - m_min_dt() && m_next_time() != next_event_time) {
    // Pour eviter d'etre sous le pas de temps min au prochain
    // pas de temps on reduit le pas de temps par 2
    m_time_step_before_truncation = dt;
    m_dt = (next_event_time - current_time) * 0.5;
    m_next_time = current_time + m_dt();
    if (options()->restoreTimeStepAfterEventTruncation()) {
      m_time_step_has_to_be_restored = true;
    }
    pwarning() << "Next time step is truncated due to anticipation of next event time";
  }

  m_dt_n = m_dt();

  m_final_time_is_reached = Arcane::math::abs(m_next_time() - final_time) < 1.e-14;

  m_next_step_is_replayed = false;

  if(options()->verbose()) {

    using namespace OutputFormatting;
    OutputFormatting::Array out("|r:l|");

    out << hline('-') << endl()
        << multicolumn(2,'c') << "Time step evolution" << endl()
        << hline('-') << endl();
    out << "next time step" << sep() << m_dt() << endl();
    out << hline('-') << endl();
    out << "current time" << sep() << m_time()    << endl();
    out <<    "next time" << sep() << m_next_time() << endl();
    out << hline('-') << endl();
    info() << out;

  }

  lock();
}

/*---------------------------------------------------------------------------*/

void 
TimeLineService::
_computeRestoredTimeStep()
{
  ARCANE_ASSERT((m_initialized),(" not initialized, call init method first"));

  unlock(SpyPolicy::NothingIfChanged);

  const Arcane::Real unvalid_dt = m_dt();

  Arcane::Real dt = m_evolution.suggestedRestoredTimeStep();

  if(Arcane::math::abs(dt - m_min_dt()) < 1.e-14)
    dt = m_min_dt();

  if(dt < m_min_dt()) {
    fatal() << "Min time step bound reached";
  }

  m_next_time = m_time() + dt;
  m_time_n = m_time();
  m_dt = dt;

  m_final_time_is_reached = false;
  m_time_step_has_to_be_restored = false;
  m_next_step_is_replayed = true;

  if(options()->verbose()) {

    using namespace OutputFormatting;
    OutputFormatting::Array out("|r:l|");

    out << hline('-') << endl()
        << multicolumn(2,'c') << "Time step evolution" << endl()
        << hline('-') << endl();
    out << "unvalid time step" << sep() << unvalid_dt << endl();
    out << "next time step" << sep() << m_dt() << endl();
    out << hline('-') << endl();
    out << "current time" << sep() << m_time()    << endl();
    out <<    "next time" << sep() << m_next_time() << endl();
    out << hline('-') << endl();
    info() << out;

  }

  lock();
}

/*---------------------------------------------------------------------------*/

void 
TimeLineService::
notify(const TimeStep::EntryPoint& entry_point)
{
  if(entry_point == TimeStep::Begin()) 
    fatal() << "ArcGeoSim::TimeStep::Begin enty points shouldn't be notify by user";
  if(entry_point == TimeStep::End()) 
    fatal() << "ArcGeoSim::TimeStep::End enty points shouldn't be notify by user";
  if(entry_point == TimeStep::BeforeRestoreSave()) 
    fatal() << "ArcGeoSim::TimeStep::BeforeRestoreSave enty points shouldn't be notify by user";

  m_observers.notifyObservers(entry_point);
}
  
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineService::
timeIncrementation()
{ 
  unlock();

  // Old time saving
  m_time_n = m_time();
  
  // Next time should have been computed due to events
  m_time = m_next_time();

  lock();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineService::
firstInit()
{
  init();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineService::
lastInit()
{
  m_observers.notifyObservers(TimeStep::BeforeRestoreSave());
  
  _computeTimeStep();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineService::
firstComputeLoop()
{
  m_observers.notifyObservers(TimeStep::Begin()); 
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineService::
lastComputeLoop()
{
  m_observers.notifyObservers(TimeStep::End());
  m_observers.notifyObservers(TimeStep::BeforeRestoreSave());
  
  m_observers.notifyObservers(TimeStepIsFinished);
  
  _computeTimeStep();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineService::
firstContinueInit()
{
  ARCANE_ASSERT((!m_initialized),(" already initialized"));

  m_observers.attachObserver(&m_calendar);

  m_calendar.setVerbosity(options()->verbose());

  _loadEvents();

  m_iteration = m_iteration() + 1;

  lock();

  m_initialized = true;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
TimeLineService::
firstRestore()
{
  _computeRestoredTimeStep();

  m_observers.notifyObservers(TimeStepIsRestored);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
TimeLineService::
attachObserver(TimeStep::IObserver* observer)
{
  m_observers.attachObserver(observer);
}
  
/*---------------------------------------------------------------------------*/

void 
TimeLineService::
detachObserver(TimeStep::IObserver* observer)
{
  m_observers.detachObserver(observer);
}
   
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_TIMELINE(TimeLine, TimeLineService);
// Pour simplifier le portage des applications existantes
// A retirer quand les applications auront fait les changements
ARCANE_REGISTER_SERVICE_TIMELINE(TimeMng, TimeLineService);

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_ARCGEOSIM_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
