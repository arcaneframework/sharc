// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "EventCalendar.h"
/* Author : desrozis at Wed Oct 29 09:34:33 2014
 * Generated by createNew
 */

#include "ArcGeoSim/Time/IEvent.h"

#include "ArcGeoSim/Utils/OutputFormatting/OutputFormatting.h"

#include <arcane/ISubDomain.h>

/*---------------------------------------------------------------------------*/

ArcGeoSim::EventCalendar::
EventCalendar(Arcane::ISubDomain* sd)
  : Arcane::TraceAccessor(sd->traceMng())
  , TimeVariables(sd)
  , m_verbose(false)
  , m_observers(this) 
  , m_observable(NULL) {}

/*---------------------------------------------------------------------------*/

ArcGeoSim::EventCalendar::
~EventCalendar()
{
  for(Arcane::Integer i = 0; i < m_ownership_events.size(); ++i)
    delete m_ownership_events[i];
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::EventCalendar::
schedule(IEvent* event, Ownership::ePolicy owner)
{
  attachObserver(event);

  if(owner == Ownership::Take)
    m_ownership_events.add(event);
}

/*---------------------------------------------------------------------------*/

Arcane::Real
ArcGeoSim::EventCalendar::
nextEventTime()
{
  Arcane::Real event_time = m_final_time();

  TimeStep::ObserverSet::iterator it = m_observers.begin();

  for(; it != m_observers.end(); ++it) {
    const IEvent* e = static_cast<IEvent*>(*it);
    if (e->startDate() > m_time())
      event_time = Arcane::math::min(event_time, e->startDate());
    if (e->endDate() > m_time())
      event_time = Arcane::math::min(event_time, e->endDate());
  }
  
  if(m_verbose) {

    const Arcane::Integer size = m_observers.size();

    using namespace OutputFormatting;
    OutputFormatting::Array out("|r:l|");

    out << hline('-') << endl()
        << multicolumn(2,'c') << "Event time" << endl()
        << hline('-') << endl();
    if(size == 0) {
      out << multicolumn(2,'c') << "No event planned" << endl()
          << hline('-') << endl();
    } else {
      out << multicolumn(2,'c') << size << " event(s) planned" << endl()
          << hline('-') << endl();
      out << "next event time" << sep() << event_time << endl()
          << hline('-') << endl();
    }
    info() << out;

  }

  return event_time;
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::EventCalendar::
print() const
{
  const Arcane::Integer size = m_observers.size();

  using namespace OutputFormatting;
  OutputFormatting::Array out("|r:l|");
  
  out << hline('-') << endl()
      << multicolumn(2,'c') << "Event time" << endl()
      << hline('-') << endl();
  if(size == 0) {
    out << multicolumn(2,'c') << "No event planned" << endl()
        << hline('-') << endl();
  } else {
    out << multicolumn(2,'c') << size << " event(s) planned" << endl()
        << hline('-') << endl();
    out << "min" << sep() << "max" << endl()
        << minTime() << sep() << maxTime() << endl()
        << hline('-') << endl();
    out << multicolumn(2,'c') << "Time of event(s)" << endl();
    out << "start" << sep() << "end" << endl();
    TimeStep::ObserverSet::const_iterator it = m_observers.begin();
    for(; it != m_observers.end(); ++it) {
      const IEvent* e = static_cast<IEvent*>(*it);
      if(e->startDate() == e->endDate()) {
        out << e->startDate() << sep() << "xxx" << endl();
      } else {
        out << e->startDate() << sep() << e->endDate() << endl();
      }
    }
    out << hline('-') << endl(); 
  }
  info() << out;
}

/*---------------------------------------------------------------------------*/

void 
ArcGeoSim::EventCalendar::
execute(const TimeStep::EntryPoint& entry_point)
{
  if(entry_point == TimeStep::Begin()) 
    fatal() << "ArcGeoSim::TimeStep::Begin enty points shouldn't be notify by user";
  if(entry_point == TimeStep::End()) 
    fatal() << "ArcGeoSim::TimeStep::End enty points shouldn't be notify by user";
  if(entry_point == TimeStep::BeforeRestoreSave()) 
    fatal() << "ArcGeoSim::TimeStep::BeforeRestoreSave enty points shouldn't be notify by user";

  m_observers.notifyObservers(entry_point);
}
  
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::EventCalendar::
notify(const TimeStep::EntryPoint& entry_point)
{
  m_observers.notifyObservers(entry_point);
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::EventCalendar::
notify(eTimeStepState state)
{
  m_observers.notifyObservers(state);
}

/*---------------------------------------------------------------------------*/

Arcane::Real
ArcGeoSim::EventCalendar::
minTime() const
{
  TimeStep::ObserverSet::const_iterator it = m_observers.begin();

  Arcane::Real min_date = Arcane::FloatInfo<Arcane::Real>::maxValue();
  for(; it != m_observers.end(); ++it) {
    const IEvent* e = static_cast<IEvent*>(*it);
    min_date = Arcane::math::min(min_date, e->startDate());
    min_date = Arcane::math::min(min_date, e->endDate());
  }
  
  return min_date;
}

/*---------------------------------------------------------------------------*/

Arcane::Real
ArcGeoSim::EventCalendar::
maxTime() const
{
  TimeStep::ObserverSet::const_iterator it = m_observers.begin();

  Arcane::Real max_date = - Arcane::FloatInfo<Arcane::Real>::maxValue();
  for(; it != m_observers.end(); ++it) {
    const IEvent* e = static_cast<IEvent*>(*it);
    max_date = Arcane::math::max(max_date, e->startDate());
    max_date = Arcane::math::max(max_date, e->endDate());
  }
  
  return max_date;
}

/*---------------------------------------------------------------------------*/

void 
ArcGeoSim::EventCalendar::
attachObservable(IObservable* observable)
{
  ARCANE_ASSERT((observable != NULL),("IObservable pointer null"));
  
  m_observable = observable;
}

/*---------------------------------------------------------------------------*/

void 
ArcGeoSim::EventCalendar::
attachObserver(TimeStep::IObserver* observer)
{
  m_observers.attachObserver(observer);
}
 
/*---------------------------------------------------------------------------*/

void 
ArcGeoSim::EventCalendar::
detachObserver(TimeStep::IObserver* observer)
{
  m_observers.detachObserver(observer);
}
 
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
