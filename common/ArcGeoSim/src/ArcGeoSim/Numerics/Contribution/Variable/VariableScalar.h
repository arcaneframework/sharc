// -*- C++ -*-
#pragma once
/* Author : desrozis at Tue Nov 13 08:40:09 2012
 * Generated by createNew
 */

#include "ArcGeoSim/Numerics/Contribution/Variable/BaseVariable.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
namespace ArcNum {

  BEGIN_AUDI_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
class ScalarProperty
{
public :

  typedef Arcane::VariableRefScalarT<Arcane::Real> VarType;
  typedef Arcane::VariableRefArrayT<Arcane::Real>  DerivVarType;

  typedef const Arcane::Real&                  ValueType;
  typedef Arcane::ConstArrayView<Arcane::Real> DerivType;

  ScalarProperty()
  {}

  ScalarProperty(ScalarProperty const& rhs)
  : m_value(rhs.m_value)
  , m_derivatives(rhs.m_derivatives)
  {}

  ValueType operator()() const {
    return (*m_value)() ;
  }


  inline DerivType storedDerivatives() const
  {
    return (*m_derivatives);
  }

protected :
  VarType* m_value = nullptr;
  DerivVarType* m_derivatives = nullptr ;
};

class VariableScalar
    : public ScalarProperty
    , private BaseVariable
{
public:

  typedef ScalarProperty              Base ;

  typedef typename Base::VarType      VarType ;
  typedef typename Base::DerivVarType DerivVarType ;

  VariableScalar() {}

  VariableScalar(const VariableScalar& rhs)
  : Base(rhs)
  , BaseVariable(rhs)
  {}

  template<typename MappingT>
  VariableScalar(ConstArrayView<MappingT> offsets)
  : BaseVariable(offsets)
  {}

  virtual ~VariableScalar() {}

public:

  void setValues(VarType* value)
  {
    this->m_value = value ;
  }

  void setDerivValues(DerivVarType* values)
  {
    this->m_derivatives = values ;
  }
  inline const RootContribution& operator()() const
  {
    ARCANE_ASSERT((m_ad_value.size() == 1),("error, using operator() instead of Geoxim::Item"));
    return _contribution(0);
  }

  inline const RootContribution& operator[](const Stencil::Item& item) const
  {
    ARCANE_ASSERT((m_ad_value.size() >= item.size()),("error, Geoxim::Item size not suitable"));
    const Arcane::Integer index = item.index();
    return _contribution(index);
  }

private:
  inline const RootContribution& _contribution(const Arcane::Integer& index) const
  {
    // sparse ad wrapper affectation
    RootContribution& ad_value = m_ad_value[index].first;
    ad_value.value() = Base::operator()();
    bool update_derivatives = m_ad_value[index].second;
    if(update_derivatives){
      auto* deriv = Base::storedDerivatives().unguardedBasePointer();
      ad_value.setGradient(deriv);
    }
    return ad_value;
  }

};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_AUDI_NAMESPACE
}
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

