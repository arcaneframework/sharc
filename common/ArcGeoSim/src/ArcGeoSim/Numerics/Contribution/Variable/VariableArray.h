// -*- C++ -*-
#pragma once
/* Author : desrozis at Tue Nov 13 08:40:09 2012
 * Generated by createNew
 */

#include "ArcGeoSim/Numerics/Contribution/Variable/BaseVariable.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace ArcNum {
BEGIN_AUDI_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
class ArrayProperty
{
public :
  typedef Arcane::VariableRefArrayT<Arcane::Real>  VarType;
  typedef Arcane::VariableRefArray2T<Arcane::Real> DerivVarType;


  typedef typename VarType::ConstReturnReferenceType      ConstReturnReferenceType;
  typedef typename DerivVarType::ConstReturnReferenceType DerivativesReturnType;

  ArrayProperty()
  {}

  ArrayProperty(ArrayProperty const& rhs)
  : m_values(rhs.m_values)
  , m_derivatives(rhs.m_derivatives)
  {}

  template<typename ItemT>
  ConstReturnReferenceType operator[](const ItemT& iter) const {

    const auto& values = *m_values;
#ifdef USE_ARCANE_V3
    if constexpr (std::is_same_v<ItemT,Integer>)
                   return values[Arcane::ItemLocalId(iter)];
    else
      return values[iter.internal()];
#else
    return values[iter];
#endif
  }

  template<typename I>
  inline DerivativesReturnType storedDerivatives(const I& iter) const {
    const auto& derivatives = *m_derivatives;
#ifdef USE_ARCANE_V3
    if constexpr (std::is_same_v<I,Integer>)
      return derivatives[Arcane::ItemLocalId(iter)];
    else
      return derivatives[iter.internal()];
#else
    return derivatives[iter];
#endif
  }
protected:
  VarType* m_values=nullptr;
  DerivVarType* m_derivatives = nullptr ;
};

class VariableArray
    : public ArrayProperty
    , private BaseVariable
{
public:

  typedef ArrayProperty Base ;

  typedef typename Base::VarType      VarType ;
  typedef typename Base::DerivVarType DerivVarType ;

  VariableArray() {}

  VariableArray(const VariableArray& rhs)
  : Base(rhs)
  , BaseVariable(rhs) {}

  template<typename MappingT>
  VariableArray(ConstArrayView<MappingT> offsets)
  : Base()
  , BaseVariable(offsets)
  {}

  virtual ~VariableArray() {}

public:

  void setValues(VarType* values)
  {
    this->m_values = values ;
  }

  void setDerivValues(DerivVarType* values)
  {
    this->m_derivatives = values ;
  }

  inline const RootContribution& operator[](Arcane::Integer item) const
  {
    ARCANE_ASSERT((m_ad_value.size() == 1),("error, using Arcane::Item instead of Geoxim::Item"));
    return _contribution(item,0);
  }

  inline const RootContribution& operator[](const Stencil::IntegerIndex& item) const
  {
    ARCANE_ASSERT((m_ad_value.size() >= item.size()),("error, Geoxim::Item size not suitable"));
    const Arcane::Integer index = item.index();
    return _contribution(item,index);
  }

private:
  template<typename ItemT>
  inline const RootContribution& _contribution(const ItemT& item, const Arcane::Integer& index) const
  {
    // sparse ad wrapper affectation
    RootContribution& ad_value = m_ad_value[index].first;
    ad_value.value() = Base::operator[](item);
    bool update_derivatives = m_ad_value[index].second;
    if(update_derivatives){
      auto* deriv = Base::storedDerivatives(item).unguardedBasePointer();
      ad_value.setGradient(deriv);
    }
    return ad_value;
  }

};
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_AUDI_NAMESPACE
}
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
