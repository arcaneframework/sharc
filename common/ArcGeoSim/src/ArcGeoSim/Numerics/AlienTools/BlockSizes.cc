// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
/* Author : desrozis at Thu Mar 14 12:29:22 2013
 * Generated by createNew
 */

#include "ArcGeoSim/Numerics/AlienTools/IIndexManager.h"
#include "BlockSizes.h"

#include <arcane/IParallelMng.h>
#include <arcane/SerializeMessage.h>
#include <arcane/ISerializeMessageList.h>

#include <map>
#include <list>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_ALIEN_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BlockSizes::
BlockSizes()
  : m_is_prepared(false) 
  , m_local_size(0)
  , m_max_size(0)
{
  ;
}

/*---------------------------------------------------------------------------*/

struct BlockSizes::EntrySendRequest
{
  EntrySendRequest() : comm(NULL), count(0) {}
  
  ~EntrySendRequest()
  {
    // Valide m�me si comm vaut NULL
    delete comm;
  }

  Arcane::SerializeMessage* comm;
  Integer count;
};

struct BlockSizes::EntryRecvRequest
{
  EntryRecvRequest() : comm(NULL)
  {
    ;
  }

  ~EntryRecvRequest()
  {
    // Valide m�me si comm vaut NULL
    delete comm;
  }

  Arcane::SerializeMessage* comm;
  Arcane::IntegerSharedArray ids;
};

//A. Anciaux cette partie est modifi�e: "max_size"

void
BlockSizes::
prepare(const IIndexManager& index_mng, Arcane::IntegerConstArrayView block_sizes)
{
  if(m_is_prepared)
    throw Arcane::FatalErrorException(A_FUNCINFO,"BlockSizes is already prepared");
  
  Arcane::IParallelMng* parallel_mng = index_mng.parallelMng();
   
  const Integer offset = index_mng.minLocalIndex();
  
  const Integer size = block_sizes.size();
  

  m_local_sizes.resize(size);
  m_local_offsets.resize(size+1);

  Integer sum = 0, max_size = 0;
  for(Integer i = 0; i < size; ++i) {
    const Integer block_size = block_sizes[i];
    max_size = (max_size > block_size) ? max_size : block_size;
    const Integer index = i + offset;
    m_sizes[index] = m_local_sizes[i] = block_size;
    m_offsets[index] = m_local_offsets[i] = sum;
    sum += block_size;
  }
  m_local_offsets[size] = sum ;
  m_max_size = max_size;
  m_local_size = sum;
  m_is_prepared = true;
  
  const bool is_parallel = (parallel_mng!=NULL) && (parallel_mng->commSize()>1); 
  if(not is_parallel) return;
  
  ///Arcane::ITraceMng* trace = parallel_mng->traceMng();

  const Integer rank = parallel_mng->commRank();
 
  typedef std::map<String,EntrySendRequest> SendRequestByEntry;
  typedef std::map<Integer,SendRequestByEntry> SendRequests;
  SendRequests sendRequests;

  typedef SafeConstArrayView<Integer> Owners;
  typedef std::map<String,Owners> OwnersByEntry;
  OwnersByEntry owners_by_entry;

  for(IIndexManager::EntryEnumerator e = index_mng.enumerateEntry(); e.hasNext(); ++e) {
    //IntegerConstArrayView all_indexes = e->getAllIndexes();
    Arcane::IntegerConstArrayView all_lids = e->getAllLocalIds();
    Owners owners = e->getFamily().owners(all_lids);
    const String name = e->getName();
    owners_by_entry[name] = owners;
    for(Integer i = 0; i < owners.size(); ++i) {
      if(owners[i] != rank) sendRequests[owners[i]][name].count++;
    }
  }
  
  Arcane::ISerializeMessageList* messageList = parallel_mng->createSerializeMessageList();

  Arcane::IntegerSharedArray sendToDomains(2*parallel_mng->commSize(),0);

  for(SendRequests::iterator i = sendRequests.begin(); i != sendRequests.end(); ++i) {
    const Integer destDomainId = i->first;
    SendRequestByEntry& requests = i->second;
    for(SendRequestByEntry::iterator j = requests.begin(); j != requests.end(); ++j) {
      EntrySendRequest& request = j->second;
      const String& nameString = j->first;
      sendToDomains[2*destDomainId + 0] += 1;
      sendToDomains[2*destDomainId + 1] += request.count;
      request.comm = new Arcane::SerializeMessage(parallel_mng->commRank(),destDomainId,Arcane::ISerializeMessage::MT_Send);
      messageList->addMessage(request.comm);
      Arcane::SerializeBuffer& sbuf = request.comm->buffer();
      sbuf.setMode(Arcane::ISerializer::ModeReserve);
      sbuf.reserve(nameString);                     // Chaine de caract�re du nom de l'entr�e
      sbuf.reserveInteger(1);                       // Nb d'item
      sbuf.reserve(Arcane::DT_Int32,request.count); // Les indices demand�s
      sbuf.allocateBuffer(); 
      sbuf.setMode(Arcane::ISerializer::ModePut);
      sbuf.put(nameString);
      sbuf.put(request.count);
    }
  }
  
  for(IIndexManager::EntryEnumerator e = index_mng.enumerateEntry(); e.hasNext(); ++e) { 
    const String name = e->getName();
    Owners& owners = owners_by_entry[name];
    Arcane::IntegerConstArrayView all_indexes = e->getAllIndexes();
    for(Integer i = 0; i < owners.size(); ++i) {
      if(owners[i] != rank) sendRequests[owners[i]][name].comm->buffer().put(all_indexes[i]);
    }
  }
  
  Arcane::IntegerSharedArray recvFromDomains(2*parallel_mng->commSize());
  parallel_mng->allToAll(sendToDomains,recvFromDomains,2);
  
  typedef std::list<EntryRecvRequest> RecvRequests;
  RecvRequests recvRequests;

  for(Integer isd=0, nsd=parallel_mng->commSize();isd<nsd;++isd) {
    Integer recvCount = recvFromDomains[2*isd+0];
    while(recvCount-- > 0) {
      Arcane::SerializeMessage* recvMsg = new Arcane::SerializeMessage(parallel_mng->commRank(),isd,Arcane::ISerializeMessage::MT_Recv);
      recvRequests.push_back(EntryRecvRequest());
      EntryRecvRequest& recvRequest = recvRequests.back();
      recvRequest.comm = recvMsg;
      messageList->addMessage(recvMsg);
    }
  }
  
  messageList->processPendingMessages();
  messageList->waitMessages(Arcane::Parallel::WaitAll);
  delete messageList; messageList = NULL; 
  
  messageList = parallel_mng->createSerializeMessageList();
  
  for(RecvRequests::iterator i = recvRequests.begin(); i != recvRequests.end(); ++i) {
    EntryRecvRequest & recvRequest = *i;
    String nameString;
    Integer uidCount;
    
    { 
      Arcane::SerializeBuffer& sbuf = recvRequest.comm->buffer();
      sbuf.setMode(Arcane::ISerializer::ModeGet);
      
      sbuf.get(nameString);
      uidCount = sbuf.getInteger();
      recvRequest.ids.resize(uidCount);
      sbuf.get(recvRequest.ids);
      ARCANE_ASSERT((uidCount == recvRequest.ids.size()),("Inconsistency detected"));
    }
    
    {
      #ifndef USE_ARCANE_V3
      const Integer dest = recvRequest.comm->destSubDomain(); // Attention � l'ordre bizarre
      const Integer orig = recvRequest.comm->origSubDomain(); //       de SerializeMessage
      #else
      const Integer dest = recvRequest.comm->destination().value(); // Attention � l'ordre bizarre
      const Integer orig = recvRequest.comm->source().value(); //       de SerializeMessage
      #endif
      delete recvRequest.comm;
      recvRequest.comm = new Arcane::SerializeMessage(orig,dest,Arcane::ISerializeMessage::MT_Send);
      messageList->addMessage(recvRequest.comm);
      
      Arcane::SerializeBuffer & sbuf = recvRequest.comm->buffer();
      sbuf.setMode(Arcane::ISerializer::ModeReserve);
      sbuf.reserve(nameString);      // Chaine de caract�re du nom de l'entr�e
      sbuf.reserveInteger(1);        // Nb d'item
      sbuf.reserveInteger(uidCount); // Les tailles
      sbuf.allocateBuffer();
      sbuf.setMode(Arcane::ISerializer::ModePut);
      sbuf.put(nameString);
      sbuf.put(uidCount);
    }
  }
  
  for(RecvRequests::iterator i = recvRequests.begin(); i != recvRequests.end(); ++i) {
    EntryRecvRequest & recvRequest = *i;
    Arcane::SerializeBuffer& sbuf = recvRequest.comm->buffer();
    auto& ids = recvRequest.ids;
    for(Integer j = 0; j<ids.size(); ++j) {
      sbuf.putInteger(block_sizes[ids[j]-offset]);
    }
  }
  
  typedef std::list<Arcane::SerializeMessage*> ReturnedRequests;
  ReturnedRequests returnedRequests;
 
  typedef std::map<Integer, EntrySendRequest*> SubFastReturnMap;
  typedef std::map<String, SubFastReturnMap> FastReturnMap;
  FastReturnMap fastReturnMap;

  for(SendRequests::iterator i = sendRequests.begin(); i != sendRequests.end(); ++i) {
    const Integer destDomainId = i->first;
    SendRequestByEntry & requests = i->second;
    for(SendRequestByEntry::iterator j = requests.begin(); j != requests.end(); ++j) {
      EntrySendRequest & request = j->second;
      const String nameString = j->first;
      delete request.comm; request.comm = NULL;
      Arcane::SerializeMessage * msg = new Arcane::SerializeMessage(parallel_mng->commRank(),destDomainId,Arcane::ISerializeMessage::MT_Recv);
      returnedRequests.push_back(msg);
      messageList->addMessage(msg);
      
      fastReturnMap[nameString][destDomainId] = &request;
    }
  }
  
  messageList->processPendingMessages();
  messageList->waitMessages(Arcane::Parallel::WaitAll);
  delete messageList; messageList = NULL;
  
  for(ReturnedRequests::iterator i = returnedRequests.begin(); i != returnedRequests.end(); ++i) {
    Arcane::SerializeMessage * message = *i;
    #ifndef USE_ARCANE_V3
    const Integer origDomainId = message->destSubDomain();
    #else
    const Integer origDomainId = message->destination().value();
    #endif
    Arcane::SerializeBuffer& sbuf = message->buffer();
    sbuf.setMode(Arcane::ISerializer::ModeGet);
    String nameString;
    sbuf.get(nameString);
    ARCANE_ASSERT((fastReturnMap[nameString][origDomainId] != NULL),("Inconsistency detected"));
    EntrySendRequest & request = *fastReturnMap[nameString][origDomainId];
    request.comm = *i; 
#ifdef ARCANE_DEBUG_ASSERT
    const Integer idCount = sbuf.getInteger();
#else 
    sbuf.getInteger();
#endif
    ARCANE_ASSERT((request.count == idCount),("Inconsistency detected"));
  }
  
  for(IIndexManager::EntryEnumerator e = index_mng.enumerateEntry(); e.hasNext(); ++e) {
    Arcane::IntegerConstArrayView all_indexes = e->getAllIndexes();
    Owners owners = owners_by_entry[(*e).getName()];
    for(Integer i = 0; i < owners.size(); ++i) {
      const Integer index = all_indexes[i];
      if (owners[i] != rank) {
        EntrySendRequest& request = sendRequests[owners[i]][e->getName()];
        ARCANE_ASSERT((request.count > 0),("Unexpected empty request"));
        --request.count;
        const Integer block_size = request.comm->buffer().getInteger();
        m_sizes[index] = block_size;
        m_max_size = (m_max_size > block_size) ? m_max_size : block_size;
        m_offsets[index] = sum;
        sum += block_size;
      }
    }
  }
  
//   for(IIndexManager::EntryEnumerator e = index_mng.enumerateEntry(); e.hasNext(); ++e) {
//     IntegerConstArrayView all_indexes = e->getAllIndexes();
//      for(Integer i = 0; i < all_indexes.size(); ++i) {
//        const Integer index = all_indexes[i];
//        trace->info() << "index=" << index << " size = " << m_sizes[index] << ", offset = " << m_offsets[index];
//      }
//   }
  
  m_is_prepared = true;
}

/*---------------------------------------------------------------------------*/

Integer 
BlockSizes::
size(Integer index) const
{
  ARCANE_ASSERT((m_is_prepared),("BlockSizes is not prepared"));
 
  ValuePerBlock::const_iterator it = m_sizes.find(index);

  if(it == m_sizes.end())
    throw Arcane::FatalErrorException(A_FUNCINFO,"index is not registered");

  return it.value();
}

/*---------------------------------------------------------------------------*/

Integer 
BlockSizes::
sizeFromLocalIndex(Integer index) const
{
  //A. Anciaux
  //ToDo pas faire une mapping --> aller vers un tableau pointeur
  ARCANE_ASSERT((m_is_prepared),("BlockSizes is not prepared"));
 
  return m_local_sizes[index];
}

/*---------------------------------------------------------------------------*/

Integer 
BlockSizes::
offset(Integer index) const
{
  //A. Anciaux
  //ToDo pas faire une mapping --> aller vers un tableau pointeur
  ARCANE_ASSERT((m_is_prepared),("BlockSizes is not prepared"));
 
  ValuePerBlock::const_iterator it = m_offsets.find(index);

  if(it == m_offsets.end())
    throw Arcane::FatalErrorException(A_FUNCINFO,"index is not registered");
  
  return it.value();
}



/*---------------------------------------------------------------------------*/

Integer 
BlockSizes::
offsetFromLocalIndex(Integer index) const
{
  ARCANE_ASSERT((m_is_prepared),("BlockSizes is not prepared"));
 
  return m_local_offsets[index];
}

/*---------------------------------------------------------------------------*/

Integer 
BlockSizes::
localSize() const
{
  ARCANE_ASSERT((m_is_prepared),("BlockSizes is not prepared"));
  
  return m_local_size;
}

/*---------------------------------------------------------------------------*/

Integer 
BlockSizes::
maxSize() const
{
  ARCANE_ASSERT((m_is_prepared),("BlockSizes is not prepared"));
  
  return m_max_size;
}

/*---------------------------------------------------------------------------*/

Arcane::IntegerConstArrayView 
BlockSizes::
sizeOfLocalIndex() const
{
  return m_local_sizes;
}

/*---------------------------------------------------------------------------*/

Arcane::IntegerConstArrayView 
BlockSizes::
offsetOfLocalIndex() const
{
  return m_local_offsets;
}
 
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_ALIEN_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
