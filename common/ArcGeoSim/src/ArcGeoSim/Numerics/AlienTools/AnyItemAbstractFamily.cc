// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "AnyItemAbstractFamily.h"
/* Author : havep at Mon Jun  3 12:49:08 2013
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/

#include <algorithm>
#include <arcane/utils/FatalErrorException.h>
#include "ArcGeoSim/Utils/ArrayUtils.h"

/*---------------------------------------------------------------------------*/

using namespace Arcane;

BEGIN_ALIEN_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

AnyItemAbstractFamily::
AnyItemAbstractFamily(const Arcane::AnyItem::Family & family,
                      IIndexManager * manager)
  : m_family(family)
  , m_manager(manager)
{
  Int64 max_unique_id = 0;
  m_lower_bounds.resize(m_family.groupSize()+1);
  for(Integer igrp=0;igrp<m_family.groupSize();++igrp) 
    {
      Arcane::ItemGroup group = m_family.group(igrp);
      m_lower_bounds[igrp] = m_family.firstLocalId(group);
      ENUMERATE_ITEM(iitem, group) 
        {
          max_unique_id = std::max(max_unique_id, iitem->uniqueId().asInt64());
        }
    }
  Integer max_local_id = m_family.maxLocalId();
  if ((max_local_id & ~m_item_unique_id_mask) != 0)
    throw Arcane::FatalErrorException(A_FUNCINFO,"Too large item unique ids in AnyItem::Family");
  m_lower_bounds[m_family.groupSize()] = max_local_id;
  if (m_family.groupSize() > (1<<m_group_bit_size))
    throw Arcane::FatalErrorException(A_FUNCINFO,"Too many groups in AnyItem::Family");
}

/*---------------------------------------------------------------------------*/

AnyItemAbstractFamily::
~AnyItemAbstractFamily() 
{ 
  m_manager->keepAlive(this);
}
  
/*---------------------------------------------------------------------------*/

void 
AnyItemAbstractFamily::
uniqueIdToLocalId(Int32ArrayView localIds, Int64ConstArrayView uniqueIds) const 
{ 
  ARCANE_ASSERT((localIds.size() == uniqueIds.size()),("Incompatible array argument sizes"));
  const Integer size = uniqueIds.size();

  // AnyItem uid -> igrp + item unique id
  SharedArray<Int32> group_ids(size); // tableau m�morisant dans de quel groupe est issu l'item � la m�me position
  SharedArray<SharedArray<Int64> > unique_id_by_groups(m_family.groupSize());
  for(Integer i=0;i<size;++i)
    { // Classe les uids par leur groupe sous-jacent avant d'appeler les m�thodes par IItemFamily
      Int64 uniqueId = uniqueIds[i];
      Integer igrp = _get_igroup(uniqueId);
      Int64 item_uid = _get_item_unique_id(uniqueId);
      group_ids[i] = igrp;
      unique_id_by_groups[igrp].add(item_uid);
    }

  // item unique id -> item local id
  SharedArray<SharedArray<Int32> > local_id_by_groups(m_family.groupSize());
  for(Integer igrp=0;igrp<m_family.groupSize();++igrp)
    {
      local_id_by_groups[igrp].resize(unique_id_by_groups[igrp].size());
      if (not local_id_by_groups[igrp].empty())
        {
          Arcane::ItemGroup group = m_family.group(igrp);
          Arcane::IItemFamily * family = group.itemFamily();
          family->itemsUniqueIdToLocalId(local_id_by_groups[igrp], unique_id_by_groups[igrp], true); // do_fatal = true
        }
    }
  unique_id_by_groups.dispose();

  // item local id -> AnyItem local id
  SharedArray<Integer> current_indexes(m_family.groupSize(), 0);
  for(Integer i=0;i<size;++i)
    {
      const Integer group_id = group_ids[i];
      Arcane::ItemGroup group = m_family.group(group_id);
      const Int32 item_lid = local_id_by_groups[group_id][current_indexes[group_id]++];
      const Integer local_index = (*(group.localIdToIndex()))[item_lid];
      localIds[i] = m_lower_bounds[group_id] + local_index;
    }
}

/*---------------------------------------------------------------------------*/

IIndexManager::IAbstractFamily::Item 
AnyItemAbstractFamily::
item(Int32 localId) const
{
  ARCANE_ASSERT((localId < m_family.maxLocalId()),("Bad Abstract Family localId"));
  Integer igrp = ArcGeoSim::ArrayScan::dichotomicIntervalScan(localId, m_lower_bounds.size(), m_lower_bounds.unguardedBasePointer());
  ARCANE_ASSERT((igrp < m_family.groupSize()),("Invalid group index"));
  Arcane::ItemVectorView view = m_family.group(igrp).view();
  Arcane::Item item = view[localId - m_lower_bounds[igrp]];
  return IAbstractFamily::Item(_form_unique_id(igrp, item.uniqueId()),
                               item.owner());
}

/*---------------------------------------------------------------------------*/

SafeConstArrayView<Integer> 
AnyItemAbstractFamily::
owners(Int32ConstArrayView localIds) const
{
  const Integer size = localIds.size();
  SharedArray<Integer> result(size);
  for(Integer i=0;i<size;++i)
    {
      Int32 localId = localIds[i];
      ARCANE_ASSERT((localId < m_family.maxLocalId()),("Bad Abstract Family localId"));
      Integer igrp = ArcGeoSim::ArrayScan::dichotomicIntervalScan(localId, m_lower_bounds.size(), m_lower_bounds.unguardedBasePointer());
      ARCANE_ASSERT((igrp < m_family.groupSize()),("Invalid group index"));
      Arcane::ItemVectorView view = m_family.group(igrp).view();
      Arcane::Item item = view[localId - m_lower_bounds[igrp]];
      result[i] = item.owner();
    }
  return result;
}

/*---------------------------------------------------------------------------*/

SafeConstArrayView<Int64> 
AnyItemAbstractFamily::
uids(Int32ConstArrayView localIds) const
{
  const Integer size = localIds.size();
  SharedArray<Int64> result(size);
  for(Integer i=0;i<size;++i)
    {
      Int32 localId = localIds[i];
      ARCANE_ASSERT((localId < m_family.maxLocalId()),("Bad Abstract Family localId"));
      Integer igrp = ArcGeoSim::ArrayScan::dichotomicIntervalScan(localId, m_lower_bounds.size(), m_lower_bounds.unguardedBasePointer());
      ARCANE_ASSERT((igrp < m_family.groupSize()),("Invalid group index"));
      Arcane::ItemVectorView view = m_family.group(igrp).view();
      Arcane::Item item = view[localId - m_lower_bounds[igrp]];
      result[i] = _form_unique_id(igrp, item.uniqueId());
    }
  return result;
}

/*---------------------------------------------------------------------------*/

SafeConstArrayView<Int32>
AnyItemAbstractFamily::
allLocalIds() const 
{
  const Integer size = m_family.maxLocalId();
  SharedArray<Int32> local_ids(size);
  for(Integer i=0;i<size;++i)
    local_ids[i] = i;
  return local_ids;
}

/*---------------------------------------------------------------------------*/

END_ALIEN_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
