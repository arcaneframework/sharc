// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "ArcGeoSim/Utils/ArcGeoSim.h"
#include "NewtonSolver.h"
/* Author : desrozis at Thu May 19 11:08:08 2016
 * Generated by createNew
 */

#include <alien/expression/solver/SolverStat.h>
#include <alien/kernels/simple_csr/algebra/SimpleCSRLinearAlgebra.h>

//#include "ArcGeoSim/Numerics/Discretization/Schemes/TwoPointsStencil.h"

/*---------------------------------------------------------------------------*/

#include "ArcGeoSim/Physics/Law2/VariableAccessor.h"

ArcNum::NewtonSolver::
NewtonSolver()
  : Arcane::TraceAccessor(_arcaneGetDefaultSubDomain()->traceMng())
  , m_newton(*this, _arcaneGetDefaultSubDomain()->traceMng())
  , m_newton_iteration(Arcane::VariableBuildInfo(_arcaneGetDefaultSubDomain()->meshes()[0], "NewtonIteration", Arcane::IVariable::PNoDump|Arcane::IVariable::PNoNeedSync))
  , m_newton_iteration_max(Arcane::VariableBuildInfo(_arcaneGetDefaultSubDomain()->meshes()[0], "NewtonIterationMax", Arcane::IVariable::PNoDump|Arcane::IVariable::PNoNeedSync)) {}

/*---------------------------------------------------------------------------*/

void
ArcNum::NewtonSolver::
init(std::shared_ptr<ArcNum::INonLinearSystem> non_linear_system)
{
  m_non_linear_system = non_linear_system;

  if(m_non_linear_system.get() == nullptr) {
    fatal() << "Non linear system pointer null";
  }

  m_linear_solver->init();

  // TODO without geoxim algebra and formulation
  // Nothing to be done, we'll use class attributes directly if feature is still desired
  /*if(m_with_elimination)
    m_algebra.enableElimination();
    if(m_with_row_sum || m_with_row_sum_on_residual)
    m_algebra.enableRowSum();
    if(m_with_normalization)
    m_algebra.enableNormalization();

    const Geoxim::IFormulation& formulation = m_non_linear_system->formulation();

    m_algebra.define(formulation);*/

  _createAlgebraicObjects();

  m_newton.parameterize(m_iteration_max, m_relative_tolerance, m_tolerance);
  m_newton_iteration_max = m_iteration_max;
  m_newton_iteration = 0;


  m_initialized = true;
}

/*---------------------------------------------------------------------------*/



void
ArcNum::NewtonSolver::
_createAlgebraicObjects()
{
  // from geoxim algebra and formulation
  //const Law::PropertyVector& unknowns = m_non_linear_system->equationSystem();
  ArcNum::LinearSystem::MeshGroupBlock bc;
  bc.name = "My Linear System";
  //bc.nbEquations = unknowns.size();
  bc.nbEquations = m_non_linear_system->nbEquations() ;
  //auto & domain = m_non_linear_system->folder();
  auto & domain = m_non_linear_system->systemDomain();
  bc.group = domain.support();
  m_linear_system = ArcNum::LinearSystem(bc, m_with_elimination);
  m_linear_system.setNormalizeOpt(m_with_normalization) ;
  m_linear_system.setFirstRowSumOpt(m_with_first_row_sum) ;
  m_linear_system.setDiagScalingOpt(m_with_diag_scaling) ;
  Alien::BlockMatrix& matrix = m_linear_system.matrix();
  Alien::MatrixProfiler blockProfiler(matrix);
  auto indexes = m_linear_system.indexes();
  Arcane::Integer block_size = m_linear_system.rhs().block().size();

  m_non_linear_system->initLinearSystemProfile(domain.support(),
                                                blockProfiler,
                                                indexes,
                                                block_size) ;

  m_non_linear_system->setSolutionVariables(m_solution) ;

  m_block_residual_scaling = Alien::BlockVector(m_linear_system.rhs().block(), m_linear_system.rhs().distribution());
}

/*---------------------------------------------------------------------------*/

Arcane::Real
ArcNum::NewtonSolver::
newtonError()
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));
  Alien::SimpleCSRLinearAlgebra alg;
  return alg.norm2(m_linear_system.rhs());
}

/*---------------------------------------------------------------------------*/

void
ArcNum::NewtonSolver::
newtonUpdate(bool &NonPhysicalSolution)
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  // TODO If debug feature requested
  /*ArcGeoSim::OptionalAppService<Geoxim::Debug> debug;
    if(debug.isAvailable()) {
    // ATTENTION, tres couteux !!!
    const Geoxim::IFormulation& formulation = m_non_linear_system->formulation();
    const Geoxim::UnknownsManager& um = formulation.equationSystem().unknownsManager();
    Geoxim::VariableCellFolder delta_folder("Delta");
    delta_folder.disableVerbosity();
    // ATTENTION, PROBLEME AVEC AMR => allCells() a remplacer
    delta_folder.setSupport(allCells());
    ENUMERATE_UNKNOWNS(iunknown, um) {
    delta_folder.addVariable(iunknown->property());
    }
    Geoxim::VariableVector delta = m_algebra.newUnknownVector(delta_folder);
    delta.fill(0.);
    Geoxim::Axpy axpy = m_algebra.axpy();
    axpy(delta, m_linear_system);
    debug->printUnknownVariations(delta, um);
    }*/

  {
    // TODO with alien
    /*if(m_theta.isEnabled()) {
    // i.e. m_solution += theta * m_linear_system.alienSolution()
    // ou theta = f(m_linear_system.alienSolution(), thresold)
    axpy(m_solution, m_theta, m_linear_system);
    } else {
    // i.e. m_solution += m_linear_system.alienSolution()
    axpy(m_solution, m_linear_system);
    }*/
    this->_axpy(m_solution, m_linear_system);
  }


  {
    // Contrainte sur la solution
    m_non_linear_system->applyConstraintOnSolution(NonPhysicalSolution);
  }
}

/*---------------------------------------------------------------------------*/

// TODO Is this method "necessary" ? (XT)
void
ArcNum::NewtonSolver::
newtonAssemble()
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  // TODO If debug feature requested
  /*ArcGeoSim::OptionalAppService<Geoxim::Debug> debug;
    if(debug.isAvailable()) {
    debug->printLinearSystem(m_linear_system);
    }*/

}

/*---------------------------------------------------------------------------*/

bool
ArcNum::NewtonSolver::
newtonSolve()
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  return m_linear_system.solve(m_linear_solver);
}

/*---------------------------------------------------------------------------*/

void
ArcNum::NewtonSolver::
newtonLinearize()
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  // TODO If debug feature requested
  /*ArcGeoSim::OptionalAppService<Geoxim::Debug> debug;
    if(debug.isAvailable()) {
    Arcane::VariableScalarReal global_old_time(Arcane::VariableBuildInfo(subDomain(), "GlobalOldTime"));
    debug->file() << std::endl << std::endl
    << "##################################################################"  << std::endl
    << "############### DEBUG MODE :"
    << " NStep = " << m_nb_call
    << " Time = " << global_old_time()
    << " Iter = " << m_newton.lastIteration() << std::endl
    << "##################################################################"  << std::endl
    << std::endl << std::endl;
    }*/

  Alien::BlockMatrix& matrix = m_linear_system.matrix();
  Alien::BlockVector& rhs = m_linear_system.rhs();
  const Arcane::Integer localSize = rhs.distribution().localSize();
  const Arcane::Integer blockSize = rhs.block().size();
  {
    Alien::LocalBlockVectorWriter vw(rhs);
    for (Arcane::Integer i = 0; i < localSize; ++i)
    {
      ArrayView<Real> values = vw[i];
      for(Integer j=0; j < blockSize;++j)
        values[j] = 0.;
    }
  }

  ArcNum::Vector residual(rhs, m_linear_system.indexes());
  ArcNum::Matrix jacobian(matrix, m_linear_system.indexes());

  // Calcul des termes explicites
  if(m_newton.lastIteration() == 0) {
    m_non_linear_system->updateExplicitTerms();
  }

  {
    // Construction des residus R et de la jacobienne J
    m_non_linear_system->build(residual,jacobian);
  }

  {
    Alien::LocalBlockVectorWriter vw(rhs);
    for (Arcane::Integer i = 0; i < localSize; ++i)
    {
      ArrayView<Real> values = vw[i];
      for(Integer j=0; j < blockSize;++j)
        values[j] = -values[j];
    }
  }
}
    
/*---------------------------------------------------------------------------*/

void
ArcNum::NewtonSolver::
newtonBeforeSolve(Arcane::Integer iteration)
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  if(iteration == 1) {
    m_linear_solver->startNonLinear();
  }

  if(m_debug_dump_matlab) {
    info()<<"write files DebugNewton Vector and Matrix "<<m_nb_call<<"_"<<iteration<<".txt";
    std::ostringstream oss;
    oss << "DebugNewtonMatrix_" << m_nb_call << "_" << iteration << ".txt";
    std::string var = oss.str();
    m_linear_system.dumpMatrix(var);
    //m_linear_system.dumpMatrix(std::string::fo("DebugNewtonMatrix_{0}_{1}.txt",
	//					      m_nb_call, iteration));
    //m_linear_system.dumpRhs(Arcane::String::format("DebugNewtonVector_{0}_{1}.txt",
	//					   m_nb_call, iteration));
  }
}

/*---------------------------------------------------------------------------*/

void
ArcNum::NewtonSolver::
newtonAfterSolve(Arcane::Integer iteration)
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  // Get Linear Solver Status
  auto status = m_linear_solver->getStatus();

  // Print Linear Solver Infos
  if(m_debug_info_linear_solver)
  {
    info() << "Newton Iteration [" << std::setw(2) << iteration << "] "
	   << "* LinearSolver error = " << status.succeeded
	   << " " << std::setw(5) << status.iteration_count
	   << " " << std::setw(10) << status.residual;
  }

  if(m_debug_stat_linear_solver)
  {
    auto solver_stat = m_linear_solver->getSolverStat();
    solver_stat.print(traceMng(), status, "DebugInfo Linear Solver");
  }

  if(m_save_and_fatal_at_iteration == iteration)
  {
    std::ostringstream oss;
    oss << "DebugNewtonMatrix_{" << m_nb_call << "}_{" << iteration << "}.txt";
    std::string var = oss.str();
    m_linear_system.dumpMatrix(var);
    //m_linear_system.dumpMatrix(Arcane::String::format("Matrix{0}_{1}.txt",
	//					      m_nb_call, iteration));
    m_linear_system.dumpRhs(Arcane::String::format("Residual{0}_{1}.txt",
						   m_nb_call, iteration));
    m_linear_system.dumpSolution(Arcane::String::format("Delta{0}_{1}.txt",
							m_nb_call, iteration));
    fatal() << "User stop Newton at iteration " << iteration;
  }

  if(m_dump_and_fatal_at_iteration == iteration)
  {
    m_linear_system.dumpMatrix();
    m_linear_system.dumpRhs();
    m_linear_system.dumpSolution();
    fatal() << "User stop Newton at iteration " << iteration;
  }
}

/*---------------------------------------------------------------------------*/

bool
ArcNum::NewtonSolver::
solve()
{
  // pour marquer que l'on resout et pouvoir checker durant les callbacks
  m_is_solving = true;

  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  m_nb_call ++;

  bool r = m_newton.solve();


  // Mise a jour (pour politique de pas de temps)
  m_newton_iteration = m_newton.lastIteration();

  m_is_solving = false;

  return r;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
