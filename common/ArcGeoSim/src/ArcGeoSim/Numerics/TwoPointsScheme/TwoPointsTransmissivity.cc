// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "TwoPointsTransmissivity.h"
/* Author : desrozis at Wed Sep  4 10:21:36 2013
 * Generated by createNew
 */

//#include "Geoxim/Mesh/AdaptiveMeshControl/MeshAdapter.h"

#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"
#include "ArcGeoSim/Mesh/Geometry/ManualUpdateGeometryPolicy.h"
#include "ArcGeoSim/Appli/IAppServiceMng.h"

#include <arcane/utils/TraceAccessor.h>
#include <arcane/ISubDomain.h>

extern "C" Arcane::ISubDomain* _arcaneGetDefaultSubDomain();

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace ArcNum {

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

TwoPointsTransmissivity::Transmissivity::
Transmissivity(Arcane::IMesh* mesh, 
               eConvention& convention,
               Arcane::VariableFaceReal& transmissivity)
  : m_mesh(mesh)
  , m_current_convention(convention)
  , m_transmissivity(transmissivity) {}

/*---------------------------------------------------------------------------*/

const Arcane::VariableFaceReal& 
TwoPointsTransmissivity::Transmissivity::
operator[](eConvention convention)
{
  if(m_current_convention != convention) {
    m_current_convention = convention;
    _transform();
  }
  
  return m_transmissivity;
}

/*---------------------------------------------------------------------------*/

void
TwoPointsTransmissivity::Transmissivity::
_transform()
{
  ENUMERATE_FACE(iface, m_mesh->allFaces()) {
    if(iface->isSubDomainBoundary()) {
      m_transmissivity[iface] *= ( iface->boundaryCell() == iface->backCell() ) ? 1 : -1;
    }
  }
}
 
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

TwoPointsTransmissivity::
TwoPointsTransmissivity()
  : Arcane::TraceAccessor(_arcaneGetDefaultSubDomain()->traceMng())
  , m_verbose(false)
  , m_geometric_properties_computed(false)
  , m_mesh(_arcaneGetDefaultSubDomain()->defaultMesh())
  , m_current_convention(Classical)
{
  ARCANE_ASSERT((m_mesh),("IMesh pointer null"));
}

/*---------------------------------------------------------------------------*/

void 
TwoPointsTransmissivity::
enableVerboseMode()
{
  m_verbose = true;
}

/*---------------------------------------------------------------------------*/
  
void
TwoPointsTransmissivity::
disableVerboseMode()
{
  m_verbose = false;
}

/*---------------------------------------------------------------------------*/

void
TwoPointsTransmissivity::
addOperator(Arcane::String name, IDivKGradDiscreteOperator* discrete_operator)
{
  ARCANE_ASSERT((discrete_operator),("IDivKGradDiscreteOperator pointer null"));

  if(m_operators.find(name) != m_operators.end())
    fatal() << "Two-points transmissivity operator '" << name << "' already registered";
  
  discrete_operator->init();
  
  m_operators[name] = discrete_operator;
  
  m_geometric_properties_computed = false;
}

/*---------------------------------------------------------------------------*/

void
TwoPointsTransmissivity::
computeOperator(Arcane::String name, Arcane::VariableCellReal& diffusion)
{
  auto it = m_operators.find(name);

  if(it == m_operators.end())
    fatal() << "Two points operator '" << name << "' is not registered";
  
  _allocateVariable(it->first);
  
  _prepareOperator(it->first, it->second);
    
  _formOperator(it->first, it->second, *m_transmissivities[it->first], diffusion);

  m_diffusion_variable[name] = diffusion.variable();
  m_diffusion_type[name] = "Real";
}

/*---------------------------------------------------------------------------*/

void
TwoPointsTransmissivity::
computeOperator(Arcane::String name, Arcane::VariableCellReal3& diffusion)
{
  auto it = m_operators.find(name);

  if(it == m_operators.end())
    fatal() << "Two points operator '" << name << "' is not registered";

  _allocateVariable(it->first);

  _prepareOperator(it->first, it->second);

  _formOperator(it->first, it->second, *m_transmissivities[it->first], diffusion);

  m_diffusion_variable[name] = diffusion.variable();
  m_diffusion_type[name] = "Real3";
}

/*---------------------------------------------------------------------------*/

void
TwoPointsTransmissivity::
computeOperator(Arcane::String name, Arcane::VariableCellReal3x3& diffusion)
{
  auto it = m_operators.find(name);

  if(it == m_operators.end())
    fatal() << "Two points operator '" << name << "' is not registered";

  _allocateVariable(it->first);

  _prepareOperator(it->first, it->second);

  _formOperator(it->first, it->second, *m_transmissivities[it->first], diffusion);

  m_diffusion_variable[name] = diffusion.variable();
  m_diffusion_type[name] = "Real3x3";
}

/*---------------------------------------------------------------------------*/

void
TwoPointsTransmissivity::
_recompute()
{
  for(auto it : m_operators) {

    auto name = it.first;

    {
      auto coeffs = std::make_shared<CoefficientArrayT<Arcane::Cell>>(m_mesh->allFaces(),
          m_mesh->allCells());
      m_cell_coefficients[name] = coeffs;
    }

    {
      auto coeffs = std::make_shared<CoefficientArrayT<Arcane::Face>>(m_mesh->allFaces(),
          m_mesh->allCells().outerFaceGroup());
      m_face_coefficients[name] = coeffs;
    }

    auto* discrete_operator = it.second;

    discrete_operator->prepare(m_mesh,
        m_cell_coefficients[name].get(),
        m_face_coefficients[name].get());

    // Form Operator

    const Arcane::String diffusion_type = m_diffusion_type[name];

    if ( diffusion_type == "Real" )
    {
      Arcane::VariableCellReal diffusion(m_diffusion_variable[name]);
      _formOperator(name, discrete_operator, *m_transmissivities[name], diffusion);
    }

    else if (diffusion_type == "Real3" )
    {
      Arcane::VariableCellReal3 diffusion(m_diffusion_variable[name]);
      _formOperator(name, discrete_operator, *m_transmissivities[name], diffusion);
    }

    else if ( diffusion_type == "Real3x3" )
    {
      Arcane::VariableCellReal3x3 diffusion(m_diffusion_variable[name]);
      _formOperator(name, discrete_operator, *m_transmissivities[name], diffusion);
    }

    else
    {
      fatal() << "Unknown Diffusion Type = " << diffusion_type ;
    }

  }
}

/*---------------------------------------------------------------------------*/

TwoPointsTransmissivity::Transmissivity
TwoPointsTransmissivity::
operator[](Arcane::String name) const
{
  auto it = m_transmissivities.find(name);
  
  if(it == m_transmissivities.end())
    fatal() << "Transmissivity for '" << name << "' is not found";
  
  return Transmissivity(m_mesh,m_current_convention,*(it->second));
}

/*---------------------------------------------------------------------------*/

void
TwoPointsTransmissivity::
_allocateVariable(Arcane::String name)
{
  if(m_transmissivities.find(name) == m_transmissivities.end()) {
    Arcane::StringBuilder sb("Transmissivity_");
    sb += name;
    Arcane::VariableBuildInfo bi(m_mesh,sb.toString());
    m_transmissivities[name] = std::make_shared<Arcane::VariableFaceReal>(bi);
    if(m_verbose)
      info() << " Variable created : '" << m_transmissivities[name]->name() << "'";
  }
  
  if(m_transmissivities[name] == NULL)
    fatal() << "Transmissivity container of '" << name << "' is pointer null";
}

/*---------------------------------------------------------------------------*/

void
TwoPointsTransmissivity::
_prepareOperator(Arcane::String name, IDivKGradDiscreteOperator* discrete_operator)
{
  bool need_prepare = false;
  if(m_cell_coefficients.find(name) == m_cell_coefficients.end()) {
    auto coeffs = std::make_shared<CoefficientArrayT<Arcane::Cell>>(m_mesh->allFaces(),
                                                                    m_mesh->allCells());
    m_cell_coefficients[name] = coeffs;
    need_prepare = true;
  }
  if(m_face_coefficients.find(name) == m_face_coefficients.end()) {
    auto coeffs = std::make_shared<CoefficientArrayT<Arcane::Face>>(m_mesh->allFaces(),
                                                                    m_mesh->allCells().outerFaceGroup());
    m_face_coefficients[name] = coeffs;
    need_prepare = true;
  }
  
  if(need_prepare) 
    discrete_operator->prepare(m_mesh, 
                               m_cell_coefficients[name].get(),
                               m_face_coefficients[name].get());
}

/*---------------------------------------------------------------------------*/

void
TwoPointsTransmissivity::
_formOperator(Arcane::String name,
              IDivKGradDiscreteOperator* discrete_operator, 
              Arcane::VariableFaceReal& transmissivity,
              Arcane::VariableCellReal& diffusion)
{
  discrete_operator->formDiscreteOperator(diffusion);
	
  auto coefficients = m_cell_coefficients[name];
  
  ENUMERATE_FACE(iface, m_mesh->allFaces()) {
    const Arcane::Integer stencil_size = coefficients->stencilSize(*iface);
    if(iface->isSubDomainBoundary()) {
      if(stencil_size != 1) fatal() << "Only two points boundary scheme allowed";
    } else {
      if(stencil_size != 2) fatal() << "Only two points scheme allowed";
    }
    
    const Arcane::Real trans_face = coefficients->coefficients(*iface)[0];
    
    transmissivity[iface] = trans_face;
    
    if (m_verbose) {
			if(iface->isSubDomainBoundary())
        info() << name << " TransFaceKb [" <<  iface->uniqueId() << "]=" << trans_face; 
      else
        info() << name << " TransFaceKL [" <<  iface->uniqueId() << "]=" << trans_face;
    }
  }
}

/*---------------------------------------------------------------------------*/

void
TwoPointsTransmissivity::
_formOperator(Arcane::String name,
              IDivKGradDiscreteOperator* discrete_operator,
              Arcane::VariableFaceReal& transmissivity,
              Arcane::VariableCellReal3& diffusion)

{
  discrete_operator->formDiscreteOperator(diffusion);

  auto coefficients = m_cell_coefficients[name];

  ENUMERATE_FACE(iface, m_mesh->allFaces()) {
    const Arcane::Integer stencil_size = coefficients->stencilSize(*iface);
    if(iface->isSubDomainBoundary()) {
      if(stencil_size != 1) fatal() << "Only two points boundary scheme allowed";
    } else {
      if(stencil_size != 2) fatal() << "Only two points scheme allowed";
    }

    const Arcane::Real trans_face = coefficients->coefficients(*iface)[0];

    transmissivity[iface] = trans_face;

    if (m_verbose) {
            if(iface->isSubDomainBoundary())
        info() << name << " TransFaceKb [" <<  iface->uniqueId() << "]=" << trans_face;
      else
        info() << name << " TransFaceKL [" <<  iface->uniqueId() << "]=" << trans_face;
    }
  }
}

/*---------------------------------------------------------------------------*/

void
TwoPointsTransmissivity::
_formOperator(Arcane::String name,
              IDivKGradDiscreteOperator* discrete_operator,
              Arcane::VariableFaceReal& transmissivity,
              Arcane::VariableCellReal3x3& diffusion)

{
  discrete_operator->formDiscreteOperator(diffusion);

  auto coefficients = m_cell_coefficients[name];

  ENUMERATE_FACE(iface, m_mesh->allFaces()) {
    const Arcane::Integer stencil_size = coefficients->stencilSize(*iface);
    if(iface->isSubDomainBoundary()) {
      if(stencil_size != 1) fatal() << "Only two points boundary scheme allowed";
    } else {
      if(stencil_size != 2) fatal() << "Only two points scheme allowed";
    }

    const Arcane::Real trans_face = coefficients->coefficients(*iface)[0];

    transmissivity[iface] = trans_face;

    if (m_verbose) {
      if(iface->isSubDomainBoundary())
        info() << name << " TransFaceKb [" <<  iface->uniqueId() << "]=" << trans_face;
      else
        info() << name << " TransFaceKL [" <<  iface->uniqueId() << "]=" << trans_face;
    }
  }
}


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
