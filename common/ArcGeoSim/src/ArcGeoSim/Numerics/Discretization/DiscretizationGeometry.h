// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCANEDEMO_SCHEMEAPI2016_DISCRETIZATIONGEOMETRY_H
#define ARCANEDEMO_SCHEMEAPI2016_DISCRETIZATIONGEOMETRY_H
/* Author : encheryg at Thu Feb 18 18:55:21 2016
 * Generated by createNew
 */
#include <memory>
#include <type_traits>

#include <arcane/MeshVariable.h>

#include <ArcGeoSim/Appli/AppService.h>
#include <ArcGeoSim/Mesh/Geometry/IGeometryMng.h>
#include <ArcGeoSim/Mesh/SurfaceUtils/INotMatchingSurfaceMng.h>

#include "ArcGeoSim/Numerics/Discretization/DiscretizationConnectivity.h"

class DiscretizationGeometry
{
public:
  DiscretizationGeometry(DiscretizationConnectivity& dc, const bool simpleCorefinement = false, 
                         const Arcane::VariableCellReal* surfaceMeshThicknesses = nullptr,
                         bool useMassFaceCentersIfAvailable = true,
                         const Arcane::VariableCellReal* faultCoreThicknesses = nullptr) ;
  virtual ~DiscretizationGeometry() {}
  bool simpleCorefinement() const {return m_simpleCorefinement ;}
  DiscretizationConnectivity* discretizationConnectivity() const {return m_dc ;}
  void update() {_fillFaceVariables() ; _fillCellVariables() ;}

  static Arcane::Real hyperplaneDistance(const Real3& normal, const Real3& P0, const Real3& P1) {
    if(Arcane::math::isNearlyZero(normal.abs()))
      throw Arcane::FatalErrorException(A_FUNCINFO, "Normal equal to zero") ;
    else
      return math::scaMul(normal, P1 - P0) ;
  }

private:

  using SimpleCenterContactType = NotMatchingSurfaceProperty::Variable<NotMatchingSurfaceProperty::PSimpleCorefinementCenter>::type ;

  using SimpleNormalContactType = NotMatchingSurfaceProperty::Variable<NotMatchingSurfaceProperty::PSimpleCorefinementNormal>::type ;

  using SimpleAreaContactType = NotMatchingSurfaceProperty::Variable<NotMatchingSurfaceProperty::PSimpleCorefinementArea>::type ;

  using DoubleAreaContactType = NotMatchingSurfaceProperty::Variable<NotMatchingSurfaceProperty::PDoubleCorefinementArea>::type ;

  using DoubleNormalContactType = NotMatchingSurfaceProperty::Variable<NotMatchingSurfaceProperty::PDoubleCorefinementNormal>::type ;

  using DoubleCenterContactType = NotMatchingSurfaceProperty::Variable<NotMatchingSurfaceProperty::PDoubleCorefinementCenter>::type ;

  DiscretizationConnectivity* m_dc ;

  const bool m_simpleCorefinement ;

  std::unique_ptr<Arcane::VariableDoFReal> m_cellMeasures ;
  std::unique_ptr<Arcane::VariableDoFReal3> m_cellCenters ;

  std::unique_ptr<Arcane::VariableDoFArrayReal> m_faceMeasures ;
  std::unique_ptr<Arcane::VariableDoFArrayReal3> m_faceCenters ;
  std::unique_ptr<Arcane::VariableDoFArrayReal3> m_faceOrientedUnitNormals ;
  std::unique_ptr<Arcane::VariableDoFArrayBool> m_undefinedContactCenters ;

  void _fillFaceVariables() ;

  void _fillFaceVariablesForActiveFaces(IGeometryMng::Real3Variable domainCellCenters,
                                        IGeometryMng::Real3Variable domainFaceCenters,
                                        IGeometryMng::Real3Variable domainFaceNormals,
                                        IGeometryMng::RealVariable domainFaceMeasures) ;

  void _fillFaceVariablesForSimpleCorefinement(IGeometryMng::Real3Variable domainCellCenters,
                                                IGeometryMng::Real3Variable domainFaceCenters) ;

  void _fillFaceVariablesForDoubleCorefinement(IGeometryMng::Real3Variable domainCellCenters,
                                               IGeometryMng::Real3Variable domainFaceCenters) ;

  void _fillFaceVariablesForDoubleCorefinementWithSurfaceMesh(IGeometryMng::Real3Variable domainFaceCenters,
                                                              IGeometryMng::Real3Variable domainFaceNormals,
                                                              IGeometryMng::RealVariable domainFaceMeasures) ;

  void _fillFaceVariablesForSurfaceMeshFaces(const IGeometryMng::Real3Variable domainFaceNormals,
                                             const IGeometryMng::RealVariable domainFaceMeasures,
                                             const IGeometryMng::Real3Variable surfCellCenters,
                                             const IGeometryMng::Real3Variable surfCellNormals,
                                             const IGeometryMng::RealVariable surfCellMeasures,
                                             const IGeometryMng::RealVariable surfFaceMeasures,
                                             const Arcane::VariableNodeReal3 nodesCoords) ;

  void _fillCellVariables() ;

  void _check() ;

  template<typename T>
  friend class Centers ;

  template<typename T>
  friend class Measures ;

  template<typename T>
  friend class OrientedUnitNormals ;

private :
  const Arcane::VariableCellReal* m_surfaceMeshThicknesses ;
  bool m_withSurfaceMesh ;
  bool m_cellPropertiesComputed ;
  bool m_facePropertiesComputed ;
  bool m_useMassFaceCentersIfAvailable ;
  const Arcane::VariableCellReal* m_faultCoreThicknesses ;
  bool m_withFaultCore ;
};


template<typename T>
class Measures {} ;

template<typename T>
class Centers {} ;

template<typename T>
class OrientedUnitNormals {} ;

template<>
class Measures<Discretization::Cell> {

public:
  Measures(DiscretizationGeometry* g) : m_g(g) {
    if(not m_g -> m_cellPropertiesComputed)
      throw Arcane::FatalErrorException(A_FUNCINFO, "Cell properties not initialized") ;
  }

  Arcane::Real operator()(const Discretization::Cell cell) const {
    return (*m_g -> m_cellMeasures)[cell] ;
  }

  Arcane::Real operator()(const Discretization::CellEnumerator ce) const {
    return (*m_g -> m_cellMeasures)[ce] ;
  }

private:
  DiscretizationGeometry* m_g ;
} ;

template<>
class Centers<Discretization::Cell> {

public:
  Centers(DiscretizationGeometry* g) : m_g(g)
  , m_geometry(ArcGeoSim::AppService<IGeometryMng>())
  , m_cellCenters(m_geometry -> getReal3VariableProperty(m_g->discretizationConnectivity()->mesh() -> allCells(),IGeometryProperty::PCenter)){
    if(not m_g -> m_cellPropertiesComputed)
      throw Arcane::FatalErrorException(A_FUNCINFO, "Cell properties not initialized") ;
  }

  Arcane::Real3 operator()(const Discretization::Cell cell) const {
    return  (*m_g -> m_cellCenters)[cell] ;
  }

  Arcane::Real3 operator()(const Discretization::CellEnumerator ce) const {
    return (*m_g -> m_cellCenters)[ce] ;
  }

private:
  DiscretizationGeometry* m_g ;
  IGeometryMng* m_geometry ;
  const IGeometryMng::Real3Variable m_cellCenters ;
} ;

template<>
class Measures<Discretization::Face> {

public:
  Measures(DiscretizationGeometry* g) : m_g(g) {
    if(not m_g -> m_facePropertiesComputed)
      throw Arcane::FatalErrorException(A_FUNCINFO, "Face properties not initialized") ;
  }

  Arcane::Real operator()(const Discretization::Face face, 
                          Discretization::FaceCellInd ind = Discretization::FaceCellInd::Back) const {
    auto i = static_cast<std::underlying_type<Discretization::FaceCellInd>::type>(ind) ;
    return (*m_g->m_faceMeasures)[face][i] ;
  }

  Arcane::Real operator()(const Discretization::FaceEnumerator fe, 
                          Discretization::FaceCellInd ind = Discretization::FaceCellInd::Back) const {
    auto i = static_cast<std::underlying_type<Discretization::FaceCellInd>::type>(ind) ;
    return (*m_g->m_faceMeasures)[fe][i] ;
  }

private:
  DiscretizationGeometry* m_g ;
} ;

template<>
class Centers<Discretization::Face> {

public:
  Centers(DiscretizationGeometry* g) : m_g(g) {
    if(not m_g -> m_facePropertiesComputed)
      throw Arcane::FatalErrorException(A_FUNCINFO, "Face properties not initialized") ;
  }

  Arcane::Real3 operator()(const Discretization::Face face,
                           Discretization::FaceCellInd ind = Discretization::FaceCellInd::Back) const {
    auto i = static_cast<std::underlying_type<Discretization::FaceCellInd>::type>(ind) ;
    return (*m_g->m_faceCenters)[face][i] ;
  }

  Arcane::Real3 operator()(const Discretization::FaceEnumerator fe,
                           Discretization::FaceCellInd ind = Discretization::FaceCellInd::Back) const {
    auto i = static_cast<std::underlying_type<Discretization::FaceCellInd>::type>(ind) ;
    return (*m_g->m_faceCenters)[fe][i] ;
  }

  bool undefinedContactCenter(const Discretization::Face face,
                              Discretization::FaceCellInd ind = Discretization::FaceCellInd::Back) const {
    auto i = static_cast<std::underlying_type<Discretization::FaceCellInd>::type>(ind) ;
    return (*m_g->m_undefinedContactCenters)[face][i] ;
  }

  bool undefinedContactCenter(const Discretization::FaceEnumerator fe,
                              Discretization::FaceCellInd ind = Discretization::FaceCellInd::Back) const {
    auto i = static_cast<std::underlying_type<Discretization::FaceCellInd>::type>(ind) ;
    return (*m_g->m_undefinedContactCenters)[fe][i] ;
  }

private:
  DiscretizationGeometry* m_g ;
} ;

template<>
class OrientedUnitNormals<Discretization::Face> {

public:
  OrientedUnitNormals(DiscretizationGeometry* g) : m_g(g) {
    if(not m_g -> m_facePropertiesComputed)
      throw Arcane::FatalErrorException(A_FUNCINFO, "Face properties not initialized") ;
  }

  Arcane::Real3 operator()(const Discretization::Face face, 
                           Discretization::FaceCellInd ind = Discretization::FaceCellInd::Back) const {
    auto i = static_cast<std::underlying_type<Discretization::FaceCellInd>::type>(ind) ; 
    return (*m_g->m_faceOrientedUnitNormals)[face][i] ;
  }

  Arcane::Real3 operator()(const Discretization::FaceEnumerator fe, 
                           Discretization::FaceCellInd ind = Discretization::FaceCellInd::Back) const {
    auto i = static_cast<std::underlying_type<Discretization::FaceCellInd>::type>(ind) ; 
    return (*m_g->m_faceOrientedUnitNormals)[fe][i] ;
  }

private:
  DiscretizationGeometry* m_g ;
} ;

template<>
class Centers<Discretization::Node> {

public:
  Centers(DiscretizationGeometry* g) : m_g(g)
                                     , m_nodeCenters(m_g -> discretizationConnectivity() -> mesh() -> nodesCoordinates()){}

  Arcane::Real3 operator()(const Discretization::Node node) const {
    return m_nodeCenters[m_g->discretizationConnectivity()->node(node)] ;
  }

  Arcane::Real3 operator()(const Discretization::NodeEnumerator ne) const {
    return m_nodeCenters[m_g->discretizationConnectivity()->node(ne)] ;
  }

private:
  DiscretizationGeometry* m_g ;
  const Arcane::VariableNodeReal3 m_nodeCenters ;
} ;



#endif /* ARCANEDEMO_SCHEMEAPI2016_DISCRETIZATIONGEOMETRY_H */
