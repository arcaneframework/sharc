// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
/* Author : encheryg at Tue Jan  5 18:14:12 2016
 * Generated by createNew
 */
#include <arcane/ArcaneVersion.h>
#ifdef USE_ARCANE_V3
#include <arcane/mesh/DualUniqueIdMng.h>
#else
#include <arcane/utils/DualUniqueIdMng.h>
#endif
#if (ARCANE_VERSION >= 22200)
#include <arcane/mesh/GhostLayerFromConnectivityComputer.h>
#else
#include <arcane/dof/GhostLayerFromConnectivityComputer.h>
#endif

#include <ArcGeoSim/Appli/AppService.h>
#include <ArcGeoSim/Mesh/SurfaceUtils/INotMatchingSurfaceMng.h>
#include <ArcGeoSim/Utils/ItemGroupBuilder.h>

#include "DiscretizationConnectivity.h"

using namespace ArcGeoSim::Surface ;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
void DiscretizationConnectivity::_createContactFacesSet() {
  // Inits the contact faces set in all cases
  Arcane::FaceGroup emptyFaceGroup = m_mesh -> faceFamily() -> findGroup("ContactDiscretizationConnectivityEmptyGroup", true) ;
  m_contactFacesSet.init(emptyFaceGroup) ;

  if(m_matcher != nullptr) {
    FaceFaceContactFamily* contactFamily = m_matcher -> facefaceContactFamily() ;

    m_contactFacesSet.init(contactFamily -> allFaces()) ;
  }
}

/*---------------------------------------------------------------------------*/

void DiscretizationConnectivity::_filterArcaneCellsForDiscretization() {
  m_filteredCellGroup = m_mesh -> cellFamily() -> findGroup("ArcaneCellsForDiscretization", true) ;

  m_filteredCellGroup.clear() ;

  Arcane::IntegerUniqueArray lIds ;

  lIds.reserve(m_cellGroup.size()) ;

  m_ownCellNeighbourFlag.resize(mesh() -> cellFamily() -> maxLocalId()) ;
  m_ownCellNeighbourFlag.fill(m_useOnlyCellWithOwnNeighbour ? false : true) ;

  if(m_useOnlyCellWithOwnNeighbour) {
    ENUMERATE_FACE(iFace, mesh() -> allActiveFaces()) {
      const auto& face(*iFace) ;
      if(face.isSubDomainBoundary()) {
        const auto& boundaryCell(face.boundaryCell()) ;

        if(boundaryCell.isOwn()) {
          m_ownCellNeighbourFlag[boundaryCell.localId()] = true ;
        }
      } else {
        const auto& backCell(face.backCell()) ;
        const auto& frontCell(face.frontCell()) ;

        if(backCell.isOwn() or frontCell.isOwn()) {
          m_ownCellNeighbourFlag[backCell.localId()] = true ;
          m_ownCellNeighbourFlag[frontCell.localId()] = true ;
        }
      }
    }

    ENUMERATE_FACEFACECONTACT(iContact, m_matcher -> allFaceFaceContacts()) {
      const auto& contact(*iContact) ;
      const auto& face1(contact.face1()) ;
      const auto& face2(contact.face2()) ;

      if(!face1.null() && !face2.null()) {
        const auto& cell1(face1.boundaryCell()) ;
        const auto& cell2(face2.boundaryCell()) ;

        if(cell1.isOwn() or cell2.isOwn()) {
          m_ownCellNeighbourFlag[cell1.localId()] = true ;
          m_ownCellNeighbourFlag[cell2.localId()] = true ;
        }
      }
    }
  }

  ENUMERATE_CELL(iCell, m_cellGroup) {
    const auto& cell(*iCell) ;
    if(DiscretizationConnectivityUtils::AMRT<Arcane::Cell>::isActive(cell) &&
       m_ownCellNeighbourFlag[cell.localId()]) {
      lIds.add(cell.localId()) ;
    }
  }

  m_filteredCellGroup.addItems(lIds) ;

  m_isInCellGroup.fill(false) ;

  ENUMERATE_CELL(iCell, m_filteredCellGroup) {
    m_isInCellGroup[iCell] = true ;
  }

  if(surfaceMesh() != nullptr) {
    m_isInSurfaceCellGroup.reset(new Arcane::VariableCellBool(
        Arcane::VariableBuildInfo(m_surfaceMesh,
                                  "DiscretizationConnectivityIsInSurfaceCellGroup",
                                  m_surfaceMesh -> cellFamily() -> name(),
                                  Arcane::IVariable::PNoDump|Arcane::IVariable::PNoNeedSync))) ;
    m_isInSurfaceCellGroup -> fill(false) ;
    ENUMERATE_CELL(iCell, m_surfaceCellGroup) {
      (*m_isInSurfaceCellGroup)[iCell] = true ;
    }
  }
}

/*---------------------------------------------------------------------------*/
DiscretizationConnectivity::
DiscretizationConnectivity(Arcane::ITraceMng* traceMng, Arcane::IMesh* mesh, 
                           INotMatchingSurfaceMng* matcher,
                           Discretization::ItemKindPairList l,
                           const Arcane::CellGroup ce,
                           Arcane::String connectivityName,
                           const bool useOnlyCellWithOwnNeighbour,
                           Arcane::IMesh* surfaceMesh,
                           const Arcane::CellGroup surfaceGroup,
                           const Arcane::String surfaceFaceGroupName,
                           const bool addFaultCore)
  : m_useOnlyCellWithOwnNeighbour(useOnlyCellWithOwnNeighbour)
  , m_connectivityName(connectivityName)
  , m_mesh(mesh)
  , m_surfaceMesh(surfaceMesh)
  , m_matcher(matcher)
#if ARCANE_VERSION < 31307
  , m_connectivityMng(traceMng)
  , m_dofMng(mesh, &m_connectivityMng)
#else
  , m_dofMng(mesh)
#endif
#ifdef USE_ARCANE_V3
  , m_cellFamily(m_dofMng.getFamily("DiscretizationCellFamily"))
  , m_faceFamily(m_dofMng.getFamily("DiscretizationFaceFamily"))
  , m_nodeFamily(m_dofMng.getFamily("DiscretizationNodeFamily"))
#else
  , m_cellFamily(&m_dofMng.family("DiscretizationCellFamily"))
  , m_faceFamily(&m_dofMng.family("DiscretizationFaceFamily"))
  , m_nodeFamily(&m_dofMng.family("DiscretizationNodeFamily"))
#endif
  , m_cellEC(nullptr)
  , m_surfCellEC(nullptr)
  , m_faceEC(nullptr)
  , m_surfFaceEC(nullptr)
  , m_nodeEC(nullptr)
  , m_contactEC(nullptr)
  , m_faultCoreContactEC(nullptr)
  , m_cellREC(nullptr)
  , m_surfCellREC(nullptr)
  , m_faceREC(nullptr)
  , m_surfFaceREC(nullptr)
  , m_nodeREC(nullptr)
  , m_surfNodeREC(nullptr)
  , m_faceCellsEMC(nullptr)
  , m_cellFacesEMC(nullptr)
  , m_nodeCellsEMC(nullptr)
  , m_nodeFacesEMC(nullptr)
#if (ARCANE_VERSION >= 20305)
  ,m_face_cells_connectivity_vector(nullptr)
  ,m_cell_faces_connectivity_vector(nullptr)
  ,m_node_cells_connectivity_vector(nullptr)
  ,m_node_faces_connectivity_vector(nullptr)
  ,m_face_nodes_connectivity_vector(nullptr)
#endif
  , m_cellGroup(ce)
  , m_surfaceCellGroup(surfaceGroup)
  , m_surfaceFaceGroupName(surfaceFaceGroupName)
  , m_isInCellGroup(Arcane::VariableBuildInfo(mesh, "DiscretizationConnectivityIsInCellGroup"))
  , m_isInSurfaceCellGroup(nullptr)
  , m_isInFaceGroup(Arcane::VariableBuildInfo(mesh, "DiscretizationConnectivityIsInFaceGroup"))
  , m_isInSurfaceFaceGroup(nullptr)
  , m_isInNodeGroup(Arcane::VariableBuildInfo(mesh, "DiscretizationConnectivityIsInNodeGroup"))
  , m_isCellGroupBoundary(nullptr)
  , m_isSubDomainBoundary(nullptr)
  , m_isContact(nullptr)
  , m_isFaultCoreContact(nullptr)
  , m_isDisSurfCell(nullptr)
  , m_isDisSurfFace(nullptr)
  , m_addFaultCore((m_surfaceMesh != nullptr) && addFaultCore)
{
  _createContactFacesSet() ;

  _filterArcaneCellsForDiscretization() ;

  _createFaceToSurfCellLIdAndReverseMaps() ;

  _createItemGroupsOfCellGroup() ;

  _createNonCellGroupFlags() ;

  for(Discretization::ItemKindPair ip : l) {
      m_iks.insert(ip.first) ;
      m_iks.insert(ip.second) ;
  }

  if(m_iks.find(Discretization::ItemKind::Cell) != m_iks.end()) {
      _initArcaneDiscretizationConnectivityT(m_mesh -> cellFamily(),
                                             m_cellFamily,
                                             "DiscretizationCellConnectivity",
                                             m_cellEC,
                                             m_cellREC) ;

      DiscretizationConnectivityUtils::ItemSelectFunctorT<Discretization::Cell, false> select(*m_cellEC, m_filteredCellGroup) ;

      _createDiscretizationGroupsT<Discretization::Cell>(m_cellFamily, select, {{&m_allDisCells,"AllDiscretizationCells"}}) ;

      if(m_surfaceMesh != nullptr) {
        _initArcaneDiscretizationConnectivityT(m_surfaceMesh -> cellFamily(), m_cellFamily,
                                               "DiscretizationSurfaceCellConnectivity", m_surfCellEC, m_surfCellREC) ;

        DiscretizationConnectivityUtils::ItemSelectFunctorT<Discretization::Cell, false> select(*m_surfCellEC, m_surfaceCellGroup.activeCellGroup()) ;

        _createDiscretizationGroupsT<Discretization::Cell>(m_cellFamily, select, {{&m_allDisCells,"AllDiscretizationCells"}}, false) ;
      }

      if(m_addFaultCore) {
        _createContactDiscretizationConnectivity(m_cellFamily, m_faultCoreContactEC) ;

        DiscretizationConnectivityUtils::ItemSelectFunctorT<Discretization::Cell, true> select(m_faultCoreContactEC.get(), 
                                                                                               contactGroup(),
                                                                                               *m_cellEC,
                                                                                               m_filteredCellGroup,
                                                                                               *m_surfCellEC,
                                                                                               m_surfaceCellGroup.activeCellGroup()) ;

        _createDiscretizationGroupsT<Discretization::Cell>(m_cellFamily, select, {{&m_allDisCells,"AllDiscretizationCells"}}, false) ;

        _createDiscretizationGroupsT<Discretization::Cell>(m_cellFamily, select,
              {{&m_faultCoreDisCells,"FaultCoreDiscretizationCells"}, {&m_nonFaultCoreDisCells,"NonFaultCoreDiscretizationCells"}}, true) ;
      } else {
        m_nonFaultCoreDisCells = m_allDisCells ;
      }

      _setFlagOnDiscretizationItemsT<Contact, true>(m_cellFamily, m_faultCoreContactEC, contactGroup(),
                                                    "DiscretizationConnectivityIsFaultCoreContact", m_isFaultCoreContact) ;


      _setFlagOnDiscretizationItemsT<Arcane::Cell>(m_cellFamily, m_surfCellEC, m_surfaceCellGroup.activeCellGroup(), 
                                                   "DiscretizationConnectivityIsDisSurfCell", m_isDisSurfCell) ;
  }

  if(m_iks.find(Discretization::ItemKind::Face) != m_iks.end()) {
      _initArcaneDiscretizationConnectivityT(m_mesh -> faceFamily(),
                                             m_faceFamily,
                                             "DiscretizationFaceConnectivity",
                                             m_faceEC,
                                             m_faceREC) ;

      _createContactDiscretizationConnectivity(m_faceFamily, m_contactEC, m_addFaultCore) ;

      if(m_surfaceMesh != nullptr) {
        _initArcaneSurfaceFaceDiscretizationConnectivity() ;

        Arcane::UniqueArray<Arcane::FaceGroup> faceGroups ;
        faceGroups.add(m_faceGroup) ;
        faceGroups.add(m_facesOfSurfaceCellGroup) ;
        Arcane::UniqueArray<Arcane::VariableCellBool> cellGroupFlags ;
        cellGroupFlags.add(m_isInCellGroup),
        cellGroupFlags.add(*m_isInSurfaceCellGroup) ;
        DiscretizationConnectivityUtils::ItemSelectFunctorT<Discretization::Face, true> select(*m_faceEC, *m_surfFaceEC,
                                                                                               faceGroups,
                                                                                               cellGroupFlags,
                                                                                               m_contactFacesSet,
                                                                                               contactGroup(),
                                                                                               m_contactEC.get(),
                                                                                               m_surfaceMesh,
                                                                                               m_faceToSurfCellLIdMap) ;

        _createDiscretizationGroupsT<Discretization::Face>(m_faceFamily, select, {{&m_allDisFaces, "AllDiscretizationFaces"},
              {&m_innerDisFaces, "InnerDiscretizationFaces"}, {&m_outerDisFaces, "OuterDiscretizationFaces"}}) ;

      } else {
        DiscretizationConnectivityUtils::ItemSelectFunctorT<Discretization::Face, false> select(*m_faceEC,
                                                                                                m_faceGroup,
                                                                                                m_isInCellGroup,
                                                                                                m_contactFacesSet,
                                                                                                contactGroup(),
                                                                                                m_contactEC.get()) ;

        _createDiscretizationGroupsT<Discretization::Face>(m_faceFamily, select, {{&m_allDisFaces, "AllDiscretizationFaces"},
              {&m_innerDisFaces, "InnerDiscretizationFaces"}, {&m_outerDisFaces, "OuterDiscretizationFaces"}}) ;
      }

      _setFlagOnMultiConnectedDiscretizationItemsT<Arcane::Face>(m_faceFamily, m_surfFaceEC, m_facesOfSurfaceCellGroup,
                                                                 "DiscretizationConnectivityIsDisSurfFace" , m_isDisSurfFace) ;

      if(m_addFaultCore)
        _setFlagOnMultiConnectedDiscretizationContactFaces("DiscretizationConnectivityIsContact", m_isContact) ;
      else
        _setFlagOnDiscretizationItemsT<Contact>(m_faceFamily, m_contactEC, contactGroup(),
                                                "DiscretizationConnectivityIsContact" , m_isContact) ;

      _setFlagOnMultiConnectedDiscretizationItemsT<Arcane::Face>(m_faceFamily, m_surfFaceEC, m_facesWithDuplicatedDisFaceGroup, 
                                                                 "DiscretizationConnectivityIsDuplicatedDisSurfFace", m_isDuplicatedDisSurfFace) ;

      _createBoundaryFlags() ;
  }

  if(m_iks.find(Discretization::ItemKind::Node) != m_iks.end()) {
      _initArcaneDiscretizationConnectivityT(m_mesh -> nodeFamily(),
          m_nodeFamily,
          "DiscretizationNodeConnectivity",
          m_nodeEC,
          m_nodeREC) ;

      DiscretizationConnectivityUtils::ItemSelectFunctorT<Discretization::Node, false> select(*m_nodeEC,
          m_filteredCellGroup.nodeGroup(),
          m_isInCellGroup) ;

      _createDiscretizationGroupsT<Discretization::Node>(m_nodeFamily, select, {{&m_allDisNodes, "AllDiscretizationNodes"},
            {&m_innerDisNodes, "InnerDiscretizationNodes"}, 
              {&m_outerDisNodes, "OuterDiscretizationNodes"}}) ;
  }      

  for(Discretization::ItemKindPair ip : l) {
      if(ip.first == Discretization::ItemKind::Face && ip.second == Discretization::ItemKind::Cell) {

        if(m_surfaceMesh != nullptr) {
          DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Face, Discretization::Cell, true> mct(*m_faceEC,
                                                                                                                              *m_surfFaceEC,
                                                                                                                              *m_cellEC,
                                                                                                                              *m_surfCellEC,
                                                                                                                              m_faultCoreContactEC.get(),
                                                                                                                              m_faceGroup,
                                                                                                                              m_facesOfSurfaceCellGroup,
                                                                                                                              m_surfaceCellGroup,
                                                                                                                              m_isInCellGroup,
                                                                                                                              *m_isInSurfaceCellGroup,
                                                                                                                              contactGroup(),
                                                                                                                              m_contactEC,
                                                                                                                              m_surfaceMesh,
                                                                                                                              m_faceToSurfCellLIdMap) ;

          _createDiscretizationMultiConnectivityT(mct, "DiscretizationFaceCellConnectivity", m_faceCellsEMC) ;
         } else {
           DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Face, Discretization::Cell, false> mct(*m_faceEC,
                                                                                                                                *m_cellEC,
                                                                                                                                m_faceGroup,
                                                                                                                                m_isInCellGroup,
                                                                                                                                contactGroup(),
                                                                                                                                m_contactEC) ;

          _createDiscretizationMultiConnectivityT(mct, "DiscretizationFaceCellConnectivity", m_faceCellsEMC) ;
         }
       } else if(ip.first == Discretization::ItemKind::Cell && ip.second == Discretization::ItemKind::Face) {
         if(m_surfaceMesh != nullptr) {
           DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Cell, Discretization::Face, true> mct(*m_cellEC,
                                                                                                                               *m_surfCellEC,
                                                                                                                               *m_faceEC,
                                                                                                                               *m_surfFaceEC,
                                                                                                                               m_faultCoreContactEC.get(),
                                                                                                                               m_faceGroup,
                                                                                                                               m_facesOfSurfaceCellGroup,
                                                                                                                               m_surfaceCellGroup,
                                                                                                                               m_isInCellGroup,
                                                                                                                               *m_isInSurfaceCellGroup,
                                                                                                                               contactGroup(),
                                                                                                                               m_contactEC,
                                                                                                                               m_surfaceMesh,
                                                                                                                               m_faceToSurfCellLIdMap) ;

           _createDiscretizationMultiConnectivityT(mct, "DiscretizationCellFaceConnectivity", m_cellFacesEMC) ;
          
        } else {
          DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Cell, Discretization::Face, false> mct(*m_cellEC,
                                                                                                                               *m_faceEC,
                                                                                                                               m_faceGroup,
                                                                                                                               m_isInCellGroup,
                                                                                                                               contactGroup(),
                                                                                                                               m_contactEC) ;
          _createDiscretizationMultiConnectivityT(mct, "DiscretizationCellFaceConnectivity", m_cellFacesEMC) ;
        }
      } else if(ip.first == Discretization::ItemKind::Node && ip.second == Discretization::ItemKind::Cell) {
        DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Node, Discretization::Cell, false> mct(m_mesh -> nodeFamily() -> maxLocalId(),
                                                                                                                             m_mesh -> cellFamily() -> maxLocalId(),
                                                                                                                             *m_nodeEC,
                                                                                                                             *m_cellEC, 
                                                                                                                             m_nodesOfCellGroup,
                                                                                                                             m_isInCellGroup) ;
        _createDiscretizationMultiConnectivityT(mct, "DiscretizationNodeCellConnectivity", m_nodeCellsEMC) ;

      } else if(ip.first == Discretization::ItemKind::Cell && ip.second == Discretization::ItemKind::Node) {
        DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Cell, Discretization::Node, false> mct(*m_cellEC,
                                                                                                                             *m_nodeEC,
                                                                                                                             m_filteredCellGroup);

        _createDiscretizationMultiConnectivityT(mct, "DiscretizationCellNodeConnectivity", m_cellNodesEMC) ;
        
      } else if(ip.first == Discretization::ItemKind::Node && ip.second == Discretization::ItemKind::Face) {
        DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Node, Discretization::Face, false> mct(*m_nodeEC,
                                                                                                                             *m_faceEC,
                                                                                                                             m_nodesOfCellGroup,
                                                                                                                             m_isInCellGroup,
                                                                                                                             m_contactFacesSet,
                                                                                                                             m_ownCellNeighbourFlag) ;

        _createDiscretizationMultiConnectivityT(mct, "DiscretizationNodeFaceConnectivity", m_nodeFacesEMC) ;

      } else if(ip.first == Discretization::ItemKind::Face && ip.second == Discretization::ItemKind::Node) {
        DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Face, Discretization::Node, false> mct(*m_faceEC,
                                                                                                                             *m_nodeEC,
                                                                                                                             m_faceGroup) ;

        _createDiscretizationMultiConnectivityT(mct, "DiscretizationFaceNodeConnectivity", m_faceNodesEMC) ;
      }
  }
#if (ARCANE_VERSION >= 20305)
if (m_faceCellsEMC.get() != nullptr) m_face_cells_connectivity_vector = ConnectivityVectorPtr(new Arcane::ConnectivityItemVector(m_faceCellsEMC.get()));
if (m_cellFacesEMC.get() != nullptr) m_cell_faces_connectivity_vector = ConnectivityVectorPtr(new Arcane::ConnectivityItemVector(m_cellFacesEMC.get()));
if (m_nodeCellsEMC.get() != nullptr) m_node_cells_connectivity_vector = ConnectivityVectorPtr(new Arcane::ConnectivityItemVector(m_nodeCellsEMC.get()));
if (m_cellNodesEMC.get() != nullptr) m_cell_nodes_connectivity_vector = ConnectivityVectorPtr(new Arcane::ConnectivityItemVector(m_cellNodesEMC.get()));
if (m_nodeFacesEMC.get() != nullptr) m_node_faces_connectivity_vector = ConnectivityVectorPtr(new Arcane::ConnectivityItemVector(m_nodeFacesEMC.get()));
if (m_faceNodesEMC.get() != nullptr) m_face_nodes_connectivity_vector = ConnectivityVectorPtr(new Arcane::ConnectivityItemVector(m_faceNodesEMC.get()));
#endif

  _check() ;
}

/*---------------------------------------------------------------------------*/
DiscretizationConnectivity::
DiscretizationConnectivity(ITraceMng* traceMng, IMesh* mesh, 
                           INotMatchingSurfaceMng* matcher,
                           Discretization::ItemKindPairList l,
                           Arcane::String connectivityName,
                           const bool useOnlyCellWithOwnNeighbour,
                           Arcane::IMesh* surfaceMesh,
                           const Arcane::CellGroup surfaceGroup,
                           const Arcane::String surfaceFaceGroupName,
                           const bool addFaultCore)
  : DiscretizationConnectivity(traceMng,  mesh, matcher, l, mesh -> allActiveCells(), connectivityName,
                               useOnlyCellWithOwnNeighbour, surfaceMesh, surfaceGroup, surfaceFaceGroupName,
                               addFaultCore) {}

/*---------------------------------------------------------------------------*/
void
DiscretizationConnectivity::
update() {
  _createContactFacesSet() ;

  _filterArcaneCellsForDiscretization() ;

  _createFaceToSurfCellLIdAndReverseMaps() ;
  
  _createItemGroupsOfCellGroup() ;

  _createNonCellGroupFlags() ;

  if(m_cellEC.get() != nullptr) {
      _updateArcaneDiscretizationConnectivityT(m_mesh -> cellFamily(),
                                               m_cellFamily,
                                               m_cellEC,
                                               m_cellREC) ;

      DiscretizationConnectivityUtils::ItemSelectFunctorT<Discretization::Cell, false> select(*m_cellEC, m_filteredCellGroup) ;
      _createDiscretizationGroupsT<Discretization::Cell>(m_cellFamily, select, {{&m_allDisCells,"AllDiscretizationCells"}}) ;

      if(m_surfaceMesh != nullptr) {
        _updateArcaneDiscretizationConnectivityT(m_surfaceMesh -> cellFamily(), m_cellFamily, m_surfCellEC, m_surfCellREC) ;
        
        DiscretizationConnectivityUtils::ItemSelectFunctorT<Discretization::Cell, false> select(*m_surfCellEC, m_surfaceCellGroup.activeCellGroup()) ;

        _createDiscretizationGroupsT<Discretization::Cell>(m_cellFamily, select, {{&m_allDisCells,"AllDiscretizationCells"}}, false) ;
      }

      if(m_addFaultCore) {
        _createContactDiscretizationConnectivity(m_cellFamily, m_faultCoreContactEC) ;

        DiscretizationConnectivityUtils::ItemSelectFunctorT<Discretization::Cell, true> select(m_faultCoreContactEC.get(),
            contactGroup(),
            *m_cellEC,
            m_filteredCellGroup,
            *m_surfCellEC,
            m_surfaceCellGroup.activeCellGroup()) ;

        _createDiscretizationGroupsT<Discretization::Cell>(m_cellFamily, select, {{&m_allDisCells,"AllDiscretizationCells"}}, false) ;

        _createDiscretizationGroupsT<Discretization::Cell>(m_cellFamily, select,
            {{&m_faultCoreDisCells,"FaultCoreDiscretizationCells"}, {&m_nonFaultCoreDisCells,"NonFaultCoreDiscretizationCells"}}, true) ;
      } else {
        m_nonFaultCoreDisCells = m_allDisCells ;
      }

      _setFlagOnDiscretizationItemsT<Contact, true>(m_cellFamily, m_faultCoreContactEC, contactGroup(),
          "DiscretizationConnectivityIsFaultCoreContact", m_isFaultCoreContact) ;

      _setFlagOnDiscretizationItemsT<Arcane::Cell>(m_cellFamily, m_surfCellEC, m_surfaceCellGroup.activeCellGroup(), 
                                                   "DiscretizationConnectivityIsDisSurfCell", m_isDisSurfCell) ;

  }

  if(m_faceEC.get() != nullptr) {
      _updateArcaneDiscretizationConnectivityT(m_mesh -> faceFamily(),
                                               m_faceFamily,
                                               m_faceEC,
                                               m_faceREC) ;

      _createContactDiscretizationConnectivity(m_faceFamily, m_contactEC, m_addFaultCore) ;

      if(m_surfaceMesh != nullptr) {
        _updateSurfaceFaceDiscretizationConnectivity() ;

        Arcane::UniqueArray<Arcane::FaceGroup> faceGroups ;
        faceGroups.add(m_faceGroup) ;
        faceGroups.add(m_facesOfSurfaceCellGroup) ;
        Arcane::UniqueArray<Arcane::VariableCellBool> cellGroupFlags ;
        cellGroupFlags.add(m_isInCellGroup),
        cellGroupFlags.add(*m_isInSurfaceCellGroup) ;
        DiscretizationConnectivityUtils::ItemSelectFunctorT<Discretization::Face, true> select(*m_faceEC, *m_surfFaceEC,
                                                                                               faceGroups,
                                                                                               cellGroupFlags,
                                                                                               m_contactFacesSet,
                                                                                               contactGroup(),
                                                                                               m_contactEC.get(),
                                                                                               m_surfaceMesh,
                                                                                               m_faceToSurfCellLIdMap) ;

        _createDiscretizationGroupsT<Discretization::Face>(m_faceFamily, select, {{&m_allDisFaces, "AllDiscretizationFaces"},
              {&m_innerDisFaces, "InnerDiscretizationFaces"}, {&m_outerDisFaces, "OuterDiscretizationFaces"}}) ;
      } else {
        DiscretizationConnectivityUtils::ItemSelectFunctorT<Discretization::Face, false> select(*m_faceEC,
                                                                                                m_faceGroup,
                                                                                                m_isInCellGroup,
                                                                                                m_contactFacesSet,
                                                                                                contactGroup(),
                                                                                                m_contactEC.get()) ;

        _createDiscretizationGroupsT<Discretization::Face>(m_faceFamily, select, {{&m_allDisFaces, "AllDiscretizationFaces"},
              {&m_innerDisFaces, "InnerDiscretizationFaces"}, {&m_outerDisFaces, "OuterDiscretizationFaces"}}) ;
      }

      _setFlagOnMultiConnectedDiscretizationItemsT<Arcane::Face>(m_faceFamily, m_surfFaceEC, m_facesOfSurfaceCellGroup,
                                                                 "DiscretizationConnectivityIsDisSurfFace" , m_isDisSurfFace) ;

      if(m_addFaultCore)
        _setFlagOnMultiConnectedDiscretizationContactFaces("DiscretizationConnectivityIsContact" , m_isContact) ;
      else
        _setFlagOnDiscretizationItemsT<Contact>(m_faceFamily, m_contactEC, contactGroup(),
                                              "DiscretizationConnectivityIsContact" , m_isContact) ;

      _setFlagOnMultiConnectedDiscretizationItemsT<Arcane::Face>(m_faceFamily, m_surfFaceEC, m_facesWithDuplicatedDisFaceGroup, 
                                                                 "DiscretizationConnectivityIsDuplicatedDisSurfFace" , m_isDuplicatedDisSurfFace) ;
            
      _createBoundaryFlags() ;
  }

  if(m_nodeEC.get() != nullptr) {
      _updateArcaneDiscretizationConnectivityT(m_mesh -> nodeFamily(),
          m_nodeFamily,
          m_nodeEC,
          m_nodeREC) ;

      DiscretizationConnectivityUtils::ItemSelectFunctorT<Discretization::Node, false> select(*m_nodeEC,
          m_filteredCellGroup.nodeGroup(),
          m_isInCellGroup) ;

      _createDiscretizationGroupsT<Discretization::Node>(m_nodeFamily, select, {{&m_allDisNodes, "AllDiscretizationNodes"},
                                                                                {&m_innerDisNodes, "InnerDiscretizationNodes"}, 
                                                                                  {&m_outerDisNodes, "OuterDiscretizationNodes"}}) ;
  }   

  if(m_faceCellsEMC.get() != nullptr) {
    if(m_surfaceMesh != nullptr) {
      DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Face, Discretization::Cell, true> mct(*m_faceEC,
                                                                                                                          *m_surfFaceEC,
                                                                                                                          *m_cellEC,
                                                                                                                          *m_surfCellEC,
                                                                                                                          m_faultCoreContactEC.get(),
                                                                                                                          m_faceGroup,
                                                                                                                          m_facesOfSurfaceCellGroup,
                                                                                                                          m_surfaceCellGroup,
                                                                                                                          m_isInCellGroup,
                                                                                                                          *m_isInSurfaceCellGroup,
                                                                                                                          contactGroup(),
                                                                                                                          m_contactEC,
                                                                                                                          m_surfaceMesh,
                                                                                                                          m_faceToSurfCellLIdMap) ;

      _createDiscretizationMultiConnectivityT(mct, "DiscretizationFaceCellConnectivity", m_faceCellsEMC) ;
    } else {
      DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Face, Discretization::Cell, false> mct(*m_faceEC,
                                                                                                                           *m_cellEC,
                                                                                                                           m_faceGroup,
                                                                                                                           m_isInCellGroup,
                                                                                                                           contactGroup(),
                                                                                                                           m_contactEC) ;
      _createDiscretizationMultiConnectivityT(mct, "DiscretizationFaceCellConnectivity", m_faceCellsEMC) ;
    }
  }

  if(m_cellFacesEMC.get() != nullptr) {
    if(m_surfaceMesh != nullptr) {
      DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Cell, Discretization::Face, true> mct(*m_cellEC,
                                                                                                                          *m_surfCellEC,
                                                                                                                          *m_faceEC,
                                                                                                                          *m_surfFaceEC,
                                                                                                                          m_faultCoreContactEC.get(),
                                                                                                                          m_faceGroup,
                                                                                                                          m_facesOfSurfaceCellGroup,
                                                                                                                          m_surfaceCellGroup,
                                                                                                                          m_isInCellGroup,
                                                                                                                          *m_isInSurfaceCellGroup,
                                                                                                                          contactGroup(),
                                                                                                                          m_contactEC,
                                                                                                                          m_surfaceMesh,
                                                                                                                          m_faceToSurfCellLIdMap) ;

      _createDiscretizationMultiConnectivityT(mct, "DiscretizationCellFaceConnectivity", m_cellFacesEMC) ;
          
    } else {
      DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Cell, Discretization::Face, false> mct(*m_cellEC,
                                                                                                                           *m_faceEC,
                                                                                                                           m_faceGroup,
                                                                                                                           m_isInCellGroup,
                                                                                                                           contactGroup(),
                                                                                                                           m_contactEC) ;

      _createDiscretizationMultiConnectivityT(mct, "DiscretizationCellFaceConnectivity", m_cellFacesEMC) ;
    }    
  }

  if(m_nodeCellsEMC.get() != nullptr) {
    DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Node, Discretization::Cell, false> mct(m_mesh -> nodeFamily() -> maxLocalId(), 
                                                                                                                         m_mesh -> cellFamily() -> maxLocalId(),
                                                                                                                         *m_nodeEC,
                                                                                                                         *m_cellEC, 
                                                                                                                         m_nodesOfCellGroup,
                                                                                                                         m_isInCellGroup) ;
    _createDiscretizationMultiConnectivityT(mct, "DiscretizationNodeCellConnectivity", m_nodeCellsEMC) ;
  }

  if(m_cellNodesEMC.get() != nullptr) {
    DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Cell, Discretization::Node, false> mct(*m_cellEC,
                                                                                                                         *m_nodeEC,
                                                                                                                         m_filteredCellGroup) ;

    _createDiscretizationMultiConnectivityT(mct, "DiscretizationCellNodeConnectivity", m_cellNodesEMC) ;
  }

  if(m_nodeFacesEMC.get() != nullptr) {
    DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Node, Discretization::Face, false> mct(*m_nodeEC,
                                                                                                                         *m_faceEC,
                                                                                                                         m_nodesOfCellGroup,
                                                                                                                         m_isInCellGroup,
                                                                                                                         m_contactFacesSet,
                                                                                                                         m_ownCellNeighbourFlag) ;
    _createDiscretizationMultiConnectivityT(mct, "DiscretizationNodeFaceConnectivity", m_nodeFacesEMC) ;
  }

  if(m_faceNodesEMC.get() != nullptr) {
    DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<Discretization::Face, Discretization::Node, false> mct(*m_faceEC,
                                                                                                                         *m_nodeEC,
                                                                                                                         m_faceGroup) ;

    _createDiscretizationMultiConnectivityT(mct, "DiscretizationFaceNodeConnectivity", m_faceNodesEMC) ;
  }
#if (ARCANE_VERSION >= 20305)
  // Done to handle new connectivities object: no longer needed ? connectivity not re-created...// SDC
  if (m_faceCellsEMC.get() != nullptr) m_face_cells_connectivity_vector.reset(new Arcane::ConnectivityItemVector(m_faceCellsEMC.get()));
  if (m_cellFacesEMC.get() != nullptr) m_cell_faces_connectivity_vector.reset(new Arcane::ConnectivityItemVector(m_cellFacesEMC.get()));
  if (m_nodeCellsEMC.get() != nullptr) m_node_cells_connectivity_vector.reset(new Arcane::ConnectivityItemVector(m_nodeCellsEMC.get()));
  if (m_cellNodesEMC.get() != nullptr) m_cell_nodes_connectivity_vector.reset(new Arcane::ConnectivityItemVector(m_cellNodesEMC.get()));
  if (m_nodeFacesEMC.get() != nullptr) m_node_faces_connectivity_vector.reset(new Arcane::ConnectivityItemVector(m_nodeFacesEMC.get()));
  if (m_faceNodesEMC.get() != nullptr) m_face_nodes_connectivity_vector.reset(new Arcane::ConnectivityItemVector(m_faceNodesEMC.get()));
#endif
  _check() ;
}

/*---------------------------------------------------------------------------*/
template<typename T>
void 
DiscretizationConnectivity::
_initArcaneDiscretizationConnectivityT(Arcane::IItemFamily* family,
                                       Discretization::Family* disFamily,
                                       const Arcane::String connectivityName,
                                       ExtendedConnectivityTUPtr<T>& ptr,
                                       ReverseExtendedConnectivityTUPtr<typename Discretization::ConvertA2D<T>::Type>& rPtr)
{
#ifdef USE_ARCANE_V3
  Arcane::IItemFamily* disFamily_asIItemFamily = disFamily->itemFamily();
#else
  Arcane::IItemFamily* disFamily_asIItemFamily = disFamily;
#endif
  const auto& group(family->allItems()) ;
  const auto& ownGroup(group.own()) ;
  Arcane::Integer nbOwnItems = ownGroup.size() ;

  Arcane::Int64UniqueArray uIds(nbOwnItems) ;

  _createUIdsT(disFamily, ownGroup, uIds) ;

  Arcane::Int32UniqueArray lIds(uIds.size()) ;

  disFamily->addDoFs(uIds, lIds) ;
#if (ARCANE_VERSION >= 20305)
  disFamily->endUpdate();
#endif

  // Add dofs in an ItemGroup (since the family belongs to several connectivities)
  ItemGroupBuilder<DoF> connectivity_group_builder(m_mesh,Arcane::String::format("{0}group",connectivityName),disFamily->name());
  connectivity_group_builder.add(disFamily_asIItemFamily->view(lIds).enumerator());
  m_connectivity_groups[connectivityName] = connectivity_group_builder.buildGroup();

  ConnectivityMap map ;

  _fillConnectivityMap(lIds, family, ownGroup, map) ;

  ptr.reset(new ExtendedConnectivityT<T>(family, disFamily_asIItemFamily, map, connectivityName)) ;

  Arcane::GhostLayerFromConnectivityComputer ghostBuilder(ptr.get()) ;
  IItemConnectivitySynchronizer* synchronizer = m_dofMng.connectivityMng() -> createSynchronizer(ptr.get(), &ghostBuilder) ;
  synchronizer -> synchronize() ;

  m_dofMng.connectivityMng() -> registerConnectivity(ptr.get()) ;

  /*ENUMERATE_ITEM(iitem, family -> allItems()) {
    if(family -> itemKind() == Arcane::IK_Face && ((iitem -> localId() == 2566 && iitem -> owner() == 0) || (iitem -> localId() == 2509 && iitem -> owner() == 2))) {
      std::cout << "AMR 4p Bug : one family item in init" << iitem -> localId() << std::endl ;
    } 
    }*/

  ConnectivityMap rMap ;

  _fillReverseConnectivityMap(disFamily, *ptr, group, rMap) ;

#if (ARCANE_VERSION < 20305)
  rPtr.reset(new ReverseExtendedConnectivityT<typename Discretization::ConvertA2D<T>::Type>(disFamily, family, rMap,"Reverse" + connectivityName, false)) ;
#else
  rPtr.reset(new ReverseExtendedConnectivityT<typename Discretization::ConvertA2D<T>::Type>(disFamily_asIItemFamily, family, rMap,"Reverse" + connectivityName)) ;
#endif

  m_dofMng.connectivityMng() -> registerConnectivity(rPtr.get()) ;
}

/*---------------------------------------------------------------------------*/
void 
DiscretizationConnectivity::
_identifyDoublyConnectedSurfCellsAndAct(const ItemGroupMapT<Arcane::Face, Arcane::Cell>& contactFaceLIdToSurfCell,
                                        std::function<void (const Arcane::Face&)>& action)
{
  m_facesWithDuplicatedDisFaceGroup = m_surfaceMesh->faceFamily()->findGroup("FacesWithDuplicatedDisFaceGroup", true) ;
  m_facesWithDuplicatedDisFaceGroup.clear() ;

  Arcane::IntegerSharedArray lIds ;

  ENUMERATE_FACEFACECONTACT(iContact, m_matcher->facefaceContactFamily()->allContacts()) {
    const FaceFaceContact contact = *iContact ;
    const Arcane::Face f1 = contact.face1() ;
    const Arcane::Face f2 = contact.face2() ;

    if(not (f1.null() || f2.null())) {
      const Arcane::Cell c1 = contactFaceLIdToSurfCell[f1] ;
      const Arcane::Cell c2 = contactFaceLIdToSurfCell[f2] ;

      ENUMERATE_FACE(iFace, c1.faces()) {
        ENUMERATE_CELL(iCell, iFace->cells()) {
          if(*iCell == c2 && iFace->isOwn()) {
            action(*iFace) ;                      
            lIds.add(iFace->localId());
          }
        }
      }    
    }
  }
  m_facesWithDuplicatedDisFaceGroup.addItems(lIds);
}

/*---------------------------------------------------------------------------*/
void 
DiscretizationConnectivity::
_createDoFForDoublyConnectedCellsOnSurfaceMesh(Arcane::IntegerUniqueArray& nbSurfFaceToDisFace, 
                                               Arcane::Int32SharedArray& lIds) 
{
  // Creates additional DOFs for surface cells which have two common faces

  Arcane::FaceGroup contactFaces(m_matcher->facefaceContactFamily()->allFaces()) ;

  ItemGroupMapT<Arcane::Face, Arcane::Cell> contactFaceToSurfCell(contactFaces) ;

  Arcane::ItemVector contactFaceGroupToSurfCell(Arcane::MeshToMeshTransposer::transpose(m_mesh, m_surfaceMesh, contactFaces.view())) ;

  ENUMERATE_FACE(iFace, contactFaces) {
    contactFaceToSurfCell[iFace] = contactFaceGroupToSurfCell[iFace.index()].toCell() ;
  }

  std::function<void (const Arcane::Face&)> action = [&nbSurfFaceToDisFace](const Arcane::Face& f) {
    ++nbSurfFaceToDisFace[f.localId()] ;
  } ;

  _identifyDoublyConnectedSurfCellsAndAct(contactFaceToSurfCell, action) ;

  Arcane::Int64UniqueArray uIds(m_facesWithDuplicatedDisFaceGroup.size()) ;

#ifdef USE_ARCANE_V3
  const Arcane::Int64 maxItemUIdPlusOne(Arcane::mesh::DoFUids::getMaxItemUid(m_faceFamily->itemFamily()) + 1) ;
#else
  const Arcane::Int64 maxItemUIdPlusOne(Arcane::mesh::DoFUids::getMaxItemUid(m_faceFamily) + 1) ;
#endif

  ENUMERATE_FACE(iFace, m_facesWithDuplicatedDisFaceGroup) {
    uIds[iFace.index()] = maxItemUIdPlusOne + Arcane::mesh::DoFUids::uid(iFace->uniqueId().asInt64()) ;
  }

  lIds.resize(uIds.size()) ;

  m_faceFamily->addDoFs(uIds, lIds) ;

#if (ARCANE_VERSION >= 20305)
  m_faceFamily->endUpdate();
#endif

  //std::cout << Arcane::String::format("{0} DoFs have been added\n", uIds.size()).localstr() ;
}

/*---------------------------------------------------------------------------*/
void 
DiscretizationConnectivity::
_initArcaneSurfaceFaceDiscretizationConnectivity()
{
  Arcane::IItemFamily* surfFaceFamily(m_surfaceMesh -> faceFamily()) ;

  const Arcane::String connectivityName("DiscretizationSurfaceFaceConnectivity") ;

  Arcane::Integer nbOwnGroupItems = m_facesOfSurfaceCellGroup.own().size() ;

  Arcane::Int64UniqueArray uIds(nbOwnGroupItems) ;

  _createUIdsT(m_faceFamily, m_facesOfSurfaceCellGroup.own(), uIds) ;

  Arcane::Int32UniqueArray lIds(uIds.size()) ;

  m_faceFamily->addDoFs(uIds, lIds) ;

#if (ARCANE_VERSION >= 20305)
  m_faceFamily->endUpdate();
#endif

  Arcane::IntegerUniqueArray nbSurfFaceToDisFace(m_surfaceMesh->faceFamily()->maxLocalId(), 1) ;

  Arcane::Int32SharedArray lIds2 ;

  _createDoFForDoublyConnectedCellsOnSurfaceMesh(nbSurfFaceToDisFace, lIds2) ;

  MultiConnectivityMap surfFaceToDisFaceMap ;

#if (ARCANE_VERSION >= 20201)
  surfFaceToDisFaceMap.resize(m_surfaceMesh->faceFamily(), nbSurfFaceToDisFace.constView(), NULL_ITEM_LOCAL_ID) ;
#else
  surfFaceToDisFaceMap.resize(m_surfaceMesh->faceFamily(), nbSurfFaceToDisFace.constView()) ;

  IntegerConstArrayView surfFaceToDisFaceMapDim2Sizes(surfFaceToDisFaceMap.dim2Sizes()) ;

  ENUMERATE_FACE(iFace, m_surfaceMesh->allFaces()) {
    for(Arcane::Integer i(0) ; i < surfFaceToDisFaceMapDim2Sizes[iFace->localId()] ; ++i) {
      surfFaceToDisFaceMap[iFace][i] = Arcane::NULL_ITEM_LOCAL_ID ;
    }
  }
#endif

ENUMERATE_FACE(iFace, m_facesOfSurfaceCellGroup.own()) {
    surfFaceToDisFaceMap[iFace][0] = lIds[iFace.index()] ;
  }

  ENUMERATE_FACE(iFace, m_facesWithDuplicatedDisFaceGroup) {
    surfFaceToDisFaceMap[iFace][1] = lIds2[iFace.index()] ;
  }

#ifdef USE_ARCANE_V3
  Arcane:IItemFamily* m_faceFamily_asIItemFamily = m_faceFamily->itemFamily();
#else
  Arcane:IItemFamily* m_faceFamily_asIItemFamily = m_faceFamily;
#endif

  m_surfFaceEC.reset(new FaceExtendedMultiConnectivity(surfFaceFamily, m_faceFamily_asIItemFamily, surfFaceToDisFaceMap, connectivityName)) ;

  Arcane::GhostLayerFromConnectivityComputer ghostBuilder(m_surfFaceEC.get()) ;
  IItemConnectivitySynchronizer* synchronizer = m_dofMng.connectivityMng() -> createSynchronizer(m_surfFaceEC.get(), &ghostBuilder) ;
  synchronizer -> synchronize() ;

  m_dofMng.connectivityMng() -> registerConnectivity(m_surfFaceEC.get()) ;

  ConnectivityMap rMap ;

#if (ARCANE_VERSION >= 20201)
  rMap.resize(m_faceFamily_asIItemFamily, Arcane::NULL_ITEM_LOCAL_ID) ;
#else
  rMap.resize(&m_faceFamily) ;
#endif

  _fillReverseConnectivityMapForSurfaceMeshFaces(rMap) ;

#if (ARCANE_VERSION < 20305)
  m_surfFaceREC.reset(new FaceReverseExtendedConnectivity(m_faceFamily, surfFaceFamily, rMap,"Reverse" + connectivityName, false)) ;
#else
  m_surfFaceREC.reset(new FaceReverseExtendedConnectivity(m_faceFamily_asIItemFamily, surfFaceFamily, rMap,"Reverse" + connectivityName)) ;
#endif

  m_dofMng.connectivityMng()->registerConnectivity(m_surfFaceREC.get()) ;
}

/*---------------------------------------------------------------------------*/
template<typename T, bool faultCore>
void 
DiscretizationConnectivity::
_setFlagOnDiscretizationItemsT(Discretization::Family* disFamily,
                               typename DiscretizationConnectivityUtils::ExtConnectivityUPtr<T>::Type& ptr,
                               const typename Discretization::Group<T>::Type group,              
                               Arcane::String varName,
                               VariableDoFBoolUPtr& var) {
  if(var == nullptr)
    var.reset(new Arcane::VariableDoFBool(Arcane::VariableBuildInfo(m_mesh, varName,
                                                                    disFamily->name(),
                                                                    Arcane::IVariable::PNoDump
                                                                    | Arcane::IVariable::PNoNeedSync
                                                                    | IVariable::PNoRestore))) ;
  var -> fill(false) ;

  if(ptr != nullptr) {
    for(typename Discretization::Enum<T>::Type ie(group.enumerator()); ie.hasNext(); ++ie) {
      typename Discretization::ConvertA2D<T, faultCore>::Type dI((*ptr)(ie)) ;
    
      (*var)[dI] = true ;
    }
  }
}

/*---------------------------------------------------------------------------*/
template<typename T>
void 
DiscretizationConnectivity::
_setFlagOnMultiConnectedDiscretizationItemsT(Discretization::Family* disFamily,
                                             typename DiscretizationConnectivityUtils::ExtMultiConnectivityUPtr<T>::Type& ptr,
                                             const typename Discretization::Group<T>::Type group,              
                                             Arcane::String varName,
                                             VariableDoFBoolUPtr& var) {
  if(var == nullptr)
    var.reset(new Arcane::VariableDoFBool(Arcane::VariableBuildInfo(m_mesh, varName,
                                                                    disFamily->name(),
                                                                    Arcane::IVariable::PNoDump
                                                                    | Arcane::IVariable::PNoNeedSync
                                                                    | IVariable::PNoRestore))) ;
  var -> fill(false) ;

  for(typename Discretization::Enum<T>::Type ie(group.enumerator()); ie.hasNext(); ++ie) {
    Discretization::ConnectedItems iv((*ptr)(ie));

    for(Arcane::Integer i(0) ; i < iv.size() ; ++i) {
      typename Discretization::ConvertA2D<T>::Type dI(iv[i]) ;
    
      (*var)[dI] = true ;
    }
  }
}

/*---------------------------------------------------------------------------*/
void
DiscretizationConnectivity::
_setFlagOnMultiConnectedDiscretizationContactFaces(const Arcane::String varName,
                                                   VariableDoFBoolUPtr& var) {
  if(var == nullptr)
    var.reset(new Arcane::VariableDoFBool(Arcane::VariableBuildInfo(m_mesh, varName,
                                                                    m_faceFamily->name(),
                                                                    Arcane::IVariable::PNoDump
                                                                    | Arcane::IVariable::PNoNeedSync
                                                                    | IVariable::PNoRestore))) ;
  var -> fill(false) ;

  ENUMERATE_FACEFACECONTACT(iContact, contactGroup()) {
    const Arcane::Integer nbConnectedItems(m_contactEC -> nbConnectedItem((Arcane::ItemLocalId) iContact -> localId())) ;

    for(Arcane::Integer i(0) ; i < nbConnectedItems ; ++i) {
      Discretization::Face disFace((*m_contactEC)(iContact, i)) ;

      (*var)[disFace] = true ;
    }
  }
}

/*---------------------------------------------------------------------------*/
void 
DiscretizationConnectivity::
_createContactDiscretizationConnectivity(Discretization::Family* disFamily,
                                         ContactExtendedConnectivityUPtr& ptr,
                                         const bool multi) {
  if(m_matcher != nullptr) {
    if(ptr != nullptr) {
      Arcane::IntegerSharedArray toBeRemoved ;
      ptr -> connectedItems(toBeRemoved) ;
      disFamily->removeDoFs(toBeRemoved) ;
#if (ARCANE_VERSION >= 20305)
      disFamily->endUpdate();
#endif
    }
    
    Arcane::Integer nbContacts(contactGroup().size()) ;
    
    Arcane::IParallelMng* parallelMng(m_mesh -> parallelMng()) ;

    const Arcane::Integer maxNbContacts(parallelMng -> reduce(Arcane::Parallel::ReduceMax, nbContacts)) ;

    const Arcane::Integer rank(parallelMng -> commRank()) ;

    Arcane::Int64UniqueArray uIds ;
#ifdef USE_ARCANE_V3
    const Arcane::Int64 maxItemUIdPlusOne(Arcane::mesh::DoFUids::getMaxItemUid(disFamily->itemFamily()) + 1) ;
#else
    const Arcane::Int64 maxItemUIdPlusOne(Arcane::mesh::DoFUids::getMaxItemUid(disFamily) + 1) ;
#endif

    if(multi) {
      uIds.resize(2*nbContacts) ;
      const Arcane::Integer maxNbContactsX2(2 * maxNbContacts) ;
      const Arcane::Integer shift(rank * maxNbContactsX2) ;

      Arcane::Integer i(0) ;
      ENUMERATE_FACEFACECONTACT(iContact, contactGroup()) {
        const FaceFaceContact contact = *iContact ;

        if(contact.isOwn()) {
          for(Arcane::Integer j(0) ; j < 2 ; ++j) {
            uIds[i] = maxItemUIdPlusOne + shift + i ;
            ++i ;
          }
        }
      }
    } else {
      const Arcane::Integer shift(rank * maxNbContacts) ;
      // New
      uIds.reserve(nbContacts) ;
      Arcane::Integer i(0) ;
      ENUMERATE_FACEFACECONTACT(iContact, contactGroup()) {
        const FaceFaceContact contact = *iContact ;

        if(contact.isOwn()) {
          uIds.add(maxItemUIdPlusOne + shift + i) ;
          ++i ;
        }
      }
      // Old
      /* uIds.resize(nbContacts) ;
       for(Arcane::Integer i(0) ; i < nbContacts ; ++i) {
        uIds[i] = maxItemUIdPlusOne + shift + i ;
      } */
    }
    
    Arcane::Int32UniqueArray lIds(uIds.size()) ;
    disFamily->addDoFs(uIds, lIds) ;
#if (ARCANE_VERSION >= 20305)
    disFamily->endUpdate();
#endif
        
#if (ARCANE_VERSION >= 20305)
    if (ptr.get() != nullptr) ptr->targetFamily()->removeTargetConnectivity(ptr.get());
#endif
    // Contact family has changed...need to create a new object
    FaceFaceContactFamily* contactFamily = m_matcher -> facefaceContactFamily() ;
    ptr.reset(new ContactExtendedConnectivity(contactFamily, 
					      disFamily, lIds, contactGroup(),
					      "DiscretizationContactConnectivity", multi)) ;
#if (ARCANE_VERSION >= 20305)
    // SDC : register contact connectivity in dof family to follow DoF compaction
    ptr->targetFamily()->addTargetConnectivity(ptr.get());
#endif

    // Compute contact parallel infos
    ptr->sourceFamily()->computeSynchronizeInfos();
    Arcane::GhostLayerFromConnectivityComputer ghostBuilder(ptr.get()) ;
    IItemConnectivitySynchronizer* synchronizer = m_dofMng.connectivityMng() -> createSynchronizer(ptr.get(), &ghostBuilder) ;
    synchronizer -> synchronize() ;
  }
}

/*---------------------------------------------------------------------------*/
template<class T, class U, bool surfaceMeshFlag>
void 
DiscretizationConnectivity::
_createDiscretizationMultiConnectivityT(const DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<T, U, surfaceMeshFlag>& mct,
                                        const Arcane::String connectivityName,
                                        ExtendedMultiConnectivityTUUPtr<T, U>& ptrTU) {
  Discretization::Family* familyT(mct.familyT()) ;
  Discretization::Family* familyU(mct.familyU()) ;
#ifdef USE_ARCANE_V3
  Arcane::IItemFamily *familyT_asIItemFamily = familyT->itemFamily();
  Arcane::IItemFamily *familyU_asIItemFamily = familyU->itemFamily();
#else
  Arcane::IItemFamily *familyT_asIItemFamily = familyT;
  Arcane::IItemFamily *familyU_asIItemFamily = familyU;
#endif


  Arcane::IntegerUniqueArray nbTToU(familyT_asIItemFamily -> maxLocalId(), 0) ;

  mct.count(nbTToU) ;

  MultiConnectivityMap TToUMap ;

#if (ARCANE_VERSION >= 20201)
  TToUMap.resize(familyT_asIItemFamily, nbTToU.constView(), NULL_ITEM_LOCAL_ID) ;
#else
  TToUMap.resize(familyT, nbTToU.constView()) ;
#endif

  mct.map(TToUMap) ;

  if (ptrTU.get() != nullptr) m_dofMng.connectivityMng()->unregisterConnectivity(ptrTU.get());

  ptrTU.reset(new ExtendedMultiConnectivityTU<T, U>(familyT_asIItemFamily, familyU_asIItemFamily, TToUMap, connectivityName)) ;

  m_dofMng.connectivityMng() -> registerConnectivity(ptrTU.get()) ;
}

/*---------------------------------------------------------------------------*/
template<typename T, bool surfaceMeshFlag>
void
DiscretizationConnectivity::
_createDiscretizationGroupsT(Discretization::Family* family,
                             const DiscretizationConnectivityUtils::ItemSelectFunctorT<T, surfaceMeshFlag>& select,
                             DisGroupNameInitList groupsWithNames, const bool clear) {
  Arcane::UniqueArray<Arcane::IntegerSharedArray> lIdsV(groupsWithNames.size()) ;

#ifdef USE_ARCANE_V3
  Arcane::IItemFamily *family_asIItemFamily = family->itemFamily();
#else
  Arcane::IItemFamily *family_asIItemFamily = family;
#endif

  for(auto g : groupsWithNames) {
      *(g.first) = family_asIItemFamily->findGroup(g.second, true) ;
      if(clear)
        g.first -> clear() ;
  }

  select(lIdsV) ;

  Arcane::Integer n = 0 ;
  for(auto g : groupsWithNames) {
      g.first -> addItems(lIdsV[n]) ;
      ++n ;
  }
}

/*---------------------------------------------------------------------------*/
void 
DiscretizationConnectivity::
_createItemGroupsOfCellGroup() {
  const auto& faceFamily(m_mesh -> faceFamily()) ;

  m_faceGroup = faceFamily -> findGroup("ActiveFacesOfCellGroup", true) ;

  m_faceGroup.clear() ;

  auto flag(&m_isInCellGroup) ;

  auto usedFace = [&flag](const Arcane::Face& testFace) {
    bool inFaceGroup(false) ;
    ENUMERATE_CELL(iCell, testFace.cells()) {
      inFaceGroup = inFaceGroup || (*flag)[*iCell] ;
    }
    return inFaceGroup &&
    DiscretizationConnectivityUtils::AMRT<Arcane::Face>::isActive(testFace) ;
  } ;

  Arcane::IntegerSharedArray lIds ;

  if(surfaceMesh() != nullptr) {
    Arcane::BoolUniqueArray lIdIsPresent(faceFamily -> maxLocalId() , false) ;

    ENUMERATE_FACE(iFace, mesh() -> allActiveFaces()) {
      if(usedFace(*iFace)) {
        const auto lId(iFace -> localId()) ;
        lIdIsPresent[lId] = true ;
        lIds.add(lId) ;
      }
    }

    ENUMERATE_CELL(iCell , m_surfaceCellGroup) {
      const Arcane::Face parentFace(iCell -> parent() -> toFace());
      const auto lId(parentFace.localId()) ;
      if(!lIdIsPresent[lId]) {
        lIdIsPresent[lId] = true ;
        lIds.add(lId) ;
      }
    }
  } else {
    ENUMERATE_FACE(iFace, mesh() -> allActiveFaces()) {

      const bool isContact(m_contactFacesSet.hasKey(*iFace)) ;
      
      if(not isContact && usedFace(*iFace))
        lIds.add(iFace -> localId()) ;    
    }
  }

  m_faceGroup.addItems(lIds) ;

  if(surfaceMesh() != nullptr) {
    lIds.clear() ;
    const auto& surfaceFaceFamily(surfaceMesh() -> faceFamily()) ;

    m_facesOfSurfaceCellGroup = surfaceFaceFamily -> findGroup("ActiveFacesOfSurfaceCellGroup", true) ;
    m_facesOfSurfaceCellGroup.clear() ;

    flag = m_isInSurfaceCellGroup.get() ;
    if(surfaceMesh() != nullptr) {
      ENUMERATE_FACE(iFace, surfaceMesh() -> allActiveFaces()) {
        if(usedFace(*iFace))
          lIds.add(iFace -> localId()) ;
      }
    }
    m_facesOfSurfaceCellGroup.addItems(lIds) ;
  }

  const auto& nodeFamily(m_mesh -> nodeFamily()) ;
  m_nodesOfCellGroup = nodeFamily -> findGroup("NodeOfCellGroup", true) ;

  m_nodesOfCellGroup.clear() ;

  lIds.clear() ;

  ENUMERATE_NODE(iNode, mesh() -> allNodes()) {
    const auto cells(iNode -> cells()) ;
    bool hasOneCellInGroup(false) ;
    ENUMERATE_CELL(iCell, cells) {
      if(m_isInCellGroup[iCell]) {
        hasOneCellInGroup = true ;
        break ;
      }
    }
    if(hasOneCellInGroup)
      lIds.add(iNode -> localId()) ;
  }

  m_nodesOfCellGroup .addItems(lIds) ;

  // Creates contact group
  if(m_matcher != nullptr) {
    Arcane::BoolSharedArray isFaceOnContactAndInGroup(m_mesh -> faceFamily() -> maxLocalId(), false) ;

    ENUMERATE_FACE(iface, m_filteredCellGroup.faceGroup()) {
      if(m_contactFacesSet.hasKey(*iface))
        isFaceOnContactAndInGroup[iface -> localId()] = true ;
    }

    FaceFaceContactFamily* contactFamily = m_matcher -> facefaceContactFamily() ;

    Arcane::IntegerSharedArray contactLIds ;

    ENUMERATE_FACEFACECONTACT(icontact, contactFamily -> allContacts()) {
      const FaceFaceContact contact = *icontact ;
      const Arcane::Face f1 = contact.face1() ;
      const Arcane::Face f2 = contact.face2() ;
      
      const bool f1OK = f1.null() ? false : isFaceOnContactAndInGroup[f1.localId()] ;
      const bool f2OK = f2.null() ? false : isFaceOnContactAndInGroup[f2.localId()] ;

      //if(contact.isOwn() && (f1OK || f2OK)) {
      // TODO : to be fully validated
      if(f1OK || f2OK) {
        contactLIds.add(contact.localId()) ;
      }
    }
    
    m_contactGroupName = m_connectivityName + "ContactGroup" ;
      
    ContactGroup contactGroup = contactFamily -> findGroup(m_contactGroupName) ;
    
    if(contactGroup.null())
      contactGroup = contactFamily -> createGroup(m_contactGroupName) ;
    
    contactGroup.setItems(contactLIds) ;
  }
}

/*---------------------------------------------------------------------------*/
void 
DiscretizationConnectivity::
_createNonCellGroupFlags() {
  m_isInFaceGroup.fill(false) ;
  ENUMERATE_FACE(iFace, m_faceGroup) {
    m_isInFaceGroup[iFace] = true ;
  }

  if(m_surfaceMesh != nullptr) {
    m_isInSurfaceFaceGroup.reset(new Arcane::VariableFaceBool(Arcane::VariableBuildInfo(m_surfaceMesh,
                                                                                        "DiscretizationConnectivityIsInSurfaceFaceGroup",
                                                                                        m_surfaceMesh -> faceFamily() -> name(),
                                                                                        Arcane::IVariable::PNoDump
                                                                                        |
                                                                                        Arcane::IVariable::PNoNeedSync))) ;
    m_isInSurfaceFaceGroup -> fill(false) ;
    ENUMERATE_FACE(iFace, m_facesOfSurfaceCellGroup) {
      (*m_isInSurfaceFaceGroup)[iFace] = true ;
    }
  }

  m_isInNodeGroup.fill(false) ;
  ENUMERATE_NODE(iNode, m_nodesOfCellGroup) {
    m_isInNodeGroup[iNode] = true ;
  }
}

/*---------------------------------------------------------------------------*/
void 
DiscretizationConnectivity::
_createBoundaryFlags() {
  if(m_isCellGroupBoundary == nullptr) 
    m_isCellGroupBoundary.reset(new Arcane::VariableDoFBool(Arcane::VariableBuildInfo(m_mesh, 
                                                                                      "DiscretizationConnectivityIsCellGroupBoundary",
                                                                                      m_faceFamily->name(),
                                                                                      Arcane::IVariable::PNoDump
                                                                                      | Arcane::IVariable::PNoNeedSync
                                                                                      | IVariable::PNoRestore)))  ;

  m_isCellGroupBoundary -> fill(false) ;

  if(m_isSubDomainBoundary == nullptr) 
    m_isSubDomainBoundary.reset(new Arcane::VariableDoFBool(Arcane::VariableBuildInfo(m_mesh, 
                                                                                      "DiscretizationConnectivityIsSubDomainBoundary",
                                                                                      m_faceFamily->name(),
                                                                                      Arcane::IVariable::PNoDump
                                                                                      | Arcane::IVariable::PNoNeedSync
                                                                                      | IVariable::PNoRestore)))  ;
  m_isSubDomainBoundary -> fill(false) ;

  ENUMERATE_FACE(iface, m_faceGroup){
    const Discretization::Face disFace((*m_faceEC)(iface)) ;

    if(iface -> isSubDomainBoundary()) {
      (*m_isSubDomainBoundary)[disFace] = true ;
      (*m_isCellGroupBoundary)[disFace] = true ;
    } else {
        const Arcane::Cell backCell(iface -> backCell()) ;
        const Arcane::Cell frontCell(iface -> frontCell()) ;

        if(not (m_isInCellGroup[backCell] && m_isInCellGroup[frontCell]))
          (*m_isCellGroupBoundary)[disFace] = true ;
    }
  }

  ENUMERATE_FACE(iFace, m_facesOfSurfaceCellGroup) {
    Discretization::ConnectedItems iv((*m_surfFaceEC)(iFace)) ;

    if(iFace -> isSubDomainBoundary() || iv.size() == 2) {
      for(Arcane::Integer i(0) ; i < iv.size() ; ++i) {
        Discretization::Face disFace(iv[i]) ;
        (*m_isSubDomainBoundary)[disFace] = true ;
        (*m_isCellGroupBoundary)[disFace] = true ;
      }
    } else {
        Discretization::Face disFace(iv[0]) ;
        const Arcane::Cell backCell(iFace -> backCell()) ;
        const Arcane::Cell frontCell(iFace -> frontCell()) ;

        if(not ((*m_isInSurfaceCellGroup)[backCell] && (*m_isInSurfaceCellGroup)[frontCell]))
          (*m_isCellGroupBoundary)[disFace] = true ;
    }
  }

  if(m_surfaceMesh != nullptr) {
    ENUMERATE_CELL(iCell, m_surfaceMesh -> allCells()) {
      const Arcane::Face parentFace(iCell -> parent() -> toFace()) ;
      const Arcane::Cell boundaryCell(parentFace.boundaryCell()) ;
      const Discretization::Face disFace((*m_faceEC)(parentFace)) ;
      (*m_isCellGroupBoundary)[disFace] = not ((*m_isInSurfaceCellGroup)[iCell] && m_isInCellGroup[boundaryCell]) ;
      (*m_isSubDomainBoundary)[disFace] = (*m_isCellGroupBoundary)[disFace.internal()] ;
    }

    ENUMERATE_FACEFACECONTACT(icontact, contactGroup()) {      
      const FaceFaceContact contact = *icontact ;

      const Arcane::Face face1(contact.face1()) ;
      const Arcane::Face face2(contact.face2()) ;
      
      bool contactOnSubDomainBoundary(false) ;
      bool contactOnCellGroupBoundary(false) ;

      const Arcane::Integer nbConnectedItems((*m_contactEC).nbConnectedItem((Arcane::ItemLocalId)contact.localId())) ;

      Arcane::Integer nLocFace(0) ;
      for(auto face : {face1, face2}) {
        if(not face.null()) {
          const Arcane::Cell cell(face.boundaryCell()) ;
          const Discretization::Face disFace((*m_faceEC)(face)) ;

            const bool b(cell.isActive() && m_isInCellGroup[cell]) ;

            const Arcane::ItemInternalArrayView surfCellsInternalView(m_surfaceMesh -> cellFamily() -> itemsInternal()) ;
            const Arcane::Cell surfCell(surfCellsInternalView[m_faceToSurfCellLIdMap[face]]) ;

            const bool bs(surfCell.isActive() && (*m_isInSurfaceCellGroup)[surfCell]) ;

            if(b) {
              if(bs) {
                (*m_isSubDomainBoundary)[disFace] = false ;
                (*m_isCellGroupBoundary)[disFace] = false ;
              } else {
                // To be corrected : the contact should not exist
                contactOnCellGroupBoundary = true ;
              }
            } else {
              if(not bs){
                // To be corrected : the contact should not exist
                contactOnCellGroupBoundary = true ;
              }
            }
        } else {
          contactOnSubDomainBoundary = true ;
          contactOnCellGroupBoundary = true ;

          if(nbConnectedItems == 2) {
            const Discretization::Face disContact = (*m_contactEC)(contact, nLocFace) ;
            (*m_isSubDomainBoundary)[disContact] = true ;
            (*m_isCellGroupBoundary)[disContact] = true ;
          }
        }
        ++nLocFace ;
      }

      if(nbConnectedItems == 1) {
        const Discretization::Face disContact = (*m_contactEC)(contact, 0) ;

        if(contactOnSubDomainBoundary)
          (*m_isSubDomainBoundary)[disContact] = true ;

        if(contactOnCellGroupBoundary)
          (*m_isCellGroupBoundary)[disContact] = true ;
      }
    }
  } else {
    ENUMERATE_FACEFACECONTACT(icontact, contactGroup()) {
      const Discretization::Face disFace((*m_contactEC)(icontact)) ;
      
      const FaceFaceContact contact = *icontact ;
      
      const Arcane::Face face1(contact.face1()) ;
      const Arcane::Face face2(contact.face2()) ;
      
      if(face1.null() || face2.null()) {
        (*m_isSubDomainBoundary)[disFace] = true ;
        (*m_isCellGroupBoundary)[disFace] = true ;
      } else {
        const Arcane::Cell cell1(face1.boundaryCell()) ;
        const Arcane::Cell cell2(face2.boundaryCell()) ;

        if((cell1.isActive() && not m_isInCellGroup[cell1]) ||
           (cell2.isActive() && not m_isInCellGroup[cell2])) {
          (*m_isCellGroupBoundary)[disFace] = true ;
        }
      }
    }
  }
}

/*---------------------------------------------------------------------------*/
template<typename T>
void 
DiscretizationConnectivity::
_updateArcaneDiscretizationConnectivityT(Arcane::IItemFamily* family,
                                         Discretization::Family* disFamily,
                                         ExtendedConnectivityTUPtr<T>& ptr,
                                         ReverseExtendedConnectivityTUPtr<typename Discretization::ConvertA2D<T>::Type>& rPtr)
{
#ifdef USE_ARCANE_V3
  Arcane::IItemFamily *disFamily_asIItemFamily = disFamily->itemFamily();
#else
  Arcane::IItemFamily *disFamily_asIItemFamily = disFamily;
#endif
  ConnectivityMap& map(ptr -> itemProperty());

  ConnectivityMap& rMap(rPtr -> itemProperty());

  // SDC PATCH : to handle item owner change, we check if the item and its connected dof has the same owner. If not we change the dof owner to the item's one.
  ENUMERATE_ITEM(source_item, family->allItems()) {
    Arcane::Int32 connected_item_lid = map[source_item];
    if (connected_item_lid == NULL_ITEM_LOCAL_ID) continue;
    ItemInternal* connected_item = disFamily_asIItemFamily->view().items()[connected_item_lid];
    if (source_item->owner() != connected_item->owner()) {
        connected_item->setOwner(source_item->owner(),m_mesh->parallelMng()->commRank());
    }
  }

  disFamily_asIItemFamily->notifyItemsOwnerChanged();
  
  Arcane::Int32ArrayView added_items_lids ;
  Arcane::Int32ArrayView removed_items_lids ;

  m_dofMng.connectivityMng() -> getSourceFamilyModifiedItems(ptr.get(), added_items_lids, removed_items_lids) ;

  /*std::cout << Arcane::String::format("Number of dofs to remove {0} according to getSourceFamilyModifiedItems in subDomain {1}",
                                      removed_items_lids.size(),
                                      m_mesh -> subDomain() -> subDomainId()).localstr() << std::endl ;

  std::cout << Arcane::String::format("Number of dofs to add {0} according to getSourceFamilyModifiedItems in subDomain {1}", 
                                      added_items_lids.size(),
                                      m_mesh -> subDomain() -> subDomainId()).localstr() << std::endl ;*/

  Arcane::ItemVector added_items(family, added_items_lids) ;

  Arcane::Int32SharedArray removed_dis_items_lids ;

  // SDC: to check : this loop may be useless since to handle compaction occurring after remove,
  // the removed_item_lids should now be empty (since these lids now point to new items...)
  // The dof connected to removed items are unconnected and removed later (see remove unconnected dof below)
  for(Arcane::Integer i(0) ; i < removed_items_lids.size() ; ++i) {
      Arcane::ItemInternal internal ;
      internal.setLocalId(removed_items_lids[i]) ;
      const T removedItem(&internal) ;
      const typename Discretization::ConvertA2D<T>::Type disItem((*ptr)(removedItem)) ;
      removed_dis_items_lids.add(disItem.localId()) ;
      map[removedItem] = NULL_ITEM_LOCAL_ID ;

      /*if(family -> itemKind() == Arcane::IK_Face && ((removedItem.localId() == 2566 && removedItem.owner() == 0) || (removedItem.localId() == 2509 && removedItem.owner() == 2))) {
      std::cout << "AMR 4p Bug : one removed item " << removedItem.localId() << std::endl ;
      } */
  }

  // SDC: Also remove unconnected dof, may they be own or ghost. These dof cannot be reached from source items (since they are deconnected).
  // Their unconnection is due to the fact that they were connected to a removed item.
  // Remove only the dof of the current connectivity : use the ItemGroup => otherwise it removes dof of another connectivity...
  Arcane::ItemGroup connectivity_disItem = m_connectivity_groups[ptr->name()];
  ENUMERATE_ITEM(disItem, connectivity_disItem) {
    if (rMap[disItem] == NULL_ITEM_LOCAL_ID) {
        removed_dis_items_lids.add(disItem.localId());
    }
   }

  // SDC: Remove ghost dofs
  ENUMERATE_ITEM(source_item, family->allItems()) {
    if (map[source_item] == NULL_ITEM_LOCAL_ID) continue;
    Item connected_item = (*ptr)(T(source_item->internal()));
    if (!connected_item->isOwn()) {
        removed_dis_items_lids.add(connected_item->localId());
        map[source_item] = NULL_ITEM_LOCAL_ID;
    }
  }

  // SDC: fill rMap of removed_dis_items with NULL_ITEM_LID
  ENUMERATE_ITEM(removed_dis_item, disFamily_asIItemFamily->view(removed_dis_items_lids)) {
    rMap[removed_dis_item] = NULL_ITEM_LOCAL_ID;
  }

  /*std::cout << Arcane::String::format("Number of dofs to remove {0} in subDomain {1}",
                                      removed_dis_items_lids.size(),
                                      m_mesh -> subDomain() -> subDomainId()).localstr() << std::endl ;*/

  disFamily->removeDoFs(removed_dis_items_lids.view()) ;
#if (ARCANE_VERSION >=20305)
  disFamily->endUpdate();
#endif

  Arcane::ItemVector own_added_items(family) ;

  ENUMERATE_ITEM(iitem, family -> view(added_items_lids)){
    if(iitem -> isOwn()) {
        own_added_items.add(iitem -> localId()) ;
    }
  }

  Arcane::Int64UniqueArray uids(own_added_items.size());

  /*if(family -> itemKind() == Arcane::IK_Cell) {
    ENUMERATE_ITEM(iItem, family -> allItems()) {
      m_mesh -> traceMng() -> debug() << "CELL UID " << iItem -> uniqueId().asInt64() ;
    }
    }*/

  _createUIdsT(disFamily, own_added_items, uids) ;

  /*std::cout << Arcane::String::format("Number of dofs to add {0} in subDomain {1}",
                                      uids.size(),
                                      m_mesh -> subDomain() -> subDomainId()).localstr() << std::endl ;*/

  Arcane::Int32SharedArray lids(uids.size()) ;

  disFamily->addDoFs(uids, lids) ;
#if (ARCANE_VERSION >= 20305)
  disFamily->endUpdate();
#endif

  // SDC: Update dof group for the current connectivity with created own dofs
  connectivity_disItem.addItems(lids);

  /*std::cout << Arcane::String::format("New size of the family {0} in subDomain {1}",
                                      disFamily->view().size(),
                                      m_mesh -> subDomain() -> subDomainId()).localstr() << std::endl ;

  std::cout << Arcane::String::format("Size of the own group {0} in subDomain {1}", 
                                      group.own().size(),
                                      m_mesh -> subDomain() -> subDomainId()).localstr() << std::endl ;

  std::cout << Arcane::String::format("Size of the own cells group {0} in subDomain {1}",
                                      m_mesh -> ownCells().size(),
                                      m_mesh -> subDomain() -> subDomainId()).localstr() << std::endl  ;*/

  //Arcane::IntegerArray disLIds = disFamily->view().localIds() ;
  //_fillConnectivityMap(disLIds, family, group.own(), map) ;

#if (ARCANE_VERSION >= 20201)
  map.resize(family, NULL_ITEM_LOCAL_ID) ;
#else
  map.resize(family) ;
#endif
  
  ENUMERATE_ITEM(iItem, own_added_items) {
    /*if(family -> itemKind() == Arcane::IK_Face && ((iItem -> localId() == 2566 && iItem -> owner() == 0) || (iItem -> localId() == 2509 && iItem -> owner() == 2))) {
      std::cout << "AMR 4p Bug : one added item " << iItem -> localId() << std::endl ;
      }*/

    map[iItem] = lids[iItem.index()] ;
  }

  Arcane::String connectivityName(ptr -> name()) ;

  // SDC: can we avoid these new allocations ? Map is automatically up to date
//  ptr.reset(new ExtendedConnectivityT<T>(family, &disFamily, map, connectivityName)) ;

  Arcane::GhostLayerFromConnectivityComputer ghostBuilder(ptr.get()) ;
  IItemConnectivitySynchronizer* synchronizer = m_dofMng.connectivityMng() -> createSynchronizer(ptr.get(),&ghostBuilder) ;
  synchronizer -> synchronize() ;

  //SDC: Update dof group for the current connectivity with created  ghost dofs
  Int32UniqueArray created_ghost_dofs;
  ENUMERATE_ITEM(ghost_item, family->allItems().ghost()) {
    created_ghost_dofs.add((*ptr)(T(ghost_item->internal())).localId());
  }
  connectivity_disItem.addItems(created_ghost_dofs);

  m_dofMng.connectivityMng() -> setUpToDate(ptr.get()) ;

/*ENUMERATE_ITEM(iitem,family->allItems()) {
    if(family -> itemKind() == Arcane::IK_Face && ((iitem -> localId() == 2566 && iitem -> owner() == 0) || (iitem -> localId() == 2509 && iitem -> owner() == 2))) {
      std::cout << "AMR 4p Bug : one family item in update" << iitem -> localId() << std::endl ;
    } 
    }*/
  
//  SDC PATCH: rMap update must be done on the whole family
  _fillReverseConnectivityMap(disFamily, *ptr, family -> allItems(), rMap) ;

  Arcane::String reverseConnectivityName(rPtr -> name()) ;

#if (ARCANE_VERSION < 20201)
  rPtr.reset(new ReverseExtendedConnectivityT<typename Discretization::ConvertA2D<T>::Type>(&disFamily, family, rMap,reverseConnectivityName, false)) ;
  // Cannot work : connectivity ptr in connectivity mng is KO...
  // SDC: if you change the connectivity object (by setting a new ptr) you need to update the connectivity mng...
  // Update is not needed, reference to rMap is up to date.
#endif

  m_dofMng.connectivityMng() -> setUpToDate(rPtr.get());
}

/*---------------------------------------------------------------------------*/
void 
DiscretizationConnectivity::
_updateSurfaceFaceDiscretizationConnectivity()
{
  Arcane::IItemFamily* surfFaceFamily(m_surfaceMesh -> faceFamily()) ;

  MultiConnectivityMap& map(m_surfFaceEC -> itemProperty()) ;

  ConnectivityMap& rMap(m_surfFaceREC -> itemProperty()) ; 

  Arcane::Int32ArrayView added_items_lids ;
  Arcane::Int32ArrayView removed_items_lids ;

  m_dofMng.connectivityMng() -> getSourceFamilyModifiedItems(m_surfFaceEC.get(), added_items_lids, removed_items_lids) ;

  Arcane::ItemVector added_items(surfFaceFamily, added_items_lids) ;

  Arcane::Int32SharedArray removed_dis_items_lids ;

  for(Arcane::Integer i(0) ; i < removed_items_lids.size() ; ++i) {
      Arcane::ItemInternal internal;
      internal.setLocalId(removed_items_lids[i]);
      const Arcane::Face removedItem(&internal);
      Discretization::ConnectedItems cv((*m_surfFaceEC)(removedItem));

      for(Arcane::Integer j(0) ; j < cv.size() ; ++j) {
        const Discretization::Face disItem(cv[j]) ;
        removed_dis_items_lids.add(disItem.localId()) ;
        map[removedItem][j] = NULL_ITEM_LOCAL_ID ;
      }
  }

  // Remove dofs added for doubly connected cells
  ENUMERATE_FACE(iFace, m_facesOfSurfaceCellGroup) {
    Discretization::ConnectedItems cv((*m_surfFaceEC)(iFace));

    if(cv.size() > 1) {
      const Discretization::Face disFace(cv[1]) ;
      removed_dis_items_lids.add(disFace.localId()) ;
      map[iFace][1] = NULL_ITEM_LOCAL_ID ;
    }
  }

  m_faceFamily->removeDoFs(removed_dis_items_lids.view()) ;
#if (ARCANE_VERSION >=20305)
  m_faceFamily->endUpdate();
#endif

  Arcane::ItemVector own_added_items(surfFaceFamily) ;

  ENUMERATE_ITEM(iitem, surfFaceFamily -> view(added_items_lids)){
    if(iitem -> isOwn()) {
        own_added_items.add(iitem -> localId()) ;
    }
  }

  Arcane::Int64UniqueArray uIds(own_added_items.size());

  _createUIdsT(m_faceFamily, own_added_items, uIds) ;

  Arcane::Int32SharedArray lIds(uIds.size()) ;

  m_faceFamily->addDoFs(uIds, lIds) ;
#if (ARCANE_VERSION >= 20305)
  m_faceFamily->endUpdate();
#endif

  Arcane::IntegerUniqueArray nbSurfFaceToDisFace(surfFaceFamily->maxLocalId(), 1) ;

  Arcane::Int32SharedArray lIds2 ;

  _createDoFForDoublyConnectedCellsOnSurfaceMesh(nbSurfFaceToDisFace, lIds2) ;

#if (ARCANE_VERSION >= 20201)
  map.resize(surfFaceFamily, nbSurfFaceToDisFace.constView(), NULL_ITEM_LOCAL_ID) ;
#else
  map.resize(surfFaceFamily, nbSurfFaceToDisFace.constView()) ;
#endif
  
  ENUMERATE_ITEM(iItem, own_added_items) {
    map[iItem][0] = lIds[iItem.index()] ;
  }

  ENUMERATE_FACE(iFace, m_facesWithDuplicatedDisFaceGroup) {
    map[iFace][1] = lIds2[iFace.index()] ;
  }

  Arcane::GhostLayerFromConnectivityComputer ghostBuilder(m_surfFaceEC.get()) ;
  IItemConnectivitySynchronizer* synchronizer = m_dofMng.connectivityMng() -> createSynchronizer(m_surfFaceEC.get(),&ghostBuilder) ;
  synchronizer -> synchronize() ;

  m_dofMng.connectivityMng() -> setUpToDate(m_surfFaceEC.get()) ;

#ifdef USE_ARCANE_V3
  Arcane::IItemFamily *m_faceFamily_asIItemFamily = m_faceFamily->itemFamily();
#else
  Arcane::IItemFamily *m_faceFamily_asIItemFamily = m_faceFamily;
#endif

#if (ARCANE_VERSION >= 20201)
  rMap.resize(m_faceFamily_asIItemFamily, Arcane::NULL_ITEM_LOCAL_ID) ;
#else
  rMap.resize(&m_faceFamily) ;
#endif

  _fillReverseConnectivityMapForSurfaceMeshFaces(rMap) ;

  Arcane::String reverseConnectivityName(m_surfFaceREC -> name()) ;

#if (ARCANE_VERSION < 20201)
  m_surfFaceREC.reset(new ReverseExtendedConnectivityT<typename Discretization::ConvertA2D<T>::Type>(&m_faceFamily, surfFaceFamily, rMap,
                                                                                                      reverseConnectivityName, false)) ;
  // Cannot work : connectivity ptr in connectivity mng is KO...
  // SDC: if you change the connectivity object (by setting a new ptr) you need to update the connectivity mng...
  // Update is not needed, reference to rMap is up to date.
#endif

  m_dofMng.connectivityMng() -> setUpToDate(m_surfFaceREC.get()) ;
}

/*---------------------------------------------------------------------------*/
void 
DiscretizationConnectivity::
_createFaceToSurfCellLIdAndReverseMaps() {
#if (ARCANE_VERSION >= 20201)
  m_faceToSurfCellLIdMap.resize(m_mesh -> faceFamily(), Arcane::NULL_ITEM_LOCAL_ID) ;
#else
  m_faceToSurfCellLIdMap.resize(m_mesh -> faceFamily()) ;
      
  ENUMERATE_FACE(iFace, m_mesh -> allFaces()) {
    m_faceToSurfCellLIdMap[iFace] = Arcane::NULL_ITEM_LOCAL_ID ;
  }
#endif
  
  if(m_surfaceMesh != nullptr) {
#if (ARCANE_VERSION >= 20201)
    m_surfCellToFaceLIdMap.resize(m_surfaceMesh -> cellFamily(), Arcane::NULL_ITEM_LOCAL_ID) ;
#else
    m_surfCellToFaceLIdMap.resize(m_surfaceMesh -> cellFamily()) ;
      
    ENUMERATE_CELL(iCell, m_surfaceMesh -> allCells()) {
      m_surfCellToFaceLIdMap[iCell] = Arcane::NULL_ITEM_LOCAL_ID ;
    }
#endif

    Arcane::FaceGroup surfaceFaces = m_mesh -> faceFamily() -> findGroup(m_surfaceFaceGroupName) ;
  
    Arcane::ItemVector faceToCell = Arcane::MeshToMeshTransposer::transpose(m_mesh, m_surfaceMesh, surfaceFaces.view()) ;
  
    ENUMERATE_FACE(iFace, surfaceFaces) {
      const Arcane::Cell surfCell(faceToCell[iFace.index()].toCell()) ;
      const Arcane::Integer surfCellLId = surfCell.localId() ;
      m_faceToSurfCellLIdMap[iFace] = surfCellLId ;
      m_surfCellToFaceLIdMap[surfCell] = iFace->localId() ; 
    }    
  }
}

void DiscretizationConnectivity::_check() {
  ENUMERATE_DISCRETIZATION_CELL(iCell, nonFaultCoreCells()) {
    const auto disCell(*iCell) ;
    Discretization::ConnectedItems cellFaces(faces(disCell));

    ENUMERATE_DISCRETIZATION_FACE(iFace, cellFaces) {
      const bool onBoundary(isCellGroupBoundary(iFace)) ;
      //const auto& arcFace(face(iFace)) ;

      if(onBoundary) {
        const auto& neighbourCell(boundaryCell(iFace)) ;

        if(neighbourCell.localId() != iCell -> localId()) {
          /*const auto test(isInSurfaceMesh(disCell)) ;
          const auto test2(isInSurfaceMesh(neighbourCell)) ;
          const auto& arcCell(cell(disCell)) ;
          const auto& arcNeighboutCell(cell(neighbourCell)) ;*/
          throw Arcane::FatalErrorException(A_FUNCINFO, "Problem of group boundary") ;
        }
      }
    }
  }


}
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
