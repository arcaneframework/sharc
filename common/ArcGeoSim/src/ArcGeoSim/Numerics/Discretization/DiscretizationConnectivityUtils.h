// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCANEDEMO_SCHEMEAPI2016_DISCRETIZATIONCONNECTIVITYUTILS_H
#define ARCANEDEMO_SCHEMEAPI2016_DISCRETIZATIONCONNECTIVITYUTILS_H
/* Author : encheryg at Wed Feb 17 10:23:31 2016
 * Generated by createNew
 */
#include <vector>
#include <memory>
#include <functional>
#include <set>

#include <arcane/MeshToMeshTransposer.h>

#include <ArcGeoSim/Utils/ItemGroupMap.h>

// A remplacer par les sources Arcane
#include "ExtendedDoFConnectivity.h"
#include "Discretization.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

// Aliases
template<typename T>
using ExtendedConnectivityT = Arcane::ExtendedItemDoFConnectivityT<T, typename Discretization::ConvertA2D<T>::Type> ;

using CellExtendedConnectivity = ExtendedConnectivityT<Arcane::Cell> ;
using FaceExtendedConnectivity = ExtendedConnectivityT<Arcane::Face> ;
using NodeExtendedConnectivity = ExtendedConnectivityT<Arcane::Node> ;
using ContactExtendedConnectivity = Arcane::ContactDoFConnectivity ;

template<typename T>
using ReverseExtendedConnectivityT = Arcane::ExtendedItemDoFConnectivityT<T, typename Discretization::ConvertD2A<T>::Type> ;

using CellReverseExtendedConnectivity = ReverseExtendedConnectivityT<Discretization::Cell> ;
using FaceReverseExtendedConnectivity = ReverseExtendedConnectivityT<Discretization::Face> ;
using NodeReverseExtendedConnectivity = ReverseExtendedConnectivityT<Discretization::Node> ;

template<typename T, typename U>
using ExtendedMultiConnectivityTU = Arcane::ExtendedItemMultiArrayDoFConnectivityT<T, U> ; 

using FaceCellExtendedMultiConnectivity = ExtendedMultiConnectivityTU<Discretization::Face, Discretization::Cell> ;
using CellFaceExtendedMultiConnectivity = ExtendedMultiConnectivityTU<Discretization::Cell, Discretization::Face> ;
using NodeCellExtendedMultiConnectivity = ExtendedMultiConnectivityTU<Discretization::Node, Discretization::Cell> ;
using CellNodeExtendedMultiConnectivity = ExtendedMultiConnectivityTU<Discretization::Cell, Discretization::Node> ;
using NodeFaceExtendedMultiConnectivity = ExtendedMultiConnectivityTU<Discretization::Node, Discretization::Face> ;
using FaceNodeExtendedMultiConnectivity = ExtendedMultiConnectivityTU<Discretization::Face, Discretization::Node> ;

template<typename T>
using ExtendedMultiConnectivityT = Arcane::ExtendedItemMultiArrayDoFConnectivityT<T, typename Discretization::ConvertA2D<T>::Type> ; 

using FaceExtendedMultiConnectivity = ExtendedMultiConnectivityT<Arcane::Face> ;

template<typename T>
using ExtendedConnectivityTUPtr = 
  std::unique_ptr<ExtendedConnectivityT<T>> ;

using CellExtendedConnectivityUPtr = std::unique_ptr<CellExtendedConnectivity> ;
using FaceExtendedConnectivityUPtr = std::unique_ptr<FaceExtendedConnectivity> ;
using NodeExtendedConnectivityUPtr = std::unique_ptr<NodeExtendedConnectivity> ;
using ContactExtendedConnectivityUPtr = std::unique_ptr<ContactExtendedConnectivity> ;

template<typename T>
using ReverseExtendedConnectivityTUPtr = 
  std::unique_ptr<ReverseExtendedConnectivityT<T>> ;

using CellReverseExtendedConnectivityUPtr = std::unique_ptr<CellReverseExtendedConnectivity> ;
using FaceReverseExtendedConnectivityUPtr = std::unique_ptr<FaceReverseExtendedConnectivity> ;
using NodeReverseExtendedConnectivityUPtr = std::unique_ptr<NodeReverseExtendedConnectivity> ;

template<typename T, typename U>
using ExtendedMultiConnectivityTUUPtr = 
  std::unique_ptr<ExtendedMultiConnectivityTU<T, U>> ;

template<typename T>
using ExtendedMultiConnectivityTUPtr = 
  std::unique_ptr<ExtendedMultiConnectivityT<T>> ;

using FaceCellExtendedMultiConnectivityUPtr = std::unique_ptr<FaceCellExtendedMultiConnectivity> ;
using CellFaceExtendedMultiConnectivityUPtr = std::unique_ptr<CellFaceExtendedMultiConnectivity> ;
using NodeCellExtendedMultiConnectivityUPtr = std::unique_ptr<NodeCellExtendedMultiConnectivity> ;
using CellNodeExtendedMultiConnectivityUPtr = std::unique_ptr<CellNodeExtendedMultiConnectivity> ;
using NodeFaceExtendedMultiConnectivityUPtr = std::unique_ptr<NodeFaceExtendedMultiConnectivity> ;
using FaceNodeExtendedMultiConnectivityUPtr = std::unique_ptr<FaceNodeExtendedMultiConnectivity> ;

using FaceExtendedMultiConnectivityUPtr = std::unique_ptr<FaceExtendedMultiConnectivity> ;

using ConnectivityMap = Arcane::ItemScalarProperty<Arcane::Int32> ;
using MultiConnectivityMap = Arcane::ItemMultiArrayProperty<Arcane::Int32> ;

using DisGroupNameInitList = std::initializer_list < std::pair<Discretization::ItemGroup*, Arcane::String> > ;

typedef unsigned int uint ;
 
namespace DiscretizationConnectivityUtils {
  template<typename T> struct GroupForConnectivity {} ;
  template<> struct GroupForConnectivity<Discretization::Cell> {using Type = Arcane::CellGroup ;} ;
  template<> struct GroupForConnectivity<Discretization::Face> {using Type = Arcane::FaceGroup ;} ;
  template<> struct GroupForConnectivity<Discretization::Node> {using Type = Arcane::NodeGroup ;} ;

  template<typename T,typename U> struct GroupForMultiConnectivity {} ;
  template<> struct GroupForMultiConnectivity<Discretization::Cell,Discretization::Face> {using Type = Arcane::FaceGroup ;} ;
  template<> struct GroupForMultiConnectivity<Discretization::Face,Discretization::Cell> {using Type = Arcane::FaceGroup ;} ;
  template<> struct GroupForMultiConnectivity<Discretization::Node,Discretization::Cell> {using Type = Arcane::NodeGroup ;} ;
  template<> struct GroupForMultiConnectivity<Discretization::Cell,Discretization::Node> {using Type = Arcane::CellGroup ;} ;
  template<> struct GroupForMultiConnectivity<Discretization::Face,Discretization::Node> {using Type = Arcane::FaceGroup ;} ;
  template<> struct GroupForMultiConnectivity<Discretization::Node,Discretization::Face> {using Type = Arcane::NodeGroup ;} ;

  template<typename T> struct ExtConnectivityUPtr {using Type = ExtendedConnectivityTUPtr<T> ;} ;
  template<> struct ExtConnectivityUPtr<Contact> {using Type = ContactExtendedConnectivityUPtr ;} ;
  template<typename T> struct ExtMultiConnectivityUPtr {using Type = ExtendedMultiConnectivityTUPtr<T> ;} ;

  template<typename T>
  struct AMRT {
    static bool isActive(const Arcane::Item i) {return i.toCell().isActive() ;}
  } ;

  template<>
  struct AMRT<Arcane::Face> {
    static bool isActive(const Arcane::Item i) {
      const Arcane::Face f(i.toFace()) ;

      return (f.isSubDomainBoundary() && f.boundaryCell().isActive()) ||
        (not f.isSubDomainBoundary() && f.backCell().isActive() && f.frontCell().isActive()) ;
    }
  };

  template<typename T, template<typename> class U>
  using ConvTSRefVec = 
    Arcane::UniqueArray<std::reference_wrapper<U<typename Discretization::ConvertD2A<T>::Type>>> ;

  template<typename T, typename U>
  using GroupForMultiConnectivityTRefVec = 
    Arcane::UniqueArray<std::reference_wrapper<typename GroupForMultiConnectivity<T,U>::Type>> ;

  template<typename T, typename U, typename V>
  struct connectivityAccessT {
    static V get(const U& i, T& c, 
                 const Discretization::Pair n = Discretization::Pair::First) 
    {return c(i) ;}
  } ;

  template<>
  struct connectivityAccessT<FaceExtendedMultiConnectivity, Arcane::Face, Discretization::Face> {
    static Discretization::Face get(const Arcane::Face& i, FaceExtendedMultiConnectivity& c, 
                                    const Discretization::Pair n = Discretization::Pair::First) 
    {Discretization::ConnectedItems iv(c(i)) ; return iv[static_cast<Arcane::Integer>(n)] ;}
  } ;

  template<typename T, typename U, bool surfaceMesh>
  struct MultiConnectivityTreatmentsT ;

  template<>
  struct MultiConnectivityTreatmentsT<Discretization::Face, Discretization::Cell, false>  {
    MultiConnectivityTreatmentsT(const FaceExtendedConnectivity& faceEC,
                                 const CellExtendedConnectivity& cellEC,
                                 const Arcane::FaceGroup& faceGroup,
                                 const Arcane::VariableCellBool& cellGroupFlags,
                                 const ContactGroup cg,
                                 const ContactExtendedConnectivityUPtr& contactECUPtr)
      : 
      m_faceEC(faceEC)
      , m_cellEC(cellEC)
      , m_faceGroup(faceGroup)
      , m_cellGroupFlags(cellGroupFlags)
      , m_cg(cg)
      , m_contactECUPtr(contactECUPtr) {}

    Discretization::Family* familyT() const {return dynamic_cast<Discretization::Family*>(m_faceEC.targetFamily()) ;}

    Discretization::Family* familyU() const {return dynamic_cast<Discretization::Family*>(m_cellEC.targetFamily()) ;}

    void count(Arcane::IntegerUniqueArray& nbTToU) const {
      std::function<void (const Discretization::Face&, const Discretization::Cell&)> action = 
        [&nbTToU](const Discretization::Face& f, const Discretization::Cell& c) {
        const Arcane::Integer disFaceLId = f.localId() ;
        ++nbTToU[disFaceLId] ;
      } ;

      _loop(action) ;
    }      

    void map(MultiConnectivityMap& TToUMap) const {
      Arcane::IntegerUniqueArray currentNbTToU(m_faceEC.targetFamily() -> maxLocalId(), 0) ;

     std::function<void (const Discretization::Face&, const Discretization::Cell&)> action = 
       [&TToUMap, &currentNbTToU](const Discretization::Face& f, const Discretization::Cell& c) {
            const Arcane::Integer disFaceLId = f.localId() ;
            const Arcane::Integer disCellLId = c.localId() ;

            TToUMap[f][currentNbTToU[disFaceLId]] = disCellLId ;
            ++currentNbTToU[disFaceLId] ;
      } ;

      _loop(action) ;
    }

  protected:

    virtual void _loop(const std::function<void (const Discretization::Face&, const Discretization::Cell&)>& action ) const {
      ENUMERATE_FACE(iFace, m_faceGroup) {
        const Discretization::Face disFace(m_faceEC(iFace)) ;
        
        if(iFace -> isSubDomainBoundary()) {
          const auto boundaryCell(iFace -> boundaryCell()) ;

          if(m_cellGroupFlags[boundaryCell]) {
            const Discretization::Cell disCell(m_cellEC(boundaryCell)) ;
            action(disFace, disCell) ;
          }
        } else {
          const Arcane::Cell backCell(iFace -> backCell()) ;
          
          if(m_cellGroupFlags[backCell]) {
            const Discretization::Cell disCell(m_cellEC(backCell)) ;
            action(disFace, disCell) ;
          }
            
          const Arcane::Cell frontCell(iFace -> frontCell()) ;

          if(m_cellGroupFlags[frontCell]) {
            const Discretization::Cell disCell(m_cellEC(frontCell)) ;
            action(disFace, disCell) ;
          }
        }
      }

      if(m_contactECUPtr != nullptr) {
        ENUMERATE_FACEFACECONTACT(icontact, m_cg) {
          const FaceFaceContact contact = *icontact ;

          const Arcane::Face face1(contact.face1()) ;

          if(not face1.null()) {
            const Arcane::Cell cell(face1.boundaryCell()) ;

            if(cell.isActive() && m_cellGroupFlags[cell]) {
              const Discretization::Face disFace((*m_contactECUPtr)(icontact)) ;          
              const Discretization::Cell disCell(m_cellEC(cell)) ;

              action(disFace, disCell) ;
            }
          }

          const Arcane::Face face2(contact.face2()) ;

          if(not face2.null()) {
            const Arcane::Cell cell(face2.boundaryCell()) ;

            if(cell.isActive() && m_cellGroupFlags[cell]) {
              const Discretization::Face disFace((*m_contactECUPtr)(icontact)) ;
              const Discretization::Cell disCell(m_cellEC(cell)) ;
          
              action(disFace, disCell) ;
            }
          }
        }
      }
    }

    const FaceExtendedConnectivity& m_faceEC ;
    const CellExtendedConnectivity& m_cellEC ;
    const Arcane::FaceGroup& m_faceGroup ;
    const Arcane::VariableCellBool& m_cellGroupFlags ;
    const ContactGroup m_cg ;
    const ContactExtendedConnectivityUPtr& m_contactECUPtr ;
  } ;

  template<>
  struct MultiConnectivityTreatmentsT<Discretization::Face, Discretization::Cell, true>  :
    public MultiConnectivityTreatmentsT<Discretization::Face, Discretization::Cell, false> {
    MultiConnectivityTreatmentsT(const FaceExtendedConnectivity& faceEC,
                                 const FaceExtendedMultiConnectivity& surfFaceEC,
                                 const CellExtendedConnectivity& cellEC,
                                 const CellExtendedConnectivity& surfCellEC,
				 const ContactExtendedConnectivity* faultCoreContactEC,
                                 const Arcane::FaceGroup& faceGroup,
                                 const Arcane::FaceGroup& surfFaceGroup,
                                 const Arcane::CellGroup& surfCellGroup,
                                 const Arcane::VariableCellBool& cellGroupFlags,
                                 const Arcane::VariableCellBool& surfCellGroupFlags,
                                 const ContactGroup cg,
                                 const ContactExtendedConnectivityUPtr& contactECUPtr,
                                 Arcane::IMesh* surfMesh,
                                 const ConnectivityMap& faceToSurfCellLIdMap)
      : MultiConnectivityTreatmentsT<Discretization::Face, Discretization::Cell, false>(faceEC,
                                                                                        cellEC,
                                                                                        faceGroup,
                                                                                        cellGroupFlags,
                                                                                        cg,
                                                                                        contactECUPtr)
      , m_surfFaceEC(surfFaceEC)
      , m_surfCellEC(surfCellEC)
      , m_faultCoreContactEC(faultCoreContactEC)
      , m_surfFaceGroup(surfFaceGroup)
      , m_surfCellGroup(surfCellGroup)
      , m_surfCellGroupFlags(surfCellGroupFlags)
      , m_surfMesh(surfMesh)
      , m_faceToSurfCellLIdMap(faceToSurfCellLIdMap) {}

  private:

    void _loop(const std::function<void (const Discretization::Face&, const Discretization::Cell&)>& action) const {
      ENUMERATE_FACE(iFace, m_faceGroup) {
        const Discretization::Face disFace(m_faceEC(iFace)) ;

        if(iFace -> isSubDomainBoundary()) {
          const auto boundaryCell(iFace -> boundaryCell()) ;

          if(m_cellGroupFlags[boundaryCell]) {
            const Discretization::Cell disCell(m_cellEC(boundaryCell)) ;
            action(disFace, disCell) ;
          }
        } else {
          const Arcane::Cell backCell(iFace -> backCell()) ;
          
          if(m_cellGroupFlags[backCell]) {
            const Discretization::Cell disCell(m_cellEC(backCell)) ;
            action(disFace, disCell) ;
          }
            
          const Arcane::Cell frontCell(iFace -> frontCell()) ;

          if(m_cellGroupFlags[frontCell]) {
            const Discretization::Cell disCell(m_cellEC(frontCell)) ;
            action(disFace, disCell) ;
          }
        }
      }

      ENUMERATE_FACE(iFace, m_surfFaceGroup) {
        Discretization::ConnectedItems iv(m_surfFaceEC(iFace));
        
        bool duplicatedFace(iv.size() == 2) ;
        
        const Discretization::Face disFace(iv[0]) ;
        
        if(iFace -> isSubDomainBoundary()) {
          const Discretization::Cell disCell(m_surfCellEC(iFace -> boundaryCell())) ;
          action(disFace, disCell) ;
        } else {
          const Arcane::Cell backCell(iFace -> backCell()) ;
          const Arcane::Cell frontCell(iFace -> frontCell()) ;
          
          if(duplicatedFace) {
            if(backCell.isActive() && m_surfCellGroupFlags[backCell]) {
              const Discretization::Cell disCell(m_surfCellEC(backCell)) ;
              action(disFace, disCell) ;
            }
            
            if(frontCell.isActive() && m_surfCellGroupFlags[frontCell]) {
              const Discretization::Face disFace2(iv[1]) ;
              const Discretization::Cell disCell(m_surfCellEC(frontCell)) ;

              action(disFace2, disCell) ;
            }
          } else {
            if(m_surfCellGroupFlags[backCell]) {
              const Discretization::Cell disCell(m_surfCellEC(backCell)) ;
              action(disFace, disCell) ;
            }
            
            if(m_surfCellGroupFlags[frontCell]) {
              const Discretization::Cell disCell(m_surfCellEC(frontCell)) ;
              action(disFace, disCell) ;
            }
          }
        }
      }

      ENUMERATE_CELL(iCell, m_surfCellGroup) {
        const Discretization::Cell disCell(m_surfCellEC(iCell)) ;
        const Arcane::Face parentFace(iCell -> parent().toFace()) ;
        const Discretization::Face disFace(m_faceEC(parentFace)) ;

        action(disFace, disCell) ;
      }

      const Arcane::ItemInternalArrayView surfCellsInternalView(m_surfMesh -> cellFamily() -> itemsInternal()) ;

      if(m_contactECUPtr != nullptr) {
        ENUMERATE_FACEFACECONTACT(icontact, m_cg) {
          const FaceFaceContact contact = *icontact ;

          const Arcane::Face face1(contact.face1()) ;

          Discretization::Face disContactFace((*m_contactECUPtr)(icontact, 0)) ;

          if(not face1.null() && m_faceToSurfCellLIdMap[face1] != Arcane::NULL_ITEM_LOCAL_ID) {
            const Arcane::Cell surfCell(surfCellsInternalView[m_faceToSurfCellLIdMap[face1]]) ;

            if(surfCell.isActive() && m_surfCellGroupFlags[surfCell]) {
              const Discretization::Cell disCell(m_surfCellEC(surfCell)) ;

              action(disContactFace, disCell) ;
            }
          }

          // Adds fault core
          if(m_faultCoreContactEC != nullptr) {
            const Discretization::Cell disCoreCell((*m_faultCoreContactEC)(icontact)) ;

            action(disContactFace, disCoreCell) ;
          }

          const Arcane::Integer nbConnectedItems((*m_contactECUPtr).nbConnectedItem((Arcane::ItemLocalId)contact.localId())) ;

          if(nbConnectedItems == 2)
            disContactFace = (*m_contactECUPtr)(icontact, 1) ;

          const Arcane::Face face2(contact.face2()) ;

          if(not face2.null() && m_faceToSurfCellLIdMap[face2] != Arcane::NULL_ITEM_LOCAL_ID) {
            const Arcane::Cell surfCell(surfCellsInternalView[m_faceToSurfCellLIdMap[face2]]) ;
            
            if(surfCell.isActive() && m_surfCellGroupFlags[surfCell]) {
              const Discretization::Cell disCell(m_surfCellEC(surfCell)) ;
          
              action(disContactFace, disCell) ;
            }
          }

          // Adds fault core
          if(m_faultCoreContactEC != nullptr) {
            const Discretization::Cell disCoreCell((*m_faultCoreContactEC)(icontact)) ;
            action(disContactFace, disCoreCell) ;
          }
        }
      }
    }

    const FaceExtendedMultiConnectivity& m_surfFaceEC ;
    const CellExtendedConnectivity& m_surfCellEC ;
    const ContactExtendedConnectivity* m_faultCoreContactEC ;
    const Arcane::FaceGroup& m_surfFaceGroup ;
    const Arcane::CellGroup& m_surfCellGroup ;
    const Arcane::VariableCellBool& m_surfCellGroupFlags ;
    Arcane::IMesh* m_surfMesh ;
    const ConnectivityMap& m_faceToSurfCellLIdMap ;
  } ;

 template<>
  struct MultiConnectivityTreatmentsT<Discretization::Cell, Discretization::Face, false>  {
    MultiConnectivityTreatmentsT(const CellExtendedConnectivity& cellEC,
                                 const FaceExtendedConnectivity& faceEC,
                                 const Arcane::FaceGroup& faceGroup,
                                 const Arcane::VariableCellBool& cellGroupFlags,
                                 const ContactGroup cg,
                                 const ContactExtendedConnectivityUPtr& contactECUPtr)
      : 
      m_cellEC(cellEC)
      , m_faceEC(faceEC)
      , m_faceGroup(faceGroup)
      , m_cellGroupFlags(cellGroupFlags)
      , m_cg(cg)
      , m_contactECUPtr(contactECUPtr) {}

    Discretization::Family* familyT() const {return dynamic_cast<Discretization::Family*>(m_cellEC.targetFamily()) ;}

    Discretization::Family* familyU() const {return dynamic_cast<Discretization::Family*>(m_faceEC.targetFamily()) ;}

    void count(Arcane::IntegerUniqueArray& nbTToU) const {

      std::function<void (const Discretization::Cell&, const Discretization::Face&)> action = 
        [&nbTToU](const Discretization::Cell& c, const Discretization::Face& f) {
        const Arcane::Integer disCellLId = c.localId() ;
        ++nbTToU[disCellLId] ;
      } ;

      _loop(action) ;
    }

    void map(MultiConnectivityMap& TToUMap) const {
      Arcane::IntegerUniqueArray currentNbTToU(m_cellEC.targetFamily() -> maxLocalId(), 0) ;

      std::function<void (const Discretization::Cell&, const Discretization::Face&)> action = 
        [&currentNbTToU, &TToUMap](const Discretization::Cell& c, const Discretization::Face& f) {
            const Arcane::Integer disCellLId = c.localId() ;
            const Arcane::Integer disFaceLId = f.localId() ;

            TToUMap[c][currentNbTToU[disCellLId]] = disFaceLId ;
            ++currentNbTToU[disCellLId] ;
      } ;

      _loop(action) ;      
    }

  protected:

   virtual void _loop(const std::function<void (const Discretization::Cell&, const Discretization::Face&)>& action) const {

     ENUMERATE_FACE(iface, m_faceGroup) {
       const Discretization::Face disFace(m_faceEC(iface)) ;

       if(iface -> isSubDomainBoundary()) {
         const Arcane::Cell cell(iface -> boundaryCell()) ;

         if(m_cellGroupFlags[cell]) {
           const Discretization::Cell disCell(m_cellEC(cell)) ;

           action(disCell, disFace) ;
         }
       } else {
         const Arcane::Cell backCell(iface -> backCell()) ;
         
         if(m_cellGroupFlags[backCell]) {
           const Discretization::Cell disBackCell(m_cellEC(backCell)) ;
           
           action(disBackCell, disFace) ;
         }
         
         const Arcane::Cell frontCell(iface -> frontCell()) ;
         
         if(m_cellGroupFlags[frontCell]) {
           const Discretization::Cell disFrontCell(m_cellEC(frontCell)) ;
           
           action(disFrontCell, disFace) ;
         }
       }
     }

     if(m_contactECUPtr != nullptr) {
       ENUMERATE_FACEFACECONTACT(icontact, m_cg) {
         const FaceFaceContact contact = *icontact ;
         const Discretization::Face disFace((*m_contactECUPtr)(contact)) ;

         const Arcane::Face face1(contact.face1()) ;
         
         if(not face1.null()) {
           const Arcane::Cell cell1(face1.boundaryCell()) ;

           if(m_cellGroupFlags[cell1]) {
             const Discretization::Cell disCell1(m_cellEC(cell1)) ; ;

             action(disCell1, disFace) ;
           }
         }

         const Arcane::Face face2(contact.face2()) ;

         if(not face2.null()) {
           const Arcane::Cell cell2(face2.boundaryCell()) ;

           if(m_cellGroupFlags[cell2]) {
             const Discretization::Cell disCell2(m_cellEC(cell2)) ; ;

             action(disCell2, disFace) ;
           }
         }         
       }
     }
   }

    const CellExtendedConnectivity& m_cellEC ;
    const FaceExtendedConnectivity& m_faceEC ;
    const Arcane::FaceGroup& m_faceGroup ;
    const Arcane::VariableCellBool& m_cellGroupFlags ;
    const ContactGroup m_cg ;
    const ContactExtendedConnectivityUPtr& m_contactECUPtr ;
 } ;

  template<>
  struct MultiConnectivityTreatmentsT<Discretization::Cell, Discretization::Face, true> :
    public MultiConnectivityTreatmentsT<Discretization::Cell, Discretization::Face, false> {
    MultiConnectivityTreatmentsT(const CellExtendedConnectivity& cellEC,
                                 const CellExtendedConnectivity& surfCellEC,
                                 const FaceExtendedConnectivity& faceEC,
                                 const FaceExtendedMultiConnectivity& surfFaceEC,
				 const ContactExtendedConnectivity* faultCoreContactEC,
                                 const Arcane::FaceGroup& faceGroup,
                                 const Arcane::FaceGroup& surfFaceGroup,
                                 const Arcane::CellGroup& surfCellGroup,
                                 const Arcane::VariableCellBool& cellGroupFlags,
                                 const Arcane::VariableCellBool& surfCellGroupFlags,
                                 const ContactGroup cg,
                                 const ContactExtendedConnectivityUPtr& contactECUPtr,
                                 Arcane::IMesh* surfMesh,
                                 const ConnectivityMap& faceToSurfCellLIdMap)
      : MultiConnectivityTreatmentsT<Discretization::Cell, Discretization::Face, false>(cellEC,
                                                                                        faceEC,
                                                                                        faceGroup,
                                                                                        cellGroupFlags,
                                                                                        cg,
                                                                                        contactECUPtr)
      , m_surfCellEC(surfCellEC)
      , m_surfFaceEC(surfFaceEC)
      , m_faultCoreContactEC(faultCoreContactEC)
      , m_surfFaceGroup(surfFaceGroup)
      , m_surfCellGroup(surfCellGroup)
      , m_surfCellGroupFlags(surfCellGroupFlags)
      , m_surfMesh(surfMesh)
      , m_faceToSurfCellLIdMap(faceToSurfCellLIdMap) {}

  private:

    void _loop(const std::function<void (const Discretization::Cell&, const Discretization::Face&)>& action) const {

      ENUMERATE_FACE(iFace, m_faceGroup) {
        const Discretization::Face disFace(m_faceEC(iFace)) ;
        
        if(iFace -> isSubDomainBoundary()) {
          const Arcane::Cell cell(iFace -> boundaryCell()) ;
          
          if(m_cellGroupFlags[cell]) {
            const Discretization::Cell disCell(m_cellEC(cell)) ;
            
            action(disCell, disFace) ;
          }
        } else {
          const Arcane::Cell backCell(iFace -> backCell()) ;
          
          if(m_cellGroupFlags[backCell]) {
            const Discretization::Cell disBackCell(m_cellEC(backCell)) ;
            
            action(disBackCell, disFace) ;
          }
          
          const Arcane::Cell frontCell(iFace -> frontCell()) ;
          
          if(m_cellGroupFlags[frontCell]) {
            const Discretization::Cell disFrontCell(m_cellEC(frontCell)) ;
            
            action(disFrontCell, disFace) ;
          }
        }
      }

      ENUMERATE_FACE(iFace, m_surfFaceGroup) {
        Discretization::ConnectedItems iv(m_surfFaceEC(iFace));
        
        bool duplicatedFace(iv.size() == 2) ;
        
        const Discretization::Face disFace(iv[0]) ;
        
        if(iFace -> isSubDomainBoundary()) {
          const Discretization::Cell disCell(m_surfCellEC(iFace -> boundaryCell())) ;
          action(disCell, disFace) ;
        } else {
          const Arcane::Cell backCell(iFace -> backCell()) ;
          const Arcane::Cell frontCell(iFace -> frontCell()) ;
          
          if(duplicatedFace) {
            if(m_surfCellGroupFlags[backCell]) {
              const Discretization::Cell disCell(m_surfCellEC(backCell)) ;
              action(disCell, disFace) ;
            }
            
            if(m_surfCellGroupFlags[frontCell]) {
              const Discretization::Face disFace2(iv[1]) ;
              const Discretization::Cell disCell(m_surfCellEC(frontCell)) ;

              action(disCell, disFace2) ;
            }
          } else {
            if(m_surfCellGroupFlags[backCell]) {
              const Discretization::Cell disCell(m_surfCellEC(backCell)) ;
              action(disCell, disFace) ;
            }
            
            if(m_surfCellGroupFlags[frontCell]) {
              const Discretization::Cell disCell(m_surfCellEC(frontCell)) ;
              action(disCell, disFace) ;
            }
          }
        }
      }

      ENUMERATE_CELL(iCell, m_surfCellGroup) {
        const Discretization::Cell disCell(m_surfCellEC(iCell)) ;
        const Arcane::Face parentFace(iCell -> parent().toFace()) ;
        const Discretization::Face disFace(m_faceEC(parentFace)) ; 

        action(disCell, disFace) ;
      }

      const Arcane::ItemInternalArrayView surfCellsInternalView(m_surfMesh -> cellFamily() -> itemsInternal()) ;

      if(m_contactECUPtr != nullptr) {
        ENUMERATE_FACEFACECONTACT(icontact, m_cg) {
          const FaceFaceContact contact = *icontact ;

          const Arcane::Face face1(contact.face1()) ;

          Discretization::Face disContactFace((*m_contactECUPtr)(icontact, 0)) ;

          if(not face1.null() && m_faceToSurfCellLIdMap[face1] != Arcane::NULL_ITEM_LOCAL_ID) {
            const Arcane::Cell surfCell(surfCellsInternalView[m_faceToSurfCellLIdMap[face1]]) ;

            if(m_surfCellGroupFlags[surfCell]) {
              const Discretization::Cell disCell(m_surfCellEC(surfCell)) ;

              action(disCell, disContactFace) ;
            }
          }

          // Adds fault core
          if(m_faultCoreContactEC != nullptr) {
            const Discretization::Cell disCoreCell((*m_faultCoreContactEC)(icontact)) ;

            action(disCoreCell, disContactFace) ;
          }

          const Arcane::Integer nbConnectedItems((*m_contactECUPtr).nbConnectedItem((Arcane::ItemLocalId)contact.localId())) ;

          if(nbConnectedItems == 2)
            disContactFace = (*m_contactECUPtr)(icontact, 1) ;

          const Arcane::Face face2(contact.face2()) ;

          if(not face2.null() && m_faceToSurfCellLIdMap[face2] != Arcane::NULL_ITEM_LOCAL_ID) {
            const Arcane::Cell surfCell(surfCellsInternalView[m_faceToSurfCellLIdMap[face2]]) ;
            
            if(m_surfCellGroupFlags[surfCell]) {
              const Discretization::Cell disCell(m_surfCellEC(surfCell)) ;
          
              action(disCell, disContactFace) ;
            }
          }

          // Adds fault core
          if(m_faultCoreContactEC != nullptr) {
            const Discretization::Cell disCoreCell((*m_faultCoreContactEC)(icontact)) ;

            action(disCoreCell, disContactFace) ;
          }
        }
      }      
    }

    const CellExtendedConnectivity& m_surfCellEC ;
    const FaceExtendedMultiConnectivity& m_surfFaceEC ;
    const ContactExtendedConnectivity* m_faultCoreContactEC ;
    const Arcane::FaceGroup& m_surfFaceGroup ;
    const Arcane::CellGroup& m_surfCellGroup ;
    const Arcane::VariableCellBool& m_surfCellGroupFlags ;
    Arcane::IMesh* m_surfMesh ;
    const ConnectivityMap& m_faceToSurfCellLIdMap ;
  } ;

  template<>
  struct MultiConnectivityTreatmentsT<Discretization::Node, Discretization::Cell, false> {
    MultiConnectivityTreatmentsT(const Arcane::Integer maxArcaneNodeLocalId, 
                                 const Arcane::Integer maxArcaneCellLocalId,
                                 const NodeExtendedConnectivity& nodeEC,
                                 const CellExtendedConnectivity& cellEC,
                                 const Arcane::NodeGroup& nodeGroup,
                                 const Arcane::VariableCellBool& cellGroupFlags) 
      : m_nodeEC(nodeEC)
      , m_cellEC(cellEC)
      , m_nodeGroup(nodeGroup)
      , m_cellGroupFlags(cellGroupFlags) {}

    Discretization::Family* familyT() const {return dynamic_cast<Discretization::Family*>(m_nodeEC.targetFamily()) ;}

    Discretization::Family* familyU() const {return dynamic_cast<Discretization::Family*>(m_cellEC.targetFamily()) ;}

    void count(Arcane::IntegerUniqueArray& nbTToU) const {
      std::function<void (const Discretization::Node&, const Discretization::Cell&)> action = 
        [&nbTToU](const Discretization::Node& n, const Discretization::Cell& c) {
        const Arcane::Integer disNodeLId = n.localId() ;
        ++nbTToU[disNodeLId] ;
      } ;

      _loop(action) ;
    }

    void map(MultiConnectivityMap& TToUMap) const {
      Arcane::IntegerUniqueArray currentNbTToU(m_nodeEC.targetFamily() -> maxLocalId(), 0) ;

      std::function<void (const Discretization::Node&, const Discretization::Cell&)> action = 
      [&currentNbTToU, &TToUMap](const Discretization::Node& n, const Discretization::Cell& c) {
        const Arcane::Integer disNodeLId = n.localId() ;
        const Arcane::Integer disCellLId = c.localId() ;

        TToUMap[n][currentNbTToU[disNodeLId]] = disCellLId ;
        ++currentNbTToU[disNodeLId] ;
      } ;

      _loop(action) ;
    }

  private:

    void _loop(const std::function<void (const Discretization::Node&, const Discretization::Cell&)>& action) const {

      ENUMERATE_NODE(inode, m_nodeGroup) {
        const Discretization::Node disNode(m_nodeEC(inode)) ;
        std::set<Arcane::Integer> cellLIdSet ;

        ENUMERATE_FACE(iface, inode -> faces()) {
          if(iface -> isSubDomainBoundary()) {
            const Arcane::Cell boundaryCell(iface -> boundaryCell()) ;
            const Arcane::Integer boundaryCellLId(boundaryCell.localId()) ;
            const bool inserted(cellLIdSet.insert(boundaryCellLId).second) ;

            if(m_cellGroupFlags[boundaryCell] && inserted) {
              const Discretization::Cell disBoundaryCell(m_cellEC(boundaryCell)) ;
              action(disNode, disBoundaryCell) ;
            }
          } else {
            const Arcane::Cell backCell(iface -> backCell()) ;
            const Arcane::Integer backCellLId(backCell.localId()) ;
            bool inserted(cellLIdSet.insert(backCellLId).second) ;

            if(m_cellGroupFlags[backCell] && inserted) {
              const Discretization::Cell disBackCell(m_cellEC(backCell)) ;

              action(disNode, disBackCell) ;
            }

            const Arcane::Cell frontCell(iface -> frontCell()) ;
            const Arcane::Integer frontCellLId(frontCell.localId()) ;
            inserted = cellLIdSet.insert(frontCellLId).second ;

            if(m_cellGroupFlags[frontCell] && inserted) {
              const Discretization::Cell disFrontCell(m_cellEC(frontCell)) ;

              action(disNode, disFrontCell) ;
            }
          }
        }
      }
    }

    const NodeExtendedConnectivity& m_nodeEC ;
    const CellExtendedConnectivity& m_cellEC ;
    const Arcane::NodeGroup& m_nodeGroup ;
    const Arcane::VariableCellBool& m_cellGroupFlags ;
  } ;

  template<>
  struct MultiConnectivityTreatmentsT<Discretization::Cell, Discretization::Node, false> {
    MultiConnectivityTreatmentsT(const CellExtendedConnectivity& cellEC,
                                 const NodeExtendedConnectivity& nodeEC,
                                 const Arcane::CellGroup& cellGroup) 
      : m_cellEC(cellEC)
      , m_nodeEC(nodeEC)
      , m_cellGroup(cellGroup){}

    Discretization::Family* familyT() const {return dynamic_cast<Discretization::Family*>(m_cellEC.targetFamily()) ;}

    Discretization::Family* familyU() const {return dynamic_cast<Discretization::Family*>(m_nodeEC.targetFamily()) ;}

    void count(Arcane::IntegerUniqueArray& nbTToU) const {
      std::function<void (const Discretization::Cell&, const Discretization::Node&)> action = 
        [&nbTToU](const Discretization::Cell& c, const Discretization::Node& n) {
        const Arcane::Integer disCellLId = c.localId() ;
        ++nbTToU[disCellLId] ;
      } ;

      _loop(action) ;
    }

    void map(MultiConnectivityMap& TToUMap) const {
      Arcane::IntegerUniqueArray currentNbTToU(m_cellEC.targetFamily() -> maxLocalId(), 0) ;

      std::function<void (const Discretization::Cell&, const Discretization::Node&)> action = 
      [&currentNbTToU, &TToUMap](const Discretization::Cell& c, const Discretization::Node& n) {
        const Arcane::Integer disCellLId = c.localId() ;
        const Arcane::Integer disNodeLId = n.localId() ;

        TToUMap[c][currentNbTToU[disCellLId]] = disNodeLId ;
        ++currentNbTToU[disCellLId] ;
      } ;

      _loop(action) ;
    }

  private:

    void _loop(const std::function<void (const Discretization::Cell&, const Discretization::Node&)>& action) const {
      ENUMERATE_CELL(icell, m_cellGroup){
        const Discretization::Cell disCell(m_cellEC(icell)) ;

        ENUMERATE_NODE(inode, icell -> nodes()) {
          const Discretization::Node disNode(m_nodeEC(inode)) ;

          action(disCell, disNode) ;
        }
      }
    }

    const CellExtendedConnectivity& m_cellEC ;
    const NodeExtendedConnectivity& m_nodeEC ;
    const Arcane::CellGroup& m_cellGroup ;
  } ;


  template<>
  struct MultiConnectivityTreatmentsT<Discretization::Node, Discretization::Face, false> {
    MultiConnectivityTreatmentsT(const NodeExtendedConnectivity& nodeEC,
                                 const FaceExtendedConnectivity& faceEC,
                                 const Arcane::NodeGroup& nodeGroup,
                                 const Arcane::VariableCellBool& cellGroupFlags,
                                 const ItemGroupSet& contactFacesSet,
                                 const Arcane::BoolArray& ownCellNeighbourFlag)
  : m_nodeEC(nodeEC)
  , m_faceEC(faceEC)
  , m_nodeGroup(nodeGroup)
  , m_cellGroupFlags(cellGroupFlags)
  , m_contactFacesSet(contactFacesSet)
  , m_ownCellNeighbourFlag(ownCellNeighbourFlag) {}

    
    Discretization::Family* familyT() const {return dynamic_cast<Discretization::Family*>(m_nodeEC.targetFamily()) ;}
    
    Discretization::Family* familyU() const {return dynamic_cast<Discretization::Family*>(m_faceEC.targetFamily()) ;}

    void count(Arcane::IntegerUniqueArray& nbTToU) const {

      std::function<void (const Discretization::Node&, const Discretization::Face&)> action = 
        [&nbTToU](const Discretization::Node& n, const Discretization::Face& f) {
        const Arcane::Integer disNodeLId = n.localId() ;
        ++nbTToU[disNodeLId] ;
      } ;

      _loop(action) ;
    }

    void map(MultiConnectivityMap& TToUMap) const {
      Arcane::IntegerUniqueArray currentNbTToU(m_nodeEC.targetFamily() -> maxLocalId(), 0) ;

      std::function<void (const Discretization::Node&, const Discretization::Face&)> action = 
        [&currentNbTToU, &TToUMap](const Discretization::Node& n, const Discretization::Face& f) {
            const Arcane::Integer disNodeLId = n.localId() ;
            const Arcane::Integer disFaceLId = f.localId() ;

            TToUMap[n][currentNbTToU[disNodeLId]] = disFaceLId ;
            ++currentNbTToU[disNodeLId] ;
      } ;

      _loop(action) ;      
    }

  private:

    bool _ownCellNeighbour(const Arcane::Face& face) const {
      if(face.isSubDomainBoundary()) {
        return m_ownCellNeighbourFlag[face.boundaryCell().localId()] ;
      } else {
        return m_ownCellNeighbourFlag[face.backCell().localId()] ||
        m_ownCellNeighbourFlag[face.frontCell().localId()] ;
      }
    }

    void _loop(const std::function<void (const Discretization::Node&, const Discretization::Face&)>& action) const {
      ENUMERATE_NODE(inode, m_nodeGroup){
        const Discretization::Node disNode(m_nodeEC(inode)) ;

        ENUMERATE_FACE(iface, inode -> faces()) {
          if(AMRT<Arcane::Face>::isActive(*iface) && _ownCellNeighbour(*iface) && not m_contactFacesSet.hasKey(*iface)) {
            if(iface -> isSubDomainBoundary()) {

              if(m_cellGroupFlags[iface -> boundaryCell()]) {
                const Discretization::Face disFace(m_faceEC(iface)) ;

                action(disNode, disFace) ;
              }
            } else {
              const Arcane::Cell backCell = iface -> backCell() ;
              const Arcane::Cell frontCell = iface -> frontCell() ;

              if((m_cellGroupFlags[backCell] || m_cellGroupFlags[frontCell])) {
                const Discretization::Face disFace(m_faceEC(iface)) ;

                action(disNode, disFace) ;
              }
            }
          }
        }
      }
    }

    const NodeExtendedConnectivity& m_nodeEC ;
    const FaceExtendedConnectivity& m_faceEC ;
    const Arcane::NodeGroup& m_nodeGroup ;
    const Arcane::VariableCellBool& m_cellGroupFlags ;
    const ItemGroupSet& m_contactFacesSet ;
    const Arcane::BoolArray& m_ownCellNeighbourFlag ;
  } ;

  template<>
  struct MultiConnectivityTreatmentsT<Discretization::Face, Discretization::Node, false> {
    MultiConnectivityTreatmentsT(const FaceExtendedConnectivity& faceEC,
                                 const NodeExtendedConnectivity& nodeEC,                               
                                 const Arcane::FaceGroup& faceGroup) 
      : m_faceEC(faceEC)
      , m_nodeEC(nodeEC)
      , m_faceGroup(faceGroup) {}

    Discretization::Family* familyT() const {return dynamic_cast<Discretization::Family*>(m_faceEC.targetFamily()) ;}
    
    Discretization::Family* familyU() const {return dynamic_cast<Discretization::Family*>(m_nodeEC.targetFamily()) ;}

    void count(Arcane::IntegerUniqueArray& nbTToU) const {

      std::function<void (const Discretization::Face&, const Discretization::Node&)> action = 
        [&nbTToU](const Discretization::Face& f, const Discretization::Node& n) {
        const Arcane::Integer disFaceLId = f.localId() ;
        ++nbTToU[disFaceLId] ;
      } ;

      _loop(action) ;
    }

    void map(MultiConnectivityMap& TToUMap) const {
      Arcane::IntegerUniqueArray currentNbTToU(m_faceEC.targetFamily() -> maxLocalId(), 0) ;

      std::function<void (const Discretization::Face&, const Discretization::Node&)> action = 
        [&currentNbTToU, &TToUMap](const Discretization::Face& f, const Discretization::Node& n) {
            const Arcane::Integer disFaceLId = f.localId() ;
            const Arcane::Integer disNodeLId = n.localId() ;

            TToUMap[f][currentNbTToU[disFaceLId]] = disNodeLId ;
            ++currentNbTToU[disFaceLId] ;
      } ;

      _loop(action) ;      
    }

  private:

    void _loop(const std::function<void (const Discretization::Face&, const Discretization::Node&)>& action) const {
      ENUMERATE_FACE(iface, m_faceGroup){
        const Discretization::Face disFace(m_faceEC(iface)) ;

        ENUMERATE_NODE(inode, iface -> nodes()) {
          const Discretization::Node disNode(m_nodeEC(inode)) ;

          action(disFace, disNode) ;
        }
      }
    }

    const FaceExtendedConnectivity& m_faceEC ;
    const NodeExtendedConnectivity& m_nodeEC ;
    const Arcane::FaceGroup& m_faceGroup ;
  } ;

  template<typename T, bool surfaceMesh>
  struct ItemSelectFunctorT {} ;

  template<>
  struct ItemSelectFunctorT<Discretization::Cell, false> {
    ItemSelectFunctorT(const CellExtendedConnectivity& cellEC,
                       const Arcane::CellGroup initialGroup)
        : m_cellEC(cellEC)
        , m_initialGroup(initialGroup) {}

    void operator()(Arcane::UniqueArray<Arcane::IntegerSharedArray>& lIdsV) const {

      ENUMERATE_CELL(icell, m_initialGroup) {
        const Discretization::Cell disCell(m_cellEC(icell)) ;
        const Arcane::Integer disCellLId = disCell.localId() ;

        lIdsV[0].add(disCellLId) ;
      }
    }

  private:
    const CellExtendedConnectivity& m_cellEC ;
    const Arcane::CellGroup m_initialGroup ;
  } ;

  template<>
  struct ItemSelectFunctorT<Discretization::Cell, true> {
    ItemSelectFunctorT(const ContactExtendedConnectivity* faultCoreContactEC,
		       const ContactGroup cg,
		       const CellExtendedConnectivity& cellEC,
		       const Arcane::CellGroup domainGroup,
		       const CellExtendedConnectivity& surfCellEC,
		       const Arcane::CellGroup surfCellGroup)
      : m_faultCoreContactECPtr(faultCoreContactEC)
      , m_cg(cg)
      , m_cellEC(cellEC)
      , m_domainGroup(domainGroup)
      , m_surfCellEC(surfCellEC)
      , m_surfCellGroup(surfCellGroup){}

    void operator()(Arcane::UniqueArray<Arcane::IntegerSharedArray>& lIdsV) const {
      // Adds fault core cells to first group
      ENUMERATE_FACEFACECONTACT(iContact, m_cg) {
        const Discretization::Cell disCell((*m_faultCoreContactECPtr)(iContact)) ;
        const Arcane::Integer disCellLId = disCell.localId() ;

        lIdsV[0].add(disCellLId) ;
      }

      if(lIdsV.size() == 2) {
        // Completes the group of non fault core cells
        ENUMERATE_CELL(icell, m_domainGroup) {
          const Discretization::Cell disCell(m_cellEC(icell)) ;
          const Arcane::Integer disCellLId = disCell.localId() ;

          lIdsV[1].add(disCellLId) ;
        }

        ENUMERATE_CELL(icell, m_surfCellGroup) {
          const Discretization::Cell disCell(m_surfCellEC(icell)) ;
          const Arcane::Integer disCellLId = disCell.localId() ;

          lIdsV[1].add(disCellLId) ;
        }
      }
    }

  private:
    const ContactExtendedConnectivity* m_faultCoreContactECPtr ;
    const ContactGroup m_cg ;
    const CellExtendedConnectivity& m_cellEC ;
    const Arcane::CellGroup m_domainGroup ;
    const CellExtendedConnectivity& m_surfCellEC ;
    const Arcane::CellGroup m_surfCellGroup ;
  } ;

  inline void _selectDomainFaces(const Arcane::FaceGroup& initialGroup,
                                 const Arcane::VariableCellBool& isInCellGroup, 
                                 const FaceExtendedConnectivity& faceEC,
                                 const ItemGroupSet& contactFacesSet,
                                 Arcane::UniqueArray<Arcane::IntegerSharedArray>& lIdsV,
                                 Arcane::UniqueArray<std::set<Arcane::Int32> >& insertedDisFace) {
    ENUMERATE_FACE(iFace, initialGroup){
      const Discretization::Face disFace(faceEC(iFace)) ;
      const Arcane::Integer disFaceLId = disFace.localId() ;
      
      auto isInserted = insertedDisFace[0].insert(disFaceLId) ;
      
      if (isInserted.second) {
        lIdsV[0].add(disFaceLId) ;
      }


      if(iFace -> isSubDomainBoundary() && not contactFacesSet.hasKey(*iFace)) {
        isInserted = insertedDisFace[2].insert(disFaceLId) ;
        if (isInserted.second) {
          lIdsV[2].add(disFaceLId) ;
        }
      } else if(not iFace -> isSubDomainBoundary()) {
        const Arcane::Cell backCell(iFace -> backCell()) ;
        const Arcane::Cell frontCell(iFace -> frontCell()) ;
        
        if(not (isInCellGroup[backCell] && isInCellGroup[frontCell])) {
          isInserted = insertedDisFace[2].insert(disFaceLId) ;
          if (isInserted.second) {
            lIdsV[2].add(disFaceLId) ;
          }
        } else {
          isInserted = insertedDisFace[1].insert(disFaceLId) ;
          if (isInserted.second) {
            lIdsV[1].add(disFaceLId) ;
          }
        }
      }
    }    
  }                    

  template<>
  struct ItemSelectFunctorT<Discretization::Face, true> {
    ItemSelectFunctorT(const FaceExtendedConnectivity& faceEC,
                       const FaceExtendedMultiConnectivity& surfFaceEC,
                       const Arcane::UniqueArray<Arcane::FaceGroup>& groups,
                       const Arcane::UniqueArray<Arcane::VariableCellBool>& cellGroupFlags,
                       const ItemGroupSet& contactFacesSet,
                       const ContactGroup cg,
		       const ContactExtendedConnectivity* contactECPtr,
                       Arcane::IMesh* surfMesh,
                       const ConnectivityMap& faceToSurfCellLIdMap)
      : m_faceEC(faceEC)
      , m_surfFaceEC(surfFaceEC)
      , m_groups(groups)
      , m_cellGroupFlags(cellGroupFlags) 
      , m_contactFacesSet(contactFacesSet)
      , m_cg(cg)
      , m_contactECPtr(contactECPtr)
      , m_surfMesh(surfMesh)
      , m_faceToSurfCellLIdMap(faceToSurfCellLIdMap) {}

    void operator()(Arcane::UniqueArray<Arcane::IntegerSharedArray>& lIdsV) const {
      Arcane::UniqueArray<std::set<Arcane::Int32> > insertedDisFace(3) ;
      
      // Adds faces within domain mesh and not on contact
      _selectDomainFaces(m_groups[0], m_cellGroupFlags[0], m_faceEC, m_contactFacesSet, lIdsV, insertedDisFace) ;

      // Adds faces within surface mesh
      ENUMERATE_FACE(iFace, m_groups[1]){
        const Discretization::ConnectedItems iv(m_surfFaceEC(iFace)) ;

        for(Arcane::Integer i(0) ; i < iv.size() ; ++i) {
          const Discretization::Face disFace(iv[i]) ;
          const Arcane::Integer disFaceLId = disFace.localId() ;

          auto isInserted = insertedDisFace[0].insert(disFaceLId) ;
      
          if (isInserted.second) {
            lIdsV[0].add(disFaceLId) ;
          }
      
          if(iFace -> isSubDomainBoundary() || iv.size() == 2) {
            isInserted = insertedDisFace[2].insert(disFaceLId) ;
            if (isInserted.second) lIdsV[2].add(disFaceLId) ;          
          } else {
            const Arcane::Cell backCell(iFace -> backCell()) ;
            const Arcane::Cell frontCell(iFace -> frontCell()) ;
        
            if(not (m_cellGroupFlags[1][backCell] && m_cellGroupFlags[1][frontCell])) {
              isInserted = insertedDisFace[2].insert(disFaceLId) ;
              if (isInserted.second) lIdsV[2].add(disFaceLId) ;
            } else {
              isInserted = insertedDisFace[1].insert(disFaceLId) ;
              if (isInserted.second) lIdsV[1].add(disFaceLId) ;
            }
          }
        }
      }

      // Adds faces between surface and domain cells
      ENUMERATE_CELL(iCell, m_surfMesh -> allCells()) {
        const Arcane::Face& face(iCell -> parent().toFace()) ;

        const Arcane::Cell& domainCell(face.boundaryCell()) ;

        const bool b(m_cellGroupFlags[0][domainCell]) ;
        const bool bs(m_cellGroupFlags[1][iCell]) ;

        const Discretization::Face disFace(m_faceEC(face)) ;
        const Arcane::Integer disFaceLId = disFace.localId() ;

        if(b || bs) {
          auto isInserted = insertedDisFace[0].insert(disFaceLId) ;
          if (isInserted.second) {
            lIdsV[0].add(disFaceLId) ;
          }
        }

        if(b && bs)  {
          auto isInserted = insertedDisFace[1].insert(disFaceLId) ;
          if (isInserted.second) {
            lIdsV[1].add(disFaceLId) ;
          }
        } else if(b || bs) {
          auto isInserted = insertedDisFace[2].insert(disFaceLId) ;
          if (isInserted.second) {
            lIdsV[2].add(disFaceLId) ;
          }
        }
      }

      // Adds contacts and their boundary faces
      ENUMERATE_FACEFACECONTACT(icontact, m_cg) {
        const FaceFaceContact contact = *icontact ;
        
        const Arcane::Face face1(contact.face1()) ;
        const Arcane::Face face2(contact.face2()) ;

        const Arcane::Integer nbConnectedItems(m_contactECPtr -> nbConnectedItem((Arcane::ItemLocalId)icontact -> localId())) ;

        if(nbConnectedItems == 2) {
          Arcane::Integer i(0) ;
          for(auto face : {face1, face2}) {
            const Discretization::Face disContactFace((*m_contactECPtr)(icontact, i)) ;
            const Arcane::Integer disContactFaceLId = disContactFace.localId() ;

            auto isInserted = insertedDisFace[0].insert(disContactFaceLId);
            if (isInserted.second) {
              lIdsV[0].add(disContactFaceLId) ;
            }

            if(not face.null()) {
              const Arcane::Cell cell(face.boundaryCell()) ;

              const bool b(m_cellGroupFlags[0][cell]) ;

              const Arcane::ItemInternalArrayView surfCellsInternalView(m_surfMesh -> cellFamily() -> itemsInternal()) ;
              const Arcane::Cell surfCell(surfCellsInternalView[m_faceToSurfCellLIdMap[face]]) ;

              const bool bs(m_cellGroupFlags[1][surfCell]) ;

              if(b) {
                if(bs) {
                  isInserted = insertedDisFace[1].insert(disContactFaceLId);
                  if (isInserted.second) lIdsV[1].add(disContactFaceLId) ;
                } else {
                  isInserted = insertedDisFace[2].insert(disContactFaceLId);
                  if (isInserted.second) lIdsV[2].add(disContactFaceLId) ;
                }
              } else {
                if(bs) {
                  isInserted = insertedDisFace[1].insert(disContactFaceLId);
                  if (isInserted.second) lIdsV[1].add(disContactFaceLId) ;
                }
              }
            } else {
              isInserted = insertedDisFace[2].insert(disContactFaceLId);
              if (isInserted.second) lIdsV[2].add(disContactFaceLId) ;
            }
            ++i ;
          }
        } else {
          bool addsContact(false) ;

          Arcane::Integer nbContactNeighbours(0) ;

          for(auto face : {face1, face2}) {
            if(not face.null()) {
              const Arcane::Cell cell(face.boundaryCell()) ;

              const bool b(m_cellGroupFlags[0][cell]) ;

              const Arcane::ItemInternalArrayView surfCellsInternalView(m_surfMesh -> cellFamily() -> itemsInternal()) ;
              const Arcane::Cell surfCell(surfCellsInternalView[m_faceToSurfCellLIdMap[face]]) ;

              const bool bs(m_cellGroupFlags[1][surfCell]) ;

              if(bs) ++nbContactNeighbours ;

              if((b && bs) || bs) {
                  addsContact = true ;
              }
            }
          }

          if(addsContact) {
            const Discretization::Face disFace((*m_contactECPtr)(icontact)) ;
            const Arcane::Integer disFaceLId = disFace.localId() ;

            auto isInserted = insertedDisFace[0].insert(disFaceLId);
            if (isInserted.second) lIdsV[0].add(disFaceLId) ;

            bool addsContactAsInner(nbContactNeighbours == 2);

            if(addsContactAsInner) {
              isInserted = insertedDisFace[1].insert(disFaceLId);
              if (isInserted.second) lIdsV[1].add(disFaceLId) ;
            } else {
              isInserted = insertedDisFace[2].insert(disFaceLId);
              if (isInserted.second) lIdsV[2].add(disFaceLId) ;
            }
          }
        }
      }
    }

  private:
    const FaceExtendedConnectivity& m_faceEC ;
    const FaceExtendedMultiConnectivity& m_surfFaceEC ;
    const Arcane::UniqueArray<Arcane::FaceGroup> m_groups ;
    const Arcane::UniqueArray<Arcane::VariableCellBool> m_cellGroupFlags ;
    const ItemGroupSet& m_contactFacesSet ;
    const ContactGroup m_cg ;
    const ContactExtendedConnectivity* m_contactECPtr ;
    Arcane::IMesh* m_surfMesh ;
    const ConnectivityMap& m_faceToSurfCellLIdMap ;
  } ;

  template<>
  struct ItemSelectFunctorT<Discretization::Face, false> {
    ItemSelectFunctorT(const FaceExtendedConnectivity& faceEC,
		       const Arcane::FaceGroup& initialGroup,
		       const Arcane::VariableCellBool& isInCellGroup,
                       const ItemGroupSet& contactFacesSet,
		       const ContactGroup cg,
		       const ContactExtendedConnectivity* contactECPtr)
      : m_faceEC(faceEC)
      , m_initialGroup(initialGroup)
      , m_isInCellGroup(isInCellGroup)
      , m_contactFacesSet(contactFacesSet)
      , m_cg(cg)
      , m_contactECPtr(contactECPtr) {}

    void operator()(Arcane::UniqueArray<Arcane::IntegerSharedArray>& lIdsV) const {
      Arcane::UniqueArray<std::set<Arcane::Int32> > insertedDisFace(3);

      // Adds faces within domain mesh and not on contact
      _selectDomainFaces(m_initialGroup, m_isInCellGroup, m_faceEC, m_contactFacesSet, lIdsV, insertedDisFace) ;

      if(m_contactECPtr != nullptr) {
        ENUMERATE_FACEFACECONTACT(icontact, m_cg) {
          const FaceFaceContact contact = *icontact ;
          const Discretization::Face disFace((*m_contactECPtr)(icontact)) ;
          const Arcane::Integer disFaceLId = disFace.localId() ;

          const Arcane::Face face1(contact.face1()) ;
          const Arcane::Face face2(contact.face2()) ;

          auto isInserted = insertedDisFace[0].insert(disFaceLId) ;

          // check insertion took place (discretization face was not yet inserted).
          if (isInserted.second) lIdsV[0].add(disFaceLId) ;

          bool isInner(true) ;

          if(face1.null() || face2.null()) {
            isInserted = insertedDisFace[2].insert(disFaceLId);
            if (isInserted.second) lIdsV[2].add(disFaceLId) ;
            isInner = false ;
          } else {
            const Arcane::Cell cell1(face1.boundaryCell()) ;
            const Arcane::Cell cell2(face2.boundaryCell()) ;

            if((cell1.isActive() && not m_isInCellGroup[cell1]) ||
               (cell2.isActive() && not m_isInCellGroup[cell2])) {
              isInserted = insertedDisFace[2].insert(disFaceLId);
              if (isInserted.second) lIdsV[2].add(disFaceLId) ;
              isInner = false ;
            }
          }

          if(isInner) {
            isInserted = insertedDisFace[1].insert(disFaceLId);
            if (isInserted.second) lIdsV[1].add(disFaceLId) ;
          }
        }
      }
    }

  private:
    const FaceExtendedConnectivity& m_faceEC ;
    const Arcane::FaceGroup m_initialGroup ;
    const Arcane::VariableCellBool& m_isInCellGroup ;
    const ItemGroupSet& m_contactFacesSet ;
    const ContactGroup m_cg ;
    const ContactExtendedConnectivity* m_contactECPtr ;
  } ;

  template<>
  struct ItemSelectFunctorT<Discretization::Node, false> {
    ItemSelectFunctorT(const NodeExtendedConnectivity& nodeEC,
                       const Arcane::NodeGroup initialGroup,
                       const Arcane::VariableCellBool& isInCellGroup)
        : m_nodeEC(nodeEC)
        , m_initialGroup(initialGroup)
        , m_isInCellGroup(isInCellGroup) {}

    void operator()(Arcane::UniqueArray<Arcane::IntegerSharedArray>& lIdsV) const {

      ENUMERATE_NODE(inode, m_initialGroup){
        const Discretization::Node disNode(m_nodeEC(inode)) ;
        const Arcane::Integer disNodeLId = disNode.localId() ;

        bool isInner(true) ;

        lIdsV[0].add(disNodeLId) ;

        ENUMERATE_FACE(iface, inode -> faces()) {
          if(iface -> isSubDomainBoundary()) {
            isInner = false ;
            lIdsV[2].add(disNodeLId) ;
            break ;
          } else {
            const Arcane::Cell backCell(iface -> backCell()) ;
            const Arcane::Cell frontCell(iface -> frontCell()) ;

            if(not (m_isInCellGroup[backCell] && m_isInCellGroup[frontCell])) {
              isInner = false ;
              lIdsV[2].add(disNodeLId) ;
              break ;
            }
          }
        }

        if(isInner)
          lIdsV[1].add(disNodeLId) ;
      }
    }

  private:
    const NodeExtendedConnectivity& m_nodeEC ;
    const Arcane::NodeGroup m_initialGroup ;
    const Arcane::VariableCellBool& m_isInCellGroup ;
  } ;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCANEDEMO_SCHEMEAPI2016_DISCRETIZATIONCONNECTIVITYUTILS_H */
