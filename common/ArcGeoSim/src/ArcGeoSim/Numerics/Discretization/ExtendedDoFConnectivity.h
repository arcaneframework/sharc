// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCANEDEMO_CONNECTIVITYTEST_EXTENDEDDOFCONNECTIVITY_H
#define ARCANEDEMO_CONNECTIVITYTEST_EXTENDEDDOFCONNECTIVITY_H
/* Author : encheryg at Sat Jun 27 12:01:55 2015
 * Generated by createNew
 */

#include <functional>

#include <arcane/ArcaneVersion.h>
#include <arcane/ArcaneTypes.h>
#include <arcane/IItemFamily.h>
#include <arcane/ItemVector.h>
#include <arcane/VariableTypes.h>
#include <arcane/ItemInternal.h>


#include <arcane/utils/ArcaneGlobal.h>
#include <arcane/utils/FatalErrorException.h>
#include <arcane/utils/ITraceMng.h>

#if (ARCANE_VERSION >= 22200)
  #include <arcane/mesh/ItemProperty.h>
  #include <arcane/mesh/DoFFamily.h>
  #include <arcane/IItemConnectivity.h>
  #include <arcane/mesh/ItemConnectivity.h>
  typedef Arcane::IItemConnectivity IItemConnectivity;
  typedef Arcane::ItemVector ItemVectorType;
  using Arcane::ConnectivityItemVector;
#else
  #include <arcane/dof/ItemProperty.h>
  #include <arcane/dof/DoFFamily.h>
  #if (ARCANE_VERSION >= 20200)
    #include <arcane/IItemConnectivity.h>
    #include <arcane/dof/ItemConnectivity.h>
    typedef Arcane::IItemConnectivity IItemConnectivity;
    typedef Arcane::ItemVector ItemVectorType;
    using Arcane::ConnectivityItemVector;
  #else
    #include <arcane/dof/IConnectivity.h>
    typedef Arcane::IConnectivity IItemConnectivity;
    typedef Arcane::ItemVectorBuilder ItemVectorType;
    class ConnectivityItemVector{};
    class ItemLocalId{};
  #endif
#endif

#include "ArcGeoSim/Mesh/SurfaceUtils/ContactFamily.h"
#include "ArcGeoSim/Numerics/Discretization/Discretization.h"

ARCANE_BEGIN_NAMESPACE

#if(ARCANE_VERSION < 20305)
class ExtendedItemDoFConnectivity : public IItemConnectivity
{
public:
  
  ExtendedItemDoFConnectivity(IItemFamily* source_family, IItemFamily* target_family, const ItemScalarProperty<Int32>& item_property,
                              const String& connectivity_name, bool own = true)
  : m_source_family(source_family)
  , m_target_family(target_family)
  , m_name(connectivity_name) {
    
#if (ARCANE_VERSION < 20201)
    m_item_property.resize(m_source_family) ;
#else
    m_item_property.resize(m_source_family,NULL_ITEM_LOCAL_ID) ;
#endif

    if(own) {
      ENUMERATE_ITEM(iitem, m_source_family -> allItems().own()){
        m_item_property[iitem] = item_property[iitem] ;
      }
    } else {
      ENUMERATE_ITEM(iitem, m_source_family -> allItems()){
        m_item_property[iitem] = item_property[iitem] ;
      }
    }

  }
  
  virtual ~ExtendedItemDoFConnectivity() {}
  
public:

  const String& name() const {return m_name ;} 
  ConstArrayView<IItemFamily*> families() const {return m_families ;}
  IItemFamily* sourceFamily() const {return m_source_family ;}
  IItemFamily* targetFamily() const {return m_target_family ;}

  const Item operator() (const Item& item) const {ARCANE_ASSERT((m_item_property[item] != NULL_ITEM_LOCAL_ID),("Item must be connected to one item in ItemConnectivity."));return Item(m_target_family -> itemsInternal()[m_item_property[item]]);}
  const Item operator() (const ItemEnumerator& item) const {
    /*if(m_item_property[item] == NULL_ITEM_LOCAL_ID) {
      std::cout << "isOwn = " << item -> isOwn() << std::endl ;
      std::cout << "localId = " << item -> localId() << std::endl ;
      std::cout << "owner = " << item -> owner() << std::endl ;
      }*/
    ARCANE_ASSERT((m_item_property[item] != NULL_ITEM_LOCAL_ID),("Item must be connected to one item in ItemConnectivity."));return Item(m_target_family->itemsInternal()[m_item_property[item]]);}

  const ItemVectorType connectedItems(const Item& item) const {ARCANE_ASSERT((m_item_property[item] != NULL_ITEM_LOCAL_ID),("Item must be connected to one item in ItemConnectivity.")); return ItemVectorType(m_target_family, Arcane::Int32SharedArray(1,m_item_property[item])) ;}
  const ItemVectorType connectedItems(const ItemEnumerator& item) const {ARCANE_ASSERT((m_item_property[item] != NULL_ITEM_LOCAL_ID),("Item must be connected to one item in ItemConnectivity.")); return ItemVectorType(m_target_family, Int32SharedArray(1,m_item_property[item])) ;}

  void updateConnectivity(Int32ConstArrayView from_items, Int32ConstArrayView to_items) ;

  ItemScalarProperty<Arcane::Int32>& itemProperty() {return m_item_property ;}

#if (ARCANE_VERSION > 20200)
  //! Impl�mente l'initialisation de \a civ pour cette connectivit�e.
  void _initializeStorage(ConnectivityItemVector* civ) {}

  //! Remplit \a con_items avec les entit�s connect�es � \a item.
  ItemVectorView _connectedItems(ItemLocalId item,ConnectivityItemVector& con_items) const {
    ARCANE_ASSERT((con_items.connectivity()==this),("Bad connectivity"));
    return con_items.setItem(m_item_property[item]);
  }
#endif

  //! Notifie la connectivit� que la famille source est compact�e.
   virtual void notifySourceFamilyLocalIdChanged(Int32ConstArrayView new_to_old_ids)
   {
     m_item_property.updateSupport(new_to_old_ids);
   }

   //! Notifie la connectivit� que la famille cible est compact�e.
   virtual void notifyTargetFamilyLocalIdChanged(Int32ConstArrayView old_to_new_ids);

private:

  IItemFamily* m_source_family ;
  IItemFamily* m_target_family ;
  SharedArray<IItemFamily*> m_families ;
  ItemScalarProperty<Arcane::Int32> m_item_property;
  String m_name ;
} ;

template<class FromItemType,class ToItemType>
class ExtendedItemDoFConnectivityT : public ExtendedItemDoFConnectivity
{
public:
  ExtendedItemDoFConnectivityT(IItemFamily* source_family, IItemFamily* target_family, const ItemScalarProperty<Int32>& item_property,
                               const String& connectivity_name, bool own = true) : ExtendedItemDoFConnectivity(source_family, target_family, item_property, connectivity_name, own){}

  ~ExtendedItemDoFConnectivityT(){}

  ToItemType operator() (ItemEnumeratorT<FromItemType>& item) const {return ExtendedItemDoFConnectivity::operator()(item).internal() ;}
  ToItemType operator() (const FromItemType& item)            const {return ExtendedItemDoFConnectivity::operator()(item).internal() ;}
} ;

class ExtendedItemMultiArrayDoFConnectivity : public IItemConnectivity
{
public:
  
  ExtendedItemMultiArrayDoFConnectivity(IItemFamily* source_family, IItemFamily* target_family, const ItemMultiArrayProperty<Int32>& item_property,
                                        const String& connectivity_name)
    : m_source_family(source_family)
    , m_target_family(target_family) 
    , m_name(connectivity_name) {

#if (ARCANE_VERSION < 20201)
    m_item_property.resize(m_source_family, item_property.dim2Sizes()) ;
#else
    m_item_property.resize(m_source_family, item_property.dim2Sizes(),NULL_ITEM_LOCAL_ID) ;
#endif

    ENUMERATE_ITEM(iitem, m_source_family -> allItems()){
      const Arcane::Integer size(item_property[iitem].size()) ;
      
      for (Arcane::Integer j = 0 ; j < size ; ++j) {
          m_item_property[iitem][j] = item_property[iitem][j] ;
      }
    }
  }
  
  virtual ~ExtendedItemMultiArrayDoFConnectivity() {}
  
public:

  const String& name() const {return m_name ;} 
  ConstArrayView<IItemFamily*> families() const {return m_families ;}
  IItemFamily* sourceFamily() const {return m_source_family ;}
  IItemFamily* targetFamily() const {return m_target_family ;}

  ItemVectorType operator() (const Item& item) const {return ItemVectorType(m_target_family,m_item_property[item]) ;}
  ItemVectorType operator() (const ItemEnumerator& item) const {return ItemVectorType(m_target_family,m_item_property[item]) ;}

  const ItemVectorType connectedItems(const Item& item) const {return this->operator ()(item) ;}
  const ItemVectorType connectedItems(const ItemEnumerator& item) const {return this->operator ()(item) ;}

  void updateConnectivity(Int32ConstArrayView from_items, Int32ConstArrayView to_items) ;

  ItemMultiArrayProperty<Arcane::Int32>& itemProperty() {return m_item_property;}

  // Evolution API DOF
#if (ARCANE_VERSION > 20200)
  //! Impl�mente l'initialisation de \a civ pour cette connectivit�e.
  void _initializeStorage(ConnectivityItemVector* civ) {}

  //! Remplit \a con_items avec les entit�s connect�es � \a item.
  ItemVectorView _connectedItems(ItemLocalId item,ConnectivityItemVector& con_items) const {
    ARCANE_ASSERT((con_items.connectivity()==this),("Bad connectivity"));
    return con_items.resizeAndCopy(m_item_property[item]);
  }
#endif

  //! Notifie la connectivit� que la famille source est compact�e.
  virtual void notifySourceFamilyLocalIdChanged(Int32ConstArrayView new_to_old_ids)
  {
    m_item_property.updateSupport(new_to_old_ids);
  }

  //! Notifie la connectivit� que la famille cible est compact�e.
  virtual void notifyTargetFamilyLocalIdChanged(Int32ConstArrayView old_to_new_ids);

private:

  IItemFamily* m_source_family ;
  IItemFamily* m_target_family ;
  SharedArray<IItemFamily*> m_families ;
  ItemMultiArrayProperty<Arcane::Int32> m_item_property;
  String m_name ;
} ;

template<class FromItemType,class ToItemType>
class ExtendedItemMultiArrayDoFConnectivityT : public ExtendedItemMultiArrayDoFConnectivity
{
public:
  ExtendedItemMultiArrayDoFConnectivityT(IItemFamily* source_family, IItemFamily* target_family, const ItemMultiArrayProperty<Int32>& item_property,
                                         const String& connectivity_name) : ExtendedItemMultiArrayDoFConnectivity(source_family, target_family, item_property, connectivity_name){}

  ~ExtendedItemMultiArrayDoFConnectivityT(){}

  ItemVector operator() (ItemEnumeratorT<FromItemType>& item) const {return ExtendedItemMultiArrayDoFConnectivity::operator() (item) ;}
  ItemVector operator() (const FromItemType& item)            const {return ExtendedItemMultiArrayDoFConnectivity::operator() (item) ;}
} ;

#else

// Using new connectivities (compact is supported)
template<class FromItemType,class ToItemType>
using ExtendedItemDoFConnectivityT = Arcane::ItemConnectivityT<FromItemType,ToItemType>;
template<class FromItemType,class ToItemType>
using ExtendedItemMultiArrayDoFConnectivityT = Arcane::ItemMultiArrayConnectivityT<FromItemType,ToItemType>;

#endif


class ContactDoFConnectivity
        : public Arcane::IItemConnectivity
{
public:
  ContactDoFConnectivity(IContactFamily* source_family, Discretization::Family* target_family,
                         const Arcane::Int32UniqueArray& lIds,
                         const ContactGroup& contactGroup,
                         const Arcane::String connectivity_name,
                         const bool multi = false)
    : m_source_family(source_family)
    , m_target_family(target_family)
    , m_name(connectivity_name)
  {
    if(multi) {
      _multiConstruction(lIds, contactGroup) ;
    } else {
      _scalarConstruction(lIds, contactGroup) ;
    }
  }

  virtual ~ContactDoFConnectivity(){}

public:

  const Arcane::DoF operator() (const Contact& c, const Arcane::Integer n = 0) const {
    return m_getFunction(c, n) ;
  }

  const Arcane::DoF operator() (const ContactEnumerator& ce, const Arcane::Integer n = 0) const {
    return m_getFunction(*ce, n) ;
  }
  const String& name() const {return m_name;}

  void updateConnectivity(Int32ConstArrayView from_items, Int32ConstArrayView to_items) ;

  Arcane::IItemFamily* sourceFamily() const {return &m_source_family ;}
#ifdef USE_ARCANE_V3
  Arcane::IItemFamily* targetFamily() const {return m_target_family->itemFamily() ;}
#else
  Arcane::IItemFamily* targetFamily() const {return m_target_family ;}
#endif

  Arcane::ConstArrayView<Arcane::IItemFamily*> families() const {return m_families.view();}

  Arcane::ItemScalarProperty<Int32>& contact2DofMap() {return m_contact2DoFMap ;}

  Arcane::ItemMultiArrayProperty<Int32>& contact2MultiDoFMap() {return m_contact2MultiDoFMap ;}

  //! Notifie la connectivit� que la famille source est compact�e.
  void notifySourceFamilyLocalIdChanged(Int32ConstArrayView new_to_old_ids) {throw Arcane::NotImplementedException(A_FUNCINFO,"Not needed method. Contacts are not compacted");}

  //! Notifie la connectivit� que la famille cible est compact�e.
  void notifyTargetFamilyLocalIdChanged(Int32ConstArrayView old_to_new_ids)
  {
    m_notifyTargetModifsFunction(old_to_new_ids) ;
  }

  //! Nombre d'entit� connect�es � l'entit� source de num�ro local \a lid
  Integer nbConnectedItem(ItemLocalId lid) const {return m_nbConnectedItemFunction(lid) ;}

  void connectedItems(IntegerSharedArray& arrayToFill) {m_connectedItemsInArrayFunction(arrayToFill) ;}

   //! Impl�mente l'initialisation de \a civ pour cette connectivit�e.
   void _initializeStorage(ConnectivityItemVector* civ) {} // not used for the moment. Todo use to avoid ItemVector reallocation

   //! Remplit \a con_items avec les entit�s connect�es � \a item.
   ItemVectorView _connectedItems(ItemLocalId item,ConnectivityItemVector& con_items) const {
     return m_connectedItemsFunction(item, con_items) ;
   }

#if (ARCANE_VERSION >= 20305)
   //! localId() de la \a index-i�me entit�e connect�es � l'entit� source de num�ro local \a lid
  Int32 connectedItemLocalId(ItemLocalId lid,Integer index) const {return m_connectedItemLocalIdFunction(lid, index) ;}

#endif

private:
  void _scalarConstruction(const Arcane::Int32UniqueArray& lIds,
                           const ContactGroup& contactGroup) ;

  void _multiConstruction(const Arcane::Int32UniqueArray& lIds,
                          const ContactGroup& contactGroup) ;

  mutable ContactItemFamily m_source_family ;
  Discretization::Family* m_target_family ;
  Arcane::ItemScalarProperty<Int32> m_contact2DoFMap ;
  Arcane::ItemMultiArrayProperty<Int32> m_contact2MultiDoFMap ;
  Arcane::String m_name ;
  Arcane::SharedArray<IItemFamily*> m_families;
  std::function<const Arcane::DoF(const Contact&, const Arcane::Integer)> m_getFunction ;
  std::function<void(Int32ConstArrayView from_items, Int32ConstArrayView to_items)> m_updateFunction ;
  std::function<void(Int32ConstArrayView old_to_new_ids)> m_notifyTargetModifsFunction ;
  std::function<Integer(ItemLocalId lid)> m_nbConnectedItemFunction ;
  std::function<ItemVectorView(ItemLocalId item, ConnectivityItemVector& con_items)> m_connectedItemsFunction ;
#if (ARCANE_VERSION >= 20305)
  std::function<Integer(ItemLocalId lid,Integer index)> m_connectedItemLocalIdFunction ;
#endif
  std::function<void(IntegerSharedArray& arrayToFill)> m_connectedItemsInArrayFunction ;
} ;

ARCANE_END_NAMESPACE

#endif /* ARCANEDEMO_CONNECTIVITYTEST_EXTENDEDDOFCONNECTIVITY_H */
