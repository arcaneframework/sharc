// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "ExtendedDoFConnectivity.h"
/* Author : encheryg at Sat Jun 27 12:01:55 2015
 * Generated by createNew
 */

#if(ARCANE_VERSION < 20305)

void
Arcane::ExtendedItemDoFConnectivity::
updateConnectivity(Int32ConstArrayView from_items, Int32ConstArrayView to_items)
{
  ARCANE_ASSERT((from_items.size() == to_items.size()),
      ("from_items and to_items arrays must have the same size to update connectivity"));

#if (ARCANE_VERSION < 20201)
  m_item_property.resize(m_source_family) ;
#else
  m_item_property.resize(m_source_family,NULL_ITEM_LOCAL_ID) ;
#endif

  Arcane::ItemVectorView from_items_view = m_source_family -> view(from_items) ;

  for (Arcane::Integer i = 0 ; i < from_items.size() ; ++i) {
    m_item_property[from_items_view[i]] = to_items[i] ;
  }  
}

/*---------------------------------------------------------------------------*/

void
Arcane::ExtendedItemDoFConnectivity::
notifyTargetFamilyLocalIdChanged(Int32ConstArrayView old_to_new_ids)
{
  ENUMERATE_ITEM(item,m_source_family->view().subView(0,m_item_property.size()))
  {
    if (m_item_property[item] != NULL_ITEM_LOCAL_ID)
    m_item_property[item] = old_to_new_ids[m_item_property[item]];
  }
}

/*---------------------------------------------------------------------------*/

void
Arcane::ExtendedItemMultiArrayDoFConnectivity::
updateConnectivity(Int32ConstArrayView from_items, Int32ConstArrayView to_items)
{
  ARCANE_ASSERT((from_items.size() == to_items.size()),
      ("from_items and to_items arrays must have the same size to update connectivity"));

  // Resize item property
  Arcane::IntegerUniqueArray nb_connected_element_per_item ; // Array indexed by lids

  // Adapt to possible evolution of from family size
  nb_connected_element_per_item.resize(m_source_family -> maxLocalId(), 0) ;

  // Remove history
  for (Arcane::Integer i = 0 ; i < from_items.size() ; ++i) 
    ++nb_connected_element_per_item[from_items[i]] ;

#if (ARCANE_VERSION < 20201)
  m_item_property.resize(m_source_family, nb_connected_element_per_item) ;
#else
  m_item_property.resize(m_source_family, nb_connected_element_per_item,NULL_ITEM_LOCAL_ID) ;
#endif

  // Update item property
  Arcane::IntegerUniqueArray to_items_index ;

  to_items_index.resize(m_source_family->maxLocalId(), 0) ;

  std::set<Arcane::Int32> from_items_set ;
  std::set<Arcane::Int32> to_items_set ;
  Arcane::ItemVectorView from_items_view = m_source_family->view(from_items) ;

  for (Arcane::Integer i = 0 ; i < from_items.size() ; ++i) {
    const bool from_item_found(from_items_set.insert(from_items[i]).second) ;

    if (from_item_found || (!from_item_found && to_items_set.insert(to_items[i]).second)) { 
      m_item_property[from_items_view[i]][to_items_index[from_items[i]]] = to_items[i] ;
      ++to_items_index[from_items[i]] ;
    }
  }
}

void
Arcane::ExtendedItemMultiArrayDoFConnectivity::
notifyTargetFamilyLocalIdChanged(Int32ConstArrayView old_to_new_ids)
{
  ENUMERATE_ITEM(item,m_source_family->allItems())
  {
    for (Integer i = 0; i < m_item_property.dim2Sizes()[item.localId()]; ++i)
      {
        if (m_item_property[item][i] != NULL_ITEM_LOCAL_ID)
          m_item_property[item][i] = old_to_new_ids[m_item_property[item][i]];
      }
  }
}

/*---------------------------------------------------------------------------*/
#endif

void
Arcane::ContactDoFConnectivity::
updateConnectivity(Int32ConstArrayView from_items, Int32ConstArrayView to_items)
{
  ARCANE_ASSERT((from_items.size() == to_items.size()),
      ("from_items and to_items arrays must have the same size to update connectivity"));

  std::set<Arcane::Int32> from_items_set ;
  std::set<Arcane::Int32> to_items_set ;

  for (Arcane::Integer i = 0 ; i < from_items.size() ; ++i) {
    const bool from_item_inserted(from_items_set.insert(from_items[i]).second) ;

    if (from_item_inserted || (!from_item_inserted && to_items_set.insert(to_items[i]).second)) { 
      const Contact& c(&(m_source_family .contactFamily()-> contactsInternal()[from_items[i]]));
      m_contact2DoFMap[c] = to_items[i] ;
    }
  }
}

/*---------------------------------------------------------------------------*/

void 
Arcane::ContactDoFConnectivity::
_scalarConstruction(const Arcane::Int32UniqueArray& lIds,
                    const ContactGroup& contactGroup) {
#if(ARCANE_VERSION < 20201)
  m_contact2DoFMap.resize(m_source_family.contactFamily()) ;
#else
  m_contact2DoFMap.resize(m_source_family.contactFamily(), NULL_ITEM_LOCAL_ID) ;
#endif

#ifdef USE_ARCANE_V3
  Arcane::IItemFamily* m_target_family_asIItemFamily =
      m_target_family->itemFamily();
#else
  Arcane::IItemFamily* m_target_family_asIItemFamily =
      m_target_family;
#endif

  m_families.add(&m_source_family); // now Contact family can be seen as a IItemFamily. To do replace contact by DoF !!
  m_families.add(m_target_family_asIItemFamily);

  Arcane::Integer i(0) ;
  ENUMERATE_FACEFACECONTACT(icontact, contactGroup) {
    const FaceFaceContact contact = *icontact ;

    if(contact.isOwn()) {
      m_contact2DoFMap[icontact] = lIds[i++] ;
    }
  }
  
  m_getFunction = [this,m_target_family_asIItemFamily](const Contact& c, const Arcane::Integer n) {
    ARCANE_ASSERT((m_contact2DoFMap[c] != NULL_ITEM_LOCAL_ID),("Contact must be connected to one dof in ContactToDoFConnectivity."));
    return Arcane::DoF(m_target_family_asIItemFamily -> itemsInternal()[m_contact2DoFMap[c]]) ;
  } ;

  m_notifyTargetModifsFunction = [this](Int32ConstArrayView old_to_new_ids) {
    m_source_family.contactFamily()->updateInternalList() ;
    ENUMERATE_FACEFACECONTACT(icontact,m_source_family.contactFamily()->allContacts()){
      const FaceFaceContact contact = *icontact ;
      if (contact.isOwn() && m_contact2DoFMap[icontact] != NULL_ITEM_LOCAL_ID) {
        m_contact2DoFMap[icontact] = old_to_new_ids[m_contact2DoFMap[icontact]] ;
      }
    }
  } ;

  m_nbConnectedItemFunction = [](ItemLocalId lid) {
    return 1 ;
  } ; 

  m_connectedItemsFunction = [this](ItemLocalId item, ConnectivityItemVector& con_items){
#if (ARCANE_VERSION >= 20305)
    ARCANE_ASSERT((con_items.accessor()==this),("Bad connectivity"));
#endif // ARCANE_VERSION >= 20305
    return con_items.setItem(m_contact2DoFMap[item]);
  } ;

#if (ARCANE_VERSION >= 20305)
  m_connectedItemLocalIdFunction = [this] (ItemLocalId lid, Integer index) {
    ARCANE_ASSERT((index==0),("Invalid value for index"));
    return m_contact2DoFMap[lid];
  } ;

#endif

  m_connectedItemsInArrayFunction = [this](IntegerSharedArray& arrayToFill) {
    Arcane::ConstArrayView<Arcane::Int32> view(m_contact2DoFMap.view()) ;
    for(Arcane::Integer i(0) ; i < view.size() ; ++i) {
      if(view[i] != NULL_ITEM_LOCAL_ID)
        arrayToFill.add(view[i]) ;
    }
  };
}

/*---------------------------------------------------------------------------*/

void Arcane::ContactDoFConnectivity::
_multiConstruction(const Arcane::Int32UniqueArray& lIds,
                   const ContactGroup& contactGroup) {
  Arcane::IntegerUniqueArray sizes(contactGroup.family() -> maxLocalId(), 0) ;
  
  ENUMERATE_FACEFACECONTACT(iContact, contactGroup) {
    const FaceFaceContact contact = *iContact ;
    
    if(contact.isOwn()) {
      for(Arcane::Integer i(0) ; i < 2 ; ++i) {
        sizes[iContact -> localId()] += 1 ;
      }
    }
  }
  
#if(ARCANE_VERSION < 20201)
  m_contact2MultiDoFMap.resize(m_source_family.contactFamily(), sizes) ;
#else
  m_contact2MultiDoFMap.resize(m_source_family.contactFamily(), sizes, NULL_ITEM_LOCAL_ID) ;
#endif

#ifdef USE_ARCANE_V3
  Arcane::IItemFamily* m_target_family_asIItemFamily =
      m_target_family->itemFamily();
#else
  Arcane::IItemFamily* m_target_family_asIItemFamily =
      m_target_family;
#endif
  
  Arcane::Integer i(0) ;
  ENUMERATE_FACEFACECONTACT(iContact, contactGroup) {
    const FaceFaceContact contact = *iContact ;
    
    IntegerArrayView memberView(m_contact2MultiDoFMap[iContact]) ;

    if(contact.isOwn()) {
      for(Arcane::Integer j(0) ; j < 2 ; ++j) {
        memberView[j] = lIds[i] ;
        i++ ;
      }
    }
  }
  
  m_families.add(&m_source_family); // now Contact family can be seen as a IItemFamily. To do replace contact by DoF !!
  m_families.add(m_target_family_asIItemFamily);
  
  m_getFunction = [this,m_target_family_asIItemFamily](const Contact& c, const Arcane::Integer n) {
    ARCANE_ASSERT((m_contact2MultiDoFMap[c].size() > 0),("Contact must be connected to one dof in ContactToDoFConnectivity."));
    ARCANE_ASSERT((n < m_contact2MultiDoFMap[c].size()),("Bad index for contact dof"));
    ARCANE_ASSERT((m_contact2MultiDoFMap[c][n]  != NULL_ITEM_LOCAL_ID),("Contact must be connected to an existing dof in ContactToDoFConnectivity."));
    return Arcane::DoF(m_target_family_asIItemFamily -> itemsInternal()[m_contact2MultiDoFMap[c][n]]) ;
  } ;
  
  m_notifyTargetModifsFunction = [this](Int32ConstArrayView old_to_new_ids) {
    m_source_family.contactFamily()->updateInternalList() ;
    ENUMERATE_FACEFACECONTACT(iContact,m_source_family.contactFamily()->allContacts())
    {
      IntegerArrayView memberView(m_contact2MultiDoFMap[iContact]) ;
      
      for(Arcane::Integer i(0) ; i < memberView.size() ; ++i) {
        memberView[i] = old_to_new_ids[memberView[i]] ;
      }
    }    
  } ;
  
  m_nbConnectedItemFunction = [this](ItemLocalId lid) {
    IntegerArrayView memberView(m_contact2MultiDoFMap[lid]) ;
    return memberView.size() ;
  } ; 
  
  m_connectedItemsFunction = [this](ItemLocalId item, ConnectivityItemVector& con_items){
#if (ARCANE_VERSION >= 20305)
    ARCANE_ASSERT((con_items.accessor()==this),("Bad connectivity"));
#endif //ARCANE_VERSION >= 20305
    return con_items.resizeAndCopy(m_contact2MultiDoFMap[item]);
  } ;

#if (ARCANE_VERSION >= 20305)
  m_connectedItemLocalIdFunction = [this] (ItemLocalId lid, Integer index) {
    IntegerArrayView memberView(m_contact2MultiDoFMap[lid]) ;
    return memberView[index] ;
  } ;

#endif
  
  m_connectedItemsInArrayFunction = [this](IntegerSharedArray& arrayToFill) {
    ENUMERATE_FACEFACECONTACT(iContact, m_source_family.contactFamily() -> allContacts()) {
      IntegerArrayView memberView(m_contact2MultiDoFMap[iContact]) ;
      for(Arcane::Integer i(0) ; i < memberView.size() ; ++i) {          
        const Arcane::Integer dofLId(memberView[i]) ;
        
        if(dofLId != NULL_ITEM_LOCAL_ID)
          arrayToFill.add(dofLId) ;
      }
    } 
  } ;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
