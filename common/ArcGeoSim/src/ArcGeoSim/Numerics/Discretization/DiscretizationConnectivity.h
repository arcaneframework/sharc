// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCANEDEMO_SCHEMEAPI2016_DISCRETIZATIONCONNECTIVITY_H
#define ARCANEDEMO_SCHEMEAPI2016_DISCRETIZATIONCONNECTIVITY_H
/* Author : encheryg at Tue Jan  5 18:14:12 2016
 * Generated by createNew
 */

#include <stdexcept>
#include <functional>
#include <map>

#include <arcane/ArcaneVersion.h>
#include <arcane/utils/ITraceMng.h>
#if (ARCANE_VERSION >= 22200)
  #include <arcane/mesh/DoFManager.h>
  #include <arcane/mesh/ItemConnectivityMng.h>
  #include <arcane/IItemConnectivitySynchronizer.h>
  using Arcane::ItemConnectivityMng;
  using Arcane::IItemConnectivitySynchronizer;
  #include <arcane/ConnectivityItemVector.h>
#else
    #include <arcane/dof/DoFManager.h>
    #if (ARCANE_VERSION > 20200)
    #include <arcane/dof/ItemConnectivityMng.h>
    #include <arcane/IItemConnectivitySynchronizer.h>
    using Arcane::ItemConnectivityMng;
    using Arcane::IItemConnectivitySynchronizer;
    #if (ARCANE_VERSION > 20305)
      #include <arcane/ConnectivityItemVector.h>
    #endif
  #else
    #include <arcane/dof/ConnectivityManager.h>
    #include <arcane/dof/IConnectivitySynchronizer.h>
    typedef Arcane::ConnectivityManager ItemConnectivityMng;
    typedef Arcane::IConnectivitySynchronizer IItemConnectivitySynchronizer;
  #endif
#endif

#include "DiscretizationConnectivityUtils.h"
#include <ArcGeoSim/Mesh/SurfaceUtils/INotMatchingSurfaceMng.h>
#include <ArcGeoSim/Utils/ItemGroupMap.h>

using namespace ArcGeoSim::Surface ;


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
using VariableDoFBoolUPtr = std::unique_ptr<Arcane::VariableDoFBool> ;

class DiscretizationConnectivity
{
public:
  DiscretizationConnectivity(Arcane::ITraceMng* traceMng, Arcane::IMesh* mesh,
                             INotMatchingSurfaceMng* matcher,
                             Discretization::ItemKindPairList l,
                             const Arcane::CellGroup ce,
                             Arcane::String connectivityName,
                             const bool useOnlyCellWithOwnNeighbour=false,
                             Arcane::IMesh* surfaceMesh = nullptr,
                             const Arcane::CellGroup surfaceGroup = Arcane::CellGroup(),
                             const Arcane::String surfaceFaceGroupName = "",
                             const bool addFaultCore = false) ;

  DiscretizationConnectivity(Arcane::ITraceMng* traceMng, Arcane::IMesh* mesh, 
                             INotMatchingSurfaceMng* matcher,
                             Discretization::ItemKindPairList l,
                             Arcane::String connectivityName,
                             const bool useOnlyCellWithOwnNeighbour=false,
                             Arcane::IMesh* surfaceMesh = nullptr,
                             const Arcane::CellGroup surfaceGroup = Arcane::CellGroup(),
                             const Arcane::String surfaceFaceGroupName = "",
                             const bool addFaultCore = false) ;

  void update() ;

  Discretization::Cell cell(const Arcane::Cell c, bool isInSurfaceMesh = false) const {
    const auto lId(c.localId()) ;
    const auto error = [lId]{ throw Arcane::FatalErrorException(A_FUNCINFO,
                              Arcane::String::format("Arcane cell {0} not present in Discretization\n",
                                                     lId)) ;};

    if(isInSurfaceMesh) {
      if((*m_isInSurfaceCellGroup)[c]) {
        return (*m_surfCellEC)(c) ;
      } else {
        error() ;
        return Arcane::Item() ;
      }
    } else {
      if(m_isInCellGroup[c]) {
        return (*m_cellEC)(c) ;
      } else {
        error() ;
        return Arcane::Item() ;
      }
    }
  }

  Discretization::Cell cell(Arcane::CellEnumerator ce, bool isInSurfaceMesh = false) const 
  {return cell(*ce, isInSurfaceMesh) ;}

  Discretization::Cell cell(const Contact& c) const {
    if(not m_addFaultCore)
      throw Arcane::FatalErrorException(A_FUNCINFO,"No discretization cell on given contact since no fault core") ;

    return (*m_faultCoreContactEC)(c) ;
  }

  Discretization::Cell cell(const ContactEnumerator& ce) const {
    return cell(*ce) ;
  }

  Arcane::Cell cell(const Discretization::Cell c) const {
    if((*m_isFaultCoreContact)[c])
      throw Arcane::FatalErrorException(A_FUNCINFO,"This cell is defined on a fault core contact and not on an Arcane cell.") ;

    return (*m_isDisSurfCell)[c] ? (*m_surfCellREC)(c) : (*m_cellREC)(c) ;
  }

  Arcane::Cell cell(Discretization::CellEnumerator ce) const {return cell(*ce) ;}

  bool isMissing(const Arcane::Face f, const bool isInSurfaceMesh = false) {
    return ! (isInSurfaceMesh ? (*m_isInSurfaceFaceGroup)[f] : m_isInFaceGroup[f]) ;
  }

  Discretization::Face face(const Arcane::Face f, const bool isInSurfaceMesh = false, 
                            const Discretization::Pair n = Discretization::Pair::First) const {
    const auto lId(f.localId()) ;
    const auto error = [lId]{ throw Arcane::FatalErrorException(A_FUNCINFO,
                                    Arcane::String::format("Arcane face {0} not present in Discretization\n",
                                                           lId)) ;};

    if(isInSurfaceMesh) {
      if((*m_isInSurfaceFaceGroup)[f]) {
        return DiscretizationConnectivityUtils::connectivityAccessT<FaceExtendedMultiConnectivity,
        Arcane::Face, Discretization::Face>::get(f, *m_surfFaceEC, n) ;
      } else {
        error() ;
        return Arcane::Item() ;
      }
    } else {
      if(m_isInFaceGroup[f]) {
        return (*m_faceEC)(f) ;
      } else {
        error() ;
        return Arcane::Item() ;
      }
    }
  }

  Discretization::Face face(Arcane::FaceEnumerator fe, const bool isInSurfaceMesh = false,
                            const Discretization::Pair n = Discretization::Pair::First) const 
  {return face(*fe, isInSurfaceMesh, n) ;}

  Arcane::Integer nbFaces(const Contact& c) const {
    return m_contactEC -> nbConnectedItem((ItemLocalId)c.localId()) ;
  }

  Arcane::Integer nbFaces(const FaceFaceContactEnumerator& ce) const {
    return nbFaces(*ce) ;
  }

  Discretization::Face face(const Contact& c,
                            const Discretization::Pair n = Discretization::Pair::First) const
  {
    Arcane::Integer nToInt(static_cast<Arcane::Integer>(n)) ;
    return (*m_contactEC)(c, nToInt) ; 
  }

  Discretization::Face face(const FaceFaceContactEnumerator& ce, 
                            const Discretization::Pair n = Discretization::Pair::First) const {return face(*ce, n) ;}

  // Returns null face if f is a contact
  Arcane::Face face(const Discretization::Face f) const {
    if((*m_isContact)[f]) {
      return Arcane::Face() ;
    } else {
      return (*m_isDisSurfFace)[f] ? (*m_surfFaceREC)(f) : (*m_faceREC)(f) ;
    }
  }

  // Returns null face if *fe is a contact
  Arcane::Face face(Discretization::FaceEnumerator fe) const {
    return face(*fe) ;
  }

  Discretization::Node node(const Arcane::Node n) const {
    if(m_isInNodeGroup[n]) {
      return (*m_nodeEC)(n) ;
    } else {
      m_mesh -> traceMng() -> fatal() << "Arcane node not present in Discretization" ;
      return Discretization::Node() ;
    }
  }

  Discretization::Node node(Arcane::NodeEnumerator ne) const {return node(*ne) ;}

  Arcane::Node node(const Discretization::Node n) const {return (*m_nodeREC)(n) ;}

  Arcane::Node node(Discretization::NodeEnumerator ne) const {return (*m_nodeREC)(ne) ;}

#if (ARCANE_VERSION < 20305)

  Discretization::ItemVector cells(const Discretization::Node n) const { return (*m_nodeCellsEMC)(n) ;}

  Discretization::ItemVector cells(Discretization::NodeEnumerator ne) const { return (*m_nodeCellsEMC)(ne) ;}

  Discretization::ItemVector faces(const Discretization::Node n) const { return (*m_nodeFacesEMC)(n) ;}

  Discretization::ItemVector faces(Discretization::NodeEnumerator ne) const { return (*m_nodeFacesEMC)(ne) ;}

  Discretization::ItemVector faces(const Discretization::Cell c) const { return (*m_cellFacesEMC)(c) ;}

  Discretization::ItemVector faces(Discretization::CellEnumerator ce) const { return (*m_cellFacesEMC)(ce) ;}

  Discretization::ItemVector nodes(const Discretization::Cell c) const { return (*m_cellNodesEMC)(c) ;}

  Discretization::ItemVector nodes(Discretization::CellEnumerator ce) const { return (*m_cellNodesEMC)(ce) ;}

  Discretization::ItemVector nodes(const Discretization::Face f) const { return (*m_faceNodesEMC)(f) ;}

  Discretization::ItemVector nodes(Discretization::FaceEnumerator fe) const { return (*m_faceNodesEMC)(fe) ;}

  Discretization::Cell backCell(const Discretization::Face f) const { Discretization::ItemVector cv((*m_faceCellsEMC)(f)) ; return cv[0] ;}

  Discretization::Cell backCell(Discretization::FaceEnumerator fe) const { Discretization::ItemVector cv((*m_faceCellsEMC)(fe)) ; return cv[0] ;}

  Discretization::Cell frontCell(const Discretization::Face f) const { Discretization::ItemVector cv((*m_faceCellsEMC)(f)) ; return cv[1] ;}

  Discretization::Cell frontCell(Discretization::FaceEnumerator fe) const { Discretization::ItemVector cv((*m_faceCellsEMC)(fe)) ; return cv[1] ;}

  Discretization::Cell boundaryCell(const Discretization::Face f) const { Discretization::ItemVector cv((*m_faceCellsEMC)(f)) ; return cv[0] ;}

  Discretization::Cell boundaryCell(Discretization::FaceEnumerator fe) const { Discretization::ItemVector cv((*m_faceCellsEMC)(fe)) ; return cv[0] ;}

  Discretization::Cell cell(const Discretization::Face& f, const Discretization::FaceCellInd ind) const
    { Discretization::ItemVector cv((*m_faceCellsEMC)(f)) ; return cv[static_cast<int>(ind)] ;}


#else

  // SDC : to clean...
  // SDC : new API watchout ConnectedItems, should not be created inside enumerate loops for perf...refactoring todo
  // Si on veut garder les m�thodes const il faut alors passer le connectivity vector � l'appel => plus de modif d'API...
//  Arcane::ItemVectorView cells(const Discretization::Node n) {return (*m_nodeCellsEMC)(n,*m_node_cells_connectivity_vector) ;}
//  Arcane::ItemVectorView cells(Discretization::NodeEnumerator ne) { return (*m_nodeCellsEMC)(*ne, *m_node_cells_connectivity_vector) ;}
  Arcane::ConnectivityItemVectorCatalyst cells(const Discretization::Node n) const {return (*m_nodeCellsEMC)(n) ;}
  Arcane::ConnectivityItemVectorCatalyst cells(Discretization::NodeEnumerator ne) const { return cells(*ne) ;}


//  Arcane::ItemVectorView faces(const Discretization::Node n)  { return (*m_nodeFacesEMC)(n,*m_node_faces_connectivity_vector) ;}
//  Arcane::ItemVectorView faces(Discretization::NodeEnumerator ne) { return (*m_nodeFacesEMC)(*ne,*m_node_faces_connectivity_vector) ;}
  Arcane::ConnectivityItemVectorCatalyst faces(const Discretization::Node n) const { return (*m_nodeFacesEMC)(n) ;}
  Arcane::ConnectivityItemVectorCatalyst faces(Discretization::NodeEnumerator ne) const { return faces(*ne) ;}


//  Arcane::ItemVectorView faces(const Discretization::Cell c)  { return (*m_cellFacesEMC)(c,*m_cell_faces_connectivity_vector) ;}
//  Arcane::ItemVectorView faces(Discretization::CellEnumerator ce) { return (*m_cellFacesEMC)(*ce, *m_cell_faces_connectivity_vector) ;}
  Arcane::ConnectivityItemVectorCatalyst faces(const Discretization::Cell c) const { return (*m_cellFacesEMC)(c) ;}
  Arcane::ConnectivityItemVectorCatalyst faces(Discretization::CellEnumerator ce) const {return faces(*ce) ;}

  //  Arcane::ItemVectorView nodes(const Discretization::Cell c)  { return (*m_cellNodesEMC)(c, *m_cell_nodes_connectivity_vector) ;}
  //  Arcane::ItemVectorView nodes(Discretization::CellEnumerator ce)  { return (*m_cellNodesEMC)(*ce, *m_cell_nodes_connectivity_vector) ;}
    Arcane::ConnectivityItemVectorCatalyst nodes(const Discretization::Cell c) const { return (*m_cellNodesEMC)(c) ;}
    Arcane::ConnectivityItemVectorCatalyst nodes(Discretization::CellEnumerator ce) const { return nodes(*ce) ;}

    //  Arcane::ItemVectorView nodes(const Discretization::Face f)  { return (*m_faceNodesEMC)(f, *m_face_nodes_connectivity_vector) ;}
//  Arcane::ItemVectorView nodes(Discretization::FaceEnumerator fe)  { return (*m_faceNodesEMC)(*fe, *m_face_nodes_connectivity_vector) ;}
  Arcane::ConnectivityItemVectorCatalyst nodes(const Discretization::Face f) const { return (*m_faceNodesEMC)(f) ;}
  Arcane::ConnectivityItemVectorCatalyst nodes(Discretization::FaceEnumerator fe) const { return nodes(*fe) ;}


//  Discretization::Cell backCell(const Discretization::Face f) { return (*m_faceCellsEMC)(f, *m_face_cells_connectivity_vector)[0];}
//  Discretization::Cell backCell(Discretization::FaceEnumerator fe) {return (*m_faceCellsEMC)(*fe,*m_face_cells_connectivity_vector)[0];}
//  Discretization::Cell backCell(const Discretization::Face f){return Discretization::Cell(m_faceCellsEMC->targetFamily()->itemsInternal().begin(),m_faceCellsEMC->connectedItemLocalId(Arcane::ItemLocalId(f.localId()),0));}
  Discretization::Cell backCell(const Discretization::Face f) const {return {m_faceCellsEMC->targetFamily()->itemsInternal().unguardedBasePointer(),m_faceCellsEMC->connectedItemLocalId(Arcane::ItemLocalId(f.localId()),0)};}
  Discretization::Cell backCell(Discretization::FaceEnumerator fe) const {return backCell(*fe);}



//  Discretization::Cell frontCell(const Discretization::Face f)  {return (*m_faceCellsEMC)(f,*m_face_cells_connectivity_vector)[1];}
//  Discretization::Cell frontCell(Discretization::FaceEnumerator fe)  {return (*m_faceCellsEMC)(*fe,*m_face_cells_connectivity_vector)[1];}
  Discretization::Cell frontCell(const Discretization::Face f) const{return {m_faceCellsEMC->targetFamily()->itemsInternal().unguardedBasePointer(),m_faceCellsEMC->connectedItemLocalId(Arcane::ItemLocalId(f.localId()),1)};}
  Discretization::Cell frontCell(Discretization::FaceEnumerator fe) const {return frontCell(*fe);}


//  Discretization::Cell boundaryCell(const Discretization::Face f)  {return (*m_faceCellsEMC)(f,*m_face_cells_connectivity_vector)[0];}
//  Discretization::Cell boundaryCell(Discretization::FaceEnumerator fe)  {return (*m_faceCellsEMC)(*fe,*m_face_cells_connectivity_vector)[0] ;}
  // SDC difference entre boundaryCell et backCell ??
  Discretization::Cell boundaryCell(const Discretization::Face f) const {return {m_faceCellsEMC->targetFamily()->itemsInternal().unguardedBasePointer(),m_faceCellsEMC->connectedItemLocalId(Arcane::ItemLocalId(f.localId()),0)};}
  Discretization::Cell boundaryCell(Discretization::FaceEnumerator fe) const {return boundaryCell(*fe);}

  Discretization::Cell cell(const Discretization::Face& f, const Discretization::FaceCellInd ind) const
    { return {m_faceCellsEMC->targetFamily()->itemsInternal().unguardedBasePointer(),m_faceCellsEMC->connectedItemLocalId(Arcane::ItemLocalId(f.localId()),static_cast<int>(ind))};}

#endif //ARCANE_VERSION < 20305

  bool isCellGroupBoundary(const Discretization::Face f) const { return (*m_isCellGroupBoundary)[f] ; }

  bool isCellGroupBoundary(Discretization::FaceEnumerator fe) const { return (*m_isCellGroupBoundary)[fe] ; }

  bool isSubDomainBoundary(const Discretization::Face f) const { return (*m_isSubDomainBoundary)[f] ; }

  bool isSubDomainBoundary(Discretization::FaceEnumerator fe) const { return (*m_isSubDomainBoundary)[fe] ; }

  bool isInSurfaceMesh(const Discretization::Cell c) const {return (*m_isDisSurfCell)[c] ; }

  bool isInSurfaceMesh(Discretization::CellEnumerator ce) const {return (*m_isDisSurfCell)[ce] ; }

  bool isFaceOfSurfaceMesh(const Discretization::Face f) const { return (*m_isDisSurfFace)[f] ;}

  bool isFaceOfSurfaceMesh(Discretization::FaceEnumerator fe) const { return (*m_isDisSurfFace)[fe] ;}

  bool isDuplicatedDiscretizationFaceInSurfaceMesh(const Discretization::Face f) const {return (*m_isDuplicatedDisSurfFace)[f] ;}

  bool isDuplicatedDiscretizationFaceInSurfaceMesh(Discretization::FaceEnumerator fe) const {return (*m_isDuplicatedDisSurfFace)[fe] ;}

  bool isContact(const Discretization::Face f) const { return (*m_isContact)[f] ; }

  bool isContact(const Discretization::FaceEnumerator fe) const { return isContact(*fe) ; }

  bool isFaultCoreContact(const Discretization::Cell c) const {return (*m_isFaultCoreContact)[c] ;}

  bool isFaultCoreContact(const Discretization::CellEnumerator ce) const {return isFaultCoreContact(*ce) ;}

  Discretization::ItemGroup allCells() const {return m_allDisCells ;}

  Discretization::ItemGroup faultCoreCells() const {return m_faultCoreDisCells ;}

  Discretization::ItemGroup nonFaultCoreCells() const {return m_nonFaultCoreDisCells ;}

  Discretization::ItemGroup allFaces() const {return m_allDisFaces ;}

  Discretization::ItemGroup innerFaces() const {return m_innerDisFaces ;}

  Discretization::ItemGroup outerFaces() const {return m_outerDisFaces ;}

  Discretization::ItemGroup allNodes() const {return m_allDisNodes ;}

  Discretization::ItemGroup innerNodes() const {return m_innerDisNodes ;}

  Discretization::ItemGroup outerNodes() const {return m_outerDisNodes ;}

  Arcane::CellGroup cellGroup() const {return m_filteredCellGroup ;}

  Arcane::CellGroup surfaceCellGroup() const {return m_surfaceCellGroup ;}

  Arcane::FaceGroup activeFacesOfCellGroup() const {return m_faceGroup ;}

  Arcane::FaceGroup duplicatedFacesInSurfaceMeshGroup() const {return m_facesWithDuplicatedDisFaceGroup ;}

  ContactGroup contactGroup() const {
    if(m_matcher != nullptr) {
      ContactGroup contactGroup = m_matcher -> facefaceContactFamily() -> findGroup(m_contactGroupName) ;

      if(contactGroup.null())
        throw Arcane::FatalErrorException(A_FUNCINFO, Arcane::String::format("Contact group {0} does not exist.", m_contactGroupName)) ;
      else 
        return contactGroup ;
    } else {
      return ContactGroup() ;
    }
  }

  Arcane::FaceGroup facesOfSurfaceCellGroup() const {return m_facesOfSurfaceCellGroup ;}

  Arcane::Integer faceToSurfCellLId(const Arcane::Face f) const {return m_faceToSurfCellLIdMap[f] ;}

  Arcane::String connectivityName() const {return m_connectivityName ;} 

  Arcane::IMesh* mesh() const {return m_mesh ;}

  Arcane::IMesh* surfaceMesh() const {return m_surfaceMesh ;}

  INotMatchingSurfaceMng* notMatchingSurfaceMng() const {return m_matcher ;}

  Discretization::ItemKindSet itemKinds() const {return m_iks ;}

  Arcane::String cellFamilyName() const {return m_cellFamily->name() ;}

  Arcane::String faceFamilyName() const {return m_faceFamily->name() ;}

  Discretization::Family* cellFamily() const {return m_cellFamily ;}

  Discretization::Family* faceFamily() const {return m_faceFamily ;}

  Discretization::Family* nodeFamily() const {return m_nodeFamily ;}

  Arcane::Integer getSpaceDimension() {
      return m_mesh -> dimension() ;
  }

private :

  // Variables
  const bool m_useOnlyCellWithOwnNeighbour ;
  Discretization::ItemKindSet m_iks ;
  Arcane::String m_connectivityName ;
  Arcane::IMesh* m_mesh ;
  Arcane::IMesh* m_surfaceMesh ;
  INotMatchingSurfaceMng* m_matcher ;
#if ARCANE_VERSION < 31307
  ItemConnectivityMng m_connectivityMng ;
#endif
  Arcane::DoFManager m_dofMng ;

  Discretization::Family* m_cellFamily ;
  Discretization::Family* m_faceFamily ;
  Discretization::Family* m_nodeFamily ;

  CellExtendedConnectivityUPtr m_cellEC ;
  CellExtendedConnectivityUPtr m_surfCellEC ;
  FaceExtendedConnectivityUPtr m_faceEC ;
  FaceExtendedMultiConnectivityUPtr m_surfFaceEC ;
  NodeExtendedConnectivityUPtr m_nodeEC ;
  ContactExtendedConnectivityUPtr m_contactEC ;
  ContactExtendedConnectivityUPtr m_faultCoreContactEC ;

  CellReverseExtendedConnectivityUPtr m_cellREC ;
  CellReverseExtendedConnectivityUPtr m_surfCellREC ;
  FaceReverseExtendedConnectivityUPtr m_faceREC ;
  FaceReverseExtendedConnectivityUPtr m_surfFaceREC ;
  NodeReverseExtendedConnectivityUPtr m_nodeREC ;
  NodeReverseExtendedConnectivityUPtr m_surfNodeREC ;

  FaceCellExtendedMultiConnectivityUPtr m_faceCellsEMC ;
  CellFaceExtendedMultiConnectivityUPtr m_cellFacesEMC ;
  NodeCellExtendedMultiConnectivityUPtr m_nodeCellsEMC ;
  CellNodeExtendedMultiConnectivityUPtr m_cellNodesEMC ;
  NodeFaceExtendedMultiConnectivityUPtr m_nodeFacesEMC ;
  FaceNodeExtendedMultiConnectivityUPtr m_faceNodesEMC ;

#if (ARCANE_VERSION >= 20305)
  // SDC : no longer needed, to remove. ConnectivityVector are now directly handled (ConnectedItems)
  typedef std::unique_ptr<Arcane::ConnectivityItemVector> ConnectivityVectorPtr;
  ConnectivityVectorPtr m_face_cells_connectivity_vector;
  ConnectivityVectorPtr m_cell_faces_connectivity_vector;
  ConnectivityVectorPtr m_node_cells_connectivity_vector;
  ConnectivityVectorPtr m_cell_nodes_connectivity_vector;
  ConnectivityVectorPtr m_node_faces_connectivity_vector;
  ConnectivityVectorPtr m_face_nodes_connectivity_vector;
#endif

  ConnectivityMap m_faceToSurfCellLIdMap ;
  ConnectivityMap m_surfCellToFaceLIdMap ;

  Arcane::CellGroup m_cellGroup ;
  Arcane::CellGroup m_filteredCellGroup ;
  Arcane::CellGroup m_surfaceCellGroup ;
  Arcane::FaceGroup m_faceGroup ;
  Arcane::FaceGroup m_facesOfSurfaceCellGroup ;
  Arcane::NodeGroup m_nodesOfCellGroup ;

  Arcane::FaceGroup m_facesWithDuplicatedDisFaceGroup ;

  Arcane::String m_surfaceFaceGroupName ;

  Arcane::String m_contactGroupName ;
  ItemGroupSet m_contactFacesSet ;
    
  Discretization::ItemGroup m_allDisCells ;
  Discretization::ItemGroup m_nonFaultCoreDisCells ;
  Discretization::ItemGroup m_faultCoreDisCells ;

  Discretization::ItemGroup m_allDisFaces ;
  Discretization::ItemGroup m_innerDisFaces ;
  Discretization::ItemGroup m_outerDisFaces ;

  Discretization::ItemGroup m_allDisNodes ;
  Discretization::ItemGroup m_innerDisNodes ;
  Discretization::ItemGroup m_outerDisNodes ;

  // Flags
  // for groups
  Arcane::VariableCellBool m_isInCellGroup ;
  std::shared_ptr<Arcane::VariableCellBool> m_isInSurfaceCellGroup ;
  Arcane::VariableFaceBool m_isInFaceGroup ;
  std::unique_ptr<Arcane::VariableFaceBool> m_isInSurfaceFaceGroup ;
  Arcane::VariableNodeBool m_isInNodeGroup ;

  // for some properties
  VariableDoFBoolUPtr m_isCellGroupBoundary ;
  VariableDoFBoolUPtr m_isSubDomainBoundary ;
  VariableDoFBoolUPtr m_isContact ;
  VariableDoFBoolUPtr m_isFaultCoreContact ;
  VariableDoFBoolUPtr m_isDisSurfCell ;
  VariableDoFBoolUPtr m_isDisSurfFace ;
  VariableDoFBoolUPtr m_isDuplicatedDisSurfFace ;

  const bool m_addFaultCore ;

  // Connectivities ItemGroups (for a connectivity the ItemGroup contains only the DoF involved in the connectivity, and not all the family)
  std::map<Arcane::String,Arcane::ItemGroup> m_connectivity_groups;

  Arcane::BoolUniqueArray m_ownCellNeighbourFlag ;

  // Methods
  void _createContactFacesSet() ;

  void _filterArcaneCellsForDiscretization() ;

  void _isMissing(Arcane::IItemFamily* family, const Arcane::ItemGroup group, Arcane::BoolUniqueArray& isMissing) ;

  template<typename T>
  void _initArcaneDiscretizationConnectivityT(Arcane::IItemFamily* family,
                                              Discretization::Family* disFamily,
                                              const Arcane::String connectivityName,
                                              ExtendedConnectivityTUPtr<T>& ptr,
                                              ReverseExtendedConnectivityTUPtr<typename Discretization::ConvertA2D<T>::Type>& rPtr) ;

  void _identifyDoublyConnectedSurfCellsAndAct(const ItemGroupMapT<Arcane::Face, Arcane::Cell>& contactFaceLIdToSurfCell,
                                               std::function<void (const Arcane::Face&)>& action) ;

  void _createDoFForDoublyConnectedCellsOnSurfaceMesh(Arcane::IntegerUniqueArray& nbSurfFaceToDisFace, 
                                                      Arcane::Int32SharedArray& lIds) ;

  void _initArcaneSurfaceFaceDiscretizationConnectivity() ;

  template<typename T, bool faultCore = false>
  void _setFlagOnDiscretizationItemsT(Discretization::Family* disFamily,
                                      typename DiscretizationConnectivityUtils::ExtConnectivityUPtr<T>::Type& ptr,
                                      const typename Discretization::Group<T>::Type group,
                                      Arcane::String varName,
                                      VariableDoFBoolUPtr& var) ;

  template<typename T>
  void _setFlagOnMultiConnectedDiscretizationItemsT(Discretization::Family* disFamily,
                                                    typename DiscretizationConnectivityUtils::ExtMultiConnectivityUPtr<T>::Type& ptr,
                                                    const typename Discretization::Group<T>::Type group,
                                                    Arcane::String varName,
                                                    VariableDoFBoolUPtr& var) ;

  void _setFlagOnMultiConnectedDiscretizationContactFaces(const Arcane::String varName,
                                                          VariableDoFBoolUPtr& var) ;

  template<typename T>
  void _createUIdsT(Discretization::Family* disFamily, const T group, Arcane::Int64ArrayView uids) {
    {
#ifdef USE_ARCANE_V3
      const Arcane::Int64 maxItemUIdPlusOne(Arcane::mesh::DoFUids::getMaxItemUid(disFamily->itemFamily()) + 1) ;
#else
      const Arcane::Int64 maxItemUIdPlusOne(Arcane::mesh::DoFUids::getMaxItemUid(disFamily) + 1) ;
#endif

      Arcane::Integer i(0) ;
      ENUMERATE_ITEM(iitem, group){
        uids[i++] = maxItemUIdPlusOne + Arcane::mesh::DoFUids::uid(iitem -> uniqueId().asInt64()) ;
        //m_mesh -> traceMng() -> debug() << "MAX ITEM UID " << maxItemUId << "UID " << iitem -> uniqueId().asInt64() << "ITEM KIND " << iitem->kind() << "PROPOSED UID " << uids[i - 1] ;
      }
    }
  }

  void _fillConnectivityMap(Arcane::IntegerConstArrayView lids,
                            const Arcane::IItemFamily* family,
                            const Arcane::ItemGroup ownGroup,
                            ConnectivityMap& map) {
#if (ARCANE_VERSION >= 20201)
    map.resize(family,NULL_ITEM_LOCAL_ID) ;
#else
    map.resize(family) ;
#endif

    Arcane::Integer count(0) ;
    ENUMERATE_ITEM(iitem, ownGroup){
      map[iitem] = lids[count++] ;
    }
  }

  template<typename T>
  void _fillReverseConnectivityMap(Discretization::Family* disFamily,
                                   const ExtendedConnectivityT<T>& ec,
                                   const Arcane::ItemGroup allGroup,
                                   ConnectivityMap& rMap) {
#ifdef USE_ARCANE_V3
    Arcane::IItemFamily *disFamily_asIItemFamily = disFamily->itemFamily();
#else
    Arcane::IItemFamily *disFamily_asIItemFamily = disFamily;
#endif

#if (ARCANE_VERSION >= 20201)
    rMap.resize(disFamily_asIItemFamily,NULL_ITEM_LOCAL_ID) ;
#else
    rMap.resize(disFamily) ;
#endif

    for(Arcane::ItemEnumeratorT<T> ie(allGroup.enumerator()); ie.hasNext(); ++ie) {
        typename Discretization::ConvertA2D<T>::Type dI(ec(ie)) ;

        rMap[dI] = ie -> localId() ;
    }
  }

  void _fillReverseConnectivityMapForSurfaceMeshFaces(ConnectivityMap& rMap) {

    ENUMERATE_FACE(iFace, m_surfaceMesh->allFaces()) {
      Discretization::ConnectedItems iv((*m_surfFaceEC)(iFace));
      Discretization::Face disFace(iv[0]);
      
      rMap[disFace] = iFace->localId();
    }

    ENUMERATE_FACE(iFace, m_facesWithDuplicatedDisFaceGroup) {
      Discretization::ConnectedItems iv((*m_surfFaceEC)(iFace));
      Discretization::Face disFace(iv[1]);
      
      rMap[disFace] = iFace->localId();
    }    
  }

  void _createContactDiscretizationConnectivity(Discretization::Family* disFamily,
                                                ContactExtendedConnectivityUPtr& ptr,
                                                const bool multi = false) ;

  void _fillContactConnectivityMap(Arcane::IntegerSharedArray lids, const Arcane::Integer firstIndex,
                                   Arcane::ItemScalarProperty<Arcane::Int32>& map) ;

  template<class T, class U, bool surfaceMeshFlag>
  void _createDiscretizationMultiConnectivityT(const DiscretizationConnectivityUtils::MultiConnectivityTreatmentsT<T, U, surfaceMeshFlag>& mct,
                                               const Arcane::String connectivityName,
                                               ExtendedMultiConnectivityTUUPtr<T, U>& ptr12) ;

  template<typename T, bool surfaceMeshFlag>
  void _createDiscretizationGroupsT(Discretization::Family* family,
                                    const DiscretizationConnectivityUtils::ItemSelectFunctorT<T, surfaceMeshFlag>& select,
                                    DisGroupNameInitList groupsWithNames, const bool clear = true) ;

  void _createNonCellGroupFlags() ;
  void _createItemGroupsOfCellGroup() ;
  void _createBoundaryFlags() ;

  template<typename T>
  void _updateArcaneDiscretizationConnectivityT(Arcane::IItemFamily* family,
                                                Discretization::Family* disFamily,
                                                ExtendedConnectivityTUPtr<T>& ptr,
                                                ReverseExtendedConnectivityTUPtr<typename Discretization::ConvertA2D<T>::Type>& rPtr) ;

  void _updateSurfaceFaceDiscretizationConnectivity() ;

  void _createFaceToSurfCellLIdAndReverseMaps() ;

  void _check() ;
};

template<typename T>
class DiscretizationCellVariableRefTReaderWrapper {
public:
  DiscretizationCellVariableRefTReaderWrapper(const DiscretizationConnectivity &dc,
                                              const MeshVariableScalarRefT<Arcane::Cell, T> &var) :
      m_dc(dc),
      m_cellVar(&var) {
    m_cellLambda = [&](const Arcane::Cell &c) -> const T& {
      return (*m_cellVar)[c] ;
    };
    m_disCellLambda = [&](const Discretization::Cell &dc) -> const T& {
      return (*m_cellVar)[m_dc.cell(dc)] ;
    };
  }

  DiscretizationCellVariableRefTReaderWrapper(const DiscretizationConnectivity &dc,
                                              const MeshVariableScalarRefT<Arcane::DoF, T> &var) :
      m_dc(dc),
      m_disCellVar(&var) {

    m_cellLambda = [this](const Arcane::Cell &c) -> const T& {
      return (*m_disCellVar)[m_dc.cell(c)] ;
    };

    m_disCellLambda = [&](const Discretization::Cell &dc) -> const T& {
      return (*m_disCellVar)[dc] ;
    } ;
  }

  const T& operator[](const Arcane::Cell &c) {
    return m_cellLambda(c) ;
  }

  const T& operator[](const Arcane::CellEnumerator &ce) {
    return operator[](*ce) ;
  }

  const T& operator[](const Discretization::Cell &dc) {
    return m_disCellLambda(dc) ;
  }

  const T& operator[](const Discretization::CellEnumerator &dce) {
    return operator[](*dce) ;
  }

private:
  const DiscretizationConnectivity &m_dc;
  const MeshVariableScalarRefT<Arcane::Cell, T> *m_cellVar = nullptr;
  const MeshVariableScalarRefT<Arcane::DoF, T> *m_disCellVar = nullptr;
  std::function<const T&(const Arcane::Cell &c)> m_cellLambda ;
  std::function<const T&(const Discretization::Cell &dc)> m_disCellLambda ;
};


template<typename T>
class DiscretizationCellVariableRefTWriterWrapper {
public:
  DiscretizationCellVariableRefTWriterWrapper(const DiscretizationConnectivity &dc,
                                              MeshVariableScalarRefT<Arcane::Cell, T> &var) :
      m_dc(dc),
      m_cellVar(&var) {
    m_cellLambda = [&](const Arcane::Cell &c) -> T& {
      return (*m_cellVar)[c] ;
    };
    m_disCellLambda = [&](const Discretization::Cell &dc) -> T& {
      return (*m_cellVar)[m_dc.cell(dc)] ;
    };
  }

  DiscretizationCellVariableRefTWriterWrapper(const DiscretizationConnectivity &dc,
                                              MeshVariableScalarRefT<Arcane::DoF, T> &var) :
      m_dc(dc),
      m_disCellVar(&var) {

    m_cellLambda = [this](const Arcane::Cell &c) -> T& {
      return (*m_disCellVar)[m_dc.cell(c)] ;
    };

    m_disCellLambda = [&](const Discretization::Cell &dc) -> T& {
      return (*m_disCellVar)[dc] ;
    } ;
  }

  T& operator[](const Arcane::Cell &c) {
    return m_cellLambda(c) ;
  }

  T& operator[](const Arcane::CellEnumerator &ce) {
    return operator[](*ce) ;
  }

  T& operator[](const Discretization::Cell &dc) {
    return m_disCellLambda(dc) ;
  }

  T& operator[](const Discretization::CellEnumerator &dce) {
    return operator[](*dce) ;
  }

private:
  const DiscretizationConnectivity &m_dc;
  MeshVariableScalarRefT<Arcane::Cell, T> *m_cellVar = nullptr;
  MeshVariableScalarRefT<Arcane::DoF, T> *m_disCellVar = nullptr;
  std::function<T&(const Arcane::Cell &c)> m_cellLambda ;
  std::function<T&(const Discretization::Cell &dc)> m_disCellLambda ;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCANEDEMO_SCHEMEAPI2016_DISCRETIZATIONCONNECTIVITY_H */
