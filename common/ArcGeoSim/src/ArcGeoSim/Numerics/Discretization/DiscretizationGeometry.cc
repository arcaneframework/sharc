// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
/* Author : encheryg at Thu Feb 18 18:55:21 2016
 * Generated by createNew
 */
#include <cmath>

#include "DiscretizationGeometry.h"

using namespace ArcGeoSim::Surface;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

DiscretizationGeometry::DiscretizationGeometry(DiscretizationConnectivity& dc,
					       const bool simpleCorefinement,
					       const Arcane::VariableCellReal* surfaceMeshThicknesses,
					       const bool useMassFaceCentersIfAvailable,
					       const Arcane::VariableCellReal* faultCoreThicknesses) :
  m_dc(&dc), m_simpleCorefinement(simpleCorefinement),
  m_cellMeasures(nullptr), m_cellCenters(nullptr), m_faceMeasures(
								  nullptr), m_faceCenters(nullptr),
  m_faceOrientedUnitNormals(nullptr), m_undefinedContactCenters(
								nullptr), m_surfaceMeshThicknesses(surfaceMeshThicknesses),
  m_withSurfaceMesh(false), m_cellPropertiesComputed(false),
  m_facePropertiesComputed(false), m_useMassFaceCentersIfAvailable(
								   useMassFaceCentersIfAvailable), m_faultCoreThicknesses(
															  faultCoreThicknesses) {

  m_withSurfaceMesh = m_dc -> surfaceMesh() != nullptr;
  m_withFaultCore = m_withSurfaceMesh && m_faultCoreThicknesses != nullptr;

  const Discretization::ItemKindSet iks = m_dc->itemKinds();

  if (iks.find(Discretization::ItemKind::Face) != iks.end()) {
    m_faceMeasures.reset(new Arcane::VariableDoFArrayReal(
							  Arcane::VariableBuildInfo(m_dc->mesh(),
										    "DiscretizationFaceMeasures", m_dc->faceFamilyName())));
    m_faceCenters.reset(new Arcane::VariableDoFArrayReal3(
							  Arcane::VariableBuildInfo(m_dc->mesh(),
										    "DiscretizationFaceCenters", m_dc->faceFamilyName())));
    m_faceOrientedUnitNormals.reset(new Arcane::VariableDoFArrayReal3(
								      Arcane::VariableBuildInfo(m_dc->mesh(),
												"DiscretizationFaceOrientedUnitNormals",
												m_dc->faceFamilyName())));
    m_undefinedContactCenters.reset(new Arcane::VariableDoFArrayBool(
								     Arcane::VariableBuildInfo(m_dc->mesh(),
											       "DiscretizationUndefinedContactCenters",
											       m_dc->faceFamilyName())));

    m_faceMeasures -> resize(2);
    m_faceCenters -> resize(2);
    m_faceOrientedUnitNormals -> resize(2);
    m_undefinedContactCenters -> resize(2);

    _fillFaceVariables();
    m_facePropertiesComputed = true;
  }

  // Cell volumes are deduced from face properties when using a surface mesh
  if (iks.find(Discretization::ItemKind::Cell) != iks.end()) {
    if (m_withSurfaceMesh && not m_facePropertiesComputed) {
      throw Arcane::FatalErrorException(A_FUNCINFO,
					"Face properties should be first computed when using a surface mesh");
    }
    m_cellMeasures.reset(
			 new Arcane::VariableDoFReal(Arcane::VariableBuildInfo(
									       m_dc -> mesh(), "DiscretizationCellMeasures",
									       m_dc -> cellFamilyName())));
    m_cellCenters.reset(new Arcane::VariableDoFReal3(
						     Arcane::VariableBuildInfo(m_dc -> mesh(),
									       "DiscretizationCellCenters", m_dc -> cellFamilyName())));
    _fillCellVariables();
    m_cellPropertiesComputed = true;
  }
  //_check() ;
}

/*---------------------------------------------------------------------------*/
void DiscretizationGeometry::_fillFaceVariables() {
  ArcGeoSim::AppService < IGeometryMng > geometry;

  const auto& domainCellCenters(geometry -> getReal3VariableProperty(m_dc->mesh() -> allCells(),
								     IGeometryProperty::PCenter)) ;

  const auto massFaceCentersAvailable(m_useMassFaceCentersIfAvailable && geometry -> hasItemGroupProperty(
													  m_dc->mesh() -> allFaces(),IGeometryProperty::PMassCenter)) ;

  const auto centerProperty(massFaceCentersAvailable ? IGeometryProperty::PMassCenter : IGeometryProperty::PCenter) ;

  const auto& domainFaceCenters(geometry -> getReal3VariableProperty(m_dc->mesh() -> allFaces(),centerProperty)) ;

  const auto& domainFaceNormals = geometry -> getReal3VariableProperty(m_dc->mesh() -> allFaces(),
								       IGeometryProperty::PNormal);

  const auto& domainFaceMeasures = geometry -> getRealVariableProperty(m_dc->mesh() -> allFaces(),
								       IGeometryProperty::PMeasure);

  _fillFaceVariablesForActiveFaces(domainCellCenters, domainFaceCenters, domainFaceNormals, domainFaceMeasures);

  if (m_withSurfaceMesh) {
    const IGeometryMng::Real3Variable surfCellCenters =
      geometry -> getReal3VariableProperty(
					   m_dc -> surfaceMesh() -> allCells(),
					   IGeometryProperty::PCenter);

    const IGeometryMng::Real3Variable surfCellNormals =
      geometry -> getReal3VariableProperty(
					   m_dc -> surfaceMesh() -> allCells(),
					   IGeometryProperty::PNormal);

    const IGeometryMng::RealVariable surfCellMeasures =
      geometry -> getRealVariableProperty(
					  m_dc -> surfaceMesh() -> allCells(),
					  IGeometryProperty::PMeasure);

    const IGeometryMng::RealVariable surfFaceMeasures =
      geometry -> getRealVariableProperty(
					  m_dc -> surfaceMesh() -> allFaces(),
					  IGeometryProperty::PMeasure);

    const Arcane::VariableNodeReal3 nodesCoords =
      m_dc -> mesh() -> nodesCoordinates();

    _fillFaceVariablesForSurfaceMeshFaces(domainFaceNormals,
					  domainFaceMeasures, surfCellCenters, surfCellNormals,
					  surfCellMeasures, surfFaceMeasures, nodesCoords);

    _fillFaceVariablesForDoubleCorefinementWithSurfaceMesh(
							   domainFaceCenters, domainFaceNormals, domainFaceMeasures);
  } else {
    if (m_simpleCorefinement)
      _fillFaceVariablesForSimpleCorefinement(domainCellCenters, domainFaceCenters);
    else
      _fillFaceVariablesForDoubleCorefinement(domainCellCenters, domainFaceCenters);
  }
}

/*---------------------------------------------------------------------------*/
void DiscretizationGeometry::_fillFaceVariablesForActiveFaces(
							      IGeometryMng::Real3Variable domainCellCenters,
							      IGeometryMng::Real3Variable domainFaceCenters,
							      IGeometryMng::Real3Variable domainFaceNormals,
							      IGeometryMng::RealVariable domainFaceMeasures) {
  ENUMERATE_FACE(iface, m_dc->activeFacesOfCellGroup()) {
    const auto& arcFace(*iface) ;
    const auto& disFace(m_dc->face(iface));

    (*m_faceMeasures)[disFace][0] = (*m_faceMeasures)[disFace][1] = domainFaceMeasures[arcFace];
    (*m_faceCenters)[disFace][0] = (*m_faceCenters)[disFace][1] = domainFaceCenters[arcFace];
    (*m_undefinedContactCenters)[disFace][0] = (*m_undefinedContactCenters)[disFace][1] = false;

    auto& n0((*m_faceOrientedUnitNormals)[disFace][0]) ;

    n0 = domainFaceNormals[arcFace] / (*m_faceMeasures)[disFace][0] ;

    if(m_dc ->isCellGroupBoundary(disFace)) {
      const auto& disCell(m_dc ->boundaryCell(disFace)) ;
      const auto& arcCell(m_dc -> cell(disCell)) ;
      const auto diff(domainFaceCenters[iface] - domainCellCenters[arcCell]) ;

      const auto dotProd(Arcane::math::dot(n0, diff)) ;
      n0 *= std::copysign(1., dotProd) ;
    }

    auto& n1((*m_faceOrientedUnitNormals)[disFace][1]) ;
    n1 = -n0 ;
  }

  ENUMERATE_CELL(iCell , m_dc -> surfaceCellGroup()) {
    const Arcane::Face parentFace(iCell -> parent() -> toFace());
    const Discretization::Face disDomainFace(m_dc -> face(parentFace));

    // Possible re-affectation of centers, measures, flags and normals (see previous ENUMERATE)
    // but necessary for domain faces located on the border of the surface mesh whose boundary cell is
    // not included within the domain cell group
    (*m_faceMeasures)[disDomainFace][0] = (*m_faceMeasures)[disDomainFace][1] = domainFaceMeasures[parentFace] ;
    (*m_undefinedContactCenters)[disDomainFace][0] = (*m_undefinedContactCenters)[disDomainFace][1] = false ;
    
    Arcane::Real3 outUnitNormal(domainFaceNormals[parentFace] / domainFaceMeasures[parentFace]);

    if(parentFace.isSubDomainBoundary()) {
      if(not parentFace.isSubDomainBoundaryOutside())
	outUnitNormal *= -1.;
    }

    (*m_faceCenters)[disDomainFace][0] = (*m_faceCenters)[disDomainFace][1] =
      domainFaceCenters[parentFace] - (*m_surfaceMeshThicknesses)[iCell] * outUnitNormal;

    auto& n0((*m_faceOrientedUnitNormals)[disDomainFace][0]) ;

    n0 = outUnitNormal ;

    if(m_dc ->isCellGroupBoundary(disDomainFace)) {
      n0 *= -1. ;
    }

    auto& n1((*m_faceOrientedUnitNormals)[disDomainFace][1]) ;
    n1 = -n0 ;
  }

  // Shifts the center of the faces containing contacts
  if (m_withFaultCore) {
    ENUMERATE_CELL	(iCell, m_dc -> surfaceCellGroup()) {
      const Arcane::Face face(iCell -> parent().toFace());

      Arcane::Real3 outUnitNormal(domainFaceNormals[face] / domainFaceMeasures[face]);

      if(face.isSubDomainBoundary()) {
	if(not face.isSubDomainBoundaryOutside())
	  outUnitNormal *= -1.;
      }

      const Discretization::Face disFace(m_dc -> face(face));

      const Arcane::Real3 shift((*m_faultCoreThicknesses)[iCell] * outUnitNormal);

      (*m_faceCenters)[disFace][0] = (*m_faceCenters)[disFace][0] - shift;
      (*m_faceCenters)[disFace][1] = (*m_faceCenters)[disFace][1] - shift;
    }
  }
}

/*---------------------------------------------------------------------------*/
void DiscretizationGeometry::_fillFaceVariablesForSimpleCorefinement(
    IGeometryMng::Real3Variable domainCellCenters,
    IGeometryMng::Real3Variable domainFaceCenters) {

  INotMatchingSurfaceMng* matcher = m_dc->notMatchingSurfaceMng();

  if (matcher != nullptr) {
    const SimpleCenterContactType
        & contactCenters =
        matcher -> getPropertyVariable<
            NotMatchingSurfaceProperty::PSimpleCorefinementCenter> ();
    const SimpleNormalContactType
        & contactNormals =
        matcher -> getPropertyVariable<
            NotMatchingSurfaceProperty::PSimpleCorefinementNormal> ();
    const SimpleAreaContactType& contactMeasures =
        matcher -> getPropertyVariable<
            NotMatchingSurfaceProperty::PSimpleCorefinementArea> ();

    ENUMERATE_FACEFACECONTACT	(icontact, m_dc->contactGroup()) {
      const Discretization::Face face(m_dc->face(icontact));

      (*m_faceMeasures)[face][0] = (*m_faceMeasures)[face][1] = contactMeasures[icontact];

      const FaceFaceContact contact = *icontact;
      const Arcane::Face f1 = contact.face1();

      if(not f1.null()) {
        if(std::isnan(contactCenters[icontact].x) || std::isnan(contactCenters[icontact].y) ||
           std::isnan(contactCenters[icontact].z)) {
          (*m_faceCenters)[face][0] = (*m_faceCenters)[face][1] = domainFaceCenters[f1];
          (*m_undefinedContactCenters)[face][0] = (*m_undefinedContactCenters)[face][1] = true;
        } else {
          (*m_faceCenters)[face][0] = (*m_faceCenters)[face][1] = contactCenters[icontact];
          (*m_undefinedContactCenters)[face][0] = (*m_undefinedContactCenters)[face][1] = false;
        }

        auto& n0((*m_faceOrientedUnitNormals)[face][0]) ;

        n0  = contactNormals[icontact] / contactMeasures[icontact] ;

        const auto c1 = f1.boundaryCell() ;
        const auto faceCellVector = domainFaceCenters[f1] - domainCellCenters[c1] ;
        const auto dotProd0 = Arcane::math::dot(faceCellVector, n0) ;

        n0 *= std::copysign(1., dotProd0) ;

        (*m_faceOrientedUnitNormals)[face][1] = -n0 ;
      } else {
        const Arcane::Face f2 = contact.face2();

        if(std::isnan(contactCenters[icontact].x) || std::isnan(contactCenters[icontact].y) ||
           std::isnan(contactCenters[icontact].z)) {
          (*m_faceCenters)[face][0] = (*m_faceCenters)[face][1] = domainFaceCenters[f2];
          (*m_undefinedContactCenters)[face][0] = (*m_undefinedContactCenters)[face][1] = true;
        } else {
          (*m_faceCenters)[face][0] = (*m_faceCenters)[face][1] = contactCenters[icontact];
          (*m_undefinedContactCenters)[face][0] = (*m_undefinedContactCenters)[face][1] = false;
        }

        auto& n1((*m_faceOrientedUnitNormals)[face][1]) ;

        n1  = contactNormals[icontact] / contactMeasures[icontact] ;

        const auto c2 = f2.boundaryCell() ;
        const auto faceCellVector = domainFaceCenters[f2] - domainCellCenters[c2] ;
        const auto dotProd1 = Arcane::math::dot(faceCellVector, n1) ;

        n1 *= std::copysign(1., dotProd1) ;

        (*m_faceOrientedUnitNormals)[face][0] = -n1 ;
      }
    }
  }
}

/*---------------------------------------------------------------------------*/
void DiscretizationGeometry::_fillFaceVariablesForDoubleCorefinement(
    IGeometryMng::Real3Variable domainCellCenters,
    IGeometryMng::Real3Variable domainFaceCenters) {
  INotMatchingSurfaceMng* matcher = m_dc->notMatchingSurfaceMng();

  if (matcher != nullptr) {
    const DoubleCenterContactType
        & contactCenters =
        matcher -> getPropertyVariable<
            NotMatchingSurfaceProperty::PDoubleCorefinementCenter> ();
    const DoubleNormalContactType
        & contactNormals =
        matcher -> getPropertyVariable<
            NotMatchingSurfaceProperty::PDoubleCorefinementNormal> ();
    const DoubleAreaContactType& contactMeasures =
        matcher -> getPropertyVariable<
            NotMatchingSurfaceProperty::PDoubleCorefinementArea> ();

    ENUMERATE_FACEFACECONTACT	(icontact, m_dc->contactGroup()) {
      const Discretization::Face face(m_dc->face(icontact));

      const FaceFaceContact contact = *icontact;
      const Arcane::Face f1 = contact.face1();

      if(not f1.null()) {
        (*m_faceMeasures)[face][0] = contactMeasures[icontact].first;

        if(std::isnan(contactCenters[icontact].first.x) || std::isnan(contactCenters[icontact].first.y) ||
           std::isnan(contactCenters[icontact].first.z)) {
          (*m_faceCenters)[face][0] = domainFaceCenters[f1];
          (*m_undefinedContactCenters)[face][0] = true;
        } else {
          (*m_faceCenters)[face][0] = contactCenters[icontact].first;
          (*m_undefinedContactCenters)[face][0] = false;
        }

        auto& n0((*m_faceOrientedUnitNormals)[face][0]) ;

        n0  = contactNormals[icontact].first / contactMeasures[icontact].first ;

        const auto c1 = f1.boundaryCell() ;
        const auto faceCellVector = domainFaceCenters[f1] - domainCellCenters[c1] ;
        const auto dotProd0 = Arcane::math::dot(faceCellVector, n0) ;

        n0 *= std::copysign(1., dotProd0) ;
      }

      const Arcane::Face f2 = contact.face2();

      if(not f2.null()) {
        (*m_faceMeasures)[face][1] = contactMeasures[icontact].second;

        if(std::isnan(contactCenters[icontact].second.x) || std::isnan(contactCenters[icontact].second.y) ||
           std::isnan(contactCenters[icontact].second.z)) {
          (*m_faceCenters)[face][1] = domainFaceCenters[f2];
          (*m_undefinedContactCenters)[face][1] = true;
        } else {
          (*m_faceCenters)[face][1] = contactCenters[icontact].second;
          (*m_undefinedContactCenters)[face][1] = false;
        }

        auto& n1((*m_faceOrientedUnitNormals)[face][1]) ;

        n1  = contactNormals[icontact].second / contactMeasures[icontact].second ;

        const auto c2 = f2.boundaryCell() ;
        const auto faceCellVector = domainFaceCenters[f2] - domainCellCenters[c2] ;
        const auto dotProd1 = Arcane::math::dot(faceCellVector, n1) ;

        n1 *= std::copysign(1., dotProd1) ;
      } else {
        (*m_faceMeasures)[face][1] = (*m_faceMeasures)[face][0];
        (*m_faceCenters)[face][1] = (*m_faceCenters)[face][0];
        (*m_undefinedContactCenters)[face][1] = (*m_undefinedContactCenters)[face][0];

        // In that case, both normals are chosen in the same direction
        (*m_faceOrientedUnitNormals)[face][1] = (*m_faceOrientedUnitNormals)[face][0];
      }

      if(f1.null()) {
        (*m_faceMeasures)[face][0] = (*m_faceMeasures)[face][1];
        (*m_faceCenters)[face][0] = (*m_faceCenters)[face][1];
        (*m_undefinedContactCenters)[face][0] = (*m_undefinedContactCenters)[face][1];

        // In that case, both normals are chosen in the same direction
        (*m_faceOrientedUnitNormals)[face][0] = (*m_faceOrientedUnitNormals)[face][1];
      }
    }
  }
}

/*---------------------------------------------------------------------------*/
void DiscretizationGeometry::_fillFaceVariablesForDoubleCorefinementWithSurfaceMesh(
										    IGeometryMng::Real3Variable domainFaceCenters,
										    IGeometryMng::Real3Variable domainFaceNormals,
										    IGeometryMng::RealVariable domainFaceMeasures) {
  INotMatchingSurfaceMng* matcher = m_dc->notMatchingSurfaceMng();

  if (matcher != nullptr) {
    const DoubleCenterContactType
      & contactCenters =
      matcher -> getPropertyVariable<
	NotMatchingSurfaceProperty::PDoubleCorefinementCenter> ();
    const DoubleAreaContactType& contactMeasures =
      matcher -> getPropertyVariable<
	NotMatchingSurfaceProperty::PDoubleCorefinementArea> ();

    if (m_withFaultCore) {
      const Arcane::ItemInternalArrayView surfCellsInternalView(
								m_dc -> surfaceMesh() -> cellFamily() -> itemsInternal());

      ENUMERATE_FACEFACECONTACT		(iContact, m_dc -> contactGroup()) {
	const FaceFaceContact contact = *iContact;
	const Arcane::Face f1 = contact.face1();
	const Arcane::Face f2 = contact.face2();

	Arcane::UniqueArray<Arcane::Face> f(2) ;
  f[0] = f1 ;
  f[1] = f2 ;
	for(Arcane::Integer i(0); i < 2; ++i) {
	  Arcane::Face face(f[i]);

	  // Takes the other face and reverses its normal if the current face does not exist
	  const Arcane::Integer j((i == 0) ? 1 : 0);
	  if(face.null()) {
	    face = f[j];
	  }

	  const Discretization::Pair elem((i == 0) ? Discretization::Pair::First : Discretization::Pair::Second);
	  const Discretization::Face disContactFace(m_dc -> face(contact, elem));

	  const Arcane::Real contactMeasure((i == 0) ? contactMeasures[contact].first :
					    contactMeasures[contact].second);

	  (*m_faceMeasures)[disContactFace][0] = (*m_faceMeasures)[disContactFace][1] =
	    contactMeasure;

	  Arcane::Real3 fUnitNormal(domainFaceNormals[face] / domainFaceMeasures[face]);
	  fUnitNormal *= (face.isSubDomainBoundaryOutside()) ? 1. : -1.;

	  // Takes the initial normal for f1 and the reverse one for f2
	  Arcane::Real3 fBackFrontUnitNormal((i == 0) ? fUnitNormal : -fUnitNormal);

	  (*m_faceOrientedUnitNormals)[disContactFace][i] = fBackFrontUnitNormal;
	  (*m_faceOrientedUnitNormals)[disContactFace][j] = -fBackFrontUnitNormal;
	  
	  const Arcane::Real3 contactCenter((i == 0) ? contactCenters[contact].first :
					    contactCenters[contact].second);

	  const bool isContactCenterUnDefined(std::isnan(contactCenter.x) || std::isnan(contactCenter.y) ||
					      std::isnan(contactCenter.z));

	  const Arcane::Real3 contactCenter2((i == 0) ? contactCenters[contact].second :
					     contactCenters[contact].first);

	  const bool isContactCenter2UnDefined(std::isnan(contactCenter2.x) || std::isnan(contactCenter2.y) ||
					       std::isnan(contactCenter2.z));

	  if(isContactCenterUnDefined) {
	    (*m_undefinedContactCenters)[disContactFace][i] = true;

	    if(isContactCenter2UnDefined) {
	      (*m_faceCenters)[disContactFace][0] = (*m_faceCenters)[disContactFace][1] = domainFaceCenters[face];
	    } else {
	      const Arcane::Real3 FaceContactCentersvector(domainFaceCenters[face] - contactCenter2);
	      (*m_faceCenters)[disContactFace][0] = (*m_faceCenters)[disContactFace][1] =
		contactCenter2 + Arcane::math::dot(FaceContactCentersvector, fUnitNormal) * fUnitNormal;
	    }
	  } else {
	    (*m_undefinedContactCenters)[disContactFace][i] = false;

	    const Arcane::Real3 FaceContactCentersvector(domainFaceCenters[face] - contactCenter);
	    (*m_faceCenters)[disContactFace][0] = (*m_faceCenters)[disContactFace][1] =
	      contactCenter + Arcane::math::dot(FaceContactCentersvector, fUnitNormal) * fUnitNormal;

	  }

	  // Shift of the center because of the presence of the fault core
	  const Arcane::Cell surfCell(surfCellsInternalView[m_dc -> faceToSurfCellLId(face)]);
	  const Arcane::Real3 shift((*m_faultCoreThicknesses)[surfCell] * fUnitNormal);

	  // Tests if the opposite normal has been chosen
	  if(f[i].null()) {
	    (*m_faceCenters)[disContactFace][0] = (*m_faceCenters)[disContactFace][0] + shift;
	    (*m_faceCenters)[disContactFace][1] = (*m_faceCenters)[disContactFace][1] + shift;
	  } else {
	    (*m_faceCenters)[disContactFace][0] = (*m_faceCenters)[disContactFace][0] - shift;
	    (*m_faceCenters)[disContactFace][1] = (*m_faceCenters)[disContactFace][1] - shift;
	  }
	}
      }
    } else {
      ENUMERATE_FACEFACECONTACT(icontact, m_dc->contactGroup()) {
	const Discretization::Face disFace(m_dc->face(icontact));

	const FaceFaceContact contact = *icontact;
	const Arcane::Face f1 = contact.face1();
	const Arcane::Face f2 = contact.face2();

	uint i(0);
	for(auto f : {f1, f2}) {
	  if(not f.null()) {
	    const Arcane::Real contactMeasure((i == 0) ? contactMeasures[icontact].first :
					      contactMeasures[icontact].second);

	    const Arcane::Real3 contactCenter((i == 0) ? contactCenters[icontact].first :
					      contactCenters[icontact].second);

	    (*m_faceMeasures)[disFace][i] = contactMeasure;

	    Arcane::Real3 fUnitNormal(domainFaceNormals[f] / domainFaceMeasures[f]);
	    fUnitNormal *= (f.isSubDomainBoundaryOutside()) ? 1. : -1.;

	    (*m_faceOrientedUnitNormals)[disFace][i] = fUnitNormal;

	    if(std::isnan(contactCenter.x) || std::isnan(contactCenter.y) ||
	       std::isnan(contactCenter.z)) {
	      (*m_faceCenters)[disFace][i] = domainFaceCenters[f];
	      (*m_undefinedContactCenters)[disFace][i] = true;
	    } else {
	      const Arcane::Real3 FaceContactCentersvector(domainFaceCenters[f] - contactCenter);
	      (*m_faceCenters)[disFace][i] = contactCenter + Arcane::math::dot(FaceContactCentersvector,
									       fUnitNormal) * fUnitNormal;

	      (*m_undefinedContactCenters)[disFace][i] = false;
	    }
	  }
	  ++i;
	}

	i = 0;
	for(auto f : {f1, f2}) {
	  if(f.null()) {
	    const uint j((i == 0) ? 1 : 0);
	    (*m_faceMeasures)[disFace][i] = (*m_faceMeasures)[disFace][j];
	    (*m_faceCenters)[disFace][i] = (*m_faceCenters)[disFace][j];
	    (*m_undefinedContactCenters)[disFace][i] = (*m_undefinedContactCenters)[disFace][j];

	    // In that case, both normals are chosen in the same direction
	    (*m_faceOrientedUnitNormals)[disFace][i] = (*m_faceOrientedUnitNormals)[disFace][j];
	  }
	  ++i;
	}
      }
    }
  }
}

/*---------------------------------------------------------------------------*/
void DiscretizationGeometry::_fillFaceVariablesForSurfaceMeshFaces(
								   const IGeometryMng::Real3Variable domainFaceNormals,
								   const IGeometryMng::RealVariable domainFaceMeasures,
								   const IGeometryMng::Real3Variable surfCellCenters,
								   const IGeometryMng::Real3Variable surfCellNormals,
								   const IGeometryMng::RealVariable surfCellMeasures,
								   const IGeometryMng::RealVariable surfFaceMeasures,
								   const Arcane::VariableNodeReal3 nodesCoords) {
  ENUMERATE_FACE(iFace, m_dc -> surfaceMesh() -> allFaces()) {
    Arcane::UniqueArray<Arcane::Cell> neighbourCells;
    neighbourCells.reserve(2);

    if(iFace -> isSubDomainBoundary()) {
      const Arcane::Cell boundaryCell(iFace -> boundaryCell());

      neighbourCells.add(boundaryCell);
    } else {
      const Arcane::Cell backCell(iFace -> backCell());
      const Arcane::Cell frontCell(iFace -> frontCell());

      neighbourCells.add(backCell);
      neighbourCells.add(frontCell);
    }

    Arcane::Real3 faceCenter(Arcane::Real3::zero());

    Arcane::UniqueArray<Arcane::Real3> nodesFaceCoords;
    nodesFaceCoords.reserve(2);
    ENUMERATE_NODE(iNode, iFace -> nodes()) {
      const Arcane::Real3 nodeCoord(nodesCoords[iNode -> parent() -> toNode()]);
      nodesFaceCoords.add(nodeCoord);

      faceCenter += nodeCoord;
    }

    const Arcane::Integer nbNodes(iFace -> nodes().size());

    faceCenter /= nbNodes;

    uint c(0);
    Discretization::Pair p(Discretization::Pair::First);
    for(auto cell : neighbourCells) {
      const Arcane::Face parentFace(cell.parent() -> toFace());

      // Different from ThermiqueHybridReducedModelModule.cc l. 1446 ?
      const Arcane::Real3 cellFaceCentersVector(faceCenter - surfCellCenters[cell]);
      const Arcane::Real3 cellFaceCentersUnitVector(cellFaceCentersVector / cellFaceCentersVector.abs());

      Arcane::Real3 outDomainFaceUnitNormal(domainFaceNormals[parentFace] / domainFaceMeasures[parentFace]);

      if(parentFace.isSubDomainBoundary()) {
	if(not parentFace.isSubDomainBoundaryOutside())
	  outDomainFaceUnitNormal *= -1.;
      }

      const Discretization::Face disFace(m_dc -> face(iFace, true, p));
      const bool isDuplicatedDisFace(m_dc -> isDuplicatedDiscretizationFaceInSurfaceMesh(disFace));

      if(nbNodes > 1) {
	const Arcane::Real3 firstToSecondNodeVector(nodesFaceCoords[0] - nodesFaceCoords[1]);
	const Arcane::Real3 faceTangent(firstToSecondNodeVector / firstToSecondNodeVector.abs());
	const Arcane::Real3 normal(Arcane::math::cross(cellFaceCentersUnitVector, faceTangent));
	const Arcane::Real3 normal2(Arcane::math::cross(normal, faceTangent));
	//const Arcane::Real3 normal(Arcane::math::cross(outDomainFaceUnitNormal, cellFaceCentersUnitVector)) ;
	//const Arcane::Real3 normal2(Arcane::math::cross(normal, outDomainFaceUnitNormal)) ;
	const Arcane::Real3 unitNormal(((Arcane::math::dot(normal2, cellFaceCentersUnitVector) > 0.) ? normal2 : -1. * normal2) /
				       normal2.abs());

	if(isDuplicatedDisFace)
	  (*m_faceOrientedUnitNormals)[disFace][0] = (*m_faceOrientedUnitNormals)[disFace][1] = unitNormal;
	else
	  (*m_faceOrientedUnitNormals)[disFace][c] = unitNormal;
      } else {
	if(isDuplicatedDisFace)
	  (*m_faceOrientedUnitNormals)[disFace][0] = (*m_faceOrientedUnitNormals)[disFace][1] = cellFaceCentersUnitVector;
	else
	  (*m_faceOrientedUnitNormals)[disFace][c] = cellFaceCentersUnitVector;
      }

      const Arcane::Real faceMeasure((*m_surfaceMeshThicknesses)[cell] * (m_dc -> surfaceMesh() -> dimension() == 1 ? 1.0 :
									  Arcane::math::abs(surfFaceMeasures[iFace])));

      Arcane::Real faultCoreShift(0.);

      if(m_withFaultCore) {
	faultCoreShift += (*m_faultCoreThicknesses)[cell];
      }

      if(isDuplicatedDisFace) {
	(*m_faceCenters)[disFace][0] = faceCenter - (0.5 * (*m_surfaceMeshThicknesses)[cell] + faultCoreShift) * outDomainFaceUnitNormal;
	(*m_faceCenters)[disFace][1] = faceCenter + (0.5 * (*m_surfaceMeshThicknesses)[cell] + faultCoreShift) * outDomainFaceUnitNormal; //(*m_faceCenters)[disFace][0] ;
	(*m_faceMeasures)[disFace][0] = faceMeasure;
	(*m_faceMeasures)[disFace][1] = faceMeasure;
      } else {
	(*m_faceCenters)[disFace][c] = faceCenter - (0.5 * (*m_surfaceMeshThicknesses)[cell] + faultCoreShift) * outDomainFaceUnitNormal;
	(*m_faceMeasures)[disFace][c] = faceMeasure;
      }

      // Choose the second discretization face for the next cell
      if(isDuplicatedDisFace)
	p = Discretization::Pair::Second;
      else
	++c;
    }
  }
}

/*---------------------------------------------------------------------------*/
void DiscretizationGeometry::_fillCellVariables() {
  ArcGeoSim::AppService < IGeometryMng > geometry;

  const IGeometryMng::Real3Variable domainCellCenters =
    geometry -> getReal3VariableProperty(m_dc -> mesh() -> allCells(),
					 IGeometryProperty::PCenter);

  ENUMERATE_CELL(iCell, m_dc -> cellGroup()) {
    const Discretization::Cell disCell(m_dc -> cell(iCell));

    (*m_cellCenters)[disCell] = domainCellCenters[iCell];
  }

  if (m_withSurfaceMesh) {
    const IGeometryMng::Real3Variable surfCellCenters =
      geometry -> getReal3VariableProperty(
					   m_dc -> surfaceMesh() -> allCells(),
					   IGeometryProperty::PCenter);

    const IGeometryMng::Real3Variable surfCellNormals =
      geometry -> getReal3VariableProperty(
					   m_dc -> surfaceMesh() -> allCells(),
					   IGeometryProperty::PNormal);

    const IGeometryMng::RealVariable surfCellMeasures =
      geometry -> getRealVariableProperty(
					  m_dc -> surfaceMesh() -> allCells(),
					  IGeometryProperty::PMeasure);

    const IGeometryMng::Real3Variable faceNormals =
      geometry -> getReal3VariableProperty(
					   m_dc -> mesh() -> allFaces(),
					   IGeometryProperty::PNormal);

    const IGeometryMng::RealVariable faceMeasures =
      geometry -> getRealVariableProperty(
					  m_dc -> mesh() -> allFaces(),
					  IGeometryProperty::PMeasure);

    ENUMERATE_CELL(iCell, m_dc -> surfaceCellGroup()) {
      const Discretization::Cell disCell(m_dc -> cell(iCell, true));

      const Arcane::Face parentFace = iCell -> parent() -> toFace();

      Arcane::Real3 outUnitNormal(faceNormals[parentFace] / faceMeasures[parentFace]);

      if(parentFace.isSubDomainBoundary()) {
	if(not parentFace.isSubDomainBoundaryOutside())
	  outUnitNormal *= -1.;
      }

      (*m_cellCenters)[disCell] = surfCellCenters[iCell] -
	0.5 * (*m_surfaceMeshThicknesses)[iCell] * outUnitNormal;
    }

    if (m_withFaultCore) {
      // Computes centers of fault core cells
      INotMatchingSurfaceMng* matcher = m_dc -> notMatchingSurfaceMng();

      if (matcher != nullptr) {
	const DoubleCenterContactType
	  & contactCenters =
	  matcher -> getPropertyVariable<
	    NotMatchingSurfaceProperty::PDoubleCorefinementCenter> ();
	const DoubleAreaContactType
	  & contactMeasures =
	  matcher -> getPropertyVariable<
	    NotMatchingSurfaceProperty::PDoubleCorefinementArea> ();

	const Arcane::ItemInternalArrayView
	  surfCellsInternalView(
				m_dc -> surfaceMesh() -> cellFamily() -> itemsInternal());

	ENUMERATE_FACEFACECONTACT			(iContact, m_dc->contactGroup()) {
	  const Discretization::Cell faultCoreCell(m_dc -> cell(iContact));

	  const FaceFaceContact contact = *iContact;
	  const Arcane::Face f1 = contact.face1();
	  const Arcane::Face f2 = contact.face2();

	  (*m_cellCenters)[faultCoreCell] = Arcane::Real3::zero();
	  (*m_cellMeasures)[faultCoreCell] = 0.0;

	  uint i(0);
	  Arcane::Real nbSuppFaces(0.);
	  for(auto f : {f1, f2}) {
	    if(not f.null()) {
	      const Arcane::Real3 contactCenter((i == 0) ? contactCenters[iContact].first :
						contactCenters[iContact].second);

	      (*m_cellCenters)[faultCoreCell] += contactCenter;

	      const Arcane::Real contactMeasure((i == 0) ? contactMeasures[iContact].first :
						contactMeasures[iContact].second);

	      const Arcane::Cell surfCell(surfCellsInternalView[m_dc -> faceToSurfCellLId(f)]);

	      (*m_cellMeasures)[faultCoreCell] += contactMeasure * (*m_faultCoreThicknesses)[surfCell];

	      nbSuppFaces += 1.;
	    }
	    ++i;
	  }
	  (*m_cellCenters)[faultCoreCell] /= nbSuppFaces;
	}
      }

      // Shifts the centers of the surface mesh cells
      ENUMERATE_CELL(iCell, m_dc -> surfaceCellGroup()) {
	const Arcane::Face face(iCell -> parent().toFace());

	Arcane::Real3 outUnitNormal(faceNormals[face] / faceMeasures[face]);

	if(face.isSubDomainBoundary()) {
	  if(not face.isSubDomainBoundaryOutside())
	    outUnitNormal *= -1.;
	}

	const Arcane::Real3 shift((*m_faultCoreThicknesses)[iCell] * outUnitNormal);
	const Discretization::Cell disCell(m_dc -> cell(iCell, true));

	(*m_cellCenters)[disCell] = (*m_cellCenters)[disCell] - shift;
      }
    }

    // Computes volumes of all cells
    ENUMERATE_DISCRETIZATION_CELL(iDisCell, m_dc -> nonFaultCoreCells()) {
      Discretization::ConnectedItems disFaces(m_dc -> faces(iDisCell));

      Arcane::Integer spatialDimension(m_dc -> mesh() -> dimension());

      (*m_cellMeasures)[iDisCell] = 0.0;
      ENUMERATE_DISCRETIZATION_FACE(iDisFace, disFaces) {
	const auto isCellGroupBoundary(m_dc -> isCellGroupBoundary(iDisFace)) ;
	const Arcane::Integer backBoundCellLid = isCellGroupBoundary ?
	  m_dc -> boundaryCell(iDisFace).localId() : m_dc -> backCell(iDisFace).localId();
	const bool isBackBound = (backBoundCellLid == iDisCell -> localId());
	const Discretization::FaceCellInd faceCellInd =
	  (isBackBound ? Discretization::FaceCellInd::Back : Discretization::FaceCellInd::Front);
	auto i = static_cast<std::underlying_type<Discretization::FaceCellInd>::type>(faceCellInd);
				const Arcane::Real3 faceCenter = (*m_faceCenters)[iDisFace][i];
				const Arcane::Real3 outwardUnitNormal = (*m_faceOrientedUnitNormals)[iDisFace][i];
				const Arcane::Real measure = (*m_faceMeasures)[iDisFace][i];
				const Arcane::Real hypPlaneDistance = hyperplaneDistance(outwardUnitNormal, (*m_cellCenters)[iDisCell], faceCenter) ;
	const Arcane::Real coneMeasure = measure * hypPlaneDistance / spatialDimension ;
				(*m_cellMeasures)[iDisCell] += coneMeasure ;

      }
    }
  } else {
    const IGeometryMng::RealVariable domainCellMeasures =
      geometry -> getRealVariableProperty(m_dc -> mesh() -> allCells(),
					  IGeometryProperty::PMeasure);

    ENUMERATE_CELL(iCell, m_dc -> cellGroup()) {
      const Discretization::Cell disCell(m_dc -> cell(iCell));

      (*m_cellMeasures)[disCell] = domainCellMeasures[iCell];
    }
  }

}

/*---------------------------------------------------------------------------*/
void DiscretizationGeometry::_check() {
  ENUMERATE_DISCRETIZATION_CELL(iCell, m_dc -> allCells()) {
    Arcane::Real3 sum(Arcane::Real3::zero());
    Arcane::Real3 computedCellCenter(Arcane::Real3::zero());
    Arcane::Real totalArea(0.);

    const Arcane::Real3 cellCenter((*m_cellCenters)[iCell]);

    Discretization::ConnectedItems faces(m_dc->faces(iCell));
    ENUMERATE_DISCRETIZATION_FACE(iFace, faces) {
      const Arcane::Integer backBoundCellLid = m_dc -> isCellGroupBoundary(iFace) ?
	m_dc -> boundaryCell(iFace).localId() : m_dc -> backCell(iFace).localId();
      const bool isBackBound = (backBoundCellLid == iCell -> localId());
      const Discretization::FaceCellInd faceCellInd =
	(isBackBound ? Discretization::FaceCellInd::Back : Discretization::FaceCellInd::Front);
      auto i = static_cast<std::underlying_type<Discretization::FaceCellInd>::type>(faceCellInd);

			sum += (*m_faceMeasures)[iFace][i] * (*m_faceOrientedUnitNormals)[iFace][i];
			computedCellCenter += (*m_faceMeasures)[iFace][i] * (*m_faceCenters)[iFace][i];
      totalArea += (*m_faceMeasures)[iFace][i];
    }

    computedCellCenter /= totalArea;

    const Arcane::Real sumNorm(sum.abs());
    if(sumNorm > 1.0e-12) {

      if(m_dc -> isInSurfaceMesh(iCell))
	std::cout << "Cell in surface mesh\n";

      ENUMERATE_DISCRETIZATION_FACE(iFace, faces) {
	const Arcane::Integer backBoundCellLid = m_dc -> isCellGroupBoundary(iFace) ?
	  m_dc -> boundaryCell(iFace).localId() : m_dc -> backCell(iFace).localId();
	const bool isBackBound = (backBoundCellLid == iCell -> localId());
	const Discretization::FaceCellInd faceCellInd =
	  (isBackBound ? Discretization::FaceCellInd::Back : Discretization::FaceCellInd::Front);
	auto i = static_cast<std::underlying_type<Discretization::FaceCellInd>::type>(faceCellInd);

	std::cout << Arcane::String::format("Face {2}  : n = {0}, measure = {1}\n",
					    (*m_faceOrientedUnitNormals)[iFace][i],
					    (*m_faceMeasures)[iFace][i], iFace -> localId()).localstr();
      }

      const Arcane::String msg(Arcane::String::format("DiscretizationGeometry : sum of measured normals = {0} in cell {1}", sumNorm, iCell -> localId()));
      throw Arcane::FatalErrorException(A_FUNCINFO, msg);
    }

    for(Arcane::Integer i(0); i < 3; ++i) {
      const Arcane::Real diff(Arcane::math::abs(computedCellCenter[i] - cellCenter[i]));
      if (diff > 0.1) {
	const Arcane::String msg(Arcane::String::format("DiscretizationGeometry : centers = {0} and {1} in cell {1}",
							computedCellCenter, cellCenter, iCell -> localId()));
	throw Arcane::FatalErrorException(A_FUNCINFO, msg);
      }
    }
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
