#ifndef ARCGEOSIM_NUMERICS_EXPRESSIONS_KOZENYCARMANNFUNCTION_KOZENYCARMANNFUNCTION_H
#define ARCGEOSIM_NUMERICS_EXPRESSIONS_KOZENYCARMANNFUNCTION_KOZENYCARMANNFUNCTION_H
/* Author : desrozis at Tue Feb 17 08:52:36 2009
 * Generated by createNew
 */

namespace Arcane
  {
  }
using namespace Arcane;

#include "ArcGeoSim/Numerics/Expressions/IFunctionR1vR1.h"

#include <arcane/ArcaneVersion.h>
#include <arcane/utils/Array.h>
#include <arcane/utils/String.h>
#include <arcane/utils/ITraceMng.h>

class KozenyCarmannFunction : public IFunctionR1vR1
  {
public:
  /** Constructeur de la classe */
  KozenyCarmannFunction(ITraceMng * trace_mng) :
    m_trace_mng(trace_mng), m_parameter_value(0), m_0_2_div_parameter_2_factor(
        0), m_20_div_parameter_2_factor(0)
    {
      ;
    }

  /** Destructeur de la classe */
  virtual
  ~KozenyCarmannFunction()
    {
    }

public:

  //@{ @name Methods from IIFunction

  //! Initialisation
  void
  init();

  //! Setting parameter
  void
  setParameter(const String & name, const Real & parameter);
  void
  setParameter(Integer index, const Real & parameter);

  //! Getting number of parameter
  Integer
  nbParameter() const;

  //! Getting name of parameter
  String
  parameterName(Integer index) const;

  //! Setting vectorized variable
  void
  setVariable(const String & name, const Array<Real> & variable);
  void
  setVariable(Integer index, const Array<Real> & variable);

  //! Getting number of variable
  Integer
  nbVariable() const;

  //! Getting name of variable
  String
  variableName(Integer index) const;

  //! Setting evaluation vectorized result
  void
  setEvaluationResult(Array<Real> & result);

  //! Setting derivation vectorized result
  /*! Derivation following @name di variable */
  void
  setDerivationResult(Integer di, Array<Real> & result);

  //! Setting derivation vectorized result
  /*! Derivation following @name di variable */
  void
  setDerivationResult(const String & di, Array<Real> & result);

  //! Eval vectorized data service function
  void
  eval();

  //! Cleanup
  void
  cleanup();

  //@}

public:

  //@{ @name Local methods

  //! Point-wise evaluation
  Real
  eval(const Real & var0);
  void
  eval(const Real & var0, Real & res0);

  //! Vector evaluation
  void
  eval(const Array<Real> & var0, Array<Real> & res0);

  //! Vector evaluation
  void
  eval(const ConstArrayView<Real> var0, ArrayView<Real> res0);

  //! Coupled function and derivative scalar evaluation (temporary: derivation handling in IFunction still to be defined)
  void
  eval(const Real & var0, Real & res0, Real & diffres0)
    {
      m_trace_mng->fatal() << "Not yet implemented";
    }

  //! Point-wise derivation (temporary: derivation handling in IFunction still to be defined)
  Real
  diffEval(const Real & variable)
    {
      m_trace_mng->fatal() << "Not yet implemented";
      return 0;
    }

  //@}

public:

  //! Setting name of variable
  void
  setVariableName(const String & name);

  //! Setting parameter of variable
  void
  setParameterName(const String & name);

private:

  void
  computeFactor();
  Real
  evalSup(const Real & var0) const;
  Real
  evalInf(const Real & var0) const;

protected:
  //! Trace manager
  ITraceMng * m_trace_mng;

  //! Variable name
  String m_variable_name;

  //! Variable name
  String m_parameter_name;

  //! Parameter value
  Real m_parameter_value;

  RealConstArrayView m_variable;
  RealArrayView m_eval_result;
  RealArrayView m_diff_result;

private:

  // Expression utils
  //
  // 0.2 / parameter^2 factor
  Real m_0_2_div_parameter_2_factor;
  //
  // 20. / parameter^2 factor
  Real m_20_div_parameter_2_factor;
  };

#endif /* ARCGEOSIM_NUMERICS_EXPRESSIONS_KOZENYCARMANNFUNCTION_KOZENYCARMANNFUNCTION_H */
