#ifndef ARCGEOSIM_NUMERICS_EXPRESSIONS_PIECEWISEFUNCTIONR2VR1_H
#define ARCGEOSIM_NUMERICS_EXPRESSIONS_PIECEWISEFUNCTIONR2VR1_H
/* Author : dechaiss at Wed Oct 14 10:55:20 2009
 * Generated by createNew
 */

#include <arcane/utils/ITraceMng.h>
#include <arcane/utils/Math.h>
#include <arcane/ArcaneVersion.h>
#include <arcane/utils/Array.h>
#include "ArcGeoSim/Utils/Utils.h"
#include "ArcGeoSim/Numerics/Expressions/PieceWiseFunction/IPieceWiseFunction.h"
#include "ArcGeoSim/Numerics/Expressions/IFunctionR2vR1.h"
#include <vector> // For vector use instead of Array
#include <arcane/utils/Limits.h> // For boundary behavior, Arcane tools
#include <arcane/utils/Exception.h>
#include <limits> // Boundary behavior std tools (to generate NaN)

//! Structure for matrix definition type : by rows or by columns
struct VectorType
{
  enum eVectorType
  {
    row,
    column
  };
};

class PWFArcaneTools
{
public:
  typedef Arcane::RealSharedArray2 PWFArray2;
  typedef Arcane::RealArrayView PWFArrayView;

  class PWFArray2View
  {
  public:
    PWFArray2View(Arcane::RealArray2View all_data,
                  const Arcane::Integer dim1_first_index,
                  const Arcane::Integer dim1_size,
                  const Arcane::Integer dim2_first_index,
                  const Arcane::Integer dim2_size)
    : m_all_data(all_data)
    , m_dim1_first_index(dim1_first_index)
    , m_dim1_size(dim1_size)
    , m_dim2_first_index(dim2_first_index)
    , m_dim2_size(dim2_size){}

    PWFArrayView operator[](const Arcane::Integer i)
    {
      ARCANE_ASSERT(i < m_dim1_size,(Arcane::String::format("Index out of bound in first dimension of piece wise function array 2 index {0} > size {1} ",i,m_dim1_size).localstr()));
      return m_all_data[i + m_dim1_first_index].subView(m_dim2_first_index, m_dim2_size);
    }

  private:
    Arcane::RealArray2View m_all_data;
    Arcane::Integer m_dim1_first_index;
    Arcane::Integer m_dim1_size;
    Arcane::Integer m_dim2_first_index;
    Arcane::Integer m_dim2_size;
  };

public:
  Arcane::Integer dim1Size(PWFArray2& data) {return data.dim1Size();}
  Arcane::Integer dim2Size(PWFArray2& data) {return data.dim2Size();}
  void resize(PWFArray2& data, const Arcane::Integer row_size, const Arcane::Integer column_size)
  {
    data.resize(row_size, column_size);
  }
  PWFArray2View view(PWFArray2& data,
                     const Arcane::Integer dim1_first_index, const Arcane::Integer dim1_bound_index,
                     const Arcane::Integer dim2_first_index, const Arcane::Integer dim2_bound_index)
  {
    // bound_index = last_index + 1 (unherited from previous boost implementation)
    Arcane::Integer dim1_size = dim1_bound_index - dim1_first_index;
    Arcane::Integer dim2_size = dim2_bound_index - dim2_first_index;
    return PWFArray2View(data.view(), dim1_first_index, dim1_size, dim2_first_index, dim2_size);
  }
  void fillDim1(PWFArray2& data, const Arcane::Integer dim2_index, const Arcane::Real value)
  {
    // No extraction possible of first dimension with Arcane::Array2
    for (Arcane::Integer i = 0; i < data.dim1Size(); ++i)
      {
        data[i][dim2_index] = value;
      }
  }
  void fillDim2(PWFArray2& data, const Arcane::Integer dim1_index, const Arcane::Real value)
  {
    PWFArrayView view = data[dim1_index];
    std::fill(view.begin(), view.end(), value);
  }

  void print(PWFArray2& data, ostream& o) const
  {
    for (Arcane::Integer i = 0; i < data.dim1Size(); ++i)
      {
        for (Arcane::Integer j = 0; j < data.dim2Size(); ++j)
          {
            o << "\"";
            o << data.item(i, j);
            o << "\"";
          }
      }
  }
  void fill(PWFArray2& data, const Arcane::Real value)
  {
    data.fill(value);
  }

};

typedef PWFArcaneTools PWFDataTools;

// Template class PieceWiseFunctionR2vR1T. Template argument is the interpolator
template<typename T>
class PieceWiseFunctionR2vR1T :
    public IPieceWiseFunction,
    public IFunctionR2vR1,
    public PWFDataTools
{
public:
  //! Template parameter
  typedef T TypeT;
  typedef typename T::eProlongationType ProlongationType;

public:
  //! Constructeur par copie. Copie la configuration mais pas les données => utiliser la méthode clone pour copier les données
  PieceWiseFunctionR2vR1T(const PieceWiseFunctionR2vR1T<T>& from)
    : m_trace_mng(from.m_trace_mng)
    , m_nb_variables(from.m_nb_variables)
    , m_border_type(from.m_border_type)
    , m_prolongation_type(from.m_prolongation_type)
    , m_out_of_bound_value(from.m_out_of_bound_value)
    , m_coef_right_derivative(from.m_coef_right_derivative)
    , m_coef_left_derivative(from.m_coef_left_derivative)
    , m_initialized(false)
    , m_filled(false)
    , m_boundary_defined(false)
  {
    for (Integer i = 0; i < m_nb_variables; i++)
      {
        m_inserted_point_number[i] = 0;
        m_total_point_number[i] = 0;
      }
    initBorderCondition();
  }

public:
  //! Constructeurs de la classe
  PieceWiseFunctionR2vR1T(ITraceMng * trace_mng)
    : m_trace_mng(trace_mng)
    , m_nb_variables(2)
    , m_border_type(BorderType::InfiniteProlongation)
    , m_prolongation_type(T::ConstantProlongation)
    , m_out_of_bound_value(std::numeric_limits<Real>::quiet_NaN())
    , m_coef_right_derivative(0)
    , m_coef_left_derivative(0)
    , m_initialized(false)
    , m_filled(false)
    , m_boundary_defined(false)
  {
    for (Integer i = 0; i < m_nb_variables; i++)
      {
        m_inserted_point_number[i] = 0;
        m_total_point_number[i] = 0;
      }
  }

  //

  //! Destructeur de la classe
  virtual ~PieceWiseFunctionR2vR1T()
  {
    ;
  }

public:
  void init();

  //! Setting parameter
  void setParameter(const String & name, const Real & parameter)
  {
    m_trace_mng->fatal() << "No parameter for PieceWiseFunction";
  }
  void setParameter(Integer index, const Real & parameter)
  {
    m_trace_mng->fatal() << "No parameter for PieceWiseFunction";
  }

  //! Getting number of parameter
  Integer nbParameter() const
  {
    return 0;
  }

  //! Getting name of parameter
  String parameterName(Integer index) const
  {
    m_trace_mng->fatal() << "No parameter for PieceWiseFunction";
    return "";
  }

  //! Getting number of variable
  Integer nbVariable() const
  {
    return m_nb_variables;
  }

  //! Getting name of variable
  virtual String variableName(Integer index) const;

  //! Setting name of variable
  void setvariableName(Integer index, const String & name);

  //! Setting vectorized variable
  void setVariable(const String & name, const Array<Real> & variable);
  void setVariable(Integer index, const Array<Real> & variable);

  //! Setting evaluation vectorized result
  void setEvaluationResult(Array<Real> & result);

  //! Setting derivation vectorized result
  /*! Derivation following @name di variable */
  void setDerivationResult(Integer di, Array<Real> & result);
  void setDerivationResult(const String & di, Array<Real> & result);

  //! Eval vectorized data service function
  void eval();

  //! Derivation Eval vectorized data service function
  void diffeval();

  //! Cleanup after evaluation
  void cleanup();

  //! Point eval service function
  inline Real eval(const Real & var0, const Real & var1);
  void eval(const Real & var0, const Real & var1, Real & res0);

  //! Eval vectorized data service function
  void eval(const Array<Real> & var0, const Array<Real> & var1, Array<Real> & res0);
  void eval(const ConstArrayView<Real> var0, const ConstArrayView<Real> var1, ArrayView<Real> res0);

  //! Coupled function and derivative scalar evaluation (temporary: derivation handling in IFunction still to be defined)
  inline void eval(const Real & var0, const Real & var1, Real & result, Real & diffres0, Real & diffres1);

  //! Point derivation vs var0
  inline Real diff0Eval(const Real & var0, const Real & var1);

  //! Point derivation vs var1
  inline Real diff1Eval(const Real & var0, const Real & var1);

  void addTableVector(const RealArray & x0, const Real & x1, const RealArray & y,
                      const VectorType::eVectorType vectorType);

  //! Printing point
  void printPoints() const;

  //! Set boundary behavior
  void initBorderCondition(const BorderType::eBorderType& border_type,
                           const ProlongationType& prolongation_type, const Real& lower_row_limit,
                           const Real& upper_row_limit, const Real& lower_col_limit,
                           const Real& upper_col_limit, const BorderType::eCutType& cut_type);
  void initBorderCondition(); //! Default behavior: infinite constant prolongation

  //! Set limit point derivative choice (default = right derivative)
  void setLimitDerivationStrategy(const LimitDerivationStrategy::eLimitDerivationStrategy & derivation_strategy);

  //! Shift and rescale the Table
  void shiftRescale(const Real new_xmin, const Real new_xmax, const Real new_ymin, const Real new_ymax);

  void clone(const PieceWiseFunctionR2vR1T<T>& original_piecewisefunction)
  {
    throw Arcane::NotImplementedException(A_FUNCINFO);
  }

  void getPieceWiseFunctionType(PieceWiseFunctionType& type) const;

private:
  //! Trace manager
  ITraceMng * m_trace_mng;

  //! Variable names
  const Integer m_nb_variables;
  String m_axe_name[2];

  //! --- Table Data ---

  //! Points data
  //    typedef Array<Real> ComponentData; // To use Arcane::Array<Real> for storage (more costly at present)
  //    if Array is used : only 2 lines to change in setPoints(x,y) methode : push_back() <=> add()
  typedef std::vector<Real> ComponentData; // To use std::vector for storage (more efficient cf. doc)
  typedef ComponentData::iterator ComponentDataIterator;
  ComponentData m_x[2], m_x_scan[2];
  PWFDataTools::PWFArray2 m_y;

  Integer m_first_point_index[2], m_last_point_index[2];
  Integer m_inserted_point_number[2], m_total_point_number[2]; // m_total_points_number = m_inserted_points_number + boundary_points_number

  //! Border condition type
  BorderType::eBorderType m_border_type;
  ProlongationType m_prolongation_type;
  Real m_lower_limit[2], m_upper_limit[2], m_out_of_bound_value;
  Integer m_coef_right_derivative, m_coef_left_derivative; // to define table point derivative choice (right or left)

  //! View to handle Table Data
  RealConstArrayView m_var[2];
  RealArrayView m_eval_result;
  RealArrayView m_diff_result[2];

  //! Check table is ready to use : created and filled
  bool m_initialized;
  //! Check table contains at least one point
  bool m_filled;
  //! Check if boundary type has been defined by user (cannot be changed after filling table)
  bool m_boundary_defined;

  bool checkAxeDef(const RealArray & x0, const VectorType::eVectorType axeType);

  //! Boundary condition methods : set border type, init and update table
  void initBorderType(const BorderType::eBorderType& border_type,
                      const ProlongationType& prolongation_type, const Real& lower_row_limit,
                      const Real& upper_row_limit, const Real& lower_col_limit,
                      const Real& upper_col_limit, const BorderType::eCutType& cut_type);
  void initGhostPoints();
  void updateGhostPoints();
};

#include "PieceWiseFunctionR2vR1T.h"

#endif /* ARCGEOSIM_NUMERICS_EXPRESSIONS_PIECEWISEFUNCTIONR2VR1_H */
