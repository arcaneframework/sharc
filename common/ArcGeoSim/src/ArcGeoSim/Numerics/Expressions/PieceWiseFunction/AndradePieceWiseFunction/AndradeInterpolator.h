#ifndef ARCGEOSIM_NUMERICS_EXPRESSIONS_ANDRADEPIECEWISEFUNCTION_ANDRADEINTERPOLATOR_H
#define ARCGEOSIM_NUMERICS_EXPRESSIONS_ANDRADEPIECEWISEFUNCTION_ANDRADEINTERPOLATOR_H
/* Author : ricois at Tue Oct 20 14:12:57 2009
 * Generated by createNew
 * Interpolation selon la formule d'Andrade :
 * Sur un intervalle [x1,x2] de l'abscisse,
 *    Y = y(x) = a * ln( b/x )
 *    Ou a et b sont deux constantes.
 *
 *    En posant y1 = y(x1) et y2 = y(x2), on
 *                       / X2 * ( x - x1 )            y2    \
 *      Y(x) = y1 * exp | ------------------ * log ( ---- )  |
 *                       \ X  * ( x2 - x1 )           y1    /
 * Voir UINTP1 du PumaFlow
 *
 */

#include <arcane/utils/UtilsTypes.h>
#include <arcane/utils/Math.h>
#include <vector>
#include "ArcGeoSim/Numerics/Expressions/PieceWiseFunction/IPieceWiseFunction.h"

namespace Arcane
  {

  }
using namespace Arcane;

class AndradeInterpolator
  {
public:
  /** Constructeur de la classe */
  AndradeInterpolator()
    {
      ;
    }

  /** Destructeur de la classe */
  virtual
  ~AndradeInterpolator()
    {
    }

public:

  enum eProlongationType
    {
    ConstantProlongation, LinearProlongation
    };

  //** Interpolator interval data type */
  typedef Real IntervalData;

  /** Static inline Andrade interpolation method */
  inline static Real
  interpolate(const Real* const x, const Real* y, const IntervalData* const coef,
      const Real v)
    {
      //! Return Andrade interpolate
      return math::exp( *coef * ( v - *x ) / v ) * *y;
    }

  /** Static inline Andrade interpolation : get derivative */
  inline static Real
  differentiate(const Real* const x, const Real* const y,
      const IntervalData* const coef, const Real v)
    {
      return math::exp( *coef * ( v - *x ) / v ) * *y * *coef * *x / v / v;
    }

  /** Static inline update ghost cells value method */
  inline static void
  updateGhostPoints(const eProlongationType& prolongation_type,
      Real* const x_begin, Real* const x_end, Real* const y_begin,
      Real* const y_end)
    {
      switch (prolongation_type)
        {
      case (ConstantProlongation):
        //! x and y Ghost cells = Table first point
        *x_begin = *(x_begin + 1);
        *x_end = *(x_end - 1);
        *y_begin = *(y_begin + 1);
        *y_end = *(y_end - 1);
        break;
      case (LinearProlongation):
        //! x and y Ghost cells = Table first point
        *x_begin = *(x_begin + 1);
        *x_end = *(x_end - 1);
        *y_begin = *(y_begin + 1);
        *y_end = *(y_end - 1);
        break;
        };
    }

  /** Static interval coefficient setting method */
  inline static const IntervalData&
  getForbiddenInterval(const Real& forbidden_interval_value)
    {
      return forbidden_interval_value;
    }

  /** Static method giving number of intervals connected at the right and left of one inserted point */
  inline static void
  getConnectedIntervalNumber(Integer & nb_linterval, Integer & nb_rinterval)
    {
      nb_linterval = 1;
      nb_rinterval = 1;
    }

  /** Static interval coefficient setting method : get default interval coef */
  inline static IntervalData
  getDefaultInterval()
    {
      return 0;
    }

  /** Static interval coefficient precalculation method
   * coef = x2 * ln (y2/y1) / (x2 - x1)
   * */

  static void
  computeIntervalCoef(const Real* const x_left_bound,
      const Real* const y_left_bound, const Integer& interval_number,
      IntervalData* const interval_coeff)
    {
      *interval_coeff = *(x_left_bound + 1) / ( *(x_left_bound + 1) - *x_left_bound ) *
         math::log( *(y_left_bound + 1) / *y_left_bound ) ;
    }

  /** Static inline update ghost value method */
  inline static void
  updateGhostIntervals(const eProlongationType& prolongation_type,
      Real* const x_begin, Real* const x_end, Real* const y_begin,
      Real* const y_end, Real* const interval_begin, Real* const interval_end)
    {
      switch (prolongation_type)
        {
      case (ConstantProlongation):
        //! Interval ghost cells : infinite constant prolongation
        *interval_begin = 0;
        *interval_end = 0;
        break;
      case (LinearProlongation):
        //! Interval ghost cells : infinite constant prolongation
        *interval_begin = *(interval_begin + 1);
        *interval_end = *(interval_end - 1);
        break;
        }
    }

  /** Static method giving type of interpolator using enumeration defined in IPieceWiseFunction.h */
  inline static void
  getInterpolatorType(
      PieceWiseFunctionType::eInterpolatorType & interpolator_type)
    {
      interpolator_type = PieceWiseFunctionType::AndradeInterpolator;
    }

  };

#endif /* ARCGEOSIM_NUMERICS_EXPRESSIONS_ANDRADEPIECEWISEFUNCTION_ANDRADEINTERPOLATOR_H */
