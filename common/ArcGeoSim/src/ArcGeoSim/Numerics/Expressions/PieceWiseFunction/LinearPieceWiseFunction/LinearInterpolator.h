#ifndef ARCGEOSIM_NUMERICS_EXPRESSIONS_LINEARPIECEWISEFUNCTION_LINEARINTERPOLATOR_H
#define ARCGEOSIM_NUMERICS_EXPRESSIONS_LINEARPIECEWISEFUNCTION_LINEARINTERPOLATOR_H
/* Author : dechaiss at Wed Oct 14 16:34:02 2009
 * Generated by createNew
 */
#include <arcane/utils/UtilsTypes.h>
#include <iostream>
#include <vector>
#include "ArcGeoSim/Numerics/Expressions/PieceWiseFunction/IPieceWiseFunction.h"

namespace Arcane
  {
  }
using namespace Arcane;

class LinearInterpolator
  {
public:
  /** Constructeur de la classe */
  LinearInterpolator()
    {
      ;
    }

  /** Destructeur de la classe */
  virtual
  ~LinearInterpolator()
    {
      ;
    }

public:

  /** Type of outside-bound prolongation allowed by the interpolator */
  enum eProlongationType
    {
    ConstantProlongation, LinearProlongation
    };

  /** Interpolator interval data type */
  typedef Real IntervalData;

  /** Static inline linear interpolation method */
  inline static Real
  interpolate(const Real* const x, const Real* const y,
      const IntervalData* const coef, const Real v)
    {
      //! Return linear interpolate (left derivative since interval [a, b[)
      return *coef * (v - *x) + *y;
    }

  /** Static inline linear interpolation : get derivative */
  inline static Real
  differentiate(const Real* const x, const Real* const y,
      const IntervalData* const coef, const Real v)
    {
      return *coef;
    }

  /** Static interval coefficient precalculation method */
  inline static void
  computeIntervalCoef(const Real* const x_left_bound,
      Real* const y_left_bound, const Integer& interval_number,
      IntervalData* const interval_coeff)
    {
      *interval_coeff = (*(y_left_bound + 1) - *y_left_bound)
          / ((*(x_left_bound + 1) - *x_left_bound));
    }

  /** Static inline update ghost cells value method */
  inline static void
  updateGhostPoints(const eProlongationType& prolongation_type,
      Real* const x_begin, Real* const x_end, Real* const y_begin,
      Real* const y_end)
    {
      switch (prolongation_type)
        {
      case (ConstantProlongation):
        //! x and y Ghost cells = Table first point
        *x_begin = *(x_begin + 1);
        *x_end = *(x_end - 1);
        *y_begin = *(y_begin + 1);
        *y_end = *(y_end - 1);
        break;
      case (LinearProlongation):
        //! x and y Ghost cells = Table first point
        *x_begin = *(x_begin + 1);
        *x_end = *(x_end - 1);
        *y_begin = *(y_begin + 1);
        *y_end = *(y_end - 1);
        break;
        }
    }

  /** Static inline compute ghost interval coefficient method */
  inline static void
  updateGhostIntervals(const eProlongationType& prolongation_type,
      Real* const x_begin, Real* const x_end, Real* const y_begin,
      Real* const y_end, Real* const interval_begin, Real* const interval_end)
    {
      switch (prolongation_type)
        {
      case (ConstantProlongation):
        //! Interval ghost cells : infinite constant prolongation
        *interval_begin = 0;
        *interval_end = 0;
        break;
      case (LinearProlongation):
        //! Interval ghost cells : infinite linear prolongation
        *interval_begin = *(interval_begin + 1);
        *interval_end = *(interval_end - 1);
        break;
        }
    }

  /** Static interval coefficient setting method : set forbidden interval coef */
  inline static const IntervalData&
  getForbiddenInterval(const Real& forbidden_interval_value)
    {
      return forbidden_interval_value;
    }

  /** Static interval coefficient setting method : get default interval coef */
  inline static IntervalData
  getDefaultInterval()
    {
      return 0;
    }

  /** Static method giving number of intervals connected at the right and left of one inserted point :
   *  ie : interval which coefficients are modified by the inserted point */
  inline static void
  getConnectedIntervalNumber(Integer& nb_left_interval, Integer& nb_right_interval)
    {
      nb_left_interval = 1;
      nb_right_interval = 1;
    }
  
  /** Static method giving type of interpolator using enumeration defined in IPieceWiseFunction.h */
    inline static void
    getInterpolatorType(PieceWiseFunctionType::eInterpolatorType & interpolator_type)
      {
        interpolator_type = PieceWiseFunctionType::LinearInterpolator;
      }

  };

#endif /* ARCGEOSIM_NUMERICS_EXPRESSIONS_LINEARPIECEWISEFUNCTION_LINEARINTERPOLATOR_H */
