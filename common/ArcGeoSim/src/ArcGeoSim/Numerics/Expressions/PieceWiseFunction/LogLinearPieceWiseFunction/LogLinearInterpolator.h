#ifndef ARCGEOSIM_NUMERICS_EXPRESSIONS_LOGLINEARPIECEWISEFUNCTION_LOGLINEARINTERPOLATOR_H
#define ARCGEOSIM_NUMERICS_EXPRESSIONS_LOGLINEARPIECEWISEFUNCTION_LOGLINEARINTERPOLATOR_H
/* Author : dechaiss at Tue Oct 20 14:12:57 2009
 * Generated by createNew
 */

#include <arcane/utils/UtilsTypes.h>
#include <arcane/utils/Math.h>
#include <vector>
#include "ArcGeoSim/Numerics/Expressions/PieceWiseFunction/IPieceWiseFunction.h"

namespace Arcane
  {

  }
using namespace Arcane;

class LogLinearInterpolator
  {
public:
  /** Constructeur de la classe */
  LogLinearInterpolator()
    {
      ;
    }

  /** Destructeur de la classe */
  virtual
  ~LogLinearInterpolator()
    {
    }

public:

  enum eProlongationType
    {
    ConstantProlongation, LinearProlongation
    };

  //** Interpolator interval data type */
  typedef Real IntervalData;

  /** Static inline linear interpolation method */
  inline static Real
  interpolate(const Real* const x, const Real* y, const IntervalData* const coef,
      const Real v)
    {
      //! Return linear interpolate
      return math::pow(10., *coef * (v - *x) + *y);
    }

  /** Static inline linear interpolation : get derivative */
  inline static Real
  differentiate(const Real* const x, const Real* const y,
      const IntervalData* const coef, const Real v)
    {
      return math::pow(10., *coef * (v - *x) + *y) * *coef;
    }

  /** Static inline update ghost cells value method */
  inline static void
  updateGhostPoints(const eProlongationType& prolongation_type,
      Real* const x_begin, Real* const x_end, Real* const y_begin,
      Real* const y_end)
    {
      switch (prolongation_type)
        {
      case (ConstantProlongation):
        //! x and y Ghost cells = Table first point
        *x_begin = *(x_begin + 1);
        *x_end = *(x_end - 1);
        *y_begin = *(y_begin + 1);
        *y_end = *(y_end - 1);
        break;
      case (LinearProlongation):
        //! x and y Ghost cells = Table first point
        *x_begin = *(x_begin + 1);
        *x_end = *(x_end - 1);
        *y_begin = *(y_begin + 1);
        *y_end = *(y_end - 1);
        break;
        };
    }

  /** Static interval coefficient setting method */
  inline static const IntervalData&
  getForbiddenInterval(const Real& forbidden_interval_value)
    {
      return forbidden_interval_value;
    }

  /** Static method giving number of intervals connected at the right and left of one inserted point */
  inline static void
  getConnectedIntervalNumber(Integer & nb_linterval, Integer & nb_rinterval)
    {
      nb_linterval = 1;
      nb_rinterval = 1;
    }

  /** Static interval coefficient setting method : get default interval coef */
  inline static IntervalData
  getDefaultInterval()
    {
      return 0;
    }

  /** Static interval coefficient precalculation method */
  static void
  computeIntervalCoef(const Real* const x_left_bound,
      const Real* const y_left_bound, const Integer& interval_number,
      IntervalData* const interval_coeff)
    {
      *interval_coeff = (*(y_left_bound + 1) - *y_left_bound)
          / ((*(x_left_bound + 1) - *x_left_bound));
    }

  /** Static inline update ghost value method */
  inline static void
  updateGhostIntervals(const eProlongationType& prolongation_type,
      Real* const x_begin, Real* const x_end, Real* const y_begin,
      Real* const y_end, Real* const interval_begin, Real* const interval_end)
    {
      switch (prolongation_type)
        {
      case (ConstantProlongation):
        //! Interval ghost cells : infinite constant prolongation
        *interval_begin = 0;
        *interval_end = 0;
        break;
      case (LinearProlongation):
        //! Interval ghost cells : infinite constant prolongation
        *interval_begin = *(interval_begin + 1);
        *interval_end = *(interval_end - 1);
        break;
        }
    }

  /** Static method giving type of interpolator using enumeration defined in IPieceWiseFunction.h */
  inline static void
  getInterpolatorType(
      PieceWiseFunctionType::eInterpolatorType & interpolator_type)
    {
      interpolator_type = PieceWiseFunctionType::LogLinearInterpolator;
    }

  };

#endif /* ARCGEOSIM_NUMERICS_EXPRESSIONS_LOGLINEARPIECEWISEFUNCTION_LOGLINEARINTERPOLATOR_H */
