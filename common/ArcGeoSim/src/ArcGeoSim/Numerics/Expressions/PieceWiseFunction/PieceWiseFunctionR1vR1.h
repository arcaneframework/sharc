#ifndef ARCGEOSIM_NUMERICS_EXPRESSIONS_PIECEWISEFUNCTIONR1VR1_H
#define ARCGEOSIM_NUMERICS_EXPRESSIONS_PIECEWISEFUNCTIONR1VR1_H
/* Author : dechaiss at Wed Oct 14 10:55:20 2009
 * Generated by createNew
 */

#include <arcane/ArcaneVersion.h>
#include <arcane/utils/Array.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/utils/Math.h>
#include "ArcGeoSim/Numerics/Expressions/PieceWiseFunction/IPieceWiseFunction.h"
#include "ArcGeoSim/Numerics/Expressions/IFunctionR1vR1.h"
#include <vector> // For vector use instead of Array
#include <arcane/utils/Limits.h> // For boundary behavior, Arcane tools
#include <limits> // Boundary behavior std tools (to generate NaN)


// Template class PieceWiseFunctionR1vR1T. Template argument is the interpolator
template<typename T>
  class PieceWiseFunctionR1vR1T :
      public IPieceWiseFunction, public IFunctionR1vR1
    {
  public:
    //! Template parameter
    typedef T TypeT;
    typedef typename T::eProlongationType ProlongationType;

  public:
    //! Constructeurs de la classe
    PieceWiseFunctionR1vR1T(ITraceMng * trace_mng) :
    m_trace_mng(trace_mng), m_inserted_point_number(0), m_total_point_number(0),
    m_inserted_interval_number(0), m_total_interval_number(0),
    m_border_type(BorderType::InfiniteProlongation),
    m_prolongation_type(T::ConstantProlongation),
    m_out_of_bound_value(std::numeric_limits<Real>::quiet_NaN()),
    m_coef_right_derivative(0), m_coef_left_derivative(0),
    m_initialized(false), m_filled(false), m_first_point(true), m_boundary_defined(false)
      {
        ;
      }

    //

    //! Destructeur de la classe
    virtual ~PieceWiseFunctionR1vR1T()
      {
        ;
      }

  public:
    void init();

    //! Setting parameter
    void setParameter(const String & name, const Real & parameter)
      {
        m_trace_mng->fatal() << "No parameter for PieceWiseFunction";
      }
    void setParameter(Integer index, const Real & parameter)
      {
        m_trace_mng->fatal() << "No parameter for PieceWiseFunction";
      }

    //! Getting number of parameter
    Integer nbParameter() const
      {
        return 0;
      }

    //! Getting name of parameter
    String parameterName(Integer index) const
      {
        m_trace_mng->fatal() << "No parameter for PieceWiseFunction";
        return "";
      }

    //! Getting number of variable
    Integer nbVariable() const
      {
        return 1;
      }

    //! Getting name of variable
    String variableName(Integer index) const;

    //! Setting name of variable
    void setVariableName(const String & name);

    //! Setting vectorized variable
    void setVariable(const String & name, const Array<Real> & variable);
    void setVariable(Integer index, const Array<Real> & variable);

    //! Setting evaluation vectorized result
    void setEvaluationResult(Array<Real> & result);

    //! Setting derivation vectorized result
    /*! Derivation following @name di variable */
    void setDerivationResult(Integer di, Array<Real> & result);
    void setDerivationResult(const String & di, Array<Real> & result);

    //! Eval vectorized data service function
    void eval();

    //! Cleanup after evaluation
    void cleanup();
  private:
    inline Real _eval(const Real & variable) const;
    void _eval(const Real & variable, Real & result) const;
    //! Point eval service function
  public:
    inline Real eval(const Real & variable);
    void eval(const Real & variable, Real & result);

    //! Eval vectorized data service function
  private:
    void _eval(const Array<Real> & variable, Array<Real> & result) const;
    void _eval(const ConstArrayView<Real> variable, ArrayView<Real> result) const;

    //! Coupled function and derivative scalar evaluation (temporary: derivation handling in IFunction still to be defined)
    inline void _eval(const Real & variable, Real & result, Real & diffresult) const;
  public:
    void eval(const Array<Real> & variable, Array<Real> & result);
    void eval(const ConstArrayView<Real> variable, ArrayView<Real> result);

   //! Coupled function and derivative scalar evaluation (temporary: derivation handling in IFunction still to be defined)
    inline void eval(const Real & variable, Real & result, Real & diffresult);
    //! Point derivation
  private:
    inline Real _diffEval(const Real & variable) const;
  public:
    inline Real diffEval(const Real & variable);

    //! Setting point
    void setPoint(const Real & x, const Real & y);

    //! Printing point
    void printPoints() const;

    //! Set boundary behavior
    void initBorderCondition(const BorderType::eBorderType& border_type,
        const ProlongationType& prolongation_type,
        const Real& lower_limit, const Real& upper_limit,
        const BorderType::eCutType& cut_type);
    void initBorderCondition(); //! Default behavior: infinite constant prolongation

    //! Set limit point derivative choice (default = right derivative)
    void setLimitDerivationStrategy(const LimitDerivationStrategy::eLimitDerivationStrategy & derivation_strategy);

    //! Shift and rescale the Table
    void shiftRescale(const Real new_xmin, const Real new_xmax, const Real new_ymin,
        const Real new_ymax);

    void clone(const PieceWiseFunctionR1vR1T<T>& original_piecewisefunction);

    void getPieceWiseFunctionType(PieceWiseFunctionType& type) const;

  private:
    //! Trace manager
    ITraceMng * m_trace_mng;

    //! Variable name
    String m_name;

    //! --- Table Data ---

    //! Points data
    //    typedef Array<Real> ComponentData; // To use Arcane::Array<Real> for storage (more costly at present)
    //    if Array is used : only 2 lines to change in setPoints(x,y) methode : push_back() <=> add()
    typedef std::vector<Real> ComponentData; // To use std::vector for storage (more efficient cf. doc)
    ComponentData m_x, m_y, m_x_scan;
    Real m_x_min, m_x_max, m_y_min, m_y_max;
    Integer m_first_point_index, m_last_point_index;
    Integer m_inserted_point_number, m_total_point_number; // m_total_points_number = m_inserted_points_number + boundary_points_number
    Integer m_current_x_index;

    //! Interval data
    typedef std::vector<typename T::IntervalData> InterpolatorIntervalData;
    InterpolatorIntervalData m_interval;
    Integer m_first_interval_index, m_last_interval_index, m_first_modified_interval_index, m_last_modified_interval_index;
    Integer m_inserted_interval_number, m_total_interval_number;// m_total_interval_number = m_inserted_interval_number + boundary_interval_number
    Integer m_nb_right_interval, m_nb_left_interval; // number of interval at the left and right of the current point

    //! Border condition type
    BorderType::eBorderType m_border_type;
    ProlongationType m_prolongation_type;
    Real m_lower_limit, m_upper_limit, m_out_of_bound_value;
    Integer m_coef_right_derivative, m_coef_left_derivative; // to define table point derivative choice (right or left)

    //! View to handle Table Data 
    RealConstArrayView m_variable;
    RealArrayView m_eval_result;
    RealArrayView m_diff_result;

    //! Check table is ready to use : created and filled
    bool m_initialized;
    //! Check table contains at least one point
    bool m_filled;
    bool m_first_point;
    //! Check if boundary type has been defined by user (cannot be changed after filling table)
    bool m_boundary_defined;

    //! Point insertion in table
    void addTablePoint(const Real & x, const Real & y);
    void sort();
    
    //! Interval coefficients computation
    void computeIntervalCoef();
    void getConnectedIntervals();
    void getEffectiveIntervalNumber(Integer x_index);

    //! Boundary condition methods : set border type, init and update table and interval ghost cells
    void initBorderType(const BorderType::eBorderType& border_type,
        const ProlongationType& prolongation_type,
        const Real& lower_limit, const Real& upper_limit,const BorderType::eCutType& cut_type);
    void initGhostPoints();
    void initGhostIntervals();
    void updateGhostPoints();
    void updateGhostIntervals();
    void updateLimitPoints(); //! used if m_upper_limit or m_lower_limit change 
  };

#include "PieceWiseFunctionR1vR1T.h"

#endif /* ARCGEOSIM_NUMERICS_EXPRESSIONS_PIECEWISEFUNCTIONR1VR1_H */
