#ifndef ARCGEOSIM_NUMERICS_EXPRESSIONS_CONSTANTPIECEWISEFUNCTION_CONSTANTINTERPOLATOR_H
#define ARCGEOSIM_NUMERICS_EXPRESSIONS_CONSTANTPIECEWISEFUNCTION_CONSTANTINTERPOLATOR_H
/* Author : dechaiss at Mon Oct 19 16:12:54 2009
 * Generated by createNew
 */

#include <arcane/utils/UtilsTypes.h>
#include <vector>
#include "ArcGeoSim/Numerics/Expressions/PieceWiseFunction/IPieceWiseFunction.h"

namespace Arcane
  {
  }
using namespace Arcane;

class ConstantInterpolator
  {
public:
  /** Constructeur de la classe */
  ConstantInterpolator()
    {
      ;
    }

  /** Destructeur de la classe */
  virtual
  ~ConstantInterpolator()
    {
    }

public:

  /** Type of outside-bound prolongation allowed by the interpolator */
  enum eProlongationType
    {
    ConstantProlongation
    };

  //** Interpolator interval data type */
  typedef Real IntervalData;

  /** Static inline linear interpolation method */
  inline static Real
  interpolate(const Real* x, const Real* y, const IntervalData* coef, const Real v)
    {
      //! Constant mode: 
      return *y + *coef; // *coef = 0 or NaN : to handle border condition
    }

  /** Static inline linear interpolation : get derivative */
  inline static Real
  differentiate(const Real* const x, const Real* const y,
      const IntervalData* const coef, const Real v)
    {
      return *coef;
    }

  /** Static interval coefficient precalculation method */
  static void
  computeIntervalCoef(const Real* const x_left_bound,
      const Real* const y_left_bound, const Integer& interval_number,
      IntervalData* const interval_coeff)
    {
      *interval_coeff = 0.;
    }

  /** Static inline update ghost cells value method */
  inline static void
  updateGhostPoints(const eProlongationType& prolongation_type,
      Real* const x_begin, Real* const x_end, Real* const y_begin,
      Real* const y_end)
    {
      switch (prolongation_type)
        {
      case (ConstantProlongation):
        //! x and y Ghost cells = Table first point
        *x_begin = *(x_begin + 1);
        *x_end = *(x_end - 1);
        *y_begin = *(y_begin + 1);
        *y_end = *(y_end - 1);
        break;
        }
    }

  /** Static inline update ghost value method */
  inline static void
  updateGhostIntervals(const eProlongationType& prolongation_type,
      Real* const x_begin, Real* const x_end, Real* const y_begin,
      Real* const y_end, Real* const interval_begin, Real* const interval_end)
    {
      switch (prolongation_type)
        {
      case (ConstantProlongation):
        //! Interval ghost cells : infinite constant prolongation
        *interval_begin = 0;
        *interval_end = 0;
        break;
        }
    }

  /** Static interval coefficient setting method */
  inline static const IntervalData&
  getForbiddenInterval(const Real& forbidden_interval_value)
    {
      return forbidden_interval_value;
    }

  /** Static interval coefficient setting method : get default interval coefficient for initialization*/
  inline static IntervalData
  getDefaultInterval()
    {
      return 0;
    }

  /** Static method giving number of intervals connected at the right and left of one inserted point 
   * for constant interpolation two intervals created but no one modified (coef = 0 everywhere)*/
  inline static void
  getConnectedIntervalNumber(Integer& nb_left_interval,
      Integer& nb_right_interval)
    {
      //! interval [a b[
      nb_left_interval = 0;
      nb_right_interval = 0;
    }

  /** Static method giving type of interpolator using enumeration defined in IPieceWiseFunction.h */
  inline static void
  getInterpolatorType(
      PieceWiseFunctionType::eInterpolatorType & interpolator_type)
    {
      interpolator_type = PieceWiseFunctionType::ConstantInterpolator;
    }

  };

#endif /* ARCGEOSIM_NUMERICS_EXPRESSIONS_CONSTANTPIECEWISEFUNCTION_CONSTANTINTERPOLATOR_H */
