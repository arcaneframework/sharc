#ifndef ARCGEOSIM_NUMERICS_EXPRESSIONS_LINEARPIECEWISEFUNCTION_BILINEARINTERPOLATOR_H
#define ARCGEOSIM_NUMERICS_EXPRESSIONS_LINEARPIECEWISEFUNCTION_BILINEARINTERPOLATOR_H
/* Author : dechaiss at Wed Oct 14 16:34:02 2009
 * Generated by createNew
 */
#include <arcane/utils/UtilsTypes.h>
#include <iostream>
#include <vector>
#include "ArcGeoSim/Numerics/Expressions/PieceWiseFunction/IPieceWiseFunction.h"

namespace Arcane
  {
  }
using namespace Arcane;

class BiLinearInterpolator
  {
public:
  /** Constructeur de la classe */
  BiLinearInterpolator()
    {
      ;
    }

  /** Destructeur de la classe */
  virtual
  ~BiLinearInterpolator()
    {
      ;
    }

public:

  /** Type of outside-bound prolongation allowed by the interpolator */
  enum eProlongationType
    {
    ConstantProlongation, LinearProlongation
    };

  /** Interpolator interval data type */
  typedef Real IntervalData;

  /** Static inline linear interpolation method */
  inline static Real
  interpolate(const Real* const x00, const Real* const x01,
      const Real* const x10, const Real* const x11, const Real* const y00,
      const Real* const y01, const Real* const y10, const Real* const y11,
      const Real* const x0, const Real* const x1)
  {
    //! Return Bilinear interpolate
    Real x00red = (*x0 - *x00) / (*x01 - *x00);
    Real x10red = (*x1 - *x10) / (*x11 - *x10);
    return *y00 * (1. - x00red) * (1. - x10red) + *y01 * x00red * (1. - x10red)
        + *y10 * (1. - x00red) * x10red + *y11 * x00red * x10red;

  }

  /** Static inline linear interpolation : get derivative vs var0*/
  inline static Real
  differentiate0(const Real* const x00, const Real* const x01,
      const Real* const x10, const Real* const x11, const Real* const y00,
      const Real* const y01, const Real* const y10, const Real* const y11,
      const Real* x1)
  {
    //! Return Bilinear interpolate derivative wrt x0
    Real x00reddx0 = 1. / (*x01 - *x00);
    Real x10red = (*x1 - *x10) / (*x11 - *x10);
    return x00reddx0 * ((1. - x10red) * (*y01 - *y00) + x10red * (*y11 - *y10));

  }

  /** Static inline linear interpolation : get derivative vs Var1*/
  inline static Real
  differentiate1(const Real* const x00, const Real* const x01,
      const Real* const x10, const Real* const x11, const Real* const y00,
      const Real* const y01, const Real* const y10, const Real* const y11,
      const Real *x0)
  {
    //! Return Bilinear interpolate derivative wrt x0
    Real x00red = (*x0 - *x00) / (*x01 - *x00);
    Real x10reddx1 = 1. / (*x11 - *x10);
    return x10reddx1 * ((1. - x00red) * (*y10 - *y00) + x00red * (*y11 - *y01));
  }

  /** Static inline update ghost cells value method */
  inline static void
  updateGhostPoints(const eProlongationType& prolongation_type,
      Real* const x_begin, Real* const x_end, Real* const y_begin,
      Real* const y_end, Real*  const x, Real*  y)
  {
    switch (prolongation_type)
      {
    case (ConstantProlongation):
      *y = *y_begin;
      break;
    case (LinearProlongation):
      *y = *y_begin + (*x - *x_begin) * (*y_end - *y_begin) / (*x_end
          - *x_begin);
      break;
      }
  }

  
  /** Static method giving type of interpolator using enumeration defined in IPieceWiseFunction.h */
    inline static void
    getInterpolatorType(PieceWiseFunctionType::eInterpolatorType & interpolator_type)
      {
        interpolator_type = PieceWiseFunctionType::LinearInterpolator;
      }

  };

#endif /* ARCGEOSIM_NUMERICS_EXPRESSIONS_LINEARPIECEWISEFUNCTION_BILINEARINTERPOLATOR_H */
