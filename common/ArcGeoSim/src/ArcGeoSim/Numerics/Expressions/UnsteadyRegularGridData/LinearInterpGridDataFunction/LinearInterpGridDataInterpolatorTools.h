// -*- C++ -*-
#ifndef ARCGEOSIM_NUMERICS_EXPRESSIONS_UNSTEADYREGULARGRIDDATA_LINEARINTERPGRIDDATAFUNCTION_LINEARINTERPGRIDDATAINTERPOLATORTOOLS_H
#define ARCGEOSIM_NUMERICS_EXPRESSIONS_UNSTEADYREGULARGRIDDATA_LINEARINTERPGRIDDATAFUNCTION_LINEARINTERPGRIDDATAINTERPOLATORTOOLS_H
/* Author : dechaiss at Mon Jun 27 13:46:37 2011
 * Generated by createNew
 */

#include <numeric>

#include <arcane/MathUtils.h>
#include <arcane/utils/UtilsTypes.h>
#include <arcane/utils/FatalErrorException.h>

#include "ArcGeoSim/Utils/ArcGeoSim.h"

using namespace Arcane;

BEGIN_ARCGEOSIM_NAMESPACE

namespace LinearInterpGridDataInterpolatorTools {


// Property index manager. Property are written in input for all x, then all y, then all z and finally all t.
class PropertyIndexManager
{
public:
  PropertyIndexManager(){}
  virtual ~PropertyIndexManager(){}

public:
  inline static Integer computePropertyIndex(const Integer & x_index, const Integer& y_index,
                                             const Integer& z_index, const Integer& t_index,
                                             const Array<Integer>& size)
  {
    return size[0] * size[1] * size[2] * t_index + size[0] * size[1]
                   * z_index + size[0] * y_index + x_index;
  }
};

/*---------------------------------------------------------------------------*/

// Grid
class Grid
{
public:
  
  /** Constructeur de la classe */
  Grid() {}
  
  /** Destructeur de la classe */
  virtual ~Grid() {}
  
public:

  typedef Real cell_type[4]; // (x1,x2,y1,y2)
  typedef Real one_dimension_neighbor_type[2];
  typedef Real node_property_type[4];
  typedef node_property_type cell_property_type[4]; // cell_property[nb_cell][nb_node] with nb_cell = nb_z*nb_t
  typedef Integer nb_neighbor_type[4]; // Number of neighbor in each direction
  typedef Integer neighbor_index_type[2]; // Index of the neighbors in a given direction

private:
  inline static void _getNeighborIndex(const Integer& closest_neighbor_index, const Real& value,
                                       const Real& upper_grid_value, const Integer direction_size,
                                       neighbor_index_type& neighbor_indexes, Integer& nb_neighbor)
  {
    // Case with only one neighbor
    if (direction_size == 1)
      {
        neighbor_indexes[0] = closest_neighbor_index;
        neighbor_indexes[1] = std::numeric_limits<Integer>::signaling_NaN();
        nb_neighbor = 1;
      }
    else
      {
        // Case with two neighbors
        // Closest neighbor index is in most cases lower to value:
        // --> in that case neighbor_indexes[0] = closest_neighbor_index and neighbor_indexes[1] = closest_neighbor_index +1
        //
        // The only particular case is when the point is exactly the upper bound of the grid in the considered direction (upper_grid_value):
        // --> in that case neighbor_indexes[0] = closest_neighbor_index -1 and neighbor_indexes[1] = closest_neighbor_index
        if (value != upper_grid_value)
          {
        	if ( closest_neighbor_index == -1 )
        	{
        		neighbor_indexes[0] = 0;
        		neighbor_indexes[1] = 0;
        		nb_neighbor = 1;
        	}
        	else 
        		if ( closest_neighbor_index == direction_size)
        		{
        			neighbor_indexes[0] = direction_size-1;
        			neighbor_indexes[1] = direction_size-1;
        			nb_neighbor = 1;
        		}
        		else
        		{  
        			neighbor_indexes[0] = closest_neighbor_index;
        			neighbor_indexes[1] = closest_neighbor_index+1;
        			nb_neighbor = 2;
        		}
          }
        else
          {
        	if ( closest_neighbor_index == -1 )
        	{
        		neighbor_indexes[0] = 0;
        		neighbor_indexes[1] = 0;
        		nb_neighbor = 1;
        	}
        	else 
        		if ( closest_neighbor_index == direction_size)
        		{
        			neighbor_indexes[0] = direction_size-1;
        			neighbor_indexes[1] = direction_size-1;
        			nb_neighbor = 1;
        		}
        		else
        		{     		
        			neighbor_indexes[0] = closest_neighbor_index-1;
        			neighbor_indexes[1] = closest_neighbor_index;
        			nb_neighbor = 2;
        		}
          }
        //nb_neighbor = 2;
      }
  }

public:
  inline static void getNeighborhood(const Array<Real>& interp_point_coordinates,
                                     const Array<Integer>& lower_limit_grid_point_indexes,
                                     const Array<Real>& grid_x, const Array<Real>& grid_y,
                                     const Array<Real>& grid_z, const Array<Real>& grid_t,
                                     const Array<Real>& property,const Array<Integer>& size,
                                     cell_type& cell,
                                     one_dimension_neighbor_type& grid_neighbor_z,
                                     one_dimension_neighbor_type& grid_neighbor_t,
                                     nb_neighbor_type& nb_neighbor,
                                     cell_property_type& cell_properties)
  {
    // Get neighboring cell: closer point is closest inferior point, execpted if point is upper grid point i.e grid_i[size-1]
    //--x direction always 2 neighbors
    neighbor_index_type x_neighbor_indexes;
    _getNeighborIndex(lower_limit_grid_point_indexes[0],interp_point_coordinates[0],grid_x[size[0]-1],size[0],
                      x_neighbor_indexes,nb_neighbor[0]);
    cell[0] = grid_x[x_neighbor_indexes[0]];
    cell[1] = grid_x[x_neighbor_indexes[1]];
    //--y direction always 2 neighbors
    neighbor_index_type y_neighbor_indexes;
    _getNeighborIndex(lower_limit_grid_point_indexes[1],interp_point_coordinates[1],grid_y[size[1]-1],size[1],
                      y_neighbor_indexes,nb_neighbor[1]);
    cell[2] = grid_y[y_neighbor_indexes[0]];
    cell[3] = grid_y[y_neighbor_indexes[1]];
    //--z direction, one or two neighbors
    neighbor_index_type z_neighbor_indexes;
    _getNeighborIndex(lower_limit_grid_point_indexes[2],interp_point_coordinates[2],grid_z[size[2]-1],size[2],
                      z_neighbor_indexes,nb_neighbor[2]);
    for (Integer i=0; i< nb_neighbor[2]; ++i) grid_neighbor_z[i] = grid_z[z_neighbor_indexes[i]];
    //--t direction, one or two neighbors
    neighbor_index_type t_neighbor_indexes;
    _getNeighborIndex(lower_limit_grid_point_indexes[3],interp_point_coordinates[3],grid_t[size[3]-1],size[3],
                      t_neighbor_indexes,nb_neighbor[3]);
    for (Integer i=0; i< nb_neighbor[3]; ++i) grid_neighbor_t[i] = grid_t[t_neighbor_indexes[i]];

    // Get neighboring cell node property values for all x,y,z,t
    Integer cell_index = 0;
    Integer node_index = 0;

    for (Integer t_index = 0; t_index < nb_neighbor[3]; ++t_index)
      {
        for(Integer z_index = 0; z_index < nb_neighbor[2]; ++z_index, ++cell_index, node_index = 0)
        {
          for (Integer y_index = 0; y_index < 2; ++ y_index)
            {
              for (Integer x_index = 0; x_index < 2; ++ x_index,++node_index)
                {
                  cell_properties[cell_index][node_index] =
                      property[PropertyIndexManager::computePropertyIndex(x_neighbor_indexes[x_index],
                                                                          y_neighbor_indexes[y_index],
                                                                          z_neighbor_indexes[z_index],
                                                                          t_neighbor_indexes[t_index],size)];
                }
            }
        }
      }

  }

public:
inline static void getNeighborhood(const Array<Real>& interp_point_coordinates,
                                     const Array<Integer>& lower_limit_grid_point_indexes,
                                     const Array<Real>& grid_x, const Array<Real>& grid_y,
                                     const Array<Real>& grid_z, const Array<Real>& grid_t,
                                     const Array<Real>& property,const Array<Integer>& size,
									 one_dimension_neighbor_type& grid_neighbor_x,
									 one_dimension_neighbor_type& grid_neighbor_y,
                                     one_dimension_neighbor_type& grid_neighbor_z,
                                     one_dimension_neighbor_type& grid_neighbor_t,
                                     nb_neighbor_type& nb_neighbor,
                                     cell_property_type& cell_properties)
  {
    // Get neighboring cell: closer point is closest inferior point, execpted if point is upper grid point i.e grid_i[size-1]
    //--x direction always 2 neighbors
    neighbor_index_type x_neighbor_indexes;
    _getNeighborIndex(lower_limit_grid_point_indexes[0],interp_point_coordinates[0],grid_x[size[0]-1],size[0],
                      x_neighbor_indexes,nb_neighbor[0]);
    for (Integer i=0; i< nb_neighbor[0]; ++i) grid_neighbor_x[i] = grid_x[x_neighbor_indexes[i]];
    //--y direction always 2 neighbors
    neighbor_index_type y_neighbor_indexes;
    _getNeighborIndex(lower_limit_grid_point_indexes[1],interp_point_coordinates[1],grid_y[size[1]-1],size[1],
                      y_neighbor_indexes,nb_neighbor[1]);
    for (Integer i=0; i< nb_neighbor[1]; ++i) grid_neighbor_y[i] = grid_y[y_neighbor_indexes[i]];
    //--z direction, one or two neighbors
    neighbor_index_type z_neighbor_indexes;
    _getNeighborIndex(lower_limit_grid_point_indexes[2],interp_point_coordinates[2],grid_z[size[2]-1],size[2],
                      z_neighbor_indexes,nb_neighbor[2]);
    for (Integer i=0; i< nb_neighbor[2]; ++i) grid_neighbor_z[i] = grid_z[z_neighbor_indexes[i]];
    //--t direction, one or two neighbors
    neighbor_index_type t_neighbor_indexes;
    _getNeighborIndex(lower_limit_grid_point_indexes[3],interp_point_coordinates[3],grid_t[size[3]-1],size[3],
                      t_neighbor_indexes,nb_neighbor[3]);
    for (Integer i=0; i< nb_neighbor[3]; ++i) grid_neighbor_t[i] = grid_t[t_neighbor_indexes[i]];

    // Get neighboring cell node property values for all x,y,z,t
    Integer cell_index = 0;
    Integer node_index = 0;

    for (Integer t_index = 0; t_index < nb_neighbor[3]; ++t_index)
          {
            for(Integer z_index = 0; z_index < nb_neighbor[2]; ++z_index, ++cell_index, node_index = 0)
            {
              for (Integer y_index = 0; y_index < nb_neighbor[1]; ++ y_index)
                {
            	  if ( y_index == 1 && nb_neighbor[0] == 1 ) node_index += 1;
                  for (Integer x_index = 0; x_index < nb_neighbor[0]; ++ x_index,++node_index)
                    {
                      cell_properties[cell_index][node_index] =
                          property[PropertyIndexManager::computePropertyIndex(x_neighbor_indexes[x_index],
                                                                              y_neighbor_indexes[y_index],
                                                                              z_neighbor_indexes[z_index],
                                                                              t_neighbor_indexes[t_index],size)];
                    }
                }
            }
          }



  }
};

/*---------------------------------------------------------------------------*/

class TwoDimensionalInterpolator
{
public:
  TwoDimensionalInterpolator(){}
  virtual ~TwoDimensionalInterpolator(){}
public:

  typedef Real interp_coeff_type[4];

  //! Calcule les coefficients d'interpolation dans la cellule = aires associ�es au point d'interpolation
  inline static void computeInterpolationCoefficients(const Array<Real>& interp_point_coordinates,
                                                      const Grid::cell_type& cell,
                                                      interp_coeff_type& interpolation_coeff)
  {
    Real cell_x_length = math::abs(cell[1]-cell[0]); // |x2-x1|
    Real cell_y_length = math::abs(cell[3]-cell[2]); // |y2-y1|
    Real xpoint_to_xmin_length = math::abs(interp_point_coordinates[0]-cell[0]); // |x-x1|
    Real xpoint_to_xmax_length = math::abs(cell[1]-interp_point_coordinates[0]); // |x2-x|
    Real ypoint_to_ymin_length = math::abs(interp_point_coordinates[1]-cell[2]); // |y-y1|
    Real ypoint_to_ymax_length = math::abs(cell[3]-interp_point_coordinates[1]); // |y2-y|
    Real cell_area = cell_x_length*cell_y_length;
    // Compute interpolation coefficients for the points (x1,y1) ; (x2,y1) ; (x1,y2) ; (x2,y2)
    if ( cell_x_length == 0.0 && cell_y_length == 0.0)
    {
    	interpolation_coeff[0] = 1.0;
    	interpolation_coeff[1] = 0.0;
    	interpolation_coeff[2] = 0.0;
    	interpolation_coeff[3] = 0.0;
    }
    else
    	if ( cell_x_length == 0.0 )
    	{
    		interpolation_coeff[0] = ypoint_to_ymax_length / cell_y_length; // point (x1,y1) => coef = |y2-y|/cell_y_length
    		interpolation_coeff[2] = ypoint_to_ymin_length / cell_y_length; // point (x1,y2) => coef = |y-y1|/cell_y_length

    		interpolation_coeff[1] = 0.0; // point (x1,y1) => coef = 0.0
    		interpolation_coeff[3] = 0.0; // point (x1,y2) => coef = 0.0
    	}
    	else
    		if ( cell_y_length == 0.0 )
    		{
    			interpolation_coeff[0] = xpoint_to_xmax_length / cell_x_length; // point (x1,y1) => coef = |x2-x|/cell_x_length
    			interpolation_coeff[1] = xpoint_to_xmin_length / cell_x_length; // point (x2,y1) => coef = |x-x1|/cell_x_length

    			interpolation_coeff[2] = 0.0; // point (x1,y2) => coef = 0.0
    			interpolation_coeff[3] = 0.0; // point (x2,y2) => coef = 0.0

    		}
    		else
    		{
    			interpolation_coeff[0] = xpoint_to_xmax_length * ypoint_to_ymax_length / cell_area; // point (x1,y1) => coef = |x2-x|*|y2-y|/cell_area
    			interpolation_coeff[1] = xpoint_to_xmin_length * ypoint_to_ymax_length / cell_area; // point (x2,y1) => coef = |x-x1|*|y2-y|/cell_area
    			interpolation_coeff[2] = xpoint_to_xmax_length * ypoint_to_ymin_length / cell_area; // point (x1,y2) => coef = |x2-x|*|y-y1|/cell_area
    			interpolation_coeff[3] = xpoint_to_xmin_length * ypoint_to_ymin_length / cell_area; // point (x2,y2) => coef = |x-x1|*|y-y1|/cell_area
    		}

  }

  //! Interpole une valeur dans une maille carr� ou rectangulaire (lin�aire, bas� sur les aires, obtenus par composition de barycentre 1D)
  inline static Real interpolate(const interp_coeff_type& interpolation_coeff,
                                 const Grid::node_property_type& node_property)
  {
    Real interpolated_property = 0;
    
    //Real number =   std::numeric_limits<Real>::quiet_NaN();
    
    
    //cout  << "number = number =" << std::boolalpha
    //          << ( number == number ) << '\n';
	      
	      
    //if ( node_property[0] != node_property[0] && node_property[1] != node_property[1] ) 
    //return (node_property[2]*interpolation_coeff[2] + node_property[3]*interpolation_coeff[3])/(interpolation_coeff[2]+interpolation_coeff[3]);		   
        
    for (Integer i = 0; i< 4; ++i) interpolated_property += node_property[i]*interpolation_coeff[i];
    
    
    return interpolated_property;
  }
};

/*---------------------------------------------------------------------------*/

class OneDimensionalInterpolator
{
public:
  OneDimensionalInterpolator(){}
  virtual ~OneDimensionalInterpolator(){}
public:

  typedef Real interp_coeff_type[2]; //!<Coefficient d'interpolation. Si un seul point, un seul coeff = 1.

  //! Calcule les coefficients d'interpolation dans la cellule = aires associ�es au point d'interpolation
   inline static void computeInterpolationCoefficients(const Real& interp_point,
                                                       const Grid::one_dimension_neighbor_type& grid_neighbor_current_direction,
                                                       const Integer& direction_nb_neigbhor,
                                                       interp_coeff_type& interpolation_coeff)
   {
     if (direction_nb_neigbhor == 2)
       {
         Real interp_length = math::abs(grid_neighbor_current_direction[1]-grid_neighbor_current_direction[0]);
         interpolation_coeff[0] = math::abs(grid_neighbor_current_direction[1]-interp_point)/interp_length;
         interpolation_coeff[1] = math::abs(interp_point-grid_neighbor_current_direction[0])/interp_length;
       }
     else if (direction_nb_neigbhor == 1)
       {
         interpolation_coeff[0] = 1;
         interpolation_coeff[1] = std::numeric_limits<Real>::signaling_NaN(); // Not to be used value
       }
     else
       throw FatalErrorException(String::format("Number of neighbor = {0} forbidden. Can only be 0 or 1",direction_nb_neigbhor));
   }
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

}  // namespace LinearInterpGridDataInterpolatorTools





END_ARCGEOSIM_NAMESPACE

#endif /* ARCGEOSIM_NUMERICS_EXPRESSIONS_UNSTEADYREGULARGRIDDATA_LINEARINTERPGRIDDATAFUNCTION_LINEARINTERPGRIDDATAINTERPOLATORTOOLS_H */
