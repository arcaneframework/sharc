// -*- C++ -*-
#ifndef ARCGEOSIM_NUMERICS_EXPRESSIONS_UNSTEADYREGULARGRIDDATA_LINEARINTERPGRIDDATAFUNCTION_LINEARINTERPGRIDDATAINTERPOLATOR_H
#define ARCGEOSIM_NUMERICS_EXPRESSIONS_UNSTEADYREGULARGRIDDATA_LINEARINTERPGRIDDATAFUNCTION_LINEARINTERPGRIDDATAINTERPOLATOR_H
/* Author : dechaiss at Fri Jun 24 13:50:44 2011
 * Generated by createNew
 */
#include<iostream> // TEST

#include "ArcGeoSim/Numerics/Expressions/UnsteadyRegularGridData/LinearInterpGridDataFunction/LinearInterpGridDataInterpolatorTools.h"

using namespace Arcane;

using namespace ArcGeoSim::LinearInterpGridDataInterpolatorTools;

class InterpGridDataTools;

class LinearInterpGridDataInterpolator
{
public:
  
  /** Constructeur de la classe */
  LinearInterpGridDataInterpolator() {}
  
  /** Destructeur de la classe */
  virtual ~LinearInterpGridDataInterpolator() {}
  
public:



  /** interpolation method */
  inline static Real interpolate(const Array<Real>& interp_point_coordinates, const Array<Integer>& lower_limit_grid_point_indexes,
                                 const Array<Real>& grid_x,const Array<Real>& grid_y,
                                 const Array<Real>& grid_z, const Array<Real>& grid_t,
                                 const Array<Real>& property, const Array<Integer>& size)
  {
    // Linear interpolation: area interpolation obtained composing 1D barycenter in each direction
    //Grid::cell_type cell; // cell (x1,x2,y1,y2) containing interpolation point
	Grid::one_dimension_neighbor_type grid_neighbor_x; // neighboring x (may have only one point)
	Grid::one_dimension_neighbor_type grid_neighbor_y; // neighboring y (may have only one point)
    Grid::one_dimension_neighbor_type grid_neighbor_z; // neighboring z (may have only one point)
    Grid::one_dimension_neighbor_type grid_neighbor_t; // neighboring t (may have only one point)
    Grid::cell_property_type cell_properties; // Property at the nodes of cells at (z1,t1), (z1,t2), (z2,t1), (z2,t2)
    Real interpolated_property = 0;
    Grid::nb_neighbor_type nb_neighbor; // Number of neighbor in each direction x, y, z, t

    Grid::getNeighborhood(interp_point_coordinates,lower_limit_grid_point_indexes, grid_x,grid_y,grid_z,grid_t,
                          property,size,grid_neighbor_x,grid_neighbor_y,grid_neighbor_z,grid_neighbor_t,nb_neighbor,cell_properties);

    // Prepare interpolation: compute interpolation coefficients
    // TwoDimensionalInterpolator::interp_coeff_type cell_interp_coeff;
    // TwoDimensionalInterpolator::computeInterpolationCoefficients(interp_point_coordinates,cell,cell_interp_coeff);

    OneDimensionalInterpolator::interp_coeff_type x_interp_coeff;
    OneDimensionalInterpolator::computeInterpolationCoefficients(interp_point_coordinates[0],grid_neighbor_x,nb_neighbor[0],x_interp_coeff);
    OneDimensionalInterpolator::interp_coeff_type y_interp_coeff;
    OneDimensionalInterpolator::computeInterpolationCoefficients(interp_point_coordinates[1],grid_neighbor_y,nb_neighbor[1],y_interp_coeff);
    OneDimensionalInterpolator::interp_coeff_type z_interp_coeff;
    OneDimensionalInterpolator::computeInterpolationCoefficients(interp_point_coordinates[2],grid_neighbor_z,nb_neighbor[2],z_interp_coeff);
    OneDimensionalInterpolator::interp_coeff_type t_interp_coeff;
    OneDimensionalInterpolator::computeInterpolationCoefficients(interp_point_coordinates[3],grid_neighbor_t,nb_neighbor[3],t_interp_coeff);


    // Interpolate
    Integer cell_index = 0;
    /*for (Integer t_current = 0; t_current < nb_neighbor[3]; ++ t_current)
      {
        Real interpolated_property_tmp = 0;
        for (Integer z_current = 0; z_current < nb_neighbor[2]; ++ z_current, ++cell_index)
          {
            interpolated_property_tmp += z_interp_coeff[z_current]*
                TwoDimensionalInterpolator::interpolate(cell_interp_coeff,cell_properties[cell_index]);
          }
        interpolated_property += t_interp_coeff[t_current]*interpolated_property_tmp;
      }*/

    for (Integer t_current = 0; t_current < nb_neighbor[3]; ++ t_current)
          {
            Real interpolated_property_tmp = 0;
            for (Integer z_current = 0; z_current < nb_neighbor[2]; ++ z_current, ++cell_index)
              {
            	Real interpolated_property_y = 0;
            	for (Integer y_current = 0; y_current < nb_neighbor[1]; ++ y_current)
            	{
            		Real interpolated_property_x = 0;
            		for (Integer x_current = 0; x_current < nb_neighbor[0]; ++ x_current)
            		{
            			interpolated_property_x += x_interp_coeff[x_current]*cell_properties[cell_index][x_current+2*y_current];
            		}
            		interpolated_property_y += y_interp_coeff[y_current]*interpolated_property_x;
            	}
            	interpolated_property_tmp += z_interp_coeff[z_current]*interpolated_property_y;
              }
            interpolated_property += t_interp_coeff[t_current]*interpolated_property_tmp;
          }

    return interpolated_property;
  }

};




#endif /* ARCGEOSIM_NUMERICS_EXPRESSIONS_UNSTEADYREGULARGRIDDATA_LINEARINTERPGRIDDATAFUNCTION_LINEARINTERPGRIDDATAINTERPOLATOR_H */
