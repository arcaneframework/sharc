// -*- C++ -*-
#ifndef ARCGEOSIM_NUMERICS_EXPRESSIONS_UNSTEADYREGULARGRIDDATA_UNSTEADYREGULARGRIDDATA_H
#define ARCGEOSIM_NUMERICS_EXPRESSIONS_UNSTEADYREGULARGRIDDATA_UNSTEADYREGULARGRIDDATA_H
/* Author : dechaiss at Tue Apr 13 13:39:09 2010
 * Generated by createNew
 */

#include "ArcGeoSim/Numerics/Expressions/UnsteadyRegularGridData/IUnsteadyRegularGridData.h"
#include <arcane/ArcaneVersion.h>
#include <arcane/utils/Array.h>
#include <arcane/utils/Array2.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/IIOMng.h>
#include <arcane/utils/TraceMessage.h>

#include <vector>
#include <fstream>
#include <string>
#include <iostream>

// class used to store interpolated point
class UnsteadyGridPoint
{
public:
  typedef SharedArray<Real> vector;
  UnsteadyGridPoint(const Real& x, const Real& y, const Real& z, const Real& t) :
    m_vector(4)
  {
    m_vector[0] = x;
    m_vector[1] = y;
    m_vector[2] = z;
    m_vector[3] = t;
  }

  virtual
  ~UnsteadyGridPoint() {}
  vector& operator()() {return m_vector;}

private:
  vector m_vector;
};

// Main
template<typename T>
  class UnsteadyRegularGridDataT : public IUnsteadyRegularGridData
  {
  public:
    //! Typedef
    typedef SharedArray<Integer> PointIndex;
    typedef SharedArray<Real> PointCollection;

  public:
    //! Constructeur de la classe
    UnsteadyRegularGridDataT(ITraceMng* trace_mng, IIOMng* io_mng);

    //! Destructeur de la classe
    virtual
    ~UnsteadyRegularGridDataT() {}

  public:

    //! Init
    void init();

    //! Setting parameter
    void setParameter(const String & name, const Real & parameter) {m_trace_mng->fatal() << "No parameter for UnsteadyRegularGridData";}
    void setParameter(Integer index, const Real & parameter) {m_trace_mng->fatal() << "No parameter for UnsteadyRegularGridData";}

    //! Getting number of parameter
    Integer nbParameter() const {return 0;}

    //! Getting name of parameter
    String parameterName(Integer index) const {m_trace_mng->fatal() << "No parameter for UnsteadyRegularGridData"; return "";}

    //! Getting name of variable
    String variableName(Integer index) const;

    //! Setting vectorized variable
    void setVariable(const String & name, const Array<Real> & variable);
    void setVariable(Integer index, const Array<Real> & variable);

    //! Setting evaluation vectorized result
    void setEvaluationResult(Array<Real> & result);

    //! Setting derivation vectorized result
    /*! Derivation following @name di variable */
    void setDerivationResult(Integer di, Array<Real> & result) {m_trace_mng->fatal() << "Derivation not implemented in UnsteadyGridData";}
    void setDerivationResult(const String & di, Array<Real> & result) {m_trace_mng->fatal() << "Derivation not implemented in UnsteadyGridData";}

    //! Eval vectorized data service function
    void eval();

    //! Cleanup after evaluation
    void cleanup();

    //! setPoints (read Data file)
    RegularGridType::GridDimension setPoints(const String& file_name);

    void setRegularGridType(const RegularGridType::eRegularGridType& grid_type);

    //! Point-wise evaluation
    /*! An optimized syntax will be introduce for single return evaluation
     */
    void eval(const Real & var0, const Real & var1,
              const Real & var2, const Real & var3, Real & res0);

    //! Vector evaluation
    void eval(const Array<Real> & var0, const Array<Real> & var1,
    		const Array<Real> & var2, const Array<Real> & var3, Array<Real> & res0);

    //! Vector evaluation
    void eval(const ConstArrayView<Real> var0, const ConstArrayView<Real> var1,
              const ConstArrayView<Real> var2, const ConstArrayView<Real> var3, ArrayView<Real> res0);

    //! Scalar return for point-wise evaluation
    Real eval(const Real & x, const Real & y, const Real & z, const Real & t);

    //! Print grid for debug
    void printGrid() const;

    //! Getting file name
    String getFileName() const;

    //! Getting grid type
    RegularGridType::eRegularGridType getGridType() const;

  private:
    ITraceMng* m_trace_mng;
    IIOMng* m_io_mng;
    bool m_initialized, m_filled, m_variable_initialized, m_variable_empty;
    Integer m_variable_size, m_variable_component_index;
    SharedArray<String> m_variable_name;
    String m_filename;
    String m_mesh_file_directory_name;
    String m_schema_name;
    Real m_time;
    PointCollection m_x, m_y, m_z, m_t, m_property;
    SharedArray<RealConstArrayView> m_variable;
    RealArrayView m_result;
    RegularGridType::eRegularGridType m_grid_type;
    RegularGridType::GridDimension m_grid_dimension = RegularGridType::GridDimension::eUndefined;
    SharedArray<Integer> m_grid_size;

    //! read interpolation points
    void _readInterpolationPoints();
    void _readNonUniformGrid();
    void _readUniformGrid();

    RegularGridType::GridDimension _readGrid_XDMF();

    //! read interpolation points from XDMF file
    RegularGridType::GridDimension _readInterpolationPoints_XDMF();

    //! Transpose row major data to column major data
    SharedArray<Real> transposeData(const SharedArray<Real> & values, int dimX, int dimY, int dimZ);

    //! find index of point closer to (x,y,z,t)
    void _findCloserPoint(const Array<Real>& point_value, PointIndex& closer_point_index);

    //! Find variable in vector of size n hybrid dichotomy/linear search
    Integer _scan(const Real& variable, const Integer& n, const Real* const vector) const;

    //! Setting name of variable
    void _setVariableName(Integer index, const String& name);

    //! Check point coordinates sorted in increasing order
    bool _isSortedGrid();
    bool _isSortedArray(const RealArray& array);

  };

#include "UnsteadyRegularGridDataT.h"

#endif /* ARCGEOSIM_NUMERICS_EXPRESSIONS_UNSTEADYREGULARGRIDDATA_UNSTEADYREGULARGRIDDATA_H */
