// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "LinearSystem.h"
/* Author : desrozis at Wed Mar  5 16:59:25 2014
 * Generated by createNew
 */

#include <arcane/ISubDomain.h>
#include <alien/ref/AlienImportExport.h>

#include <alien/kernels/simple_csr/SimpleCSRMatrix.h>
#include <alien/kernels/simple_csr/SimpleCSRVector.h>


#include <alien/kernels/simple_csr/algebra/SimpleCSRLinearAlgebra.h>
#include <alien/kernels/simple_csr/algebra/SimpleCSRInternalLinearAlgebra.h>
#include <alien/expression/krylov/AlienKrylov.h>
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ArcNum::LinearSystem::
LinearSystem()
  : m_trace(_arcaneGetDefaultSubDomain()->traceMng())
  {}

/*---------------------------------------------------------------------------*/

ArcNum::LinearSystem::
LinearSystem(const LinearSystem& system)
  : m_trace(_arcaneGetDefaultSubDomain()->traceMng())
  , m_alien_space(system.m_alien_space)
  , m_alien_vector_index_manager(system.m_alien_vector_index_manager)
  , m_alien_vector_index_set(system.m_alien_vector_index_set)
  , m_alien_vector_indexes(system.m_alien_vector_indexes)
  , m_mdist(system.m_mdist)
  , m_vdist(system.m_vdist)
  , m_alien_block(system.m_alien_block)
  , m_alien_rhs(system.m_alien_rhs)
  , m_alien_solution(system.m_alien_solution)
  , m_alien_matrix(system.m_alien_matrix) {}

/*---------------------------------------------------------------------------*/

ArcNum::LinearSystem&
ArcNum::LinearSystem::
operator=(const LinearSystem& system)
{
  m_trace = _arcaneGetDefaultSubDomain()->traceMng();
  m_alien_space = system.m_alien_space;
  m_alien_vector_index_manager = system.m_alien_vector_index_manager;
  m_alien_vector_index_set = system.m_alien_vector_index_set;
  m_alien_vector_indexes = system.m_alien_vector_indexes;
  m_mdist = system.m_mdist;
  m_vdist = system.m_vdist;
  m_alien_block = system.m_alien_block;
  m_alien_rhs = system.m_alien_rhs;
  m_alien_solution = system.m_alien_solution;
  m_alien_matrix = system.m_alien_matrix;
  return *this;
}

/*---------------------------------------------------------------------------*/

ArcNum::LinearSystem::
LinearSystem(const MeshGroupBlock& group,
             bool is_reduced)
  : m_trace(_arcaneGetDefaultSubDomain()->traceMng())
  , m_alien_vector_index_manager(new Alien::ArcaneTools::BasicIndexManager(_arcaneGetDefaultSubDomain()->parallelMng()))
{
  this->_init(group);
}

/*---------------------------------------------------------------------------*/

void
ArcNum::LinearSystem::
_init(const MeshGroupBlock& group)
{
  m_alien_vector_index_manager->setTraceMng(m_trace);

  m_alien_vector_index_set = m_alien_vector_index_manager->buildVectorIndexSet(group.name, group.group, group.nbEquations);
  m_alien_block.reset(new Alien::Block(group.nbEquations));

  m_alien_vector_index_manager->prepare();
  m_alien_vector_indexes.resize(m_alien_vector_index_set.size());
  m_alien_vector_indexes = m_alien_vector_index_manager->getIndexes(m_alien_vector_index_set);

  this->_prepareAlien();
}

/*---------------------------------------------------------------------------*/

void
ArcNum::LinearSystem::
_prepareAlien()
{
  m_alien_space = new Alien::ArcaneTools::Space(m_alien_vector_index_manager.get(), m_alien_block->size());
  m_mdist = Alien::ArcaneTools::createMatrixDistribution(*m_alien_space, m_alien_block->size());
  m_vdist = Alien::ArcaneTools::createVectorDistribution(*m_alien_space, m_alien_block->size());

  m_alien_rhs.reset(new Alien::BlockVector(*m_alien_block, m_vdist));
  m_alien_solution.reset(new Alien::BlockVector(*m_alien_block, m_vdist));
  m_alien_matrix.reset(new Alien::BlockMatrix(*m_alien_block, m_mdist));
}

/*---------------------------------------------------------------------------*/

bool
ArcNum::LinearSystem::
solve(Alien::ILinearSolver* solver)
{
  {
    const Alien::SimpleCSRMatrix<Real>& csr = m_alien_matrix->impl()->get<Alien::BackEnd::tag::simplecsr>();
    const Alien::SimpleCSRMatrix<Real>::ProfileType& profile = csr.getProfile();
    int nrows = profile.getNRows();
    int blk_size = m_alien_matrix->block().size();
    int nnz = profile.getNnz();
    const int* cols = profile.cols();
    const int* kcol = profile.kcol();
    const double* values = csr.getAddressData();
    m_trace->info()<<"MATRIX("<<nrows<<","<<nnz<<","<<blk_size<<")";
    for(int i=0;i<nrows;++i)
    {
      m_trace->info()<<"ROW["<<i<<"]:";
      for(int k=kcol[i];k<kcol[i+1];++k)
      {
        m_trace->info()<<'\t'<<"COL("<<k<<","<<cols[k]<<")";
        for(int j=0;j<blk_size*blk_size;++j)
        {
          m_trace->info()<<'\t'<<'\t'<<j<<","<<std::hexfloat<<values[k*blk_size*blk_size+j];
        }
      }
    }
    {
      const Alien::SimpleCSRVector<Real>& v = m_alien_rhs->impl()->get<Alien::BackEnd::tag::simplecsr>();
      const double* values = v.getAddressData();
      for(int i=0;i<nrows;++i)
      {
        m_trace->info()<<"RHS["<<i<<"]:";
        for(int j=0;j<blk_size;++j)
        {
            m_trace->info()<<'\t'<<j<<","<<std::hexfloat<<values[i*blk_size+j];
        }
      }
    }
    {
      const Alien::SimpleCSRVector<Real>& v = m_alien_solution->impl()->get<Alien::BackEnd::tag::simplecsr>();
      const double* values = v.getAddressData();
      for(int i=0;i<nrows;++i)
      {
        m_trace->info()<<"SOL["<<i<<"]:";
        for(int j=0;j<blk_size;++j)
        {
            m_trace->info()<<'\t'<<j<<","<<std::hexfloat<<values[i*blk_size+j];
        }
      }
    }
  }

  try
  {

    bool succeed = solver->solve(*m_alien_matrix,
                                 *m_alien_rhs,
                                 *m_alien_solution);

    const auto& status = solver->getStatus();

    Arcane::Integer iteration = status.iteration_count;

    /*


      typedef Alien::SimpleCSRInternalLinearAlgebra    AlgebraType ;
      typedef typename AlgebraType::BackEndType        BackEndType ;
      typedef Alien::Iteration<AlgebraType>            StopCriteriaType ;

      auto const& true_A = m_alien_matrix->impl()->get<BackEndType>() ;
      auto const& true_b = m_alien_rhs->impl()->get<BackEndType>() ;
      auto&       true_x = m_alien_solution->impl()->get<BackEndType>(true) ;

      AlgebraType alg ;
      StopCriteriaType stop_criteria{alg,true_b,1.e-6,1000,m_trace} ;
      typedef Alien::BiCGStab<AlgebraType> SolverType ;
      SolverType solver{alg,m_trace} ;
      solver.setOutputLevel(3) ;
      typedef Alien::DiagPreconditioner<AlgebraType> PrecondType ;
      PrecondType      precond{alg,true_A} ;
      precond.init() ;
      solver.solve(precond,stop_criteria,true_A,true_b,true_x) ;
      bool succeed = stop_criteria.getStatus() ;
      Arcane::Integer iteration = stop_criteria() ;
      m_trace->info()<<"NB ITERATIONS : "<<iteration;
    */
    m_trace->info()<<"LINEARSOLVER : "<<succeed<<" ITERATION="<<iteration;
    {
      const Alien::SimpleCSRMatrix<Real>& csr = m_alien_matrix->impl()->get<Alien::BackEnd::tag::simplecsr>();
      const Alien::SimpleCSRMatrix<Real>::ProfileType& profile = csr.getProfile();
      int nrows = profile.getNRows();
      int blk_size = m_alien_matrix->block().size();
      const Alien::SimpleCSRVector<Real>& v = m_alien_solution->impl()->get<Alien::BackEnd::tag::simplecsr>();
      const double* values = v.getAddressData();
      for(int i=0;i<nrows;++i)
      {
        m_trace->info()<<"SOL["<<i<<"]:";
        for(int j=0;j<blk_size;++j)
        {
            m_trace->info()<<'\t'<<j<<","<<std::hexfloat<<values[i*blk_size+j];
        }
      }
    }

    if(succeed)
      return true;
    else
      return false;
  }
  catch(Arccore::FatalErrorException& e)
  {
    throw e;
  }
  catch(...)
  {
    return false;
  }
}

/*---------------------------------------------------------------------------*/

void
ArcNum::LinearSystem::
dumpSolution(Arcane::String name)
{
  //Alien::AsciiDumper dumper(Alien::AsciiDumper::eMatlabStyle);
  //dumper.dump(name, *m_alien_solution);
  std::cout<<"with the actual system writer use juste dumpMartix fuction to dump the matrix and the rhs";
}

/*---------------------------------------------------------------------------*/

void
ArcNum::LinearSystem::
dumpMatrix(std::string name)
{
  //Alien::AsciiDumper dumper(Alien::AsciiDumper::eMatlabStyle);
  //dumper.dump(name, *m_alien_matrix);
  Alien::SystemWriter writer(name,"ascii",_arcaneGetDefaultSubDomain()->parallelMng()->messagePassingMng()) ;
  writer.dump(*m_alien_matrix, *m_alien_rhs) ;


}

/*---------------------------------------------------------------------------*/

void
ArcNum::LinearSystem::
dumpRhs(Arcane::String name)
{
  //Alien::AsciiDumper dumper(Alien::AsciiDumper::eMatlabStyle);
  //dumper.dump(name, *m_alien_rhs);
  std::cout<<"with the actual system writer use juste dumpMartix(std::string) fuction to dump the matrix and the rhs";

}

/*---------------------------------------------------------------------------*/

void
ArcNum::LinearSystem::
dumpSolution()
{
  //Alien::AsciiDumper dumper(Alien::AsciiDumper::eMatlabStyle);
  //dumper.dump(*m_alien_solution);
  std::cout<<"with the actual system writer use juste dumpMartix fuction to dump the matrix and the rhs";

}

/*---------------------------------------------------------------------------*/

void
ArcNum::LinearSystem::
dumpMatrix()
{
  //Alien::AsciiDumper dumper(Alien::AsciiDumper::eMatlabStyle);
  //dumper.dump(*m_alien_matrix);
  std::cout<<"with the actual system writer use juste dumpMartix(std::string) fuction to dump the matrix and the rhs";

}

/*---------------------------------------------------------------------------*/

void
ArcNum::LinearSystem::
dumpRhs()
{
  //Alien::AsciiDumper dumper(Alien::AsciiDumper::eMatlabStyle);
  //dumper.dump(*m_alien_rhs);
  std::cout<<"with the actual system writer use juste dumpMartix(std::string) fuction to dump the matrix and the rhs";

}

/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
