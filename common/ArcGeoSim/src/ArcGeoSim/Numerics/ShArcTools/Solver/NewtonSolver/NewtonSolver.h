// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCNUM_NUMERICS_SOLVER_NEWTONSOLVER_H
#define ARCNUM_NUMERICS_SOLVER_NEWTONSOLVER_H
/* Author : desrozis at Thu May 19 11:08:08 2016
 * Generated by createNew
 */

#include "ArcGeoSim/Numerics/ShArcTools/Solver/INewtonSolver.h"
// instead ProfilingNewton
#include "ArcGeoSim/Numerics/ShArcTools/Solver/Newton.h"
#include "ArcGeoSim/Numerics/ShArcTools/LinearAlgebra/LinearSystem/LinearSystem.h"
#include "ArcGeoSim/Numerics/ShArcTools/LinearAlgebra/Vector.h"
#include "ArcGeoSim/Numerics/ShArcTools/LinearAlgebra/Matrix.h"

#include "ArcGeoSim/Appli/AppService.h"

#include <arcane/IMesh.h>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace ArcNum {

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class NewtonSolver
  : public Arcane::TraceAccessor
{
public:

  NewtonSolver() ;
  
  ~NewtonSolver() {}

public:

  void setLinearSolver(Alien::ILinearSolver* solver) { m_linear_solver = solver; }

  // TODO : check what options will be used, remove everything else (XT)
  void setWithElimination(bool b) { m_with_elimination = b; }
  void setIterationMax(Arcane::Integer b) { m_iteration_max = b; }
  void setRelativeTolerance(Arcane::Real b) { m_relative_tolerance = b; }
  void setTolerance(Arcane::Real b) { m_tolerance = b; }
  void setDebugDumpMatlab(bool b) { m_debug_dump_matlab = b; }
  void setDebugInfoLinearSolver(bool b) { m_debug_info_linear_solver = b; }
  void setDebugStatLinearSolver(bool b) { m_debug_stat_linear_solver = b; }
  void setSaveAndFatalAtIteration(Arcane::Integer b) { m_save_and_fatal_at_iteration = b; }
  void setDumpAndFatalAtIteration(Arcane::Integer b) { m_dump_and_fatal_at_iteration = b; }
  // TODO A revoir/activer (XT)
  //void setTheta(const RelaxationTheta& theta) { m_theta = theta; }

  // Initialisation
  void init(std::shared_ptr<ArcNum::INonLinearSystem> non_linear_system);
  
  // Resolution du probleme non lineaire
  bool solve();

  // Permet de placer un report specifique
  //void setNewtonReport(std::shared_ptr<Geoxim::INewtonReport> report);

  // Interface a realiser pour Algorithm::Newton
  void newtonLinearize();
  Arcane::Real newtonError();
  void newtonAssemble();
  Alien::SolverStatus newtonSolve();
  void newtonBeforeSolve(Arcane::Integer i);
  void newtonAfterSolve(Arcane::Integer i);
  void newtonUpdate(bool &NonPhysicalSolution);

private:

  void _twoPointsProfiler(Arcane::IMesh* mesh,
                          Arcane::CellGroup cells,
			  Alien::MatrixProfiler& blockProfiler,
			  Arcane::ConstArray2View<Arcane::Integer> indexes) const;

  void _createAlgebraicObjects();

  // TODO A revoir/utiliser axpy d'Alien quand les structures de donnees seront changees (XT)
  void _axpy(Arcane::SharedArray<Arcane::VariableCellReal*>& y, LinearSystem& system) const
  {
    const Law::PropertyVector& equation_system = m_non_linear_system->equationSystem();
    
    Arcane::Integer nb_equations = equation_system.size();

    auto & domain = m_non_linear_system->folder();
    Arcane::CellGroup cells = domain.support();
  
    auto indexes = system.indexes();
    const Alien::BlockVector& solution = system.solution();
    auto offset = solution.distribution().offset();

    ENUMERATE_CELL(icell, cells.own()) {
      Arcane::Integer id = indexes[icell->localId()][0]/nb_equations - offset;
      Alien::LocalBlockVectorReader vr(solution);
      ConstArrayView<Real> values = vr[id];
      //ARCANE_ASSERT((block.size() == nb_equations),("number of equations and size block not matching"));
      
      for(Arcane::Integer i = 0; i < nb_equations; ++i) {
	(*y[i])[icell] += values[i];
      }
    }
    
    for(Arcane::Integer i = 0; i < nb_equations; ++i)
      y[i]->synchronize();

  }

private:

  bool m_initialized;
  
  Alien::ILinearSolver* m_linear_solver;
  bool m_with_elimination;
  Arcane::Integer m_iteration_max;
  Arcane::Real m_relative_tolerance;
  Arcane::Real m_tolerance;
  bool m_debug_dump_matlab;
  bool m_debug_info_linear_solver;
  bool m_debug_stat_linear_solver;
  Arcane::Integer m_save_and_fatal_at_iteration;
  Arcane::Integer m_dump_and_fatal_at_iteration;
  Arcane::SharedArray<Gump::Property> m_variation_properties;

  // Systeme lineaire
  LinearSystem m_linear_system;

  // Solutions du systeme non lineaire
  Arcane::SharedArray<Arcane::VariableCellReal*> m_solution;

  // Systeme non lineaire
  std::shared_ptr<ArcNum::INonLinearSystem> m_non_linear_system;

  // Nombre d'appel au solveur
  Arcane::Integer m_nb_call;

  // En cours de resolution
  bool m_is_solving;

  // Newton solver
  Algorithm::Newton<NewtonSolver> m_newton;

  // TODO A revoir/activer (XT)
  // RelaxationTheta m_theta;

  // Scaling
  Alien::BlockVector m_block_residual_scaling;

  Arcane::VariableScalarInteger m_newton_iteration;
  Arcane::VariableScalarInteger m_newton_iteration_max;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCNUM_NUMERICS_SOLVER_NEWTONSOLVER_H */
