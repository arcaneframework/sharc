// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
/* Author : desrozis at Fri Oct 25 14:45:18 2013
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "NewtonSolver.h"

#include "ArcNumNewtonSolver_axl.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class ArcNumNewtonSolverService
  : public ArcaneArcNumNewtonSolverObject
  //, private Geoxim::PhysicalSystemAccessor
{
public:

  ArcNumNewtonSolverService(const Arcane::ServiceBuildInfo & sbi)
    : ArcaneArcNumNewtonSolverObject(sbi) {}
  
  ~ArcNumNewtonSolverService() {}

public:

  // Initialisation
  void init(std::shared_ptr<ArcNum::INonLinearSystem> non_linear_system);

  // Resolution du probleme non lineaire
  bool solve();

private:

  ArcNum::NewtonSolver m_solver;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
ArcNumNewtonSolverService::
init(std::shared_ptr<ArcNum::INonLinearSystem> non_linear_system)
{
  // redirection des options
  m_solver.setLinearSolver((Alien::ILinearSolver*)options()->linearSolver());
  m_solver.setWithElimination(options()->withElimination());
  m_solver.setIterationMax(options()->iterationMax());
  m_solver.setRelativeTolerance(options()->relativeTolerance());
  m_solver.setTolerance(options()->tolerance());
  m_solver.setDebugDumpMatlab(options()->debugDumpMatlab());
  m_solver.setDebugInfoLinearSolver(options()->debugInfoLinearSolver());
  m_solver.setDebugStatLinearSolver(options()->debugStatLinearSolver());
  m_solver.setSaveAndFatalAtIteration(options()->saveAndFatalAtIteration());
  m_solver.setDumpAndFatalAtIteration(options()->dumpAndFatalAtIteration());
  // TODO a revoir/activer
  /*if(options()->control.size() == 1 &&
     options()->control[0].variation.size() > 0) {
    // Seuils definis par l'utilisateur
    // NB: si la propriete n'est pas une inconnue => exception
    Geoxim::RelaxationTheta theta(non_linear_system->formulation());
    for(Arcane::Integer i = 0; i < options()->control[0].variation.size(); ++i) {
      auto p = Geoxim::XPath::property(system(), options()->control[0].variation[i].property());
      Arcane::Real th = options()->control[0].variation[i].threshold();
      theta[p] = th;
    }
    m_solver.setTheta(theta);
  }*/

  m_solver.init(non_linear_system);
}

/*---------------------------------------------------------------------------*/

bool
ArcNumNewtonSolverService::
solve()
{
  return m_solver.solve();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_ARCNUMNEWTONSOLVER(ArcNumNewtonSolver,ArcNumNewtonSolverService);

