// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "NewtonSolver.h"
/* Author : desrozis at Thu May 19 11:08:08 2016
 * Generated by createNew
 */

#include <alien/expression/solver/SolverStat.h>
#include <alien/kernels/simple_csr/algebra/SimpleCSRLinearAlgebra.h>

#include "ArcGeoSim/Numerics/TwoPointsScheme/TwoPointsStencil.h"

/*---------------------------------------------------------------------------*/

#include "ArcGeoSim/Physics/Law2/VariableAccessor.h"

ArcNum::NewtonSolver::
NewtonSolver()
  : Arcane::TraceAccessor(_arcaneGetDefaultSubDomain()->traceMng())
  , m_initialized(false)
  , m_linear_solver(nullptr)
  , m_with_elimination(true)
  , m_iteration_max(0)
  , m_relative_tolerance(0.)
  , m_tolerance(0.)
  , m_debug_dump_matlab(false)
  , m_debug_info_linear_solver(false)
  , m_debug_stat_linear_solver(false)
  , m_save_and_fatal_at_iteration(-1)
  , m_dump_and_fatal_at_iteration(-1)
  , m_nb_call(0)
  , m_is_solving(false)
  , m_newton(*this, _arcaneGetDefaultSubDomain()->traceMng())
  , m_newton_iteration(Arcane::VariableBuildInfo(_arcaneGetDefaultSubDomain()->meshes()[0], "NewtonIteration", Arcane::IVariable::PNoDump|Arcane::IVariable::PNoNeedSync))
  , m_newton_iteration_max(Arcane::VariableBuildInfo(_arcaneGetDefaultSubDomain()->meshes()[0], "NewtonIterationMax", Arcane::IVariable::PNoDump|Arcane::IVariable::PNoNeedSync)) {}

/*---------------------------------------------------------------------------*/

void
ArcNum::NewtonSolver::
init(std::shared_ptr<ArcNum::INonLinearSystem> non_linear_system)
{
  m_non_linear_system = non_linear_system;

  if(m_non_linear_system.get() == nullptr) {
    fatal() << "Non linear system pointer null";
  }

  m_linear_solver->init();

  // TODO without geoxim algebra and formulation
  // Nothing to be done, we'll use class attributes directly if feature is still desired
  /*if(m_with_elimination)
    m_algebra.enableElimination();
    if(m_with_row_sum || m_with_row_sum_on_residual)
    m_algebra.enableRowSum();
    if(m_with_normalization)
    m_algebra.enableNormalization();

    const Geoxim::IFormulation& formulation = m_non_linear_system->formulation();

    m_algebra.define(formulation);*/

  _createAlgebraicObjects();

  m_newton.parameterize(m_iteration_max, m_relative_tolerance, m_tolerance);
  m_newton_iteration_max = m_iteration_max;
  m_newton_iteration = 0;


  m_initialized = true;
}

/*---------------------------------------------------------------------------*/

// add from Geoxim TwoPointsProfiler.cc
void
ArcNum::NewtonSolver::
_twoPointsProfiler(Arcane::IMesh* mesh,
		   Arcane::CellGroup cells,
		   Alien::MatrixProfiler& blockProfiler,
		   Arcane::ConstArray2View<Arcane::Integer> indexes) const
{
  Arcane::CellGroup group = cells;
  Arcane::Integer block_size = m_linear_system.rhs().block().size();
  info() << "Define profil on group '" << group.name() << "' size = " << group.size();

  ENUMERATE_CELL(icell, group.own()) {
    const Arcane::Integer lid = icell->localId();
    blockProfiler.addMatrixEntry(indexes[lid][0]/block_size, indexes[lid][0]/block_size);
  }

  ENUMERATE_FACE(iface, group.innerActiveFaceGroup()) {
    const Arcane::Cell back_cell = iface->backCell();
    const Arcane::Integer back_lid = back_cell.localId();
    const Arcane::Cell front_cell = iface->frontCell();
    const Arcane::Integer front_lid = front_cell.localId();
    if(back_cell->isOwn())
      blockProfiler.addMatrixEntry(indexes[back_lid][0]/block_size, indexes[front_lid][0]/block_size);
    if(front_cell->isOwn())
      blockProfiler.addMatrixEntry(indexes[front_lid][0]/block_size, indexes[back_lid][0]/block_size);
  }

  // TODO : To remove ? To split ? (XT)
  /*
    ArcGeoSim::ItemConnectionGroup not_matching_connection_facets =
    ArcNum::Connection::notMatchingConnectionFacet(group.mesh());

    Arcane::VariableCellReal dead_cells(Arcane::VariableBuildInfo(mesh, "DeadCells"));

    ENUMERATE_FACEFACE_CONNECTION(iface_face, not_matching_connection_facets) {
    ArcNum::TwoPointsStencil stencil(iface_face);
    const Arcane::Cell  back_cell = stencil. back().cell();
    const Arcane::Cell front_cell = stencil.front().cell();
    if(dead_cells[back_cell] == 1. || dead_cells[front_cell] == 1.) continue;
    const Arcane::Integer  back_lid = back_cell.localId();
    const Arcane::Integer front_lid = front_cell.localId();
    //profiler(indexes[back_lid], indexes[front_lid]);
    //profiler(indexes[front_lid], indexes[back_lid]);
    }
  */

  info() << "OK Define profil";
}

/*---------------------------------------------------------------------------*/

void
ArcNum::NewtonSolver::
_createAlgebraicObjects()
{
  // from geoxim algebra and formulation
  const Law::PropertyVector& unknowns = m_non_linear_system->equationSystem();
  ArcNum::LinearSystem::MeshGroupBlock bc;
  bc.name = "My Linear System";
  bc.nbEquations = unknowns.size();
  auto & domain = m_non_linear_system->folder();
  bc.group = domain.support();
  m_linear_system = ArcNum::LinearSystem(bc, m_with_elimination);
  Alien::BlockMatrix& matrix = m_linear_system.matrix();
  Alien::MatrixProfiler blockProfiler(matrix);
  auto indexes = m_linear_system.indexes();
  _twoPointsProfiler(_arcaneGetDefaultSubDomain()->meshes()[0], domain.support(), blockProfiler, indexes);

  auto accessor = m_non_linear_system->folder().lawVariableAccessor();
  for(Integer i =0; i< unknowns.size(); ++i)
  {
    const Law::ScalarRealProperty& property = unknowns[i];
    m_solution.add(new Arcane::VariableCellReal(accessor.values(property)));
  }

  m_block_residual_scaling = Alien::BlockVector(m_linear_system.rhs().block(), m_linear_system.rhs().distribution());
}

/*---------------------------------------------------------------------------*/

Arcane::Real
ArcNum::NewtonSolver::
newtonError()
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));
  Alien::SimpleCSRLinearAlgebra alg;
  return alg.norm2(m_linear_system.rhs());
}

/*---------------------------------------------------------------------------*/

void
ArcNum::NewtonSolver::
newtonUpdate(bool &NonPhysicalSolution)
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  // TODO If debug feature requested
  /*ArcGeoSim::OptionalAppService<Geoxim::Debug> debug;
    if(debug.isAvailable()) {
    // ATTENTION, tres couteux !!!
    const Geoxim::IFormulation& formulation = m_non_linear_system->formulation();
    const Geoxim::UnknownsManager& um = formulation.equationSystem().unknownsManager();
    Geoxim::VariableCellFolder delta_folder("Delta");
    delta_folder.disableVerbosity();
    // ATTENTION, PROBLEME AVEC AMR => allCells() a remplacer
    delta_folder.setSupport(allCells());
    ENUMERATE_UNKNOWNS(iunknown, um) {
    delta_folder.addVariable(iunknown->property());
    }
    Geoxim::VariableVector delta = m_algebra.newUnknownVector(delta_folder);
    delta.fill(0.);
    Geoxim::Axpy axpy = m_algebra.axpy();
    axpy(delta, m_linear_system);
    debug->printUnknownVariations(delta, um);
    }*/

  {
    // TODO with alien
    /*if(m_theta.isEnabled()) {
    // i.e. m_solution += theta * m_linear_system.alienSolution()
    // ou theta = f(m_linear_system.alienSolution(), thresold)
    axpy(m_solution, m_theta, m_linear_system);
    } else {
    // i.e. m_solution += m_linear_system.alienSolution()
    axpy(m_solution, m_linear_system);
    }*/
    this->_axpy(m_solution, m_linear_system);
  }


  {
    // Contrainte sur la solution
    m_non_linear_system->applyConstraintOnSolution(NonPhysicalSolution);
  }
}

/*---------------------------------------------------------------------------*/

// TODO Is this method "necessary" ? (XT)
void
ArcNum::NewtonSolver::
newtonAssemble()
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  // TODO If debug feature requested
  /*ArcGeoSim::OptionalAppService<Geoxim::Debug> debug;
    if(debug.isAvailable()) {
    debug->printLinearSystem(m_linear_system);
    }*/

}

/*---------------------------------------------------------------------------*/

bool
ArcNum::NewtonSolver::
newtonSolve()
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  return m_linear_system.solve(m_linear_solver);
}

/*---------------------------------------------------------------------------*/

void
ArcNum::NewtonSolver::
newtonLinearize()
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  // TODO If debug feature requested
  /*ArcGeoSim::OptionalAppService<Geoxim::Debug> debug;
    if(debug.isAvailable()) {
    Arcane::VariableScalarReal global_old_time(Arcane::VariableBuildInfo(subDomain(), "GlobalOldTime"));
    debug->file() << std::endl << std::endl
    << "##################################################################"  << std::endl
    << "############### DEBUG MODE :"
    << " NStep = " << m_nb_call
    << " Time = " << global_old_time()
    << " Iter = " << m_newton.lastIteration() << std::endl
    << "##################################################################"  << std::endl
    << std::endl << std::endl;
    }*/

  Alien::BlockMatrix& matrix = m_linear_system.matrix();
  Alien::BlockVector& rhs = m_linear_system.rhs();
  const Arcane::Integer localSize = rhs.distribution().localSize();
  const Arcane::Integer blockSize = rhs.block().size();
  {
    Alien::LocalBlockVectorWriter vw(rhs);
    for (Arcane::Integer i = 0; i < localSize; ++i)
    {
      ArrayView<Real> values = vw[i];
      for(Integer j=0; j < blockSize;++j)
	values[j] = 0.;
    }
  }

  ArcNum::Vector residual(rhs, m_linear_system.indexes());
  ArcNum::Matrix jacobian(matrix, m_linear_system.indexes());

  // Calcul des termes explicites
  if(m_newton.lastIteration() == 0) {
    m_non_linear_system->updateExplicitTerms();
  }

  {
    // Construction des residus R et de la jacobienne J
    m_non_linear_system->build(residual,jacobian);
  }

  {
    Alien::LocalBlockVectorWriter vw(rhs);
    for (Arcane::Integer i = 0; i < localSize; ++i)
    {
      ArrayView<Real> values = vw[i];
      for(Integer j=0; j < blockSize;++j)
	values[j] = -values[j];
    }
  }
}
    
/*---------------------------------------------------------------------------*/

void
ArcNum::NewtonSolver::
newtonBeforeSolve(Arcane::Integer iteration)
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  if(m_debug_dump_matlab) {
    info()<<"write files DebugNewton Vector and Matrix "<<m_nb_call<<"_"<<iteration<<".txt";
    m_linear_system.dumpMatrix(Arcane::String::format("DebugNewtonMatrix_{0}_{1}.txt",
						      m_nb_call, iteration));
    m_linear_system.dumpRhs(Arcane::String::format("DebugNewtonVector_{0}_{1}.txt",
						   m_nb_call, iteration));
  }
}

/*---------------------------------------------------------------------------*/

void
ArcNum::NewtonSolver::
newtonAfterSolve(Arcane::Integer iteration)
{
  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  // Get Linear Solver Status
  auto status = m_linear_solver->getStatus();

  // Print Linear Solver Infos
  if(m_debug_info_linear_solver)
  {
    info() << "Newton Iteration [" << std::setw(2) << iteration << "] "
	   << "* LinearSolver error = " << status.succeeded
	   << " " << std::setw(5) << status.iteration_count
	   << " " << std::setw(10) << status.residual;
  }

  if(m_debug_stat_linear_solver)
  {
    auto solver_stat = m_linear_solver->getSolverStat();
    solver_stat.print(traceMng(), status, "DebugInfo Linear Solver");
  }

  if(m_save_and_fatal_at_iteration == iteration)
  {
    m_linear_system.dumpMatrix(Arcane::String::format("Matrix{0}_{1}.txt",
						      m_nb_call, iteration));
    m_linear_system.dumpRhs(Arcane::String::format("Residual{0}_{1}.txt",
						   m_nb_call, iteration));
    m_linear_system.dumpSolution(Arcane::String::format("Delta{0}_{1}.txt",
							m_nb_call, iteration));
    fatal() << "User stop Newton at iteration " << iteration;
  }
  if(m_dump_and_fatal_at_iteration == iteration)
  {
    m_linear_system.dumpMatrix();
    m_linear_system.dumpRhs();
    m_linear_system.dumpSolution();
    fatal() << "User stop Newton at iteration " << iteration;
  }
}

/*---------------------------------------------------------------------------*/

bool
ArcNum::NewtonSolver::
solve()
{
  // pour marquer que l'on resout et pouvoir checker durant les callbacks
  m_is_solving = true;

  ARCANE_ASSERT((m_initialized),("Newton solver not initialized"));

  m_nb_call ++;

  bool r = m_newton.solve();


  // Mise a jour (pour politique de pas de temps)
  m_newton_iteration = m_newton.lastIteration();

  m_is_solving = false;

  return r;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
