/* Author : havep at Fri Jun  6 11:02:38 2008
 * Generated by createNew
 */

#include <arcane/MathUtils.h>

#include "ArcGeoSim/Numerics/LinearAlgebra2/PETScImpl/PETScPrecomp.h"

#include "ArcGeoSim/Numerics/LinearAlgebra2/Space.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/Matrix.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/Vector.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/ILinearSolver.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/ILinearAlgebra.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/IIndexManager.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/Impl/SolverStater.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/Impl/MultiVectorImpl.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/Impl/MultiMatrixImpl.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/Accessor/VectorAccessor.h"

struct VerboseTypes
{
    enum eChoix {
        none,
        low,
        high
    };
};

using namespace Arcane;

#include "ArcGeoSim/Numerics/LinearSolver/PETScSolverImpl/IPETScKSP.h"
#include "PETScLinearSolver_axl.h"

#include <boost/shared_ptr.hpp>

/*---------------------------------------------------------------------------*/

/*! Classe/service de r�solution lin�aire PETSc
 *  Une couche interm�diaire IPETScLinearSolver pourrait etre
 *  ajout�e afin d'utiliser PETScLinearSolverService sans sa partie 'service'
 */ 
class PETScLinearSolverService
  : public ArcanePETScLinearSolverObject
{
private:
  typedef Alien::ILinearSolver::Status Status ;
  typedef Alien::Matrix         Matrix ;
  typedef Alien::Vector         Vector ;
  typedef Alien::Space          Space ;
  typedef Alien::ILinearAlgebra ILinearAlgebra ;
  typedef Alien::IIndexManager  IIndexManager ;
  typedef Alien::SolverStat     SolverStat ;
  typedef Alien::SolverStater   SolverStater ;

public:
  /** Constructeur de la classe */
  PETScLinearSolverService(const Arcane::ServiceBuildInfo & sbi);
  
  /** Destructeur de la classe */
  virtual ~PETScLinearSolverService();
  
public:
  //! Initialisation
  void init();

  //! Finalize
  void end();


  virtual void setNullSpaceConstantOption(bool flag)
  {
    m_null_space_constant_opt = flag ;
  }

  /////////////////////////////////////////////////////////////////////////////
  //
  // NEW INTERFACE
  //

  //! return package back end name
  String getBackEndName() const { return "petsc"; }

  bool solve(const Matrix & A, const Vector & b, Vector& x) ;

  //! Indicateur de support de r�solution parall�le
  bool hasParallelSupport() const;

  //! Alg�bre lin�aire compatible
  boost::shared_ptr<ILinearAlgebra> algebra(const Space & space) const;

  //! Etat du solveur
  const Status & getStatus() const;

  //! Statistiques du solveur
  const SolverStat & getSolverStat() const { return m_stater; }

private:
  bool _solve(const Mat & A, const Vec & b, Vec & x, const Alien::IIndexManager * indexManager) ;
  void internalPrintInfo() const ;
  bool _isNull(const Vector& b);
  bool _solveNullRHS( Vector& x);

private:
  //! Status
  Status m_status;

  //! Indicateur de l'initialisation globale de PETSc
  /*! La vision service de Arcane perd le sens de l'initialisation 
   * globale de PETSc. 
   * Cette variable globale permet d'y pallier */  
  static bool m_global_initialized;

  //! Indicateur du trace-info global pour PETSc
  static bool m_global_want_trace;

  //! option to manage null space constant
  bool m_null_space_constant_opt ;

  //! Statistiques d'ex�cution du solveur
  SolverStater m_stater;

public:
  void checkError(const String & msg, int ierr) const;
  String convergedReasonString(const Integer reason) const;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

bool PETScLinearSolverService::m_global_initialized = false;
bool PETScLinearSolverService::m_global_want_trace  = false;

#include <arcane/ISubDomain.h>
#include "ArcGeoSim/Utils/Utils.h"

#include <arcane/utils/NotSupportedException.h>

#include <arcane/utils/StringBuilder.h>

#include "petscmat.h"
#include "petscvec.h"
#include "petscksp.h"
#include "petscversion.h"

#include "ArcGeoSim/Numerics/LinearAlgebra2/PETScImpl/PETScLinearAlgebra.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/PETScImpl/PETScInternal.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

PETScLinearSolverService::
PETScLinearSolverService(const Arcane::ServiceBuildInfo & sbi)
: ArcanePETScLinearSolverObject(sbi)
, m_null_space_constant_opt(false)
{
  ;
}

/*---------------------------------------------------------------------------*/

PETScLinearSolverService::
~PETScLinearSolverService()
{
  ;
}

/*---------------------------------------------------------------------------*/

void
PETScLinearSolverService::
init()
{
  m_stater.reset();
  m_stater.startInitializationMeasure();

  if (not m_global_initialized) 
    {
      String petsc_options;
      StringBuilder strBuilder(" ");
      if (options()->traceInfo())
        {
          // See PetscInitialize for details
          // http://www-unix.mcs.anl.gov/petsc/petsc-as/snapshots/petsc-current/docs/manualpages/Sys/PetscInitialize.html
          strBuilder += " "; // separator
          strBuilder += "-info";
          strBuilder += " "; // separator
          strBuilder += "-log_trace petsc.log";
          m_global_want_trace = true;
        }
      if(options()->cmdLineParam.size()>0)
      {
        strBuilder += " "; // separator
        strBuilder += options()->cmdLineParam[0];
      }
      petsc_options = strBuilder.toString();
      if (not petsc_options.empty())
        info()<<"PETSC CMD : "<<petsc_options ;

      // Emulate argc,argv with dynamic options
      // (since PetscOptionsInsertString cannot insert info options)
      StringSharedArray petsc_string_options;
      builtInGetValue(petsc_string_options,petsc_options);
      int argc = petsc_string_options.size()+1;
      const char ** petsc_c_options = new const char*[argc];
      petsc_c_options[0] = NULL;
      for(Integer i=0;i<petsc_string_options.size();++i)
        petsc_c_options[i+1] = petsc_string_options[i].localstr();
      char ** argv = (char**)petsc_c_options;

      debug() << "PETSc Initialisation";
      PetscInitialize(&argc,&argv,NULL,"PETSc Initialisation");
      delete[] petsc_c_options;

      // Reduce memory due to log for graphical viewer
      PetscLogActions(PETSC_FALSE);
      PetscLogObjects(PETSC_FALSE);

#if ((PETSC_VERSION_MAJOR <= 3 && PETSC_VERSION_MINOR < 3) || (PETSC_VERSION_MAJOR < 3))
      if (options()->traceInfo())
        {
          info() << "PETSc options:";
          PetscOptionsPrint(stdout);
        }
#endif /* PETSC_VERSION */

      m_global_initialized = true;
    }
  else
    {
      if (options()->traceInfo() != m_global_want_trace)
        warning() << "PETSc trace-info option is global and given by the first initialisation; current state is " << ((m_global_want_trace)?"on":"off");
    }

  m_stater.stopInitializationMeasure();
}

/*---------------------------------------------------------------------------*/

const Alien::ILinearSolver::Status&
PETScLinearSolverService::
getStatus() const
{
  return m_status;
}

/*---------------------------------------------------------------------------*/

bool
PETScLinearSolverService::
solve(const Matrix & A, const Vector & b, Vector& x)
{
  m_stater.startPrepareMeasure();
  Alien::PETScMatrix const& matrix = A.impl()->get<Alien::BackEnd::tag::petsc>() ;
  const Alien::PETScVector & rhs = b.impl()->get<Alien::BackEnd::tag::petsc>() ;
  Alien::PETScVector& sol = x.impl()->get<Alien::BackEnd::tag::petsc>(true) ;
  m_stater.stopPrepareMeasure();

  // Find zero second member
  if (_isNull(b)) return _solveNullRHS(x);

  return _solve(matrix.internal()->m_internal,rhs.internal()->m_internal,sol.internal()->m_internal,
                A.space().indexManager());
}

/*---------------------------------------------------------------------------*/

bool
PETScLinearSolverService::
hasParallelSupport() const
{
  return options()->solver()->hasParallelSupport();
}

/*---------------------------------------------------------------------------*/

boost::shared_ptr<PETScLinearSolverService::ILinearAlgebra>
PETScLinearSolverService::
algebra(const Space & space) const
{
  return boost::shared_ptr<ILinearAlgebra>(new Alien::PETScLinearAlgebra(space));
}

/*---------------------------------------------------------------------------*/

bool 
PETScLinearSolverService::
_solve(const Mat & A, const Vec & b, Vec & x, const Alien::IIndexManager * index_manager)
{
  if (index_manager != NULL && index_manager->parallelMng()->commSize() > 1 && !hasParallelSupport())
    fatal() << "Selected solver does not have parallel support.";

  if (options()->verbose()==VerboseTypes::high)
    {
      info()<<"|---------------------------------------------|";
      info()<<"| Start Linear Solver #"<< m_stater.solveCount();
    }

  m_stater.startSolveMeasure();


  KSP ksp;

  checkError("Solver create",KSPCreate(PETSC_COMM_WORLD,&ksp));
#if ((PETSC_VERSION_MAJOR <= 3 && PETSC_VERSION_MINOR < 7) || (PETSC_VERSION_MAJOR < 3))
  checkError("Set solver operators", KSPSetOperators(ksp,
                                                     A,
                                                     A,
                                                     DIFFERENT_NONZERO_PATTERN));
#else
  checkError("Set solver operators", KSPSetOperators(ksp,
                                                     A,
                                                     A));
#endif

  options()->solver()->configure(ksp,index_manager);

  // Impact local : � r�activer en tant qu'option sp�cifique et probablement dans l'interface ILinearSolver 
  // L'impl�mentation doit �tre prise en charge par les solveurs (faut il factoriser ce mini bout de code ?)
  // L'API devrait permettre de demander au solveur sa capacit� de traiter les pbs � une constante pr�s, si oui
  // le prend en charge, sinon demande � l'utilisateur de le prendre en charge
#if ((PETSC_VERSION_MAJOR <= 3 && PETSC_VERSION_MINOR < 7) || (PETSC_VERSION_MAJOR < 3))
  const PCType pctype;
#else
  PCType pctype;
#endif
  PC pc ;
  KSPGetPC(ksp,&pc);
  PCGetType(pc, &pctype);
  if(m_null_space_constant_opt)
    {
      if(!std::string(pctype).compare(PCLU))
        {
          info() << "[PETScSolver::NullSpaceHasConstants] Matrix factorization accounting for zero pivot\n";
          PCFactorSetShiftAmount(pc, PETSC_DECIDE);
          PCFactorReorderForNonzeroDiagonal(pc, 1e-10);
        }
      else
        {
          MatNullSpace nsp;
          MatNullSpaceCreate(PETSC_COMM_WORLD, PETSC_TRUE, 0, NULL, &nsp);
#if ((PETSC_VERSION_MAJOR <= 3 && PETSC_VERSION_MINOR < 7) || (PETSC_VERSION_MAJOR < 3))
          KSPSetNullSpace(ksp, nsp);
#else
          MatSetNullSpace(A, nsp);
#endif
#ifndef NO_USER_WARNING
#warning "TODO: Ne g�re pas la fin de vie de MatNullSpace via MatNullSpaceDestroy"
#endif /* NO_USER_WARNING */
        }
    }
  

  if (options()->verbose()==VerboseTypes::high) {
#if ((PETSC_VERSION_MAJOR <= 3 && PETSC_VERSION_MINOR < 7) || (PETSC_VERSION_MAJOR < 3))
    KSPMonitorSet(ksp,KSPMonitorTrueResidualNorm,PETSC_NULL,PETSC_NULL);
#else
    PetscViewerAndFormat *vf;
    PetscViewerAndFormatCreate(PETSC_VIEWER_STDOUT_WORLD,PETSC_VIEWER_DEFAULT,&vf);
    KSPMonitorSet(ksp,(PetscErrorCode (*)(KSP,PetscInt,PetscReal,void*))KSPMonitorTrueResidualNorm,
                  vf,(PetscErrorCode (*)(void**))PetscViewerAndFormatDestroy);
#endif
  }
  
  checkError("Solver solve",KSPSolve(ksp,
                                     b,
                                     x));

  KSPConvergedReason ksp_reason;
  KSPGetConvergedReason(ksp,&ksp_reason);

  KSPGetIterationNumber(ksp,&m_status.iteration_count);
  KSPGetResidualNorm(ksp,&m_status.residual);

  m_status.succeeded = (ksp_reason >= 0);

  if (options()->verbose()==VerboseTypes::high)
    info() << "| PETScSolver final state : " << convergedReasonString(ksp_reason);
  else if (not m_status.succeeded)
    info() << "PETScSolver final state : " << convergedReasonString(ksp_reason) << " after " << String::plural(m_status.iteration_count,"iteration") << " with residual " << m_status.residual;

#if ((PETSC_VERSION_MAJOR <= 3 && PETSC_VERSION_MINOR < 3) || (PETSC_VERSION_MAJOR < 3))
  checkError("Solver destroy",KSPDestroy(ksp));
#else /* PETSC_VERSION */
  checkError("Solver destroy",KSPDestroy(&ksp));
#endif /* PETSC_VERSION */

  m_stater.stopSolveMeasure(m_status);

  if (options()->verbose()==VerboseTypes::high)
    {
      info()<<"| End Linear Solver";
      info()<<"|---------------------------------------------|";
    }

  if (options()->verbose()!=VerboseTypes::low)
    {
      internalPrintInfo();
    }
  return m_status.succeeded;
}

/*---------------------------------------------------------------------------*/

void
PETScLinearSolverService::
end()
{
  ;
}

/*---------------------------------------------------------------------------*/

void
PETScLinearSolverService::
checkError(const String & msg, int ierr) const
{
  if (ierr != 0)
    {
      const char * text;
      char * specific;
      PetscErrorMessage(ierr,&text,&specific);
      fatal() << msg << " failed : " << text << " / " << specific << "[code=" << ierr << "]";
    }
}

/*---------------------------------------------------------------------------*/

String
PETScLinearSolverService::
convergedReasonString(const Integer reason) const
{
  switch (reason) {
  case KSP_CONVERGED_RTOL:
    return "converged RTOL";
  case KSP_CONVERGED_ATOL:
    return "converged ATOL";
  case KSP_CONVERGED_ITS:
    return "converged ITS";
  case KSP_CONVERGED_CG_NEG_CURVE:
    return "converged CG_NEG_CURVE";
  case KSP_CONVERGED_CG_CONSTRAINED:
    return "converged CG_CONSTRAINED";
  case KSP_CONVERGED_STEP_LENGTH:
    return "converged STEP_LENGTH";
  case KSP_CONVERGED_HAPPY_BREAKDOWN:
    return "converged HAPPY_BREAKDOWN";
  case KSP_DIVERGED_NULL:
    return "diverged NULL";
  case KSP_DIVERGED_ITS:
    return "diverged ITS";
  case KSP_DIVERGED_DTOL:
    return "diverged DTOL";
  case KSP_DIVERGED_BREAKDOWN:
    return "diverged BREAKDOWN";
  case KSP_DIVERGED_BREAKDOWN_BICG:
    return "diverged BREAKDOWN_BICG";
  case KSP_DIVERGED_NONSYMMETRIC:
    return "diverged NONSYMMETRIC";
  case KSP_DIVERGED_INDEFINITE_PC:
    return "diverged indefinite preconditioner";
#if ((PETSC_VERSION_MAJOR <= 3 && PETSC_VERSION_MINOR < 7) || (PETSC_VERSION_MAJOR < 3))
  case KSP_DIVERGED_NAN:
    return "diverged NAN";
#endif
  case KSP_DIVERGED_INDEFINITE_MAT:
    return "diverged indefinite matrix";
  case KSP_CONVERGED_ITERATING:
    return "converged ITERATING";    
  default: {
    String msg = String("Undefined PETSc reason [") + reason + String("]");
    throw NotSupportedException(A_FUNCINFO,msg);
  }
  }
}

/*---------------------------------------------------------------------------*/

void
PETScLinearSolverService::
internalPrintInfo() const
{
  m_stater.print(traceMng(), m_status, String::format("Linear Solver : {0}",serviceInfo()->localName()));
}

/*---------------------------------------------------------------------------*/

bool
PETScLinearSolverService::
_isNull(const Vector& b)
{
  bool is_zero_second_member = false;
  boost::shared_ptr<PETScLinearSolverService::ILinearAlgebra> my_algebra = this->algebra(b.space());
  if (Arcane::math::isNearlyZero(my_algebra.get()->norm0(b))) is_zero_second_member = true;
  return is_zero_second_member;
}

bool
PETScLinearSolverService::
_solveNullRHS(Vector& x)
{
  if (options()->verbose()==VerboseTypes::high)
      {
        info()<<"|---------------------------------------------|";
        info()<<"| Start Linear Solver #"<< m_stater.solveCount();
        info()<<"| -- Zero second member -- ";
      }
  // x = 0;
  Alien::LocalVectorAccessor x_accessor(x);
  for(Integer i=0;i<x.space().localSize();++i) x_accessor[i] = 0;
  x_accessor.end();

  m_stater.startSolveMeasure();
  m_status.succeeded = true;
  if (options()->verbose()==VerboseTypes::high)
     info() << "| PETScSolver final state : converged " ;
  m_stater.stopSolveMeasure(m_status);

  if (options()->verbose()==VerboseTypes::high)
    {
      info()<<"| End Linear Solver";
      info()<<"|---------------------------------------------|";
    }

  if (options()->verbose()!=VerboseTypes::low)
    {
      internalPrintInfo();
    }

  return m_status.succeeded;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_PETSCLINEARSOLVER(PETScSolver,PETScLinearSolverService);
