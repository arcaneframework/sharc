/* Author : desrozis at Mon Mar 30 15:06:37 2009
 * Generated by createNew
 */
#include "ArcGeoSim/Numerics/LinearAlgebra2/IFPSolverImpl/IFPSolverPrecomp.h"

#include "ArcGeoSim/Numerics/LinearAlgebra2/Space.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/Matrix.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/Vector.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/ILinearSolver.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/Impl/SolverStat.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/Impl/SolverStater.h"

#include "ArcGeoSim/Numerics/LinearSolver/IFPSolverImpl/IFPSolverProperty.h"

using namespace Arcane;
using namespace ArcGeoSim::Numerics;
#include "IFPLinearSolver_axl.h"

#include <boost/shared_ptr.hpp>
#include <arcane/ISubDomain.h>
#include <arcane/IParallelMng.h>

#ifndef WIN32
#include <sys/time.h>
#include <sys/resource.h>
#endif /* WIN32 */

/*---------------------------------------------------------------------------*/

class IFPLinearSolverService
  : public ArcaneIFPLinearSolverObject
{
public:
  typedef Alien::ILinearSolver::Status Status ;
  typedef Alien::Matrix MatrixType ;
  typedef Alien::Vector VectorType ;


public:
  /** Constructeur de la classe */
  IFPLinearSolverService(const Arcane::ServiceBuildInfo & sbi);

  /** Destructeur de la classe */
  virtual ~IFPLinearSolverService() {}

public:
  //! Initialisation
  void init();

  //! Finalize
  void end();

  //! Getting solver status
  const Status& getStatus() const;

  /////////////////////////////////////////////////////////////////////////////
  //
  // NEW INTERFACE
  //

  //! return package back end name
  String getBackEndName() const { return "ifpsolver" ; }

  bool solve(const MatrixType & A, const VectorType & b, VectorType & x);


  //! Algèbre linéaire associée
  /*! Pas d'algèbre linéaire associée à IFPSolver */
  boost::shared_ptr<Alien::ILinearAlgebra>
  algebra(const Alien::Space&) const
  {
    return boost::shared_ptr<Alien::ILinearAlgebra>();
  }

  //! Indicateur de support de résolution parallèle
  bool hasParallelSupport() const { return true; }

  //! Accès aux statistiques d'exécution
  const Alien::SolverStat & getSolverStat() const { return m_stater; }

private:
  bool _solve();
  //A. Anciaux
   bool _solveRs(bool m_resizeable); 
    
  void internalPrintInfo() const ;

private:
  Integer m_max_iteration;
  Real   m_stop_criteria_value;
  Integer m_precond_option;
  bool m_precond_pressure;
  bool m_normalisation_pivot;
  bool m_normalize_opt;
  Integer m_ilu0_algo;




  bool m_is_parallel;
  Status m_status;
  Alien::SolverStater m_stater;  //<! Statistiques d'exécution du solveur
  Integer m_print_info;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;

#include "ArcGeoSim/Utils/Utils.h"

#include "IFPSolverProperty.h"
#include "IFPSolver.h"


#include "ArcGeoSim/Numerics/LinearAlgebra2/Impl/MultiMatrixImpl.h"
#include "ArcGeoSim/Numerics/LinearAlgebra2/Impl/MultiVectorImpl.h"

#define MPICH_SKIP_MPICXX 1
#include "mpi.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

IFPLinearSolverService::
IFPLinearSolverService(const Arcane::ServiceBuildInfo & sbi) :
  ArcaneIFPLinearSolverObject(sbi)
{
  m_is_parallel = sbi.subDomain()->parallelMng()->isParallel();
  m_print_info = 0; 
}

/*---------------------------------------------------------------------------*/

void 
IFPLinearSolverService::
init()
{
  m_stater.reset();

  info() << "IFPLinearSolverService::init";

#ifndef WIN32
  struct rlimit limit;
  limit.rlim_cur = limit.rlim_max = RLIM_INFINITY;
  setrlimit(RLIMIT_STACK, &limit);
#endif /* WIN32 */

  if (options()->output() > 0)
    m_print_info = options()->output();
  else if (options()->verbose())
    m_print_info = 1;
  if(subDomain()->parallelMng()->isMasterIO()){
    F2C(ifpsolversetoutputlevel)(&m_print_info) ;
  }
  else{
    Integer print_info = 0;
    F2C(ifpsolversetoutputlevel)(&print_info) ; // IFPSolve should not keep a reference to print_info
  }

  m_max_iteration = options()->numIterationsMax();
  m_stop_criteria_value = options()->stopCriteriaValue();
  switch(options()->precondOption()){
  case IFPSolverProperty::Diag :
    m_precond_option = 0;
    break;
  case IFPSolverProperty::ILU0 :
    m_precond_option = 1;
    break;
  case IFPSolverProperty::AMG :
    m_precond_option = 2;
    break;
  case IFPSolverProperty::CprAmg :
    m_precond_option = 3;
    break;
  default :
    m_precond_option = 0;
  }

 switch(options()->ilu0Algo())
  {
  case IFPSolverProperty::Normal :
    m_ilu0_algo = 0;
    break;
  case IFPSolverProperty::BlockJacobi :
    m_ilu0_algo = 1;
    break;
  case IFPSolverProperty::Optimized :
    m_ilu0_algo = 2;
    break;
  default :
    m_ilu0_algo = 0;
  }


  m_precond_pressure = (options()->precondEquation() == IFPSolverProperty::Pressure);
  m_normalisation_pivot = options()->normalisationPivot();
  m_normalize_opt = options()->needNormalisation();
  
  // TODO: use communicator from parallel manager
  MPI_Comm comm = MPI_COMM_WORLD;
  int fcomm = (int) comm;
  Integer needMpiInit = (m_is_parallel)?1:0;

 

  m_stater.startInitializationMeasure();
  F2C(ifpsolverinit)(&fcomm,&needMpiInit,&m_normalize_opt);
  m_stater.stopInitializationMeasure();
 }

/*---------------------------------------------------------------------------*/

void
IFPLinearSolverService::
end()
{
    {
      F2C(ifpsolverfreedata)() ;
    }
}

/*---------------------------------------------------------------------------*/

const Alien::ILinearSolver::Status&
IFPLinearSolverService::
getStatus() const
{
  return m_status;
}

/*---------------------------------------------------------------------------*/

bool
IFPLinearSolverService::
solve(const Alien::Matrix & A, const Alien::Vector & b, Alien::Vector & x)
{
  bool isSolverOk = false;
  m_stater.startPrepareMeasure();

  // C'est a ce moment la, que la IFP matrice est construite.
  // Avant d'arriver la, la matrice est stockee dans la SimpleCSRMatrix
  // la conversion de representation se fait a ce niveau là
  const Alien::IFPMatrix & matrix = A.impl()->get<Alien::BackEnd::tag::ifpsolver>() ;
  // Libération de l'instance solution 'x' car il n'y a pas de multi-instanciation et l'on sait que l'on le recalcule
#ifndef NO_USER_WARNING
#warning "CHECK (HP) A tester dans le périmètre ArcEOR avec écriture directe des IFPVector sans représentation SimpleCSR"
#endif /* NO_USER_WARNING */
  //x.impl()->release<BackEnd::tag::ifpsolver>() ;
  // Idem que IFPMatrix
  const Alien::IFPVector & rhs = b.impl()->get<Alien::BackEnd::tag::ifpsolver>() ;

  if (not (matrix.internal()->m_filled and rhs.internal()->m_filled))
    fatal() << "IFPSolver initialization error "
            <<" A: "<< matrix.internal()->m_filled
            <<" rhs: "<< rhs.internal()->m_filled;

  if (m_print_info and matrix.internal()->m_elliptic_split_tag)
    info() << "Elliptic split tag enabled";

  if(!matrix.getSymmetricProfile() && options()->ilu0Algo()==IFPSolverProperty::Normal)
    m_ilu0_algo=3;
  if(!matrix.getSymmetricProfile() && options()->ilu0Algo()==IFPSolverProperty::Optimized)
    m_ilu0_algo=4;

  m_stater.stopPrepareMeasure();

  if(matrix.internal()->m_system_is_resizeable == true)
    isSolverOk = _solveRs(matrix.internal()->m_system_is_resizeable);
  else
    isSolverOk = _solve();

  if (isSolverOk)
    {
#ifndef NO_USER_WARNING
#warning "CHECK (HP) A tester dans le pï¿½rimï¿½tre ArcEOR avec ï¿½criture directe des IFPVector sans reprï¿½sentation SimpleCSR"
#endif /* NO_USER_WARNING */
      //b.impl()->release<BackEnd::tag::ifpsolver>() ;
      Alien::IFPSolverInternal::VectorInternal::setRepresentationSwitch(true);
      Alien::IFPVector & sol = x.impl()->get<Alien::BackEnd::tag::ifpsolver>(true) ;
      sol.setResizable(rhs.isResizable()) ;
      Alien::IFPSolverInternal::VectorInternal::setRepresentationSwitch(false);
      sol.internal()->m_filled = true;
    }
  else
    {
      // La valeur de b en cas d'échec n'est actuellement pas bien définie : à tester.
    }


  return isSolverOk;
}


/*---------------------------------------------------------------------------*/

bool
IFPLinearSolverService::
_solve()
{
  bool m_resizeable = false;
  if(m_print_info)
  {
    info()<<"|--------------------------------------------------------|";
    info()<<"| Start Linear Solver #"<< m_stater.solveCount();
  }

  m_stater.startSolveMeasure();

  F2C(ifpsolversolve)(&m_max_iteration,
                      &m_stop_criteria_value,
                      &m_precond_option,
                      &m_precond_pressure,
                      &m_normalisation_pivot,
                      &m_ilu0_algo,
                      &m_resizeable);
  F2C(ifpsolvergetsolverstatus)(&m_status.error,
                                &m_status.iteration_count,
                                &m_status.residual);
  m_status.succeeded = (m_status.error==0);

  m_stater.stopSolveMeasure(m_status);

  if(m_print_info)
  {
    info()<<"| End Linear Solver";
    info()<<"|--------------------------------------------------------|";
    internalPrintInfo();
  }

  return m_status.succeeded;
}

//A. Anciaux
bool
IFPLinearSolverService::
_solveRs(bool m_resizeable)
{
  if(m_print_info)
  {
    info()<<"|--------------------------------------------------------|";
    info()<<"| Start Linear Solver #"<< m_stater.solveCount();
  }

  m_stater.startSolveMeasure();

  F2C(ifpsolversolve)(&m_max_iteration,
                      &m_stop_criteria_value,
                      &m_precond_option,
                      &m_precond_pressure,
                      &m_normalisation_pivot,
                      &m_ilu0_algo,
                      &m_resizeable);
  F2C(ifpsolvergetsolverstatus)(&m_status.error,
                                &m_status.iteration_count,
                                &m_status.residual);
  m_status.succeeded = (m_status.error==0);

  m_stater.stopSolveMeasure(m_status);

  if(m_print_info)
  {
    info()<<"| End Linear Solver";
    info()<<"|--------------------------------------------------------|";
    internalPrintInfo();
  }

  return m_status.succeeded;
}


/*---------------------------------------------------------------------------*/

void
IFPLinearSolverService::
internalPrintInfo() const
{
  m_stater.print(traceMng(), m_status, String::format("Linear Solver : {0}",serviceInfo()->localName()));

  Real init_solver_count = 0 ;
  Real init_precond_count = 0 ;
  Real normalyze_count = 0 ;
  Real loop_solver_count = 0 ;
  F2C(ifpsolvergetperfcount)(&init_solver_count,
                             &init_precond_count,
                             &normalyze_count,
                             &loop_solver_count) ;
  info()<<"|--------------------------------------------------------|";
  info()<<"| IFPSolver             :                                |";
  info()<<"|--------------------------------------------------------|";
  info()<<"| init solver time      : "<<init_solver_count;
  info()<<"| init precond time     : "<<init_precond_count;
  info()<<"| normalisation time    : "<<normalyze_count;
  info()<<"| loop solver time      : "<<loop_solver_count;
  info()<<"|--------------------------------------------------------|";
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_IFPLINEARSOLVER(IFPSolver,IFPLinearSolverService);
