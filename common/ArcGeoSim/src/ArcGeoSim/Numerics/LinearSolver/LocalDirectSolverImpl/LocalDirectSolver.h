#ifndef LOCALDIRECTSOLVER_H_
#define LOCALDIRECTSOLVER_H_


/* Author : haeberlf at Tue Jun  3 15:14:05 2008
 * Generated by createNew
 */
#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/vector_proxy.hpp>
#include <boost/numeric/ublas/io.hpp>
#include <boost/numeric/ublas/lu.hpp>

#include "ArcGeoSim/Numerics/LinearSolver/LocalDirectSolverImpl/ILinearSystem.h"
#include "ArcGeoSim/Numerics/LinearSolver/LocalDirectSolverImpl/ILinearSystemBuilder.h"
#include "ArcGeoSim/Numerics/LinearSolver/LocalDirectSolverImpl/ILinearSystemVisitor.h"
#include "ArcGeoSim/Numerics/Utils/Algorithms/LUSolver.h"

class LocalLinearSystem : public ILinearSystem
{
public :
  typedef boost::numeric::ublas::vector<Real> RealVector;
  typedef boost::numeric::ublas::matrix<Real> RealMatrix;
  typedef RealVector vector_type ;
  typedef RealMatrix matrix_type ;

  LocalLinearSystem()
  : m_matrix(NULL)
  , m_x(NULL)
  , m_rhs(NULL){}

  LocalLinearSystem(RealMatrix* matrix,
                    RealVector* x,
                    RealVector* rhs)
  : m_matrix(matrix)
  , m_x(x)
  , m_rhs(rhs){}

  //! initialise le system linéaire
  void init() {} ;

  //! permet d'ajouter des opérateurs au l'interface
  bool accept(ILinearSystemVisitor* visitor)
  {
    return visitor->visit(this) ;
  }

  //! démare une étape de résolution de système linéaire
  void start() {}

  //! finalise une étape de résolution et libère les objets intermédiaires
  void end() {}

  //! retourne le nom du type de système
  virtual const char * name() const { return "LocalLinearSystem" ; }

  RealMatrix* getMatrix() { return m_matrix ; }
  RealVector* getX() { return m_x ; }
  RealVector* getRhs() { return m_rhs ; }

  void setMatrix(RealMatrix* matrix) { m_matrix = matrix ; }
  void setX(RealVector* x) { m_x = x ; }
  void setRhs(RealVector* rhs) { m_rhs = rhs ; }
private :
  RealMatrix* m_matrix ;
  RealVector* m_x ;
  RealVector* m_rhs ;
};

class LocalLinearSystemBuilder : public ILinearSystemBuilder
{
public :
  LocalLinearSystemBuilder(ILinearSystem* system)
  : ILinearSystemBuilder()
  {
    m_system = dynamic_cast<LocalLinearSystem*>(system) ;
    if(!system)
      throw Arcane::FatalErrorException(A_FUNCINFO,
                                        "Only LocalLinearSystem can be used");
  }

  LocalLinearSystemBuilder(LocalLinearSystem* system)
  : m_system(system) {}

  virtual ~LocalLinearSystemBuilder() {}

  void init() {}
  void start() {}
  void freeData() {}
  void end() {}

  bool connect(LocalLinearSystem* system)
  {
    (*system) = (*m_system) ;
    return true;
  }

  bool commitSolution(LocalLinearSystem* system)
  { return true; }

  bool visit(LocalLinearSystem* system)
  { return connect(system) ; }

private :
  LocalLinearSystem* m_system ;

};

class LocalDirectSolver : public Alien::ILinearSolver
{
  public:
  //! Constructeur de la classe
  LocalDirectSolver()
    : Alien::ILinearSolver()
  , m_system(NULL)
  , m_system_is_built(false)
  , m_system_is_locked(false)
  , m_builder(NULL)
  {}

  //! Destructeur de la classe
  virtual ~LocalDirectSolver() {}

public:
  String getName() const {
    return "UblasLUSolver" ;
  }

  //! Initialisation
  void init() {}

  //! Associe un build à ce solveur
  void setLinearSystemBuilder(ILinearSystemBuilder * builder)
  { m_builder = builder ; }

  //! Retourne le système linéaire associé à ce solveur
  ILinearSystem* getLinearSystem() { return m_system ; }

  //! Construit le system lineaire
  bool buildLinearSystem(Integer nextBuildStage=BuildType::eBuildMatrix|BuildType::eBuildRhs)
  {
    bool flag = (m_builder?m_system->accept(m_builder):true) ;
    m_system_is_built = true ;
    m_system_is_locked = false ;
    return flag ;
  }

  bool buildLinearSystem(ILinearSystem*  system,Integer nextBuildStage=BuildType::eBuildMatrix|BuildType::eBuildRhs)
  {
    bool flag = system->accept(m_builder) ;
    m_system_is_built = true ;
    m_system_is_locked = false ;
    return flag ;
  }


  //! @name Etapes d'une résolution
  //@{

  //! Début de boucle locale (avant solve)
  void start() {
    delete m_system ;
    m_system = new LocalLinearSystem() ;
  }
  //! Fin de boucle locale (après solve)
  void end() {
    delete m_system ;
    m_system = NULL ;
    m_system_is_built = false ;
    m_system_is_locked = false ;
  }

  //! Résolution du system lineaire associé
  bool solve() ;

  //! Etat final après résolution
  const Alien::ILinearSolver::Status & getStatus() const { return m_status ; }

  //! Applique la procédure d'extraction de la solution
  bool getSolution() {
    if(m_builder)
      return m_builder->commitSolution(m_system) ;
    else
      return false ;
  }

  void setNullSpaceConstantOption(bool flag) {
    cout<<"Null Space Constant Option not yet implemented"<<endl ;
  }
private :
  LocalLinearSystem* m_system ;

  //! flag pour verifier si le système a été construit
  bool m_system_is_built ;

  //! flag pour empecher de resoudre le meme système deux fois
  bool m_system_is_locked ;
  ILinearSystemBuilder* m_builder ;
  Alien::ILinearSolver::Status m_status ;
};
#endif /*LOCALDIRECTSOLVER_H_*/
