// -*- C++ -*-
#ifndef ARCGEOSIM_NUMERICS_DISCRETEOPERATOR_DIVKGRADGRADMIMPL_DIVKGRADGRADMSCHEME_H
#define ARCGEOSIM_NUMERICS_DISCRETEOPERATOR_DIVKGRADGRADMIMPL_DIVKGRADGRADMSCHEME_H
/* Author : dipietrd at Mon Sep 28 08:21:42 2009
 * Generated by createNew
 */

#include <boost/shared_ptr.hpp>

#include <arcane/ArcaneVersion.h>
#include <arcane/IMesh.h>
#include <arcane/ItemPairGroup.h>
#include <arcane/utils/ITraceMng.h>

#include "GradMArray.h"
#include "GradM-LStencils.h"

#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"
#include "ArcGeoSim/Numerics/Utils/Algorithms/lu.h"
#include "ArcGeoSim/Numerics/DiscreteOperator/CoefficientArrayBuilder.h"
#include "ArcGeoSim/Numerics/DiscreteOperator/Comparator.h"
#include "ArcGeoSim/Numerics/DiscreteOperator/DiscreteOperatorProperty.h"
#include "ArcGeoSim/Numerics/DiscreteOperator/StencilBuilder.h"
#include "ArcGeoSim/Numerics/DiscreteOperator/TensorAlgebra.h"
#include "ArcGeoSim/Utils/ItemGroupBuilder.h"

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
class DivKGradGradMScheme
  : public IDivKGradDiscreteOperator
{
  typedef boost::numeric::ublas::vector<Real> RealVector;
  typedef boost::numeric::ublas::zero_vector<Real> ZeroVector;
  typedef boost::numeric::ublas::matrix<Real> RealMatrix;
  typedef boost::numeric::ublas::zero_matrix<Real> ZeroMatrix;
  typedef boost::numeric::ublas::range Range;
  typedef boost::numeric::ublas::matrix_range<RealMatrix> RealMatrixRange;
  typedef boost::numeric::ublas::permutation_matrix<std::size_t> PermutationMatrix;

private:
  typedef typename TCellCoefficientArrayBuilder::Initializer CellCoefficientArrayInitializer;
  typedef typename TFaceCoefficientArrayBuilder::Initializer FaceCoefficientArrayInitializer;

  typedef typename TCellCoefficientArrayBuilder::Inserter CellCoefficientArrayInserter;
  typedef typename TFaceCoefficientArrayBuilder::Inserter FaceCoefficientArrayInserter;

public:
  typedef enum ErrorCode {
    E_NotInitialized          = 0,
    E_CellGradientComputation = 2,
    E_UnknownProperty         = 5,
    E_FailedLInterpolation    = 6
  };

  typedef enum Property {
    P_Epsilon
  };

  struct Error {
    std::string msg;
    ErrorCode code;
    Error(const std::string& _msg, ErrorCode _code)
      : msg(_msg),
        code(_code)
    {
      // do nothing
    }
  };

public:
  //! Constructor
  DivKGradGradMScheme(ITraceMng * a_trace_mng) :
    m_geometry_service(NULL),
    m_status(DiscreteOperatorProperty::S_NONE),
    m_mesh(NULL),
    m_trace_mng(a_trace_mng),
    m_epsilon(0.),
    m_f_centers(NULL),
    m_f_normals(NULL),
    m_f_measures(NULL),
    m_c_centers(NULL),
    m_c_measures(NULL)
  {
    // do nothing
  }

  //! Destructor
  virtual ~DivKGradGradMScheme()
  {
    // do nothing
  }

public:
  //! Preliminary computations (including connectivity)
  void prepare(IMesh * mesh,
               CoefficientArrayT<Cell>* cell_coefficients,
               CoefficientArrayT<Face>* face_coefficients);
  
  //! Preliminary computations (including connectivity)
  ARCANE_DEPRECATED void prepare(const FaceGroup& internal_faces,
                                 const FaceGroup& boundary_faces,
                                 FaceGroup& c_internal_faces,
                                 FaceGroup& cf_internal_faces,
                                 CoefficientArrayT<Cell>* cell_coefficients,
                                 CoefficientArrayT<Face>* face_coefficients);
  //! Reset the operator
  void finalize();

  //! Required cell geometric properties
  inline Integer getCellGeometricProperties() {
    return (IGeometryProperty::PCenter | IGeometryProperty::PMeasure);
  }
  //! Required face geometric properties
  inline Integer getFaceGeometricProperties() {
    return (IGeometryProperty::PCenter | IGeometryProperty::PNormal | IGeometryProperty::PMeasure);
  }
  //! Return the current status
  const Integer & status() const
  {
    return m_status;
  }

public:
  //! Return faces
  const FaceGroup& faces() const { return m_faces; }
  //! Return cells
  const CellGroup& cells() const { return m_cells; }
  //! Return boundary faces
  const FaceGroup& boundaryFaces() const { return m_boundary_faces; }
  //! Return internal faces
  const FaceGroup& internalFaces() const { return m_internal_faces; }

  //! Set property
  void set(Property a_property, const Real & a_value)
  {
    switch(a_property) {
    case P_Epsilon:
      m_epsilon=a_value;
      break;
    default:
      throw(Error("Unknown property",
                  E_UnknownProperty));
    }
  }

  //! Form discrete operator
  template<typename VariableTypeT>
  void formDiscreteOperatorT(const VariableTypeT & kappa);

public:

  //! Two-point boundary treatment
  inline bool twoPointBoundary()
  {
    return false;
  }

  //! Form the discrete operator
  virtual void formDiscreteOperator(const VariableCellReal& k) = 0;
  //! Form the discrete operator
  virtual void formDiscreteOperator(const VariableCellReal3& k) = 0;
  //! Form the discrete operator
  virtual void formDiscreteOperator(const VariableCellReal3x3& k) = 0;

protected:
  // Geometry service
  IGeometryMng* m_geometry_service;
  // Status flag
  Integer m_status;

private:
  IMesh * m_mesh;
  ITraceMng * m_trace_mng;

  // Numerical zero trigger
  Real m_epsilon;

  // Face centers
  mutable const IGeometryMng::Real3Variable * m_f_centers;
  // Face normals
  mutable const IGeometryMng::Real3Variable * m_f_normals;
  // Face measures
  mutable const IGeometryMng::RealVariable * m_f_measures;
  // Cell centers
  mutable const IGeometryMng::Real3Variable * m_c_centers;
  // Cell measures
  mutable const IGeometryMng::RealVariable * m_c_measures;

  // Faces group
  FaceGroup m_faces;
  // Cells group
  CellGroup m_cells;
  // Boundary faces
  FaceGroup m_boundary_faces;
  // Internal faces
  FaceGroup m_internal_faces;
  // Internal faces whose stencil contains cell unknowns only
  FaceGroup m_c_internal_faces;
  // Internal faces whose stencil contains both cells and face unknowns
  FaceGroup m_cf_internal_faces;

  // Boundary nodes group
  NodeGroup m_boundary_nodes;
  // Internal nodes group
  NodeGroup m_internal_nodes;

  // Cell coefficients
  CoefficientArrayT<Cell>* m_cell_coefficients;
  // Face coefficients
  CoefficientArrayT<Face>* m_face_coefficients;

  boost::shared_ptr<CellCoefficientArrayInitializer> m_cell_ca_initializer;
  boost::shared_ptr<FaceCoefficientArrayInitializer> m_face_ca_initializer;

  boost::shared_ptr<CellCoefficientArrayInserter> m_cell_ca_inserter;
  boost::shared_ptr<FaceCoefficientArrayInserter> m_face_ca_inserter;

  // Compute stencils
  template<typename CellStencilBuilder, typename FaceStencilBuilder>
  void _compute_stencils(CellStencilBuilder & a_cell_stencil_builder,
                         FaceStencilBuilder & a_face_stencil_builder);

  typedef SharedArray<Integer> NodeNum;
  void _compute_local_connectivity(const Cell & cell, NodeNum & NumLocNode);

  void _compute_gradient(const Cell & cell, Array<Real3> & Grad, GradMArray & Beta);

#if (ARCANE_VERSION >= 12201)
  void _compute_residual(const Cell & cell, Array<Real3> & Grad, Array2<Real>& Resid, GradMArray & Beta);
#else /* ARCANE_VERSION */
  void _compute_residual(const Cell & cell, Array<Real3> & Grad, CArray2T<Real> & Resid, GradMArray & Beta);
#endif /* ARCANE_VERSION */

  template<typename VariableTypeT>
  void _compute_beta(const VariableTypeT & kappa, GradMArray & Beta);

  template<typename VariableTypeT>
  void _compute_l_interpolation(const Cell & cell, 
                                const VariableTypeT & kappa, 
                                L_Stencil & centered_stencil);

  template<typename VariableTypeT>
  void _compute_F_Ksigma_prime(const Cell & cell, 
                               Integer iface, 
                               Array<Real3> & Grad, 
                               Array<Real> & F_Ksigma_pr,
                               const VariableTypeT & kappa);

  template<typename VariableTypeT>
  void _compute_F_Ksigma(const VariableTypeT & kappa,
                         GradMArray & Beta, 
                         GradMArray & F_Ksigma);

  template<typename VariableTypeT, 
           typename CellCoefficientArrayBuilder, 
           typename FaceCoefficientArrayBuilder>
  void _compute_discrete_operator(const VariableTypeT & kappa,
                                  CellCoefficientArrayBuilder & cell_ca_builder,
                                  FaceCoefficientArrayBuilder & face_ca_builder);
};

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
template<typename VariableTypeT>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
                         TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
formDiscreteOperatorT(const VariableTypeT & kappa)
{
  typedef typename VariableTraitsT<VariableTypeT>::DataType DiffusionType;

  if(!(this->m_status & DiscreteOperatorProperty::S_FORMED)) {
    // Initializers
    // in shared_ptr, previous instance is destroyed when reset is called
    m_cell_ca_initializer.reset(new CellCoefficientArrayInitializer(this->m_cell_coefficients));
    m_face_ca_initializer.reset(new FaceCoefficientArrayInitializer(this->m_face_coefficients));
    // Discrete operator and initializer computation
    _compute_discrete_operator<VariableTypeT,
      CellCoefficientArrayInitializer,
      FaceCoefficientArrayInitializer>(kappa, *m_cell_ca_initializer.get(), *m_face_ca_initializer.get());
    m_cell_ca_initializer->finalizeInsert();
    m_face_ca_initializer->finalizeInsert();
    // Inserters
    m_cell_ca_inserter.reset(new CellCoefficientArrayInserter(m_cell_ca_initializer.get()));
    m_face_ca_inserter.reset(new FaceCoefficientArrayInserter(m_face_ca_initializer.get()));
    // Update status
    this->m_status |= DiscreteOperatorProperty::S_FORMED;
  } else {
    m_cell_ca_initializer->resetPosition();
    m_face_ca_initializer->resetPosition();
    _compute_discrete_operator<VariableTypeT,
      CellCoefficientArrayInserter,
      FaceCoefficientArrayInserter>(kappa, *m_cell_ca_inserter.get(), *m_face_ca_inserter.get());
  }
}

/*----------------------------------------------------------------------------*/

template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
                         TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
finalize()
{
  ARCANE_ASSERT( (m_status & DiscreteOperatorProperty::S_PREPARED),
                 ("Operator not prepared when calling finalize") );
  m_status = DiscreteOperatorProperty::S_INITIALIZED;
}

/*----------------------------------------------------------------------------*/

template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
                         TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
prepare(IMesh * mesh,
        CoefficientArrayT<Cell>* cell_coefficients,
        CoefficientArrayT<Face>* face_coefficients)
{
  ARCANE_ASSERT( (m_status & DiscreteOperatorProperty::S_INITIALIZED),
                 ("Operator not initialized when calling prepare") );

  m_mesh           = mesh;
  m_cells          = mesh->allCells();
  m_faces          = mesh->allFaces();
  m_internal_faces = m_cells.innerFaceGroup();
  m_boundary_faces = m_cells.outerFaceGroup();

  m_cell_coefficients = cell_coefficients;
  m_face_coefficients = face_coefficients;

  // Form node groups
  ItemGroupBuilder<Node> boundary_nodes_builder(m_boundary_faces.mesh(), IMPLICIT_UNIQ_NAME);
  ItemGroupBuilder<Node> internal_nodes_builder(m_internal_faces.mesh(), IMPLICIT_UNIQ_NAME);

  // Boundary nodes
  ENUMERATE_FACE(iF, m_boundary_faces) {
    const Face& F = *iF;
    boundary_nodes_builder.add(F.nodes());
  }
  m_boundary_nodes = boundary_nodes_builder.buildGroup();


  // Internal nodes
  ENUMERATE_FACE(iF, m_internal_faces) {
    const Face& F = *iF;

    ENUMERATE_NODE(iP, F.nodes()) {
      const Node & P = *iP;
      bool is_boundary = true;

      ENUMERATE_FACE(jF, iP->faces()) {
        if (jF->isSubDomainBoundary()) {
          is_boundary = true;
          break;
        }
      }

      if(!is_boundary)
        internal_nodes_builder.add(P);
      else
        break;
    }
  }
  m_internal_nodes = internal_nodes_builder.buildGroup();

  // Compute stencil sizes and init containers
  {
    StencilSizesBuilderT<Cell> cell_stencil_sizes_builder(m_cell_coefficients);
    StencilSizesBuilderT<Face> face_stencil_sizes_builder(m_face_coefficients);
    _compute_stencils(cell_stencil_sizes_builder,
                      face_stencil_sizes_builder);
    cell_stencil_sizes_builder.finalize();
    face_stencil_sizes_builder.finalize();
  }

  // Compute stencils
  {
    TCellStencilBuilder cell_stencil_builder(m_cell_coefficients);
    TFaceStencilBuilder face_stencil_builder(m_face_coefficients);
    _compute_stencils(cell_stencil_builder,
                      face_stencil_builder);
    cell_stencil_builder.finalize();
    face_stencil_builder.finalize();
  }

  m_status |= DiscreteOperatorProperty::S_PREPARED;
}
  

/*----------------------------------------------------------------------------*/

template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
                         TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
prepare(const FaceGroup& internal_faces,
        const FaceGroup& boundary_faces,
        FaceGroup& c_internal_faces,
        FaceGroup& cf_internal_faces,
        CoefficientArrayT<Cell>* cell_coefficients,
        CoefficientArrayT<Face>* face_coefficients)
{
  ARCANE_ASSERT( (m_status & DiscreteOperatorProperty::S_INITIALIZED),
                 ("Operator not initialized when calling prepare") );

  m_internal_faces = internal_faces;
  m_boundary_faces = boundary_faces;

  m_cell_coefficients = cell_coefficients;
  m_face_coefficients = face_coefficients;

  // Form face and cell groups
  ItemGroupBuilder<Face> faces_builder(m_internal_faces.mesh(), IMPLICIT_UNIQ_NAME);
  ItemGroupBuilder<Cell> cells_builder(m_internal_faces.mesh(), IMPLICIT_UNIQ_NAME);

  ENUMERATE_FACE(iF, m_internal_faces) {
    const Face& F = *iF;
    cells_builder.add(F.cells());
    faces_builder.add(F);
  }

  ENUMERATE_FACE(iF, m_boundary_faces) {
    const Face& F = *iF;
    cells_builder.add(F.cells());
    faces_builder.add(F);
  }

  m_cells = cells_builder.buildGroup();
  m_faces = faces_builder.buildGroup();

  // Form node groups
  ItemGroupBuilder<Node> boundary_nodes_builder(m_boundary_faces.mesh(), IMPLICIT_UNIQ_NAME);
  ItemGroupBuilder<Node> internal_nodes_builder(m_internal_faces.mesh(), IMPLICIT_UNIQ_NAME);

  // Boundary nodes
  ENUMERATE_FACE(iF, m_boundary_faces) {
    const Face& F = *iF;
    boundary_nodes_builder.add(F.nodes());
  }
  m_boundary_nodes = boundary_nodes_builder.buildGroup();


  // Internal nodes
  ENUMERATE_FACE(iF, m_internal_faces) {
    const Face& F = *iF;

    ENUMERATE_NODE(iP, F.nodes()) {
      const Node & P = *iP;
      bool is_boundary = true;

      ENUMERATE_FACE(jF, iP->faces()) {
        if (jF->isSubDomainBoundary()) {
          is_boundary = true;
          break;
        }
      }

      if(!is_boundary)
        internal_nodes_builder.add(P);
      else
        break;
    }
  }
  m_internal_nodes = internal_nodes_builder.buildGroup();

  // Compute stencil sizes and init containers
  {
    StencilSizesBuilderT<Cell> cell_stencil_sizes_builder(m_cell_coefficients);
    StencilSizesBuilderT<Face> face_stencil_sizes_builder(m_face_coefficients);
    _compute_stencils(cell_stencil_sizes_builder,
                      face_stencil_sizes_builder);
    cell_stencil_sizes_builder.finalize();
    face_stencil_sizes_builder.finalize();
  }

  // Compute stencils
  {
    TCellStencilBuilder cell_stencil_builder(m_cell_coefficients);
    TFaceStencilBuilder face_stencil_builder(m_face_coefficients);
    _compute_stencils(cell_stencil_builder,
                      face_stencil_builder);
    cell_stencil_builder.finalize();
    face_stencil_builder.finalize();
  }

  // Build face groups
  ItemGroupBuilder<Face> c_internal_faces_builder(m_internal_faces.mesh(), c_internal_faces.name());
  ItemGroupBuilder<Face> cf_internal_faces_builder(m_internal_faces.mesh(), cf_internal_faces.name());

  ENUMERATE_FACE(iF, m_internal_faces) {
    const Face& F = *iF;
    if(m_face_coefficients->stencilSize(F))
      cf_internal_faces_builder.add(F);
    else
      c_internal_faces_builder.add(F);
  }

  m_c_internal_faces = c_internal_faces_builder.buildGroup();
  m_cf_internal_faces = cf_internal_faces_builder.buildGroup();

  m_status |= DiscreteOperatorProperty::S_PREPARED;
}

/*----------------------------------------------------------------------------*/

template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
template<typename CellStencilBuilder, typename FaceStencilBuilder>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
                         TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
_compute_stencils(CellStencilBuilder & a_cell_stencil_builder,
                  FaceStencilBuilder & a_face_stencil_builder)
{
  // Create the indicators of internal and boundary faces, boundary nodes.
  Integer MaxFaceId = m_internal_faces.mesh()->faceFamily()->maxLocalId();
  Integer MaxCellId = m_internal_faces.mesh()->cellFamily()->maxLocalId();
  SharedArray<Byte> FaceBoun(MaxFaceId);

  CellCellGroup cell_to_cell(m_cells, m_cells, IK_Face);
  SharedArray<Integer> FaceInd1(MaxFaceId);
  FaceInd1.fill(MaxCellId);
  SharedArray<Integer> FaceInd2(MaxFaceId);
  FaceInd2.fill(MaxFaceId);

  // Compose the stencils
  ENUMERATE_ITEMPAIR(Cell, Cell, iT, cell_to_cell){
    const Cell & T = *iT;

    // Traverse neighbours by face
    ENUMERATE_SUB_ITEM(Cell, iS, iT) { // Sub-cells
      const Cell& S = *iS;

      for(Integer iF = 0 ; iF < S.nbFace() ; iF++) {
        const Face & F = S.face(iF);
        Integer Id = F.localId();
        if(FaceInd1[Id] != T.localId()){
          FaceInd1[Id] = T.localId();
          a_cell_stencil_builder.insert(F, T);
        }
      }
    }

    ENUMERATE_FACE(iF, T.faces()) {
      const Face & F = *iF;
      if(F.isSubDomainBoundary()) { // Boundary faces
        a_cell_stencil_builder.insert(F, T);

        ENUMERATE_FACE(iF1, T.faces()) { // Faces
          if(iF1->isSubDomainBoundary())
            a_face_stencil_builder.insert(*iF1, F);
        }

        ENUMERATE_SUB_ITEM(Cell, iS, iT) { // Sub-cells
          const Cell & S = *iS;
          ENUMERATE_FACE(iF1, S.faces()) {
            const Face & F1 = *iF1;
            Integer Id = F1.localId();
            if (FaceInd2[Id] != F.localId() ){
              FaceInd2[Id] = F.localId();
              a_face_stencil_builder.insert(F1, F);
            }
          }
        }
      }
    }
  }
}

/*----------------------------------------------------------------------------*/

template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
                         TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
_compute_local_connectivity(const Cell & cell, NodeNum & NumLocNode)
{
  for(Integer inode = 0 ; inode < cell.nbNode() ; ++inode){
    const Node & node = cell.node(inode);
    NumLocNode[node.localId()] = inode;
  }
}

/*----------------------------------------------------------------------------*/

template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
                         TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
_compute_gradient(const Cell & cell, Array<Real3> & Grad, GradMArray & Beta)
{
#ifndef WIN32
#warning "TODO : space dimension must become a parameter"
#endif
  Integer N = 3;
  RealMatrix B = ZeroMatrix(N, N);
  RealVector nKa(N), x(N);

  // Compute matrix B
  Real3 xK = (*m_c_centers)[cell];
  ENUMERATE_FACE(iF, cell.faces()) {
    Real3 xa = (*m_f_centers)[*iF];
    Real3 normal = (*m_f_normals)[*iF];
    Real3 xKa = xa - xK;

    if(math::scaMul(normal, xKa) < 0)
      normal = -normal ;

    nKa(0) = normal.x; nKa(1) = normal.y; nKa(2) = normal.z;
    x(0) = xKa.x; x(1) = xKa.y; x(2) = xKa.z;

    B += outer_prod(nKa, x);
  }

  // Compute gradient
  for(Integer i = 0; i != Grad.size() ; i++)
    Grad[i] = 0.;

  for(Integer iface = 0; iface < cell.nbFace() ; iface++){
    ArrayView<Real> BetaCoeff = Beta.coefficients(cell, iface);
    ArrayView<Integer> BetaStencil = Beta.stencil(cell, iface);
    Integer StSize = Beta.stencilSize(cell, iface);
    const Face & face = cell.face(iface);
    Real3 xa = (*m_f_centers)[face];
    Real3 normal = (*m_f_normals)[face];
    Real3 xKa = xa - xK;
    if( math::scaMul(normal, xKa) < 0)
      normal = -normal ;
    Grad[0] += normal*(BetaCoeff[0]-1);//central cell
    for(Integer i=0; i < StSize-1; i++){
      Integer num_face = BetaStencil[i];
      Grad[num_face+1] += normal * BetaCoeff[i+1];
    }
  }

  // Inverse local matrix
  PermutationMatrix P(N);
  Integer success = Numerics::lu_factorize(B, P, m_epsilon);
  if(success!=0) {
    throw(Error("Singular matrix", E_CellGradientComputation));
  }

  for(Integer i = 0; i != Grad.size() ; i++) {
    x(0) = Grad[i].x; x(1) = Grad[i].y; x(2) = Grad[i].z;
    lu_substitute(B, P, x);
    Grad[i].x = x(0); Grad[i].y = x(1); Grad[i].z = x(2);
  }
}

/*----------------------------------------------------------------------------*/

#if (ARCANE_VERSION >= 12201)
template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
_compute_residual(const Cell & cell, Array<Real3> & Grad, Array2<Real>& Resid, GradMArray & Beta)
{
	Integer nbfaces = cell.nbFace();
	Real3 xK = (*m_c_centers)[cell];
	for(Integer iface=0; iface<nbfaces ; iface++) {
		const Face & face = cell.face(iface);
		ArrayView<Real> BetaCoeff = Beta.coefficients(cell, iface);
		ArrayView<Integer> BetaStencil = Beta.stencil(cell, iface);
		Integer StSize = Beta.stencilSize(cell, iface);
		Real3 xa = (*m_f_centers)[face];
		Real3 xKa = xa - xK;
		Resid[iface][0] = BetaCoeff[0]-1;
		Resid[iface][0] -= math::scaMul(Grad[0],xKa);

		for(Integer i = 1; i <= nbfaces ; i++)
			Resid[iface][i] = -math::scaMul(Grad[i],xKa);

		for(Integer i=0; i < StSize-1; i++){
			Integer num_face = BetaStencil[i];
			Resid[iface][num_face+1] += BetaCoeff[i+1];
		}
	}
}
#else /* ARCANE_VERSION */
template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
                         TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
_compute_residual(const Cell & cell, Array<Real3> & Grad, CArray2T<Real> & Resid, GradMArray & Beta)
{
  Integer nbfaces = cell.nbFace();
  Real3 xK = (*m_c_centers)[cell];
  for(Integer iface=0; iface<nbfaces ; iface++) {
    const Face & face = cell.face(iface);
    ArrayView<Real> BetaCoeff = Beta.coefficients(cell, iface);
    ArrayView<Integer> BetaStencil = Beta.stencil(cell, iface);
    Integer StSize = Beta.stencilSize(cell, iface);
    Real3 xa = (*m_f_centers)[face];
    Real3 xKa = xa - xK;
    Resid[iface][0] = BetaCoeff[0]-1;
    Resid[iface][0] -= math::scaMul(Grad[0],xKa);

    for(Integer i = 1; i <= nbfaces ; i++)
      Resid[iface][i] = -math::scaMul(Grad[i],xKa);

    for(Integer i=0; i < StSize-1; i++){
      Integer num_face = BetaStencil[i];
      Resid[iface][num_face+1] += BetaCoeff[i+1];
    }
  }
}
#endif /* ARCANE_VERSION */

/*----------------------------------------------------------------------------*/

template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
template<typename VariableTypeT>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
                         TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
_compute_beta(const VariableTypeT & kappa, GradMArray&  Beta)
{
  typedef typename VariableTraitsT<VariableTypeT>::DataType DiffusionType;
#ifndef WIN32
#warning "TODO : space dimension must become a parameter"
#endif
  // Create the indicators of internal and boundary faces, boundary nodes.
  // Integer n_cells = m_cells.size();
  Integer pC = 0; // position variable forthe arrays, corresponding to cells
  Integer pF = 0; //position variable corresponding to faces

  // Compute the coefficients Beta forL-interpolation
  Integer MaxNodeId = m_internal_faces.mesh()->nodeFamily()->maxLocalId();
  NodeNum NumLocNode(MaxNodeId);

  ENUMERATE_CELL(icell, m_cells) {
    const Cell & cell = *icell;
    // build the connectivity tables
    _compute_local_connectivity(cell , NumLocNode);
    //Calculate the number of stencils
    Integer NumStencils = cell.nbNode();
    if (cell.nbNode() == 5) //Pyramid cell
      NumStencils += 3;

    // Build the vectors of local face numbers which will define the stencils
    SharedArray<std::vector<Byte> > StencilFaces(NumStencils);
    for(Integer iface = 0 ; iface < cell.nbFace() ; iface++) {
      const Face & F = cell.face(iface);
      for(Integer inode=0 ; inode<F.nbNode(); inode++) {
        const Node & node = F.node(inode);
        StencilFaces[NumLocNode[node.localId()] ].push_back(iface);
      }
    }

    if (cell.nbNode() == 5) { //Pyramid cell
      for(Integer i = 0 ; i < cell.nbNode() ; i ++) { //Search forthe vertex of the pyramid
        if (StencilFaces[i].size()==4) {
          for(Integer j = 0 ; j < 3 ; j++){
            for(Integer k = 0 ; k < 3 ; k++){
              StencilFaces[cell.nbNode() + j].push_back(StencilFaces[i][(j + k + 1) % 4]);
            }
          }
          StencilFaces[i].pop_back();
          break;
        }
      }
    }

    // build the L stencils
    L_Stencil **centered_stencils;
    centered_stencils = new L_Stencil*[NumStencils];
    //Initialize the centered stencils and calculate coefficients
    SharedArray<Byte> stencil_non_degenerate(NumStencils);
    for(Integer ist = 0 ; ist < NumStencils; ist++){
      centered_stencils[ist] = new L_Stencil(cell, StencilFaces[ist]);
      stencil_non_degenerate[ist] = true;
      try {
        _compute_l_interpolation<VariableTypeT>(cell, kappa, *centered_stencils[ist]);
      }
      catch(Error e) {
//         m_trace_mng->fatal() << "Fatal error in L-interpolation";
        stencil_non_degenerate[ist] = false;
      }
    }
    //Choose the best stencil foreach face
    SharedArray<Integer> FaceToRow(cell.nbFace());
    SharedArray<Integer> Stencil_Number(cell.nbFace());
    SharedArray<Real> FaceIndicator(cell.nbFace()); // the main parameter in choosing the proper stencil
    Stencil_Number.fill(cell.nbNode());

    for(Integer ist=0 ; ist<NumStencils ; ++ist) { //loop over the stencils
      if(stencil_non_degenerate[ist]) {
        for(Integer iface=0; iface<3 ; iface++){
          Real sum = 0.;
          for(Integer icell=0; icell<4 ; icell++)
            sum += (centered_stencils[ist]->LocBeta[iface][icell]) *
              (centered_stencils[ist]->LocBeta[iface][icell]);
          Integer locnbface = centered_stencils[ist]->getFace(iface);
          if ((Stencil_Number[locnbface] == cell.nbNode()) || (sum < FaceIndicator[locnbface])) {
            Stencil_Number[locnbface] = ist;
            FaceIndicator[locnbface] = sum;
            FaceToRow[locnbface] = iface;
          }
        }
      }
    }

    // Fill in the global structure of coefficients Beta
    Beta.posC[cell.localId()] = pC;
    for(Integer iface = 0 ; iface < cell.nbFace() ; iface++){
      Beta.posF[pC+iface] = pF;
      Integer st_num = Stencil_Number[iface];
      Integer num_coef = 4;
      Beta.index[pF] = num_coef;
      for(Integer i = 0; i < num_coef ; i++)
        Beta.coeff[pF+i] = centered_stencils[st_num]->LocBeta[FaceToRow[iface] ][i];
      for(Integer i = 1; i < num_coef ; i++)
        Beta.index[pF+i] = centered_stencils[st_num]->getFace(i-1);
      pF += num_coef;
    }
    pC += cell.nbFace();
    for(Integer ist = 0 ; ist < NumStencils; ist++)
      delete centered_stencils[ist];
    delete[] centered_stencils;
  }
}

/*----------------------------------------------------------------------------*/

template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
template<typename VariableTypeT>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
                         TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
_compute_l_interpolation(const Cell & cell,
                         const VariableTypeT & kappa,
                         L_Stencil & centered_stencil)
{
  typedef typename VariableTraitsT<VariableTypeT>::DataType DiffusionType;
#ifndef WIN32
#warning "TODO : space dimension must become a parameter"
#endif

  Integer N = 3;
  RealMatrix A = ZeroMatrix(N, N);
  RealMatrix B = ZeroMatrix(N, N+1);

  const DiffusionType & LambdaK = kappa[cell];
  Real3 xK = (*m_c_centers)[cell];
  // Generate the system forthe gradient recovery on the central cell
  for(Integer i = 0 ; i < N ; i++) {
    const Face & face = cell.face(centered_stencil.getFace(i));
    if (!face.isSubDomainBoundary()) { //internal face
      Cell L = face.backCell()!=cell ? face.backCell() : face.frontCell();
      const DiffusionType & LambdaL = kappa[L];
      Real3 xL = (*m_c_centers)[L];
      Real3 xKL = xL - xK;
      Real3 normalK, normalL;
      //get the unit normals
      if (face.backCell() == cell){
        normalK = (*m_f_normals)[face]/(*m_f_measures)[face];
        normalL = -normalK;
      }
      else{
        normalL = (*m_f_normals)[face]/(*m_f_measures)[face];
        normalK = -normalL;
      }
      Real3 Lam_Kn_K = DiscreteOperator::tensor_vector_prod<DiffusionType>::eval(LambdaK,normalK);
      Real3 Lam_Ln_L = DiscreteOperator::tensor_vector_prod<DiffusionType>::eval(LambdaL,normalL);
      Real d_L_sigma = math::abs(math::scaMul(xKL, normalK));
      Real k = math::scaMul(Lam_Ln_L, normalL)/d_L_sigma;
      Real3 row = k*xKL + Lam_Kn_K + Lam_Ln_L;
      A(i,0) = row.x;
      A(i,1) = row.y;
      A(i,2) = row.z;
      B(i,i+1) = k;
      B(i,0) = -k;
    } else { // boundary face
      Real3 x_sigma = (*m_f_centers)[face];
      Real3 row= x_sigma - xK;
      A(i,0) = row.x;
      A(i,1) = row.y;
      A(i,2) = row.z;
      B(i,i+1) = 1.;
      B(i,0) = -1.;
    }
  }

  // Find the gradient on central cell
  RealMatrix Grad(B);
  PermutationMatrix P(N);
  Integer success = Numerics::lu_factorize(A, P, m_epsilon);
  if(success!=0)
    throw(Error("Failed to compute L-interpolation",
                E_FailedLInterpolation));
  lu_substitute(A, P, Grad);

  //Calculate the coefficients Beta in the representation of the face unknown
  for(Integer i=0; i<N ; i++) {
    const Face & face = cell.face(centered_stencil.getFace(i));
    if (face.isSubDomainBoundary()) {
      for(Integer j=0; j<N+1; j++){
        centered_stencil.LocBeta[i][j] = 0.;
      }
      centered_stencil.LocBeta[i][i+1] = 1.;
    } else {
      Real3 xSigma = (*m_f_centers)[face];
      Real3 xKSigma = xSigma - xK;
      for(Integer j = 0 ; j < 4 ; j++){
        Real3 tmp;
        tmp.x = Grad(0,j); tmp.y = Grad(1,j); tmp.z = Grad(2,j);
        centered_stencil.LocBeta[i][j] = math::scaMul(tmp , xKSigma);
      }
      centered_stencil.LocBeta[i][0] += 1.;
    }
  }
}

/*----------------------------------------------------------------------------*/

template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
template<typename VariableTypeT>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
                         TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
_compute_F_Ksigma_prime(const Cell & cell, 
                        Integer iface, 
                        Array<Real3> & Grad, 
                        Array<Real> & F_Ksigma_pr,
                        const VariableTypeT & kappa)
{
  typedef typename VariableTraitsT<VariableTypeT>::DataType DiffusionType;

  const Face & face = cell.face(iface);
  Real3 xK = (*m_c_centers)[cell];
  Real3 xa = (*m_f_centers)[face];
  Real3 xKa = xa - xK;
  Real3 normal = (*m_f_normals)[face];
  if(math::scaMul(normal,xKa)<0)
    normal = -normal ;
  Real norm = 1./normal.abs();
  const DiffusionType & Lambda = kappa[cell];
  Real k;
  if (face.isSubDomainBoundary()){
    k=1.;
  } else{
    Cell L = face.backCell()!=cell ? face.backCell() : face.frontCell();
    Real3 xL = (*m_c_centers)[L];
    Real3 xLa = xa - xL;
    Real dK = math::abs(math::scaMul(xKa,normal))*norm;
    Real dL = math::abs(math::scaMul(xLa, normal))*norm;
    k = dK/(dL+dK);
  }
  for(Integer i=0; i<=cell.nbFace(); i++){
    Real3 lamgr = DiscreteOperator::tensor_vector_prod<DiffusionType>::eval(Lambda,Grad[i]);
    F_Ksigma_pr[i] = k * math::scaMul(lamgr , normal);
  }
}

/*----------------------------------------------------------------------------*/

template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
template<typename VariableTypeT>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
                         TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
_compute_F_Ksigma(const VariableTypeT & kappa,
                  GradMArray & Beta, 
                  GradMArray & F_Ksigma)
{
  typedef typename VariableTraitsT<VariableTypeT>::DataType DiffusionType;

  // Generate the pointers in F_Ksigma and set the lenghts of subarrays
  Integer pC = 0;
  Integer pF = 0;
  ENUMERATE_CELL(icell, m_cells) {
    const Cell& cell = *icell;
    Integer nbunk = cell.nbFace()+1;
    F_Ksigma.posC[cell.localId()] = pC;
    for(Integer i=0; i<cell.nbFace(); i++) {
      F_Ksigma.posF[pC+i] = pF;
      F_Ksigma.index[pF] = nbunk;
      pF += nbunk;
    }
    pC += cell.nbFace();
  }

  ENUMERATE_CELL(icell, m_cells) {
    const Cell & cell = *icell;
    const DiffusionType & Lambda = kappa[cell];
    Real alpha = DiscreteOperator::MinimumEigenvalue::compute(Lambda);
    Real3 xK = (*m_c_centers)[cell];
    Integer nbfaces = cell.nbFace();
    Integer nb_var = nbfaces + 1;

    SharedArray<Real3>  Grad(nb_var);
    // compute the strong gradient
    try {
      _compute_gradient(cell, Grad, Beta);
    }
    catch(Error e) {
      m_trace_mng->fatal() << "Fatal error in gradient computation";
    }
    // compute the residuals
#if (ARCANE_VERSION >= 12201)
    SharedArray2<Real> Resid(nbfaces, nb_var);
#else /* ARCANE_VERSION */
    CArray2T<Real> Resid(nbfaces, nb_var);
#endif /* ARCANE_VERSION */
    _compute_residual(cell, Grad, Resid, Beta);

    // Calculate distances d_{K,\sigma}
    SharedArray<Real> dK(nbfaces);
    for(Integer iface = 0; iface < cell.nbFace(); iface++) {
      const Face & face = cell.face(iface);
      Real3 xa = (*m_f_centers)[face];
      Real3 xKa = xa - xK;
      Real3 normal = (*m_f_normals)[face];
      dK[iface] = math::abs(math::scaMul(xKa,normal))/normal.abs();
    }
    for(Integer iface = 0; iface < cell.nbFace(); iface++){
      // const Face & face = cell.face(iface);
      ArrayView<Real> F_KsigmaCoeff = F_Ksigma.coefficients(cell, iface);
      ArrayView<Integer> F_KsigmaStencil = F_Ksigma.stencil(cell, iface);

      // Calculate F_Ksigma_prime - first term in the flux expression
      SharedArray<Real> F_Ksigma_pr(nb_var);
      _compute_F_Ksigma_prime<VariableTypeT>(cell, iface, Grad, F_Ksigma_pr, kappa);
      // First term in the flux expression
      for(Integer i = 0; i < nb_var ; i++)
        F_KsigmaCoeff[i] = F_Ksigma_pr[i];
      for(Integer i = 0; i < nb_var-1 ; i++)
        F_KsigmaStencil[i] = i;
      // Calculate the second term in the flux expression
      for(Integer if_prime=0; if_prime<nbfaces; if_prime++){
        ArrayView<Real> BetaCoeff = Beta.coefficients(cell, if_prime);
        ArrayView<Integer> BetaStencil = Beta.stencil(cell, if_prime);
        Integer StSize = Beta.stencilSize(cell, if_prime);
        for(Integer j=0; j<StSize-1 ; j++){
          if (BetaStencil[j] == iface){
            const Face & f_prime = cell.face(if_prime);
            Real coef =alpha*(*m_f_measures)[f_prime]*BetaCoeff[j+1]/dK[if_prime];
            for(Integer i = 0 ; i < nb_var ; i++)
              F_KsigmaCoeff[i] += coef * Resid[if_prime][i];
            break;
          }
        }
      }
      // Calculate the third term in the flux expression
      Real c1 = alpha/(*m_c_measures)[cell];
      SharedArray2<Real> coef(nbfaces, nbfaces);
      for(Integer if1=0; if1<nbfaces; if1++){
        const Face & face1 = cell.face(if1);
        Real c2 = c1*(*m_f_measures)[face1]/dK[if1];
        Real3 xa = (*m_f_centers)[face1];
        Real3 xKa = xa - xK;
        for(Integer if2=0; if2<nbfaces ; if2++){
          const Face & face2 = cell.face(if2);
          ArrayView<Real> BetaCoeff = Beta.coefficients(cell, if2);
          ArrayView<Integer> BetaStencil = Beta.stencil(cell, if2);
          Integer StSize = Beta.stencilSize(cell, if2);
          coef[if1][if2] = 0.;
          for(Integer j=0; j<StSize-1; j++){
            if (BetaStencil[j] == iface){
              Real3 normal = (*m_f_normals)[face2];
              Real3 xb = (*m_f_centers)[face2];
              Real3 xKb = xb - xK;
              if( math::scaMul(normal, xKb) < 0)
                normal = -normal ;
              Real c3 = c2 * math::scaMul(xKa,normal);
              coef[if1][if2] = c3 * BetaCoeff[j+1];
              break;
            }
          }
        }
      }
      for(Integer if1 = 0; if1 < nbfaces ; if1++)
        for(Integer if2 = 0 ; if2 < nbfaces ; if2++)
          for(Integer i = 0 ; i < nb_var ; i++)
            F_KsigmaCoeff[i] -= coef[if1][if2] * Resid[if1][i];
    }
  }
}

/*----------------------------------------------------------------------------*/

template<typename TCellStencilBuilder, typename TFaceStencilBuilder,
         typename TCellCoefficientArrayBuilder, typename TFaceCoefficientArrayBuilder>
template<typename VariableTypeT, typename CellCoefficientArrayBuilder, typename FaceCoefficientArrayBuilder>
void DivKGradGradMScheme<TCellStencilBuilder, TFaceStencilBuilder,
                         TCellCoefficientArrayBuilder, TFaceCoefficientArrayBuilder>::
_compute_discrete_operator(const VariableTypeT & kappa,
                           CellCoefficientArrayBuilder & cell_ca_builder,
                           FaceCoefficientArrayBuilder & face_ca_builder)
{
  typedef typename VariableTraitsT<VariableTypeT>::DataType DiffusionType;

  ARCANE_ASSERT( (m_status & DiscreteOperatorProperty::S_PREPARED),
                 ("Operator not prepared") );

  // Retrieve geometric properties
  m_f_centers  = &m_geometry_service->getReal3VariableProperty(this->m_faces, IGeometryProperty::PCenter);
  m_f_normals  = &m_geometry_service->getReal3VariableProperty(this->m_faces, IGeometryProperty::PNormal);
  m_f_measures = &m_geometry_service->getRealVariableProperty(this->m_faces, IGeometryProperty::PMeasure);
  m_c_centers  = &m_geometry_service->getReal3VariableProperty(this->m_cells, IGeometryProperty::PCenter);
  m_c_measures = &m_geometry_service->getRealVariableProperty(this->m_cells, IGeometryProperty::PMeasure);

  // Create the indicators of internal and boundary faces, boundary nodes.
  Integer MaxCellId = m_internal_faces.mesh()->cellFamily()->maxLocalId();

  // Compute the needed size of arrays Beta and F_Ksigma
  // (size of the double precision array and of the integer array
  // of pointers in this double array corresponding to cells)
  Integer Beta_size1 = 0;
  Integer Beta_size2 = 0;
  Integer F_Ksigma_size1 = 0;
  Integer F_Ksigma_size2 = 0;
  ENUMERATE_CELL(icell, m_cells) {
    const Cell & cell = *icell;
    Beta_size1 += cell.nbFace()*4;
    Beta_size2 += cell.nbFace();
    F_Ksigma_size1 += cell.nbFace() * (cell.nbFace() + 1);
  }
  F_Ksigma_size2 = Beta_size2;

  GradMArray Beta(Beta_size1, Beta_size2, MaxCellId);

  _compute_beta<VariableTypeT>(kappa, Beta);

  // Calculate fluxes
  GradMArray F_Ksigma(F_Ksigma_size1, F_Ksigma_size2, MaxCellId);
  _compute_F_Ksigma<VariableTypeT>(kappa, Beta, F_Ksigma);

  // Internal faces
  ENUMERATE_FACE(iface, m_internal_faces) {
    const Face& F = *iface;
    const Cell& K = F.backCell();
    const Cell& L = F.frontCell();
    Integer if1, if2;
    for (if1 = 0; if1 < K.nbFace(); if1++)
      if (K.face(if1)==F) break;
    for (if2 = 0; if2 < L.nbFace(); if2++)
      if (L.face(if2)==F) break;

    ArrayView<Real> Kcoeff = F_Ksigma.coefficients(K, if1);
    ArrayView<Real> Lcoeff = F_Ksigma.coefficients(L, if2);

    cell_ca_builder.subtract(F, K, Kcoeff[0]);
    cell_ca_builder.sum(F, L, Lcoeff[0]);
    // Assemble elements from F_Ksigma
    for (Integer i = 0; i < K.nbFace(); i++) {
      const Face& face = K.face(i);
      if (face.isSubDomainBoundary())
        face_ca_builder.subtract(F, face, Kcoeff[i+1]);
      else {
        const Cell & neigh_cell =
          face.backCell() == K ? face.frontCell() : face.backCell();
        cell_ca_builder.subtract(F, neigh_cell, Kcoeff[i+1]);
      }
    }

    // Assemble elements from F_Lsigma
    for (Integer i = 0; i < L.nbFace(); i++) {
      const Face & face = L.face(i);
      if(face.isSubDomainBoundary())
        face_ca_builder.sum(F, face, Lcoeff[i+1]);
      else {
        const Cell & neigh_cell =
          face.backCell() == L ? face.frontCell() : face.backCell();
        cell_ca_builder.sum(F, neigh_cell, Lcoeff[i+1]);
      }
    }
  }

  // Boundary faces
  ENUMERATE_FACE(iface, m_boundary_faces) {
    const Face& F = *iface;
    const Cell& K = F.boundaryCell();
    Integer if1;
    for (if1 = 0; if1 < K.nbFace(); if1++)
      if (K.face(if1)==F) break;
    ArrayView<Real> Kcoeff = F_Ksigma.coefficients(K, if1);
    cell_ca_builder.subtract(F, K, Kcoeff[0]);
    for (Integer i = 0; i < K.nbFace(); i++) {
      const Face& face = K.face(i);
      if (face.isSubDomainBoundary())
        face_ca_builder.subtract(F, face, Kcoeff[i+1]);
      else {
        const Cell & neigh_cell =
          face.backCell() == K ? face.frontCell() : face.backCell();
        cell_ca_builder.subtract(F, neigh_cell, Kcoeff[i+1]);
      }
    }
  }
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_NUMERICS_DISCRETEOPERATOR_DIVKGRADGRADMIMPL_DIVKGRADGRADMSCHEME_H */
