#include "BasicGraphBuilderService.h"
/* Author : dipietrd at Mon Dec 10 15:04:54 2007
 * Generated by createNew
 */

#include "arcane/IParallelMng.h"
#include "arcane/IGraph.h"

using namespace Arcane;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

IGraphBuilder::NodeDescriptor BasicGraphBuilderService::addNode(const Item& I) {
  if(m_state != IGraphBuilder::ADDNODES_STATE)
    error() << "State is inconsistent with a call to BasicGraphBuilderService::addNode";

  if(I.isCell())
    m_dual_cell_uid[I] = m_current_node_local_uid++;
  else if(I.isFace())
    m_dual_face_uid[I] = m_current_node_local_uid++;
  else
    fatal() << "Cannot add this type of dual node";
}

/*---------------------------------------------------------------------------*/

void BasicGraphBuilderService::endAddNodes() {
  if(m_state != IGraphBuilder::ADDNODES_STATE)
    error() << "State is inconsistent with a call to BasicGraphBuilderService::endAddNodes";

  Integer nb_dual_cells = m_dual_cell_uid.size();
  Integer nb_dual_faces = m_dual_face_uid.size();
  info() << "Adding " << nb_dual_cells << " dual cells";
  info() << "Adding " << nb_dual_faces << " dual faces";

  // Compute current domain's node global unique id base
  IParallelMng* parallel_mng = subDomain()->parallelMng(); 
  SharedArray<Int64> current_node_local_uid(1);
  current_node_local_uid[0] = m_current_node_local_uid;
  SharedArray<Int64> all_current_local_uid(parallel_mng->commSize());
  parallel_mng->allGather(current_node_local_uid, all_current_local_uid);
  for(Integer i = 0; i < subDomain()->subDomainId(); i++)
    m_node_global_uid_base += all_current_local_uid[i];

  // Add dual cells
  SharedArray<Int64> dual_cell_node_id(nb_dual_cells);
  SharedArray<Int64> dual_cell_item_id(nb_dual_cells);
  Integer info_index = 0;

  for(Item2IntMap::iterator i = m_dual_cell_uid.begin(); i != m_dual_cell_uid.end(); i++) {
    const Cell& T = i->first.toCell();
    Integer T_uid = m_node_global_uid_base + m_dual_cell_uid[T];

    dual_cell_node_id[info_index] = T_uid;
    dual_cell_item_id[info_index] = T.uniqueId();

    info_index++;
  }

  // Add dual faces
  SharedArray<Int64> dual_face_node_id(nb_dual_faces);
  SharedArray<Int64> dual_face_item_id(nb_dual_faces);
  info_index = 0;

  for(Item2IntMap::iterator i = m_dual_face_uid.begin(); i != m_dual_face_uid.end(); i++) {
    const Face& F = i->first.toFace();
    Integer F_uid = m_node_global_uid_base + m_dual_face_uid[F];

    dual_face_node_id[info_index] = F_uid;
    dual_face_item_id[info_index] = F.uniqueId();

    info_index++;
  }

  // Add dual nodes to default graph
  m_graph->addDualNodes(IT_DualCell, nb_dual_cells, dual_cell_node_id, dual_cell_item_id);
  m_graph->addDualNodes(IT_DualFace, nb_dual_faces, dual_face_node_id, dual_face_item_id);

  // Change the state of the service: after this point it will not be possible
  // to add new nodes
  m_state = IGraphBuilder::ADDLINKS_STATE;
}

/*---------------------------------------------------------------------------*/

void BasicGraphBuilderService::addLink(const Item& I1, const Item& I2) {
  if(m_state != IGraphBuilder::ADDLINKS_STATE)
    error() << "State is inconsistent with a call to BasicGraphBuilderService::addLink";

  Integer uid_I1, uid_I2;
  if(I1.isCell())
    uid_I1 = m_node_global_uid_base + m_dual_cell_uid[I1];
  else if(I1.isFace())
    uid_I1 = m_node_global_uid_base + m_dual_face_uid[I1];
  else
    error() << "Unhandled item type required while adding link";

  if(I2.isCell())
    uid_I2 = m_node_global_uid_base + m_dual_cell_uid[I2];
  else if(I2.isFace())
    uid_I2 = m_node_global_uid_base + m_dual_face_uid[I2];
  else
    error() << "Unhandled item type required while adding link";

  m_links.push_back(LinkDescriptor(uid_I1, uid_I2));
}

/*---------------------------------------------------------------------------*/

void BasicGraphBuilderService::endAddLinks() {
  if(m_state != IGraphBuilder::ADDLINKS_STATE)
    error() << "State is inconsistent with a call to BasicGraphBuilderService::endAddLinks";

  // Add links
  Integer nb_links = m_links.size();
  SharedArray<Int64> link_info(1+4*nb_links);
  link_info[0] = 0; // New format
  Integer info_index = 0;
  
  m_current_link_local_uid = 0;
  for(LinkDescriptorList::iterator i = m_links.begin(); i != m_links.end(); i++) {
    link_info[info_index++] = IT_Line2; // Link with 2 dual nodes
    link_info[info_index++] = m_current_link_local_uid++;
    link_info[info_index++] = i->uid_I1;
    link_info[info_index++] = i->uid_I2;
  }
  m_graph->addLinks(nb_links , link_info);

  // Aggiungere la creazione della variabile sui dual node contenente il tipo
  // del link

  m_state = IGraphBuilder::FINALIZED_STATE;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_BASICGRAPHBUILDER(BasicGraphBuilder,BasicGraphBuilderService);
