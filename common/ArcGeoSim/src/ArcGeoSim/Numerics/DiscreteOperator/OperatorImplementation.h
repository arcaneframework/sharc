// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_NUMERICS_DISCRETEOPERATOR_OPERATORIMPLEMENTATION_H
#define ARCGEOSIM_NUMERICS_DISCRETEOPERATOR_OPERATORIMPLEMENTATION_H
/* Author : dipietrd at Tue Nov 24 13:30:30 2009
 * Generated by createNew
 */

#include <boost/static_assert.hpp>
#include <boost/type_traits/is_same.hpp>

#include "ArcGeoSim/Numerics/DiscreteOperator/CoefficientArrayBuilder.h"
#include "ArcGeoSim/Numerics/DiscreteOperator/StencilBuilder.h"
#include "ArcGeoSim/Numerics/DiscreteOperator/OLGSchemesTypedefs.h"

#include "ArcGeoSim/Numerics/DiscreteOperator/TwoPointInterpolator.h"

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

enum EOperatorImplementation {
  WithInserter    = 0,
  WithoutInserter = 1
};

template<EOperatorImplementation I>
struct OperatorImplementationT
{
};

/*----------------------------------------------------------------------------*/

struct ImplementationWithInserter 
{
  static const EOperatorImplementation type = WithInserter;
};

struct ImplementationWithoutInserter 
{
  static const EOperatorImplementation type = WithoutInserter;
};

// N is here the space dimension
template<typename SchemeT>
struct OperatorImplementationTraitsT {};

/*----------------------------------------------------------------------------*/

template<>
struct OperatorImplementationT<WithInserter>
{
  typedef ComparatorT<bool> ComparatorType;

  template<Integer N, typename SchemeT, typename VariableTypeT>
  static void apply(SchemeT * a_scheme, const VariableTypeT & kappa)
  {
    bool success = true;
    typedef typename SchemeT::ComparatorType ComparatorType;

    typedef typename SchemeT::CellCoefficientArrayInserter CellCoefficientArrayInserter;
    typedef typename SchemeT::FaceCoefficientArrayInserter FaceCoefficientArrayInserter;

    typedef typename SchemeT::CellCoefficientArrayInitializer CellCoefficientArrayInitializer;
    typedef typename SchemeT::FaceCoefficientArrayInitializer FaceCoefficientArrayInitializer;
    
    if(a_scheme->m_status & DiscreteOperatorProperty::S_FORMED) {
      a_scheme->m_cell_ca_initializer->resetPosition();
      a_scheme->m_face_ca_initializer->resetPosition();
      // Try to construct operator using previous inserter
      // If degeneration to two point occurs in a different position
      // than the last formDiscreteOperator, an inconsistent construction
      // error is thrown
      try {
        a_scheme->template _compute_discrete_operator<N, VariableTypeT,
          CellCoefficientArrayInserter, FaceCoefficientArrayInserter,
          ComparatorT<bool>, ComparatorT<bool> >
          (kappa, 
           *a_scheme->m_cell_ca_inserter, *a_scheme->m_face_ca_inserter,
           *a_scheme->m_degeneration1_comparator, *a_scheme->m_degeneration2_comparator);
      }
      // If inconsistent construction was found, form discrete
      // operator as if it had never been formed after last
      // prepare
      catch(typename SchemeT::BaseClass::Error e) {
        switch(e.code) {
        case SchemeT::BaseClass::E_InconsistentConstruction:
          success = false;
          a_scheme->m_trace_mng->warning() << "Inconsistent construction. Recomputing inserters";
          break;
        default:
          a_scheme->m_trace_mng->fatal() << e.msg;
        }
      }
      if(success) return;
    }

    // Initializers
    // in shared_ptr, previous instance is destroyed when reset is called
    a_scheme->m_cell_ca_initializer.reset(new CellCoefficientArrayInitializer(a_scheme->m_cell_coefficients));
    a_scheme->m_face_ca_initializer.reset(new FaceCoefficientArrayInitializer(a_scheme->m_face_coefficients));
    typename ComparatorType::Initializer * degeneration1_initializer = new typename ComparatorType::Initializer();
    typename ComparatorType::Initializer * degeneration2_initializer = new typename ComparatorType::Initializer();
    // Discrete operator and initializer computation
    a_scheme->template _compute_discrete_operator<N, VariableTypeT,
      CellCoefficientArrayInitializer, FaceCoefficientArrayInitializer,
      ComparatorT<bool>::Initializer, ComparatorT<bool>::Initializer>
      (kappa, 
       *a_scheme->m_cell_ca_initializer, *a_scheme->m_face_ca_initializer,
       *degeneration1_initializer, *degeneration2_initializer);
    a_scheme->m_cell_ca_initializer->finalizeInsert();
    a_scheme->m_face_ca_initializer->finalizeInsert();
    // Inserters and comparators
    a_scheme->m_cell_ca_inserter.reset(new CellCoefficientArrayInserter(a_scheme->m_cell_ca_initializer.get()));
    a_scheme->m_face_ca_inserter.reset(new FaceCoefficientArrayInserter(a_scheme->m_face_ca_initializer.get()));
    a_scheme->m_degeneration1_comparator.reset(new ComparatorT<bool>(degeneration1_initializer));
    a_scheme->m_degeneration2_comparator.reset(new ComparatorT<bool>(degeneration2_initializer));
  }
};

/*----------------------------------------------------------------------------*/

template<>
struct OperatorImplementationT<WithoutInserter>
{
  typedef TrueComparatorT<bool> ComparatorType;

  template<Integer N, typename SchemeT, typename VariableTypeT>
  static void apply(SchemeT * a_scheme, const VariableTypeT & kappa)
  {
    typedef typename SchemeT::CellCoefficientArrayInserter CellCoefficientArrayInserter;
    typedef typename SchemeT::FaceCoefficientArrayInserter FaceCoefficientArrayInserter;

    ComparatorType degeneration1_comparator;
    ComparatorType degeneration2_comparator;

    // Create new containers
    a_scheme->m_cell_ca_inserter.reset(new CellCoefficientArrayInserter(a_scheme->m_cell_coefficients));
    a_scheme->m_face_ca_inserter.reset(new FaceCoefficientArrayInserter(a_scheme->m_face_coefficients));

    // Compute discrete operator
    a_scheme->template _compute_discrete_operator<N, VariableTypeT,
      CellCoefficientArrayInserter, FaceCoefficientArrayInserter,
      TrueComparatorT<bool>, TrueComparatorT<bool> >
      (kappa,
       *a_scheme->m_cell_ca_inserter, *a_scheme->m_face_ca_inserter,
       degeneration1_comparator, degeneration2_comparator);
  }
};

/*----------------------------------------------------------------------------*/

#define SET_OPERATOR_IMPLEMENTATION(OperatorName, Implementation) \
template<> \
struct OperatorImplementationTraitsT<OperatorName> \
  : public Implementation {};

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_NUMERICS_DISCRETEOPERATOR_OPERATORIMPLEMENTATION_H */
