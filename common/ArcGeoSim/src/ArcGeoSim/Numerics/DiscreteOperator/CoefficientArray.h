// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_DISCRETEOPERATOR_COEFFICIENTARRAY_H
#define ARCGEOSIM_DISCRETEOPERATOR_COEFFICIENTARRAY_H
/* Author : dipietrd at Tue Jun  3 10:41:11 2008
 * Generated by createNew
 */

#include <algorithm>
#include <ostream>

#include <arcane/ArcaneTypes.h>
#include <arcane/ItemGroup.h>
#include <arcane/ItemTypes.h>
#include <arcane/utils/Array.h>
#include <arcane/ArcaneVersion.h>
#if (ARCANE_VERSION >= 12201)
#else /* ARCANE_VERSION */
#include <arcane/utils/CArray.h>
#endif /* ARCANE_VERSION */
#include <arcane/utils/String.h>

#include "ArcGeoSim/Utils/ItemGroupMap.h"
#include "ArcGeoSim/Utils/Utils.h"

using namespace Arcane;

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

template<typename T>
class CoefficientArrayT
{
public:
  /** @name Typedefs and enums
   */
  //@{
  //! Item group type
  typedef typename ItemTraitsT<T>::ItemGroupType ItemGroupType;
  //! Stencil local id type
  typedef ArrayView<Integer> StencilLocalIdType;
  //! Stencil type
  typedef ItemVectorView StencilType;
  //! Coefficients type
  typedef ArrayView<Real> CoefficientsType;
  //@}

  /** @name Constructors and destructors
   */
  //@{
  //! Default constructor
  CoefficientArrayT(FaceGroup face_group, ItemGroupT<T> item_group);
  //@}

  /** @name Constructors and destructors
   */
  //@{
  //! Initialize the coefficient array
  void init(const ItemGroupMapT<Face, Integer>& stencil_sizes);
  //! Initialize the coefficient array
  void init(const Array<std::pair<ItemGroup, Integer> >& stencil_sizes);
  //! Initialize the coefficient array
  void init(const Arcane::VariableFaceInteger& stencil_sizes);
  //! Destructor
  virtual ~CoefficientArrayT() {};
  //@}

  /** @name Setters and getters
   */
  //@{
  //! Return the face group
  const FaceGroup & faceGroup() const
  {
    return m_face_group;
  }
  //! Return the number of coefficients stored
  Integer numberOfCoefficients() const;
  //! Return the size of the stencil
  Integer stencilSize(const Face& F);
  //! Return the local id of the elements in the stencil of face F
  StencilLocalIdType stencilLocalId(const Face& F);
  //! Return the stencil for face F (
  StencilType stencil(const Face& F);
  //! Return the coefficients for face F
  CoefficientsType coefficients(const Face& F);
  //@}

  /** @name Setters and getters (deprecated)
   */
  //@{
  //! Return the size of the stencil
  ARCANE_DEPRECATED inline Integer getStencilSize(const Face& F)
  {
    return this->stencilSize(F);
  }
  //! Return the local id of the elements in the stencil of face F
  ARCANE_DEPRECATED inline StencilLocalIdType getStencilLocalId(const Face& F)
  {
    return stencilLocalId(F);
  }
  //! Return the stencil for face F (
  ARCANE_DEPRECATED inline StencilType getStencil(const Face& F)
  {
    return stencil(F);
  }
  //! Return the coefficients for face F
  ARCANE_DEPRECATED inline CoefficientsType getCoefficients(const Face& F)
  {
    return coefficients(F);
  }
  //@}

  /** @name Methods
   */
  //@{
  //! Reset coefficients to zero keeping stencil information
  void resetCoefficients();
  //! Print
  void print(std::ostringstream & ostr);
  //! Print
  template<typename TraceMessageT>
  void print(TraceMessageT trace);
  //@}

private:
  FaceGroup m_face_group;
  SharedArray<Real> m_coefficients;
  SharedArray<Integer> m_stencils;
  SharedArray<Integer> m_positions;
  SharedArray<Integer> m_lengths;
  ItemInternalList m_item_internal;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<typename T>
CoefficientArrayT<T>::CoefficientArrayT(FaceGroup face_group,
                                        ItemGroupT<T> item_group)
  : m_face_group(face_group)
{
  // Initialize item internal representation
  m_item_internal = item_group.itemFamily()->itemsInternal();
}

/*---------------------------------------------------------------------------*/

template<typename T>
void CoefficientArrayT<T>::init(const ItemGroupMapT<Face, Integer>& stencil_sizes)
{
  // Compute the maximum number of elements to store
  // and find maximum id
  Integer num_el = 0;
  Integer max_id = 0;
  ENUMERATE_FACE(iF, m_face_group) {
    const Face & F = *iF;
    num_el += stencil_sizes[F];
    max_id  = std::max(max_id, F.localId());
  }

  // Make room for positions vector
  m_positions.resize(max_id + 1);
  // Make room for lengths vector
  m_lengths.resize(max_id+1);
  // Make room for coefficients vector
  m_coefficients.resize(num_el+1);
  // Make room for items vector
  m_stencils.resize(num_el+1);

  // Fill stencil sizes
  Integer curr_el = 0;
  ENUMERATE_FACE(iF, m_face_group) {
    Integer stencil_size_iF = stencil_sizes[*iF];

    m_positions[iF->localId()] = curr_el;
    m_lengths[iF->localId()]   = stencil_size_iF;
    curr_el                   += stencil_size_iF;
  }
  this->resetCoefficients();
}

/*---------------------------------------------------------------------------*/

template<typename T>
void CoefficientArrayT<T>::init(const Arcane::VariableFaceInteger& stencil_sizes)
{
  // Compute the maximum number of elements to store
  // and find maximum id
  Integer num_el = 0;
  Integer max_id = 0;
  ENUMERATE_FACE(iF, m_face_group) {
    const Face & F = *iF;
    num_el += stencil_sizes[F];
    max_id  = std::max(max_id, F.localId());
  }

  // Make room for positions vector
  m_positions.resize(max_id + 1);
  // Make room for lengths vector
  m_lengths.resize(max_id+1);
  // Make room for coefficients vector
  m_coefficients.resize(num_el+1);
  // Make room for items vector
  m_stencils.resize(num_el + 1);

  // Fill stencil sizes
  Integer curr_el = 0;
  ENUMERATE_FACE(iF, m_face_group) {
    Integer stencil_size_iF = stencil_sizes[*iF];

    m_positions[iF->localId()] = curr_el;
    m_lengths[iF->localId()]   = stencil_size_iF;
    curr_el                   += stencil_size_iF;
  }
  this->resetCoefficients();
}

/*---------------------------------------------------------------------------*/

template<typename T>
void CoefficientArrayT<T>::init(const Array<std::pair<ItemGroup, Integer> >& stencil_sizes)
{
  // Compute the maximum number of elements to store
  // and find maximum id
  Integer num_el = 0;
  Integer max_id = 0;
  for(SharedArray<std::pair<ItemGroup, Integer> >::const_iterator i = stencil_sizes.begin(); i != stencil_sizes.end(); i++) {
    num_el += i->first.size() * i->second;
    ENUMERATE_FACE(iF, i->first) {
      max_id = std::max(max_id, iF->localId());
    }
  }

  // Make room for positions vector
  m_positions.resize(max_id + 1);
  // Make room for lengths vector
  m_lengths.resize(max_id+1);
  // Make room for coefficients vector
  m_coefficients.resize(num_el+1);
  // Make room for items vector
  m_stencils.resize(num_el + 1);

  // Fill stencil sizes
  Integer curr_el = 0;
  for(SharedArray<std::pair<ItemGroup, Integer> >::const_iterator i = stencil_sizes.begin(); i != stencil_sizes.end(); i++) {
    ENUMERATE_FACE(iF, i->first) {
      m_positions[iF->localId()] = curr_el;
      m_lengths[iF->localId()]   = i->second;
      curr_el                   += i->second;
    }
  }
  this->resetCoefficients();
}

/*---------------------------------------------------------------------------*/

template<typename T>
Integer CoefficientArrayT<T>::stencilSize(const Face& F)
{
  return m_lengths[F.localId()];
}

/*---------------------------------------------------------------------------*/

template<typename T>
Integer CoefficientArrayT<T>::numberOfCoefficients() const
{
  return m_coefficients.size();
}
  
/*---------------------------------------------------------------------------*/

template<typename T>
typename CoefficientArrayT<T>::StencilLocalIdType CoefficientArrayT<T>::stencilLocalId(const Face& F)
{
  Integer base   = m_positions[F.localId()];
  Integer length = m_lengths[F.localId()];
  return StencilLocalIdType(length, &m_stencils[base]);
}

/*---------------------------------------------------------------------------*/

template<typename T>
typename CoefficientArrayT<T>::StencilType CoefficientArrayT<T>::stencil(const Face& F)
{
  return StencilType(m_item_internal, stencilLocalId(F));
}

/*---------------------------------------------------------------------------*/

template<typename T>
typename CoefficientArrayT<T>::CoefficientsType CoefficientArrayT<T>::coefficients(const Face& F)
{
  Integer base   = m_positions[F.localId()];
  Integer length = m_lengths[F.localId()];
  return CoefficientsType(length, &m_coefficients[base]);
}

/*---------------------------------------------------------------------------*/

template<typename T>
void CoefficientArrayT<T>::resetCoefficients()
{
  m_coefficients.fill(0.);
}

/*---------------------------------------------------------------------------*/

template<typename T>
void CoefficientArrayT<T>::print(std::ostringstream & ostr)
{
  ENUMERATE_FACE(iF, m_face_group) {
    const Face & F = *iF;
    ostr << FORMATF(59,'-') << endl;
    ostr << "Face "<< F.localId() << std::endl;
    if(F.isSubDomainBoundary())
      ostr << FORMATW(20) << "Boundary cell: " << F.boundaryCell().localId() << std::endl;
    else {
      ostr << FORMATW(20) << "Back cell: " << F.backCell().localId() << std::endl;
      ostr << FORMATW(20) << "Front cell: " << F.frontCell().localId() << std::endl;
    }
    ostr << FORMATW(20) << "Stencil: " << std::flush;
    StencilLocalIdType stencil = this->stencilLocalId(F);
    for(StencilLocalIdType::const_iterator iI=stencil.begin(); iI!=stencil.end(); iI++)
      ostr << *iI << " " << std::flush;
    ostr << std::endl;

    ostr << FORMATW(20) << "Coefficients: " << std::flush;
    CoefficientsType coefficients = this->coefficients(F);
    for(CoefficientsType::const_iterator taui=coefficients.begin(); taui!=coefficients.end(); taui++)
      ostr << *taui << " " << std::flush;
    ostr<< std::endl;
  }
  ostr << FORMATF(59,'-') << endl;
}

/*---------------------------------------------------------------------------*/

template<typename T>
template<typename TraceMessageT>
void CoefficientArrayT<T>::print(TraceMessageT trace)
{
  std::ostringstream ostr;
  this->print(ostr);
  trace << ostr.str();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_DISCRETEOPERATOR_COEFFICIENTARRAY_H */
