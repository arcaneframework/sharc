// -*- C++ -*-
/* Author : desrozis at Thu Nov 14 15:49:58 2013
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include <arcane/ArcaneVersion.h>
#include "ArcGeoSim/Numerics/DiscreteOperator/IDivKGradDiscreteOperator.h"
#include "ArcGeoSim/Numerics/DiscreteOperator/TypesDivKGradOLGSchemes.h"

#include "OptimizedDivKGradOScheme_axl.h"

#include "ArcGeoSim/Numerics/DiscreteOperator/CoefficientArrayBuilder.h"
#include "ArcGeoSim/Numerics/DiscreteOperator/TensorAlgebra.h"
#include "ArcGeoSim/Numerics/Utils/Algorithms/LUSolver.h"
#include "ArcGeoSim/Numerics/Utils/Algorithms/lu.h"
#include "ArcGeoSim/Numerics/DiscreteOperator/TwoPointInterpolator.h"
#include "ArcGeoSim/Numerics/DiscreteOperator/TwoPointInterpolator.h"

#include "StencilBuilder.h"

#include "ArcGeoSim/Appli/IAppServiceMng.h"

#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"

#include "ArcGeoSim/Utils/ItemGroupBuilder.h"

#include <boost/multi_array.hpp>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/matrix.hpp>

#include <Eigen/Core>
#include <Eigen/LU>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class OptimizedDivKGradOSchemeService 
  : public ArcaneOptimizedDivKGradOSchemeObject
{
protected:
  
  typedef boost::numeric::ublas::vector<Real> RealVector;
  typedef boost::numeric::ublas::zero_vector<Real> ZeroVector;
  typedef boost::numeric::ublas::matrix<Real> RealMatrix;
  typedef boost::numeric::ublas::zero_matrix<Real> ZeroMatrix;
  typedef boost::numeric::ublas::range Range;
  typedef boost::numeric::ublas::matrix_range<RealMatrix> RealMatrixRange;
  typedef boost::numeric::ublas::permutation_matrix<std::size_t> PermutationMatrix;

public:
  
  OptimizedDivKGradOSchemeService(const Arcane::ServiceBuildInfo & sbi) 
    : ArcaneOptimizedDivKGradOSchemeObject(sbi)
    , m_status(DiscreteOperatorProperty::S_NONE)
    , m_epsilon(0.)
    , m_check_sign(false)
    , m_dtodr(-1.)
    , m_type(TypesDivKGradOLGSchemes::BC_TwoPoints)
    , m_geometry_mng(NULL)
    , m_mesh(NULL)
    , m_cell_numbering(NULL)
    , m_cell_coefficients(NULL)
    , m_face_coefficients(NULL)
    , m_f_centers(NULL)
    , m_f_normals(NULL)
    , m_c_centers(NULL)
    , m_f_measures(NULL) {}
  
  ~OptimizedDivKGradOSchemeService() 
  {
    delete m_cell_numbering;
  }
  
public:

  void init();
  
  const Arcane::Integer & status() const { return m_status; }
  
  bool twoPointBoundary() 
  {
    if(m_type==TypesDivKGradOLGSchemes::BC_TwoPoints ||
       m_type==TypesDivKGradOLGSchemes::BC_StandardTwoPoints)
      return true;
    else
      return false;
  }

  void formDiscreteOperator(const Arcane::VariableCellReal& k);
  void formDiscreteOperator(const Arcane::VariableCellReal3& k);
  void formDiscreteOperator(const Arcane::VariableCellReal3x3& k);

  void formDiscreteOperator(const Arcane::SharedVariableCellReal& k);
  void formDiscreteOperator(const Arcane::SharedVariableCellReal3& k);
  void formDiscreteOperator(const Arcane::SharedVariableCellReal3x3& k);
  
  void prepare(Arcane::IMesh * mesh,
               CoefficientArrayT<Arcane::Cell>* cell_coefficients,
               CoefficientArrayT<Arcane::Face>* face_coefficients);
  
  ARCANE_DEPRECATED void prepare(const Arcane::FaceGroup&,
                                 const Arcane::FaceGroup&,
                                 Arcane::FaceGroup&,
                                 Arcane::FaceGroup&,
                                 CoefficientArrayT<Arcane::Cell>*,
                                 CoefficientArrayT<Arcane::Face>*) 
  {
    fatal() << "This method is not implemented...";
  }
  
  void finalize() {}

  Arcane::Integer getCellGeometricProperties() {
    return (IGeometryProperty::PCenter | IGeometryProperty::PMeasure);
  }
  
  Arcane::Integer getFaceGeometricProperties() {
    return (IGeometryProperty::PCenter | IGeometryProperty::PNormal | IGeometryProperty::PMeasure);
  }

  const Arcane::FaceGroup& faces() const { return m_faces; }
  const Arcane::CellGroup& cells() const { return m_cells; }
  const Arcane::FaceGroup& boundaryFaces() const { return m_boundary_faces; }
  const Arcane::FaceGroup& internalFaces() const { return m_internal_faces; }

private:

  void _computeStencils();
  
  template<typename CellStencilBuilder, typename FaceStencilBuilder>
  void _computeStencils(const Arcane::FaceCellGroup& face_to_cell,
                        const Arcane::FaceFaceGroup& face_to_bface,
                        const Arcane::FaceCellGroup& bface_to_cell,
                        CellStencilBuilder& cell_stencil_builder,
                        FaceStencilBuilder& face_stencil_builder);  
  
  template<Arcane::Integer N, typename V>
  void _formDiscreteOperator(const V& k);
  
  void _computeLocalConnectivity(const Arcane::Node & node,
                                 Arcane::VariableCellInteger& NumLocCell,
                                 Arcane::SharedArray<Arcane::IntegerSharedArray>& NumLocfacebyCell);

  template<Integer N>
  bool _computeCellGradient(const Arcane::Node & P,
                            Arcane::SharedArray<Arcane::IntegerSharedArray>& NumLocfacesbyCell,
                            Arcane::Real3SharedArray2& gradient);
  
  template<typename VariableTypeT>
  bool _enforceFluxConservation(const Arcane::Node& node, 
                                Arcane::VariableCellInteger& NumLocCell, 
                                Arcane::SharedArray<Arcane::IntegerSharedArray>& NumLocfacesbyCell,
                                Arcane::Real3SharedArray2& gradient,
                                const VariableTypeT & kappa,
                                DirectCoefficientArrayBuilderT<Cell>::Inserter& cell_ca_builder);
  
  template<typename VariableTypeT>
  void _enforceTwoPointsFluxConservation(const Node& node, 
                                         const VariableTypeT & kappa,
                                         DirectCoefficientArrayBuilderT<Cell>::Inserter& cell_ca_builder);
  
  template<typename VariableTypeT>
  void _computeTwoPointBoundaryConditions(const Arcane::Node& node,
                                          const VariableTypeT& kappa,
                                          DirectCoefficientArrayBuilderT<Cell>::Inserter& cell_ca_builder,
                                          DirectCoefficientArrayBuilderT<Face>::Inserter& face_ca_builder);
  
  template<typename VariableTypeT>
  void _computeStandardTwoPointBoundaryConditions(const Arcane::Node& node,
                                                  const VariableTypeT& kappa,
                                                  DirectCoefficientArrayBuilderT<Cell>::Inserter& cell_ca_builder,
                                                  DirectCoefficientArrayBuilderT<Face>::Inserter& face_ca_builder);
  
  template<typename VariableTypeT>
  void _computeOSchemeBoundaryConditions(const Arcane::Node& node,
                                         Arcane::VariableCellInteger & NumLocCell,
                                         Arcane::SharedArray<Arcane::IntegerSharedArray>& NumLocfacesbyCell,
                                         Arcane::Real3SharedArray2& Gradient,
                                         const VariableTypeT& kappa,
                                         DirectCoefficientArrayBuilderT<Cell>::Inserter& cell_ca_builder,
                                         DirectCoefficientArrayBuilderT<Face>::Inserter& face_ca_builder);

private:
  
  Integer m_status;
  
  Real m_epsilon;
  bool m_check_sign;
  Real m_dtodr;
  
  TypesDivKGradOLGSchemes::eType m_type;

  IGeometryMng* m_geometry_mng;

  Arcane::IMesh* m_mesh; 

  Arcane::FaceGroup m_faces;
  Arcane::CellGroup m_cells;
  Arcane::FaceGroup m_boundary_faces;
  Arcane::FaceGroup m_internal_faces;
  
  // Arcane::NodeGroup m_boundary_nodes_g;
  // Arcane::NodeGroup m_internal_nodes_g;
  
  Arcane::NodeVector m_boundary_nodes;
  Arcane::NodeVector m_internal_nodes;

  Arcane::VariableCellInteger* m_cell_numbering;
  
  CoefficientArrayT<Arcane::Cell>* m_cell_coefficients;
  CoefficientArrayT<Arcane::Face>* m_face_coefficients; 

  mutable const IGeometryMng::Real3Variable * m_f_centers;
  mutable const IGeometryMng::Real3Variable * m_f_normals;
  mutable const IGeometryMng::Real3Variable * m_c_centers;
  mutable const IGeometryMng::RealVariable * m_f_measures;
  mutable const IGeometryMng::RealVariable * m_c_measures;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
OptimizedDivKGradOSchemeService::
init() 
{
  if(m_status & DiscreteOperatorProperty::S_INITIALIZED) return;

  IAppServiceMng* app_service_mng = IAppServiceMng::instance(subDomain()->serviceMng());

  m_geometry_mng = app_service_mng->find<IGeometryMng>(true);

  m_type = options()->OschemeType();

  m_status |= DiscreteOperatorProperty::S_INITIALIZED;
  
  m_epsilon    = options()->epsilon();
  m_check_sign = options()->checkSign();
  m_dtodr      = options()->diagonalToOffDiagonalRatio();
}

/*---------------------------------------------------------------------------*/

void
OptimizedDivKGradOSchemeService::
prepare(Arcane::IMesh * mesh,
        CoefficientArrayT<Arcane::Cell>* cell_coefficients,
        CoefficientArrayT<Arcane::Face>* face_coefficients)
{
  ARCANE_ASSERT( (m_status & DiscreteOperatorProperty::S_INITIALIZED),
                 ("Operator not initialized when calling prepare") );
  
  Arcane::VariableBuildInfo cell_numbering_vb(mesh,
                                              IMPLICIT_UNIQ_NAME,
                                              IVariable::PPrivate | IVariable::PTemporary);
  
  delete m_cell_numbering;
  
  m_cell_numbering = new Arcane::VariableCellInteger(cell_numbering_vb);

  m_mesh           = mesh;
  
  m_cells          = mesh->allCells();
  m_faces          = mesh->allFaces();
  m_internal_faces = m_cells.innerFaceGroup();
  m_boundary_faces = m_cells.outerFaceGroup();

  m_cell_coefficients = cell_coefficients;
  m_face_coefficients = face_coefficients;

  m_boundary_nodes.clear();
  m_internal_nodes.clear();
  
  {
    m_boundary_nodes.setFamily(m_mesh->nodeFamily());
    Arcane::IntegerSharedArray nodes;
    nodes.reserve(m_mesh->allNodes().size());
    ENUMERATE_FACE( iface, m_boundary_faces ) {
      ENUMERATE_NODE(inode,iface->nodes()) {
        nodes.add(inode->localId());
      }
    }
    std::sort(nodes.begin(),nodes.end());
    Arcane::IntegerSharedArray::iterator it = std::unique(nodes.begin(),nodes.end());
    nodes.resize(it - nodes.begin());
    m_boundary_nodes.add(nodes);
  }
  
  {
    m_internal_nodes.setFamily(m_mesh->nodeFamily());
    Arcane::IntegerSharedArray nodes;
    nodes.reserve(m_mesh->allNodes().size());
    ENUMERATE_FACE(iface, m_internal_faces) {
      ENUMERATE_NODE(inode, iface->nodes()) {
        bool isNotBoundary = true;
        ENUMERATE_FACE(isubface, inode->faces()) {
          if (isubface->isSubDomainBoundary()) {
            isNotBoundary = false;
            break;
          }
        }
        if(isNotBoundary) {
          nodes.add(inode->localId());
        }
      }
    }
    std::sort(nodes.begin(),nodes.end());
    Arcane::IntegerSharedArray::iterator it = std::unique(nodes.begin(),nodes.end());
    nodes.resize(it - nodes.begin());
    m_internal_nodes.add(nodes);
  }
 
  _computeStencils();

  m_status |= DiscreteOperatorProperty::S_PREPARED;
}

/*---------------------------------------------------------------------------*/

void
OptimizedDivKGradOSchemeService::
_computeStencils()
{
  FaceCellGroup face_to_cell(m_internal_faces, m_cells, IK_Node);
  
  // Initialize boundary nodes indicator
  Integer MaxNodeId = m_faces.mesh()->nodeFamily()->maxLocalId();
  Arcane::ByteSharedArray node_is_boundary(MaxNodeId);
  node_is_boundary.fill(0);
  ENUMERATE_NODE(inode, m_boundary_nodes){
    node_is_boundary[inode->localId()] = 1;
  }

  // Create group of faces which have at least one node on the boundary
  Arcane::FaceGroup near_and_boun_faces;
  ItemGroupBuilder<Face> near_and_boun_faces_builder(m_mesh, IMPLICIT_NAME);
  ENUMERATE_FACE(iface, m_boundary_faces) {
    near_and_boun_faces_builder.add(*iface);
  }
  ENUMERATE_FACE(iface, m_internal_faces) {
    ENUMERATE_NODE(inode, iface->nodes()) {
      if (node_is_boundary[inode->localId()]){
        near_and_boun_faces_builder.add(*iface);
        break;
      }
    }
  }
  near_and_boun_faces = near_and_boun_faces_builder.buildGroup();
  
  // Create connectivity table between near_and_boun faces and boundary
  // faces through nodes
  FaceFaceGroup face_to_bface(near_and_boun_faces, m_boundary_faces, IK_Node);

  // Create connectivity table between boundary faces and cells
  FaceCellGroup bface_to_cell(m_boundary_faces, m_cells, IK_Node);

  // Compute stencils
  {
    Optimized::OrderedStencilBuilderT<Arcane::Cell> cell_stencil_builder(m_cell_coefficients);
    Optimized::OrderedStencilBuilderT<Arcane::Face> face_stencil_builder(m_face_coefficients);
    _computeStencils(face_to_cell,
                     face_to_bface,
                     bface_to_cell,
                     cell_stencil_builder,
                     face_stencil_builder);
    cell_stencil_builder.finalize();
    face_stencil_builder.finalize();
  }

  // Clear work groups
  near_and_boun_faces.clear();
}

/*---------------------------------------------------------------------------*/

template<typename CellStencilBuilder, typename FaceStencilBuilder>
void
OptimizedDivKGradOSchemeService::
_computeStencils(const FaceCellGroup& face_to_cell,
                 const FaceFaceGroup& face_to_bface,
                 const FaceCellGroup& bface_to_cell,
                 CellStencilBuilder& cell_stencil_builder,
                 FaceStencilBuilder& face_stencil_builder)
{
  // Compute cell stencils for internal faces
  ENUMERATE_ITEMPAIR(Face, Cell, iface, face_to_cell) {
    ENUMERATE_SUB_ITEM(Cell, isubcell, iface) {
      cell_stencil_builder.insert(*iface, *isubcell);
    }
  }

  // Cell stencils for boundary faces and face stencils for boundary
  // and near boundary faces
  switch(m_type) {
  case TypesDivKGradOLGSchemes::BC_TwoPoints:
  case TypesDivKGradOLGSchemes::BC_StandardTwoPoints:
    ENUMERATE_FACE(iface, m_boundary_faces) {
      const Face& F = *iface;
      cell_stencil_builder.insert(F, F.boundaryCell());
      face_stencil_builder.insert(F, F);
    }
    break;
  case TypesDivKGradOLGSchemes::BC_Gscheme:
  case TypesDivKGradOLGSchemes::BC_Lscheme:
  case TypesDivKGradOLGSchemes::BC_Oscheme:
    // Compute cell stencils
    ENUMERATE_ITEMPAIR(Face, Cell, iface, bface_to_cell) {
      ENUMERATE_SUB_ITEM(Cell, isubcell, iface) {
        cell_stencil_builder.insert(*iface, *isubcell);
      }
    }

    // Compute face stencils
    ENUMERATE_ITEMPAIR(Face, Face, iface, face_to_bface) {
      const Face& F = *iface;
      if (F.isSubDomainBoundary())
        face_stencil_builder.insert(F, F);

      ENUMERATE_SUB_ITEM(Face, isubface, iface) {
        face_stencil_builder.insert(F, *isubface);
      }
    }
    break;
  }
}

/*---------------------------------------------------------------------------*/

#define FORM_DISCRETE_OPERATOR(variable)                                \
  void OptimizedDivKGradOSchemeService::                                \
  formDiscreteOperator(const variable& kappa)                           \
  {                                                                     \
    switch(mesh()->dimension()) {                                       \
    case 2:                                                             \
      _formDiscreteOperator<2>(kappa);                                  \
      break;                                                            \
    case 3:                                                             \
      _formDiscreteOperator<3>(kappa);                                  \
      break;                                                            \
    default:                                                            \
      fatal() << "Dimension " << mesh()->dimension() << " not available"; \
    }                                                                   \
  }

FORM_DISCRETE_OPERATOR(Arcane::VariableCellReal);
FORM_DISCRETE_OPERATOR(Arcane::VariableCellReal3);
FORM_DISCRETE_OPERATOR(Arcane::VariableCellReal3x3);
FORM_DISCRETE_OPERATOR(Arcane::SharedVariableCellReal);
FORM_DISCRETE_OPERATOR(Arcane::SharedVariableCellReal3);
FORM_DISCRETE_OPERATOR(Arcane::SharedVariableCellReal3x3);

#undef FORM_DISCRETE_OPERATOR

/*----------------------------------------------------------------------------*/

void
OptimizedDivKGradOSchemeService::
_computeLocalConnectivity(const Node & node,
                          VariableCellInteger& NumLocCell,
                          SharedArray<IntegerSharedArray>& NumLocfacebyCell)
{
  // Local cell renumbering for fast access
  for(Integer icell=0; icell<node.nbCell(); ++icell) {
    const Cell & cell = node.cell(icell);
    NumLocCell[cell] = icell;
    NumLocfacebyCell[icell].resize(0);
  }
  // For each cell around the node, build the set of cell faces
  // sharing the node
  for(Integer iface=0; iface<node.nbFace(); ++iface) {
    const Face& face = node.face(iface);
    if(face.isSubDomainBoundary()) {
      const Cell cell0 = face.boundaryCell();
      Integer numloc_cell0  = NumLocCell[cell0];
      NumLocfacebyCell[numloc_cell0].add(iface);
    } else {
      const Cell cellback       = face.backCell();
      const Cell cellfront      = face.frontCell();
      Integer numloc_cellback  = NumLocCell[cellback];
      Integer numloc_cellfront = NumLocCell[cellfront];
      NumLocfacebyCell[numloc_cellback].add(iface);
      NumLocfacebyCell[numloc_cellfront].add(iface);
    }
  }
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

namespace DiscreteOperator {

  template<Integer N>
  struct eigen_vector_outer_prod {
  };

  // By default we assume to be in the xz plane
  template<>
  struct eigen_vector_outer_prod<2> {
    typedef Eigen::Matrix<Arcane::Real,2,2> MatrixNxN;
    static void eval(const Real3 & v1, const Real3 & v2, MatrixNxN& M) {
      M(0,0) += v1.y * v2.y;
      M(0,1) += v1.y * v2.z;
      M(1,0) += v1.z * v2.y;
      M(1,1) += v1.z * v2.z;
    }
  };

  template<>
  struct eigen_vector_outer_prod<3> {
    typedef Eigen::Matrix<Arcane::Real,3,3> MatrixNxN;
    static void eval(const Real3 & v1, const Real3 & v2, MatrixNxN& M) {
      M(0,0) += v1.x * v2.x;
      M(0,1) += v1.x * v2.y;
      M(0,2) += v1.x * v2.z;
      M(1,0) += v1.y * v2.x;
      M(1,1) += v1.y * v2.y;
      M(1,2) += v1.y * v2.z;
      M(2,0) += v1.z * v2.x;
      M(2,1) += v1.z * v2.y;
      M(2,2) += v1.z * v2.z;
    }
  };
 
  /*----------------------------------------------------------------------------*/

  template<Integer N>
  struct eigen_multiply {
  };

  template<>
  struct eigen_multiply<2> {
    typedef Eigen::Matrix<Arcane::Real,2,2> MatrixNxN;
    typedef Eigen::Matrix<Arcane::Real,2,1> VectorN;
    static Real3 eval(const Real3 & v,  MatrixNxN& M) {
      const Eigen::Map<const VectorN> x(&(v.y));
      Real3 r;
      r.x = 0.;
      Eigen::Map<VectorN> y(&(r.y));
      y = M * x;
      return r;
    }
  };

  template<>
  struct eigen_multiply<3> {
    typedef Eigen::Matrix<Arcane::Real,3,3> MatrixNxN;
    typedef Eigen::Matrix<Arcane::Real,3,1> VectorN;
    static Real3 eval(const Real3 & v,  MatrixNxN& M) {
      const Eigen::Map<const VectorN> x(&(v.x));
      Real3 r;
      Eigen::Map<VectorN> y(&(r.x));
      y = M * x;
      return r;
    }
  };
}

/*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*/

template<Integer N>
bool
OptimizedDivKGradOSchemeService::
_computeCellGradient(const Node & P,
    SharedArray<IntegerSharedArray>& NumLocfacesbyCell,
                     Real3SharedArray2& gradient)
{
  typedef Eigen::Matrix<Arcane::Real,N,N> MatrixNxN;
  
  
  ENUMERATE_CELL(icell, P.cells()) {
    Arcane::Integer iK = icell.index();
    
    // Local face numbers
    Arcane::IntegerArray& face_local = NumLocfacesbyCell[iK];
    // Number of faces of K that share the node P
    Integer nbface =  face_local.size();
  
    if(nbface < N) return true;
    
    const Real3 & xK = (*m_c_centers)[icell];
        
    if(nbface == N) {
          
      Real3 dFK[N];
      
      for(Integer iF=0; iF<N; ++iF) {
        Integer numloc_face = face_local[iF];
        const Face & F = P.face(numloc_face);
        dFK[iF] = (*m_f_centers)[F] - xK;
      }
      
      Real3 n[N];
      
      if(N == 2) {
        n[0].x = 0;
        n[0].y = -dFK[1].z;
        n[0].z =  dFK[1].y;
        n[1].x = 0;
        n[1].y = -dFK[0].z;
        n[1].z =  dFK[0].y;
      } else {
        n[0] = math::vecMul(dFK[1], dFK[2]);
        n[1] = math::vecMul(dFK[0], dFK[2]);
        n[2] = math::vecMul(dFK[0], dFK[1]);
      }
      
      gradient[iK][N] = Real3(0.,0.,0.);
      
      for(Integer iF=0; iF<N; ++iF) {
        
        const Arcane::Real v = math::dot(dFK[iF], n[iF]);

        if(math::abs(v) < 1.e-12) return true;

        const Arcane::Real3 x0 = n[iF] / v;
        
        gradient[iK][iF] = x0;
        gradient[iK][N] -= x0;
      }
      
    } else {
      
      MatrixNxN B;
      B.fill(0.);

      // Loop over the faces of cell K that share the node P
      for(Integer iF=0; iF<nbface; ++iF) {
        // Local face number around the node
        Integer numloc_face = face_local[iF];
        const Face & F = P.face(numloc_face);
        // Retrieve geometric properties
        const Real3 & xF = (*m_f_centers)[F];
        const Real3 & nF = (*m_f_normals)[F];
        Real3 dFK = xF - xK;
        Real3 nKF = (math::scaMul(nF, dFK) > 0) ? nF : -nF;
        
        DiscreteOperator::eigen_vector_outer_prod<N>::eval(nKF, dFK, B);
      } // End loop over faces
     
      const Arcane::Real inv_volume = 1. / (*m_c_measures)[icell];
      B *= inv_volume;
      
      if(std::abs(B.determinant()) < 1.e-12)
        return true;
      
      B = B.inverse().eval();
      B *= inv_volume;
     
      gradient[iK][nbface] = Real3(0.,0.,0.);
       
      for(Integer iF=0; iF<nbface; ++iF) {
        // Local face number around the node
        Integer numloc_face = face_local[iF];
        const Face & F = P.face(numloc_face);
        // Retrieve geometric properties
        const Real3 & xF = (*m_f_centers)[F];
        const Real3 & xK = (*m_c_centers)[icell];
        const Real3 & nF = (*m_f_normals)[F];
        const Real3 nKF = (math::scaMul(nF, xF-xK) > 0) ? nF : -nF;
        
        const Real3 x0 = DiscreteOperator::eigen_multiply<N>::eval(nKF, B);
        
        gradient[iK][iF]      = x0;
        gradient[iK][nbface] -= x0;
      }
   
    } // End loop over faces
  } // End loop over cells
  
  return false;
}

/*---------------------------------------------------------------------------*/

template<typename VariableTypeT>
void 
OptimizedDivKGradOSchemeService::
_enforceTwoPointsFluxConservation(const Node& node, 
                                  const VariableTypeT & kappa,
                                  DirectCoefficientArrayBuilderT<Cell>::Inserter& cell_ca_builder)
{
  // Loop over the faces sharing the node
  for(Integer iF=0; iF<node.nbFace(); ++iF) {
    // Internal nodes only => F is an internal face
    const Face& F = node.face(iF);
    // Retrieve back and front cell
    const Cell & K = F.backCell();
    const Cell & L = F.frontCell();
    
    // Compute transmissivity
    Real tau = 0.;
    switch(m_type) {
    case TypesDivKGradOLGSchemes::BC_StandardTwoPoints:
      tau = TwoPointInterpolator::standardTwoPointInternalTransmissivity(F, 
                                                                         kappa, 
                                                                         m_f_centers, 
                                                                         m_f_normals, 
                                                                         m_f_measures, 
                                                                         m_c_centers);
      break;
    default:
      tau = TwoPointInterpolator::twoPointInternalTransmissivity(F, 
                                                                 kappa, 
                                                                 m_f_centers, 
                                                                 m_f_normals, 
                                                                 m_f_measures, 
                                                                 m_c_centers);
      break;
    } // END case
    
      //Reduce to sub face flux
    tau /= F.nbNode();
    // Store flux
    cell_ca_builder.sum(F, K, tau);
    cell_ca_builder.subtract(F, L, tau);
  } // END for
}

/*---------------------------------------------------------------------------*/

template<typename VariableTypeT>
bool
OptimizedDivKGradOSchemeService::
_enforceFluxConservation(const Node& node, 
                         Arcane::VariableCellInteger& NumLocCell, 
                         Arcane::SharedArray<Arcane::IntegerSharedArray>& NumLocfacesbyCell,
                         Arcane::Real3SharedArray2& gradient,
                         const VariableTypeT & kappa,
                         DirectCoefficientArrayBuilderT<Cell>::Inserter& cell_ca_builder)
{
  typedef typename VariableTraitsT<VariableTypeT>::DataType DiffusionType;

  Integer nbface = node.nbFace();
  Integer nbcell = node.nbCell();
  Integer N = m_mesh->dimension(); // Space dimension
  
  RealMatrix A(nbface, nbface); A.clear();
  RealMatrix B(nbface, nbcell); B.clear();
  
  // Eigen::MatrixXd A(nbface, nbface); A.fill(0.);
  // Eigen::MatrixXd B(nbface, nbcell); B.fill(0.);

  //Multiply gradients by Lambda
  Real3SharedArray2 kappa_gradient(node.nbCell(),node.nbFace()+1);
  ENUMERATE_CELL(icell, node.cells()) {
    //for (Integer i = 0 ; i < node.nbCell() ; i++){
    //const Cell & T = node.cell(i);
    const Arcane::Integer i = icell.index();
    const DiffusionType & kappaT = kappa[icell];
    for (Integer j = 0 ; j < node.nbFace()+1; j++){
      kappa_gradient[i][j] = DiscreteOperator::tensor_vector_prod<DiffusionType>::eval(kappaT,gradient[i][j]);
    }
  }

  // Find maximum number of faces
  Integer max_nb_local_faces=0;
  for (Integer i=0; i<nbcell ; i++) {
    const Arcane::IntegerArray& face_local = NumLocfacesbyCell[i];
    if(face_local.size() > max_nb_local_faces)
      max_nb_local_faces = face_local.size();
  }
  // Initialize multi array for fluxes
  boost::multi_array<Real, 3> Fluxes(boost::extents[nbcell][nbface][max_nb_local_faces+1]);
  
  //Build the fluxes
  //for (Integer iK = 0 ; iK < nbcell ; iK++){
  ENUMERATE_CELL(icell, node.cells()) {
    Arcane::Integer iK = icell.index();
    //const Cell & K = node.cell(iK);
    Integer iK_loc = NumLocCell[*icell];
    Arcane::IntegerArray& face_local = NumLocfacesbyCell[iK_loc];
    Integer nbfaceK =  face_local.size();

    // Main part of the flux
    for (Integer iF = 0 ; iF < nbfaceK ; ++iF){  // Loop over the faces of cell sharing the node (rows of the matrix)
      Integer iF_loc = face_local[iF];
      const Face & F = node.face(iF_loc);
      const Real3 & nF = (*m_f_normals)[node.face(iF_loc)];
      for (Integer jF = 0 ; jF <= nbfaceK ; jF++)
        Fluxes[iK][iF_loc][jF] = // We divide by the number of nodes
          -math::scaMul(kappa_gradient[iK_loc][jF], nF) / F.nbNode();
    }

    // Add the residual terms for the cells with more than 3 (in 3D) faces sharing a node
    if (nbfaceK != N){
      // Compute residuals
      SharedArray2<Real> Resid(nbfaceK, nbfaceK+1);
      SharedArray<Real3> dK_sigma(nbfaceK);
      dK_sigma.resize(nbfaceK);
      const Real3 xK = (*m_c_centers)[icell];
      Resid.fill(0.);
      for (Integer iF = 0 ; iF < nbfaceK ; iF++){
        Integer iF_loc = face_local[iF];
        const Face & F = node.face(iF_loc);
        dK_sigma[iF] = ((*m_f_centers)[F] - xK);
      }

      for (Integer iF = 0 ; iF < nbfaceK ; iF++){
        Resid[iF][iF] = 1.;
        Resid[iF][nbfaceK] = -1.;
        for (Integer jF = 0 ; jF <= nbfaceK ; jF++){
          Resid[iF][jF] -= math::scaMul(gradient[iK_loc][jF], dK_sigma[iF]);
        }
      }

      // Compute the term involving the sum of residuals
      SharedArray<Real3> sum(nbfaceK+1);
      sum.resize(nbfaceK+1);
      sum.fill(Real3(0.,0.,0.));
      for (Integer iF = 0 ; iF <= nbfaceK ; iF++)
        for (Integer jF = 0 ; jF < nbfaceK ; jF++)
          sum[iF] += Resid[jF][iF] / dK_sigma[jF].abs2() * dK_sigma[jF];

      // Additional terms
      const DiffusionType & kappaK = kappa[icell];
      Real alpha = DiscreteOperator::MinimumEigenvalue::compute(kappaK);
      Real m_Ks = 0;
      for (Integer i = 0 ; i < nbfaceK ; i++){
        Integer numloc_face = face_local[i];
        const Face & face = node.face(numloc_face);
        m_Ks += (*m_f_measures)[face] / face.nbNode() * dK_sigma[i].abs();
      }
      m_Ks /= N;
      Real coef = alpha * m_Ks;
      for (Integer i = 0 ; i < nbfaceK ; i++){
        Integer numloc_face = face_local[i];
        const Face & face = node.face(numloc_face);
        for (Integer j = 0 ; j <= nbfaceK ; j++)
          Fluxes[iK][numloc_face][j] -= 
            coef*(Resid[i][j]/dK_sigma[i].abs2()-math::scaMul(gradient[iK_loc][i],sum[j]))/face.nbNode();
      }
    }
  }
  
  // Construct local matrices to enforce flux continuity
  ENUMERATE_FACE(iface, node.faces()) {
    //for(Integer iF = 0 ; iF < nbface ; ++iF){
    //const Face& face  = node.face(iF);
    // const Cell& K  = iface->backCell();
    // const Cell& L  = iface->frontCell();
    // Local cell numbering around one node
    const Arcane::Integer iF = iface.index();
    const Integer iK_loc   = NumLocCell[iface->backCell()];
    const Integer iL_loc   = NumLocCell[iface->frontCell()];
    // Local face numbering 
    const Arcane::IntegerArray& iF_loc_K = NumLocfacesbyCell[iK_loc];
    const Arcane::IntegerArray& iF_loc_L = NumLocfacesbyCell[iL_loc];
    const Integer nbfaceK =  iF_loc_K.size();
    const Integer nbfaceL =  iF_loc_L.size();

    for(Integer jF = 0 ; jF < nbfaceK ; ++jF){
      A(iF, iF_loc_K[jF]) += Fluxes[iK_loc][iF][jF];
    }

    for(Integer jF = 0 ; jF < nbfaceL ; ++jF){
      A(iF, iF_loc_L[jF]) -= Fluxes[iL_loc][iF][jF];
    }

    B(iF,iK_loc) = - Fluxes[iK_loc][iF][nbfaceK];
    B(iF,iL_loc) =   Fluxes[iL_loc][iF][nbfaceL];
  }
  
  // bool switch_to_two_point = false;
  {
    PermutationMatrix P(nbface);
    Integer success = Numerics::lu_factorize(A, P, m_epsilon);

    if(success != 0) {
      debug() << "O-stencil leading to a singular matrix for node "
              << node.localId()
              << ". falling back to two-points scheme";
#ifdef ARCANE_DEBUG
      (*m_degenerate_nodes)[node] = 1;
#endif /* ARCANE_DEBUG */
      //switch_to_two_point = true;
      return true;
    } else {
      lu_substitute(A, P, B);
    }
  } 
  {
    for(Integer iF = 0; iF < node.nbFace(); ++iF){
      const Face & F = node.face(iF);
      const Cell& K  = F.backCell();
      //numero locale de la maille autour du noeud
      Integer iK_loc   = NumLocCell[K];
      Arcane::IntegerArray& face_local = NumLocfacesbyCell[iK_loc];
      Integer nbfaceK =  face_local.size();

      // Update flux through F
      for (Integer jF = 0 ; jF < nbfaceK ; ++jF) {
        for(Integer iL = 0 ; iL < nbcell ; ++iL) {
          const Cell& L = node.cell(iL);
          // Add the contribution from L
          cell_ca_builder.sum(F, L, Fluxes[iK_loc][iF][jF]*B(face_local[jF], iL));
        }
      }
      cell_ca_builder.sum(F, K, Fluxes[iK_loc][iF][nbfaceK]);
    }
  }

  return false;
}

/*----------------------------------------------------------------------------*/

template<typename VariableTypeT>
void 
OptimizedDivKGradOSchemeService::
_computeTwoPointBoundaryConditions(const Node& node,
                                   const VariableTypeT& kappa,
                                   DirectCoefficientArrayBuilderT<Cell>::Inserter& cell_ca_builder,
                                   DirectCoefficientArrayBuilderT<Face>::Inserter& face_ca_builder)
{
  typedef typename VariableTraitsT<VariableTypeT>::DataType DiffusionType;

  int nbface = node.nbFace();
  // int nbmaille = node.nbCell();

  for(Integer iface=0;iface<nbface;++iface) {
    const Face& face = node.face(iface);

    Real3 nF          =  (*m_f_normals)[face];
    const Real3& xa   =  (*m_f_centers)[face];

    if(face.isSubDomainBoundary()){ // Two-point method for boundary faces
      const Cell& K = face.boundaryCell();
      const DiffusionType & kappa_K   = kappa[K];
      const Real3& xK   = (*m_c_centers)[K];

      const Real dKa    = math::abs(math::scaMul(xa-xK,nF));//distance de xK a la face
      const Real dK_A    = math::sqrt(math::scaMul(xa-xK,xa-xK));//distance de xK a xa
      const Real norme_nF = math::sqrt(math::scaMul(nF,nF));

      const Real tK     = math::scaMul(nF, DiscreteOperator::tensor_vector_prod<DiffusionType>::eval(kappa_K, nF)) / (dKa);
      Real cosO   = math::abs(math::scaMul(xa-xK,nF))/(dK_A * norme_nF);
      cosO *= cosO ;

      // Compute transmissivities
      const Real tau = tK  * cosO / face.nbNode();
      cell_ca_builder.sum(face, K, tau);
      face_ca_builder.subtract(face, face, tau);
    } else { // Try to extend MP method for non-boundary faces
      // Count the number of inner nodes
      Integer number_of_inner_nodes = 0;
      ENUMERATE_NODE(iP, face.nodes()) {
        const Node & P = *iP;
        bool is_inner_node = true;
        ENUMERATE_FACE(iF, P.faces()) {
          if(iF->isSubDomainBoundary()) {
            is_inner_node = false;
            break;
          }
        }
        if(is_inner_node)
          number_of_inner_nodes++;
      }

      if(number_of_inner_nodes > 0) { // Extend MP method
        Integer number_of_boundary_nodes = face.nbNode() - number_of_inner_nodes;
        // Adjusting factor
        Real adjusting_factor = std::pow((Real)face.nbNode() / (Real)number_of_inner_nodes, 1./number_of_boundary_nodes);
        // Extend MP method
        cell_ca_builder.multiply(face, adjusting_factor);
      } else { // Fall back to TP method
        const Cell& K   = face.backCell();
        const Cell& L   = face.frontCell();
        const DiffusionType & kappa_K   = kappa[K];
        const DiffusionType & kappa_L   = kappa[L];
        const Real3& xK   = (*m_c_centers)[K];
        const Real3& xL   = (*m_c_centers)[L];
        const Real dKa    = math::abs(math::scaMul(xa-xK,nF));//distance de xK a la face
        const Real dLa    = math::abs(math::scaMul(xa-xL,nF));//distance de xL a la face
        const Real dKL    = math::sqrt(math::scaMul(xL-xK,xL-xK));
        const Real norme_nF = math::sqrt(math::scaMul(nF,nF));

        const Real tK     = math::scaMul(nF, DiscreteOperator::tensor_vector_prod<DiffusionType>::eval(kappa_K, nF)) / (dKa * norme_nF);
        const Real tL     = math::scaMul(nF, DiscreteOperator::tensor_vector_prod<DiffusionType>::eval(kappa_L, nF)) / (dLa * norme_nF);


        Real cosO   = math::abs(math::scaMul(xL-xK,nF))/(dKL * norme_nF);
        cosO *= cosO ;
        // Compute transmissivities
        const Real tau = tK * tL * norme_nF * cosO /((tK + tL) * face.nbNode());

        cell_ca_builder.sum(face, K, tau);
        cell_ca_builder.subtract(face, L, tau);
      }
    }
  }
}

/*----------------------------------------------------------------------------*/

template<typename VariableTypeT>
void 
OptimizedDivKGradOSchemeService::
_computeStandardTwoPointBoundaryConditions(const Node& node,
                                           const VariableTypeT& kappa,
                                           DirectCoefficientArrayBuilderT<Cell>::Inserter& cell_ca_builder,
                                           DirectCoefficientArrayBuilderT<Face>::Inserter& face_ca_builder)
{
  typedef typename VariableTraitsT<VariableTypeT>::DataType DiffusionType;

  int nbface = node.nbFace();
  
  for(Integer iface=0;iface<nbface;++iface) {
    const Face& face = node.face(iface);

    Real3 nF          =  (*m_f_normals)[face];
    const Real3& xa   =  (*m_f_centers)[face];

    if(face.isSubDomainBoundary()){ // Two-point method for boundary faces
      const Cell& K = face.boundaryCell();
      const DiffusionType & kappa_K   = kappa[K];
      const Real3& xK   = (*m_c_centers)[K];

      const Real dKa    = math::abs(math::scaMul(xa-xK,nF));//distance de xK a la face
      const Real tK     = math::scaMul(nF, DiscreteOperator::tensor_vector_prod<DiffusionType>::eval(kappa_K, nF)) / (dKa);

      // Compute transmissivities
      const Real tau = tK / face.nbNode();
      cell_ca_builder.sum(face, K, tau);
      face_ca_builder.subtract(face, face, tau);
    } else { // Try to extend MP method for non-boundary faces
      // Count the number of inner nodes
      Integer number_of_inner_nodes = 0;
      ENUMERATE_NODE(iP, face.nodes()) {
        const Node & P = *iP;
        bool is_inner_node = true;
        ENUMERATE_FACE(iF, P.faces()) {
          if(iF->isSubDomainBoundary()) {
            is_inner_node = false;
            break;
          }
        }
        if(is_inner_node)
          number_of_inner_nodes++;
      }

      if(number_of_inner_nodes > 0) { // Extend MP method
        Integer number_of_boundary_nodes = face.nbNode() - number_of_inner_nodes;
        // Adjusting factor
        Real adjusting_factor = std::pow((Real)face.nbNode() / (Real)number_of_inner_nodes, 1./number_of_boundary_nodes);
        // Extend MP method
        cell_ca_builder.multiply(face, adjusting_factor);
      } else { // Fall back to TP method
        const Cell& K   = face.backCell();
        const Cell& L   = face.frontCell();
        const DiffusionType & kappa_K   = kappa[K];
        const DiffusionType & kappa_L   = kappa[L];
        const Real3& xK   = (*m_c_centers)[K];
        const Real3& xL   = (*m_c_centers)[L];
        const Real dKa    = math::abs(math::scaMul(xa-xK,nF));//distance de xK a la face
        const Real dLa    = math::abs(math::scaMul(xa-xL,nF));//distance de xL a la face
        const Real norme_nF = math::sqrt(math::scaMul(nF,nF));

        const Real tK     = math::scaMul(nF, DiscreteOperator::tensor_vector_prod<DiffusionType>::eval(kappa_K, nF)) / (dKa * norme_nF);
        const Real tL     = math::scaMul(nF, DiscreteOperator::tensor_vector_prod<DiffusionType>::eval(kappa_L, nF)) / (dLa * norme_nF);

        // Compute transmissivities
        const Real tau = tK * tL * norme_nF /((tK + tL) * face.nbNode());

        cell_ca_builder.sum(face, K, tau);
        cell_ca_builder.subtract(face, L, tau);
      }
    }
  }
}

/*----------------------------------------------------------------------------*/

template<typename VariableTypeT>
void 
OptimizedDivKGradOSchemeService::
_computeOSchemeBoundaryConditions(const Node& node,
                                  Arcane::VariableCellInteger & NumLocCell,
                                  Arcane::SharedArray<Arcane::IntegerSharedArray>& NumLocfacesbyCell,
                                  Arcane::Real3SharedArray2& Gradient,
                                  const VariableTypeT& kappa,
                                  DirectCoefficientArrayBuilderT<Cell>::Inserter& cell_ca_builder,
                                  DirectCoefficientArrayBuilderT<Face>::Inserter& face_ca_builder)
{
  Integer nbface = node.nbFace();
  Integer nbcell = node.nbCell();
  Integer N = m_mesh->dimension(); //space dimension

  typedef typename VariableTraitsT<VariableTypeT>::DataType DiffusionType;

  RealMatrix A = ZeroMatrix(nbface, nbface);
  RealMatrix B = ZeroMatrix(nbface, nbcell);
  RealMatrix C = ZeroMatrix(nbface, nbface);

  // Multiply gradients by kappa
  SharedArray2<Real3> kappa_gradient(node.nbCell(),node.nbFace()+1);
  for (Integer i = 0 ; i < node.nbCell() ; i++){
    const Cell & K = node.cell(i);
    const DiffusionType & kappa_K = kappa[K];
    for (Integer j = 0 ; j < node.nbFace()+1; j++){
      kappa_gradient[i][j] = DiscreteOperator::tensor_vector_prod<DiffusionType>::eval(kappa_K, Gradient[i][j]);
    }
  }

  // Find maximum number of faces
  Integer max_nb_local_faces=0;
  for(Integer i=0; i<nbcell; i++) {
    const Arcane::IntegerArray& face_local = NumLocfacesbyCell[i];
    if(face_local.size() > max_nb_local_faces)
      max_nb_local_faces = face_local.size();
  }
  // Initialize multi array for fluxes
  boost::multi_array<Real, 3> Fluxes(boost::extents[nbcell][nbface][max_nb_local_faces+1]);
  
  // Retrieve the normals
  SharedArray<Real3> normals(nbface);
  for (Integer i = 0 ; i < nbface ; i++){
    const Face& face  = node.face(i);
    normals[i] = (*m_f_normals)[face];
    if (face.isSubDomainBoundary() && (!face.isSubDomainBoundaryOutside()))
      normals[i] = -normals[i];
  }

  // Build the fluxes in terms of face variables and one cell variable
  for (Integer icell = 0 ; icell < nbcell ; icell++){
    const Cell & K = node.cell(icell);
    Integer mK = NumLocCell[K];
    Arcane::IntegerArray& face_local = NumLocfacesbyCell[mK];
    Integer nbfaceK =  face_local.size();

    // Main part of the flux
    for (Integer i = 0 ; i < nbfaceK ; ++i){  // Loop over the faces of cell sharing the node (rows of the matrix)
      Integer numloc_face = face_local[i];
      const Face & face = node.face(numloc_face);
      for (Integer j = 0 ; j <= nbfaceK ; j++)
        Fluxes[icell][numloc_face][j]  = -math::scaMul(kappa_gradient[mK][j], normals[numloc_face]) / face.nbNode();// We divide by the number of nodes
    }

    // Add the residual terms for the cells with more than 3 (in 3D) faces sharing a node
    if (nbfaceK != N){
      //calculate the residuals
      SharedArray2<Real> Resid(nbfaceK, nbfaceK+1);
      SharedArray<Real3> dK_sigma(nbfaceK);
      const Real3 xK = (*m_c_centers)[K];
      Resid.fill(0.);
      for (Integer i = 0 ; i < nbfaceK ; i++){
        Integer numloc_face = face_local[i];
        const Face & face = node.face(numloc_face);
        dK_sigma[i] = ((*m_f_centers)[face] - xK);
      }
      for (Integer i = 0 ; i < nbfaceK ; i++){
        Resid[i][i] =1.;
        Resid[i][nbfaceK] = -1.;
        for (Integer j = 0 ; j <= nbfaceK ; j++){
          Resid[i][j] -= math::scaMul(Gradient[mK][j] , dK_sigma[i]);
        }
      }
      //calculation of the term with the sum
      SharedArray<Real3> sum(nbfaceK+1);
      sum.fill(Real3(0.,0.,0.));
      for (Integer i = 0 ; i <= nbfaceK ; i++)
        for (Integer j = 0 ; j < nbfaceK ; j++)
          sum[i] += Resid[j][i] / dK_sigma[j].abs2() * dK_sigma[j];
      //Add the additional terms
      const DiffusionType & kappa_K = kappa[K];
      Real alpha = DiscreteOperator::MinimumEigenvalue::compute(kappa_K);
      Real m_Ks = 0;
      for (Integer i = 0 ; i < nbfaceK ; i++){
        Integer numloc_face = face_local[i];
        const Face & face = node.face(numloc_face);
        m_Ks += (*m_f_measures)[face] / face.nbNode() * dK_sigma[i].abs();
      }
      m_Ks /= N;
      Real coef = alpha * m_Ks;
      for (Integer i = 0 ; i < nbfaceK ; i++){
        Integer numloc_face = face_local[i];
        const Face & face = node.face(numloc_face);
        for (Integer j = 0 ; j <= nbfaceK ; j++)
          Fluxes[icell][numloc_face][j] -= coef * (Resid[i][j] / dK_sigma[i].abs2() - math::scaMul(Gradient[mK][i], sum[j])  ) / face.nbNode();// We divide by the number of nodes
      }
    }
  }

  // Construct the matrices ensuring the flux continuity
  for(Integer iface = 0 ; iface < nbface ; ++iface){
    const Face& face  = node.face(iface);
    if(face.isSubDomainBoundary()){
      A(iface, iface) = 1.0;
      C(iface, iface) = 1.0;
    }
    else{
      const Cell& K = face.backCell();
      const Cell& L = face.frontCell();
      //numerotation locale des mailles autour du noeud
      Integer mK = NumLocCell[K];
      Integer mL = NumLocCell[L];
      Arcane::IntegerArray& face_localK = NumLocfacesbyCell[mK];
      Arcane::IntegerArray& face_localL = NumLocfacesbyCell[mL];
      Integer nbfaceK =  face_localK.size();
      Integer nbfaceL =  face_localL.size();
      for(Integer i = 0 ; i < nbfaceK ; ++i){
        Integer numloc_face = face_localK[i];
        A(iface, numloc_face) += Fluxes[mK][iface][i] ;
      }
      for(Integer i = 0 ; i < nbfaceL ; ++i){
        Integer numloc_face = face_localL[i];
        A(iface, numloc_face) -= Fluxes[mL][iface][i] ;
      }
      B(iface, mK) = - Fluxes[mK][iface][nbfaceK] ;
      B(iface, mL) =   Fluxes[mL][iface][nbfaceL] ;
    }
  }

  {
    PermutationMatrix P(nbface);
    Integer success = Numerics::lu_factorize(A, P, m_epsilon);
    if(success!=0)
      fatal() << "Fatal error in O boundary computation";
    lu_substitute(A, P, B);
    lu_substitute(A, P, C);
  }

  // Compute the fluxes in terms of cell and boundary face variables
  for(Integer iface = 0; iface < nbface; ++iface){
    const Face & face = node.face(iface);
    Cell K;
    if(face.isSubDomainBoundary())
      K  = face.boundaryCell();
    else
      K  = face.backCell();
    // Local cell number around the node
    Integer mK   = NumLocCell[K];
    Arcane::IntegerArray& face_local = NumLocfacesbyCell[mK];
    Integer nbfaceK =  face_local.size();

    // Update the flux across the face "face"
    // Loop over the unknowns of the face belonging to the cell K
    for (Integer i = 0 ; i < nbfaceK ; ++i ) {
      // Local face number around the node    
      Integer numloc_face = face_local[i];

      for(Integer icell = 0 ; icell < nbcell ; ++icell) {
        // Retrieve the cell with local number icell
        const Cell& M = node.cell(icell);
        // Add the contribution -inner_prod(prod(kappa, grad), normal)
        cell_ca_builder.sum(face, M, Fluxes[mK][iface][i]*B(numloc_face,icell));
      }
      for(Integer iface_ = 0 ; iface_ < nbface ; ++iface_){
        // Retrieve the cell with local number icell
        const Face& F = node.face(iface_);
        if(F.isSubDomainBoundary()) {
          // Add the face unknown contribution -inner_prod(prod(kappa, gradient), normal)
          face_ca_builder.sum(face, F, Fluxes[mK][iface][i]*C(numloc_face,iface_));
        }
      }
    }
    cell_ca_builder.sum(face, K, Fluxes[mK][iface][nbfaceK]);
  }
}

/*---------------------------------------------------------------------------*/

template<Integer N, typename VariableTypeT>
void 
OptimizedDivKGradOSchemeService::
_formDiscreteOperator(const VariableTypeT & kappa)
{
  ARCANE_ASSERT( (m_status & DiscreteOperatorProperty::S_PREPARED),
                 ("Operator not prepared") );
  
  DirectCoefficientArrayBuilderT<Cell>::Inserter cell_ca_builder(m_cell_coefficients);
  DirectCoefficientArrayBuilderT<Face>::Inserter face_ca_builder(m_face_coefficients);

  typedef typename VariableTraitsT<VariableTypeT>::DataType DiffusionType;

  // Retrieve geometric properties
  m_f_centers  = &m_geometry_mng->getReal3VariableProperty(m_faces, IGeometryProperty::PCenter);
  m_f_normals  = &m_geometry_mng->getReal3VariableProperty(m_faces, IGeometryProperty::PNormal);
  m_f_measures = &m_geometry_mng->getRealVariableProperty(m_faces, IGeometryProperty::PMeasure);
  m_c_measures = &m_geometry_mng->getRealVariableProperty(m_cells, IGeometryProperty::PMeasure);
  m_c_centers  = &m_geometry_mng->getReal3VariableProperty(m_cells, IGeometryProperty::PCenter);

  Integer n_deg_1 = 0; // Number of nodes for which gradient correction is disabled
  Integer n_deg_2 = 0; // Number of nodes for which two-point method is used
  
  SharedArray<IntegerSharedArray> NumLocfacesbyCell;
  Real3SharedArray2 Gradient;
  
  // Internal nodes
  ENUMERATE_NODE(inode, m_internal_nodes) {
    const Node& node = *inode;
    
    NumLocfacesbyCell.resize(node.nbCell());
    
    // Pour chaque maille autour du noeud, on calcule Lambda Gradient
    Gradient.resize(node.nbCell(),node.nbFace()+1);

    _computeLocalConnectivity(node, *(m_cell_numbering), NumLocfacesbyCell);
    
    if(_computeCellGradient<N>(node, NumLocfacesbyCell, Gradient)) {
      debug() << "Error in local gradient computation: Singular matrix. "
              << "Switch to two points";
      
      _enforceTwoPointsFluxConservation(node, kappa, cell_ca_builder);
      
      n_deg_1++;
    
    } else {
      
      if(_enforceFluxConservation(node, *(m_cell_numbering), 
                                  NumLocfacesbyCell, Gradient,
                                  kappa, cell_ca_builder)) {
        
        _enforceTwoPointsFluxConservation(node, kappa, cell_ca_builder);
        
        n_deg_2 ++;
      }
    }
  }
  
  // Boundary faces
  switch(m_type) {
  case TypesDivKGradOLGSchemes::BC_StandardTwoPoints : { // two-point method for boundary nodes
    ENUMERATE_NODE(inode, m_boundary_nodes) {
      const Node& node = *inode;
      _computeStandardTwoPointBoundaryConditions(node, kappa, cell_ca_builder, face_ca_builder);
    }
    break;
  }
  case TypesDivKGradOLGSchemes::BC_TwoPoints : { // two-point method for boundary nodes
    ENUMERATE_NODE(inode, m_boundary_nodes) {
      const Node& node = *inode;
      _computeTwoPointBoundaryConditions(node, kappa, cell_ca_builder, face_ca_builder);
    }
    break;
  }
  case TypesDivKGradOLGSchemes::BC_Oscheme : {   // O-method for boundary nodes

    ENUMERATE_NODE(inode, m_boundary_nodes) {
      const Node& node = *inode;

      //Allocation du vecteur
      NumLocfacesbyCell.resize(node.nbCell());

      Gradient.resize(node.nbCell(),node.nbFace()+1);

      _computeLocalConnectivity(node, *(m_cell_numbering), NumLocfacesbyCell);
      
      if(not _computeCellGradient<N>(node, NumLocfacesbyCell, Gradient)) {
        debug() << "Error in local gradient computation: Singular matrix. "
                << "Gradient correction disabled";
        n_deg_1++;
      }
      
      _computeOSchemeBoundaryConditions(node, *(m_cell_numbering), NumLocfacesbyCell, 
                                        Gradient, kappa, cell_ca_builder, face_ca_builder);
    }
    break;
  }
  default:
    fatal() << "Unknown boundary condition type";
  }

  info() << "Gradient correction disabled in " << n_deg_1 << " nodes";
  info() << "Two-point method used in " << n_deg_2 + n_deg_1 << " nodes";

  // Enhance monotonicity by switching faces with negative diagonal
  // coefficients to two-point
  if ((m_check_sign)or not (m_dtodr<0)) {
    Integer n_face_2pts = 0;
    ENUMERATE_FACE(iface, m_internal_faces) {
      const Face & face = *iface;

      const Cell & K = face.backCell();
      const Cell & L = face.frontCell();

      bool force_two_pts = false;
          
      // Retrieve the transmissivities for back and front cell
      Real tauK = cell_ca_builder.coefficient(face, K);
      Real tauL = cell_ca_builder.coefficient(face, L);
          
      if(tauK <= 0 || tauL >= 0)
        force_two_pts = true;
      else {  
        //on recupere tous les coeffs 
        ArrayView<Integer> cell_stencil_face = m_cell_coefficients->stencilLocalId(face);
        ArrayView<Real> cell_coefficients_face = m_cell_coefficients->coefficients(face);
              
        //coeff hors diag negatif minimum et positif maximum
        const Integer L_lid = L.localId();
        const Integer K_lid = K.localId();
        Real min_offdiag_neg = 0;
        Real max_offdiag_pos = 0;
        for (Integer i=0;i<cell_stencil_face.size();++i) {
          const Real coeff = cell_coefficients_face[i];
          const Integer lid = cell_stencil_face[i];
          if (not(lid == L_lid) and not(lid== K_lid) )
            {
              min_offdiag_neg = math::min(coeff,min_offdiag_neg);
              max_offdiag_pos = math::max(coeff,max_offdiag_pos);
            }
        }
        //tauK >0, offK <=0 ok, max_offdiag_pos a controler 
        if (not (m_dtodr * max_offdiag_pos<tauK))
          force_two_pts = true;
        //tauL <0, offL >=0 ok, min_offdiag_neg a controler
        if (not (m_dtodr * min_offdiag_neg>tauL))
          force_two_pts = true;
      }

      if(force_two_pts) {
        n_face_2pts += 1;
        // Set all coefficients to zero
        cell_ca_builder.reset(face);
        face_ca_builder.reset(face);

        // Compute transmissivity
        Real tau = 0.;
        switch(m_type) {          
        case TypesDivKGradOLGSchemes::BC_StandardTwoPoints:
          tau = TwoPointInterpolator::standardTwoPointInternalTransmissivity(face, 
                                                                             kappa, 
                                                                             m_f_centers, 
                                                                             m_f_normals, 
                                                                             m_f_measures, 
                                                                             m_c_centers);
          break;
        default:
          tau = TwoPointInterpolator::twoPointInternalTransmissivity(face, 
                                                                     kappa, 
                                                                     m_f_centers, 
                                                                     m_f_normals, 
                                                                     m_f_measures, 
                                                                     m_c_centers);
          break;
        } // END case

          // Store flux
        cell_ca_builder.sum(face, K, tau);
        cell_ca_builder.subtract(face, L, tau);
      }
    }
    info() << "Two-point method used in  " << n_face_2pts << " out of "<< m_internal_faces.size() <<" faces";
  }
   
  m_status |= DiscreteOperatorProperty::S_FORMED;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_OPTIMIZEDDIVKGRADOSCHEME(OptimizedDivKGradOScheme,OptimizedDivKGradOSchemeService);
