#include "ArcGeoSim/Utils/Utils.h"
#include "NewtonSolverService.h"
/* Author : desrozis at Tue Mar 31 14:41:47 2009
 * Generated by createNew
 */
#include "ArcGeoSim/Utils/Utils.h"
#include "ArcGeoSim/Mesh/Utils/MeshUtils.h"

#include <arcane/Directory.h>

using namespace Arcane;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

NewtonSolverService::
~NewtonSolverService()
{
  if(m_initialized)
  {
    if(m_default_stop_criteria)
    {
      delete m_stop_criteria;
    }
  }
}

/*---------------------------------------------------------------------------*/

void
NewtonSolverService::
setNonLinearSystemBuilder(INonLinearSystemBuilder * builder)
{
  m_non_linear_system_builder = builder;
}

/*---------------------------------------------------------------------------*/

void
NewtonSolverService::
setVariableUpdater(INonLinearSystemVisitor * updater)
{
  m_variable_updater = updater;
}

/*---------------------------------------------------------------------------*/

void
NewtonSolverService::
setLinearSolver(LocalDirectSolverNamespace::ILinearSolver * solver)
{
  m_linear_solver = solver;
}

void
NewtonSolverService::
setLinearSolver(Alien::ILinearSolver * solver)
{
  m_linear_solver2 = solver;
}

/*---------------------------------------------------------------------------*/

void
NewtonSolverService::
setLinearSystemBuilder(ILinearSystemBuilder * builder)
{
  m_linear_system_builder = builder;
  m_linear_solver->setLinearSystemBuilder(builder);
}


/*---------------------------------------------------------------------------*/

void
NewtonSolverService::
setStopCriteria(INonLinearStopCriteria * stop_criteria)
{
  if(m_default_stop_criteria)
  {
    delete m_stop_criteria;
  }
  m_stop_criteria = stop_criteria;

  m_default_stop_criteria = false;
}

/*---------------------------------------------------------------------------*/

void
NewtonSolverService::
init()
{
  if(m_initialized) return;

  m_max_iteration = options()->maxNewtonIterations();

  if(m_max_iteration == 0)
  {
    fatal() << "Maximum number of newton iteration must be at least one";
  }

  const Real stop_criteria_value = options()->newtonStopCriteriaValue();

  if(m_stop_criteria==NULL)
  {
    fatal() << "NonLinearSolver fatal error : stop criteria is not set";
  }
  else
  {
    m_stop_criteria->setCriteriaValue(stop_criteria_value);
  }

  if(!m_linear_solver&&!m_linear_solver2)
  {
    fatal() << "NonLinearSolver fatal error :Linear Solver is not set";
  }

  if(m_non_linear_system_builder)
  {
    m_non_linear_system_builder->init();
  }
  else
  {
    fatal() << "NonLinearSolver fatal error : Non Linear System Builder is not set";
  }
  m_force_one_linear_step = options()->forceOneLinearStep() ;
  m_output_level = options()->outputLevel();
  m_total_non_linear_solver_iteration = 0;
  m_total_linear_solver_iteration = 0;
  m_total_succeed_resolution = 0;
  m_total_resolution = 0;

  // resize
  m_residual.resize(m_max_iteration);
  m_residual.fill(0.) ;
  m_linear_solver_residual.resize(m_max_iteration);
  m_linear_solver_residual.fill(0.) ;
  m_linear_solver_iteration.resize(m_max_iteration);
  m_linear_solver_iteration.fill(0) ;

  // Cr�ation du dossier output
  m_output_residual = options()->outputResidual();

  // Seul le proc de rang 0 �crit sur le disque
  if(m_output_residual)
  {
    IParallelMng * parallel_mng = subDomain()->parallelMng();

    if(parallel_mng)
    {
      if(parallel_mng->commRank() != 0) m_output_residual = false;
    }
  }

  // Cr�ation du repertoire
  if(m_output_residual)
  {
    String directory_name("courbes/gnuplot/NewtonResidual");

    Directory output_directory(subDomain()->exportDirectory(),directory_name);

    output_directory.createDirectory();

    m_root_file_name = output_directory.path() + "/Newton_Residual_";
  }

  m_initialized = true;
}

/*---------------------------------------------------------------------------*/

void
NewtonSolverService::
start(INonLinearSystem* system)
{
  ARCANE_ASSERT((m_stop_criteria != NULL),("Linear stop criteria pointer null"));

  m_solver_timer.start();
  m_solver_cpu_timer.start();

  m_solver_status.error = 0 ;
  m_solver_status.succeeded = false ;
  m_solver_status.iteration_count = 0 ;

  m_non_linear_system_builder->start(system);
}

/*---------------------------------------------------------------------------*/

void
NewtonSolverService::
end(INonLinearSystem * system)
{
  system->end();

  m_solver_timer.stop();
  m_solver_cpu_timer.stop();

  m_solver_status.iteration_count = m_iteration ;
  m_solver_status.error = m_status ;
  m_solver_status.residual = m_stop_criteria->criteriaValue() ;
  m_solver_status.succeeded = (m_status == Converged) ;


  m_total_non_linear_solver_iteration += m_iteration;

  if(m_status == Converged)
  {
    m_total_succeed_resolution++;
  }


  m_total_resolution++;

  if(m_output_level > 0) _print();

  if(m_output_residual && m_status == Converged) _printResidual();
}

/*---------------------------------------------------------------------------*/

Integer
NewtonSolverService::
_buildNonLinearSystem(INonLinearSystem * system)
{
  m_build_timer.start();
  m_build_cpu_timer.start();

  m_non_linear_system_builder->startStep(system);
  m_non_linear_system_builder->buildNonLinearSystem(system);
  m_non_linear_system_builder->endStep(system);

  m_build_timer.stop();
  m_build_cpu_timer.stop();

  if(m_output_level>0)
  {
    info() << "|-------------------------------------------- |";
    info() << "|Non Linear System Build Information :        |";
    info() << "|-------------------------------------------- |";
    info() << "|      Build Time : " << std::setprecision(6) << std::setw(10) << m_build_timer.lastActivationTime() << "                |";
    info() << "|Total Build Time : " << std::setprecision(6) << std::setw(10) << m_build_timer.totalTime() << "                |";
    info() << "|-------------------------------------------- |";
    info() << "|      Build CPU Time : " << std::setprecision(6) << std::setw(10) << m_build_cpu_timer.lastActivationTime() << "            |";
    info() << "|Total Build CPU Time : " << std::setprecision(6) << std::setw(10) << m_build_cpu_timer.totalTime() << "            |";
    info() << "|-------------------------------------------- |";
  }

  return 0;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

bool
NewtonSolverService::
solve(INonLinearSystem * system)
{
  //if(m_linear_solver)
#ifdef USE_ALIEN_ARCGEOSIM
    return _solve(system,m_linear_solver) ;
#endif
#ifdef USE_ALIEN_V0
    if(m_linear_solver)
      return _solve(system,m_linear_solver);
    else
      return _solve(system,m_linear_solver2) ;
#endif
    //else
#ifdef USE_ALIEN_V1
    if(m_linear_solver)
      return _solve(system,m_linear_solver);
    else
      return _solve(system,m_linear_solver2) ;
#endif

#ifdef USE_ALIEN_V2
    if(m_linear_solver)
      return _solve(system,m_linear_solver);
    else
      return _solve(system,m_linear_solver2) ;
#endif

}

bool
NewtonSolverService::
_solve(INonLinearSystem * system, Alien::ILinearSolver* solver)
{
  m_status = NotConverged;

  // Initialisation
  start(system);
  //solver->start();

  // Calcul de F(X0) et J(X0)
  _buildNonLinearSystem(system);

  m_iteration = 0;

  // Norme du residu
  if(!m_force_one_linear_step)
  {
    switch(_stop(system,m_residual[0]))
    {
    case 0 :
      {
        m_status = Converged;

        end(system);

        return true;
      }
    case 1 :
      {
        m_status = InitialGuessError;

        end(system);

        return false;
      }
    }
  }

  // R�solution de J0 R0 = F0
  if(solver->solve(system->getMatrix(),system->getRHS(),system->getSolution()))
  {
    const IBaseLinearSolver::Status& status = solver->getStatus();

    m_linear_solver_residual[0]      = status.residual;
    m_linear_solver_iteration[0]     = status.iteration_count;
    m_total_linear_solver_iteration += status.iteration_count;

    system->updateLinearSolution();
    Integer error = _updateVariable(system) ;
    solver->end();
    if(error)
    {
      m_status = PhysicalError;
      end(system);

      info()<<"A physical error has occured";
      return false;
    }
    else
      system->end() ;
  }
  else
  {
    m_status = LinearSolverError;

    end(system);

    return false;
  }

  m_iteration++;

  while(m_iteration < m_max_iteration)
  {
    m_linear_solver_residual[m_iteration] = m_linear_solver_iteration[m_iteration] = 0.;

    // Preparation du syst�me lin�aire
    //solver->start();

    // Calcul de F(Xk) et J(Xk)
    _buildNonLinearSystem(system);

    // Norme du residu
    switch(_stop(system,m_residual[m_iteration]))
    {
    case 0 :
      {
        m_status = Converged;

        end(system);

        return true;
      }
    case 1 :
      {
        m_status = PhysicalError;

        end(system);

        return false;
      }
    }

    // R�solution de Jk Rk = Fk
    if(solver->solve(system->getMatrix(),system->getRHS(),system->getSolution()))
    {
      const IBaseLinearSolver::Status& status = solver->getStatus();

      m_linear_solver_residual[m_iteration]  = status.residual;
      m_linear_solver_iteration[m_iteration] = status.iteration_count;
      m_total_linear_solver_iteration       += status.iteration_count;

      system->updateLinearSolution();
      Integer error = _updateVariable(system) ;
      solver->end();
      if(error)
      {
        m_status = PhysicalError;

        end(system);

        return false;
      }
      else
        system->end() ;
    }
    else
    {
      m_status = LinearSolverError;

      end(system);

      return false;
    }

    if(m_output_level > 1) _printIteration();

    m_iteration++;
  }

  m_iteration--;

  m_status = NotConverged;

  end(system);

  return false;
}

bool
NewtonSolverService::
_solve(INonLinearSystem * system, LocalDirectSolverNamespace::ILinearSolver* solver)
{
  m_status = NotConverged;

  // Initialisation
  start(system);
  solver->start();

  // Calcul de F(X0) et J(X0)
  _buildNonLinearSystem(system);
  
  m_iteration = 0;

  // Norme du residu
  if(!m_force_one_linear_step)
  {
    switch(_stop(system,m_residual[0]))
    {
    case 0 :
      {
        m_status = Converged;

        end(system);

        return true;
      }
    case 1 :
      {
        m_status = InitialGuessError;

        end(system);

        return false;
      }
    }
  }

  // Preparation du syst�me lin�aire
  solver->buildLinearSystem();

  // R�solution de J0 R0 = F0
  if(solver->solve())
  {
    const LocalDirectSolverNamespace::ILinearSolver::Status& status = solver->getStatus();

    m_linear_solver_residual[0]      = status.residual;
    m_linear_solver_iteration[0]     = status.iteration_count;
    m_total_linear_solver_iteration += status.iteration_count;

    if(!solver->getSolution())
      fatal() << "Error while getting the solution of the linear solver";
    solver->end();

    if(_updateVariable(system))
    {
      m_status = PhysicalError;
      end(system);

      info()<<"A physical error has occured";
      return false;
    }
  }
  else
  {
    m_status = LinearSolverError;

    solver->end();

    end(system);

    return false;
  }

  m_iteration++;

  while(m_iteration < m_max_iteration)
  {
    m_linear_solver_residual[m_iteration] = m_linear_solver_iteration[m_iteration] = 0.;

    // Preparation du syst�me lin�aire
    solver->start();

    // Calcul de F(Xk) et J(Xk)
    _buildNonLinearSystem(system);

    // Norme du residu
    switch(_stop(system,m_residual[m_iteration]))
    {
    case 0 :
      {
        m_status = Converged;

        end(system);

        return true;
      }
    case 1 :
      {
        m_status = PhysicalError;

        end(system);

        return false;
      }
    }

    solver->buildLinearSystem();

    // R�solution de Jk Rk = Fk
    if(solver->solve())
    {
      const LocalDirectSolverNamespace::ILinearSolver::Status& status = solver->getStatus();

      m_linear_solver_residual[m_iteration]  = status.residual;
      m_linear_solver_iteration[m_iteration] = status.iteration_count;
      m_total_linear_solver_iteration       += status.iteration_count;

      solver->getSolution();
      solver->end();

      if(_updateVariable(system))
      {
        m_status = PhysicalError;

        end(system);

        return false;
      }
    }
    else
    {
      m_status = LinearSolverError;

      solver->end();

      end(system);

      return false;
    }

    if(m_output_level > 1) _printIteration();

    m_iteration++;
  }

  m_iteration--;

  m_status = NotConverged;

  end(system);

  return false;
}

bool
NewtonSolverService::
solveOpt(INonLinearSystem * system)
{
  m_status = NotConverged;

  // Initialisation
  _start(system);
  m_linear_solver->start();

  // Calcul de F(X0) et J(X0)
  m_non_linear_system_builder->buildLinearizedSystem(system);

  m_iteration = 0;

  if(!m_force_one_linear_step)
  {
    // Norme du residu
    switch(_stop(system))
    {
    case 0 :
      {
        m_status = Converged;
        _end(system);
        return true;
      }
    case 1 :
      {
        m_status = InitialGuessError;
        _end(system);
        return false;
      }
    }
  }

  // Preparation du syst�me lin�aire
  m_linear_solver->buildLinearSystem();

  // R�solution de J0 R0 = F0
  if(m_linear_solver->solve())
  {
    m_linear_solver->getSolution();
    m_linear_solver->end();

    if(_updateVariable(system))
    {
      m_status = PhysicalError;
      _end(system);
      return false;
    }
  }
  else
  {
    m_status = LinearSolverError;
    m_linear_solver->end();
    end(system);
    return false;
  }

  for(m_iteration=1;m_iteration < m_max_iteration;++m_iteration)
  {
   // Preparation du syst�me lin�aire
    m_linear_solver->start();

    // Calcul de F(Xk) et J(Xk)
    m_non_linear_system_builder->buildLinearizedSystem(system);

    // Norme du residu
    switch(_stop(system))
      {
    case 0 :
      {
        m_status = Converged;
        _end(system);
        return true;
      }
    case 1 :
      {
        m_status = PhysicalError;
        _end(system);
        return false;
      }
    }

    m_linear_solver->buildLinearSystem();

    // R�solution de Jk Rk = Fk
    if(m_linear_solver->solve())
    {
      //const ILinearSolver::Status& status = m_linear_solver->getStatus();

      m_linear_solver->getSolution();
      m_linear_solver->end();

      if(_updateVariable(system))
      {
        m_status = PhysicalError;
        _end(system);
        return false;
      }
    }
    else
    {
      m_status = PhysicalError;
      m_linear_solver->end();
      _end(system);
      return false;
    }
  }
  m_iteration--;
  m_status = NotConverged;
  _end(system);
  return false;
}


/*---------------------------------------------------------------------------*/

UInt32
NewtonSolverService::
_stop(INonLinearSystem * system, Real& criteria)
{
  Integer status = system->accept(m_stop_criteria);

  criteria = m_stop_criteria->criteriaValue();

  return status;
}

/*---------------------------------------------------------------------------*/

void
NewtonSolverService::
_printIteration() const
{
  info() << "--------------------------------------------------";
  info() << "Iteration Newton no : " << m_iteration;
  info() << "Solver residual     : " << m_residual[m_iteration];
  info() << "Solver num iter     : " << m_linear_solver_iteration[m_iteration];
}

/*---------------------------------------------------------------------------*/

void
NewtonSolverService::
_print() const
{
  info() << "|---------------------------------------------|";
  info() << "|Non Linear Solver Information :              |";
  switch(m_status)
  {
  case LinearSolverError :
      {
        info() << "| ERROR  : "  << "       |";
        break;
      }
  case Converged :
    {
      info() << "| Number of iteration  : " << std::setw(6) << m_iteration <<"               |";
      info() << "| Final Residual       : " << std::setprecision(8) << std::setw(14) << m_residual[m_iteration] << "       |";
      break;
    }
  case NotConverged :
    {
      info() << "|No convergence :                             |";
      info() << "|Maximum number of Newton iteration           |";
      info() << "|has been reached                             |";
      break;
    }
  case PhysicalError :
    {
      info() << "|PHYSICAL ERROR                      |";
      break;
    }
  case InitialGuessError :
    {
      info() << "|INITIAL GUESS ERROR                      |";
      break;
    }
  }
  info()<<"|---------------------------------------------|";

  if(m_output_level > 1 && m_iteration > 0)
  {
    info()<<"|---------------------------------------------|";
    info()<<"|Iter  | NewtRes    | SolvRes    | SolvNiter  |";
    info()<<"|     0|" << std::setw(12) << std::setprecision(6) <<  m_residual[0] << "|  xxxxxxx   | xxxxxxxxx  |";
    for(Integer iter = 0 ; iter < m_iteration; ++iter)
    {
      info() << "|" << std::setw(6) << iter
             << "|" << std::setw(12) << std::setprecision(6) << m_residual[iter+1]
             << "|" << std::setw(12) << std::setprecision(6) << m_linear_solver_residual[iter]
             << "|" << std::setw(6) << m_linear_solver_iteration[iter]
             << "      |";
    }
    info()<<"|---------------------------------------------|";
  }
}

/*---------------------------------------------------------------------------*/

void
NewtonSolverService::
printInfo()
{
#if defined USE_ALIEN_ARCGEOSIM || defined USE_ALIEN_V0
  info() << "|------------------------------------------------|";
  info() << "| Non Linear Solver Information :                |";
  info() << "|------------------------------------------------|";
  info() << "| Number of resolution                |" << std::setw(10) << m_total_resolution << "|";
  info() << "| Number of succesfull resolution     |" << std::setw(10) << m_total_succeed_resolution << "|";
  info() << "| Number of failed resolution         |" << std::setw(10) << m_total_resolution-m_total_succeed_resolution << "|";
  info() << "| Total number of non linear steps    |" << std::setw(10) << m_total_non_linear_solver_iteration << "|";
  info() << "| Total number of linear solver steps |" << std::setw(10) << m_total_linear_solver_iteration << "|";
  info() << "|------------------------------------------------|";
  info() << "| Total system build time             |" << std::setw(10) << m_build_timer.totalTime() << "|";
  info() << "| Total solver time                   |" << std::setw(10) << m_solver_timer.totalTime() << "|";
  info() << "|------------------------------------------------|";
  info() << "|------------------------------------------------|";
  info() << "| Total system build cpu time         |" << std::setw(10) << m_build_cpu_timer.totalTime() << "|";
  info() << "| Total solver cpu time               |" << std::setw(10) << m_solver_cpu_timer.totalTime() << "|";
  info() << "|------------------------------------------------|";
  IInfoModel* solver_ptr = dynamic_cast<IInfoModel*> ( m_linear_solver ) ;
  if(solver_ptr)
    solver_ptr->printInfo() ;
#endif
}

/*---------------------------------------------------------------------------*/

void
NewtonSolverService::
_printResidual() const
{
  std::stringstream file_name;

  file_name << m_root_file_name.localstr() << m_total_succeed_resolution;

  std::ofstream file(file_name.str().c_str());

  file.precision(16);

  for(Integer i=0; i<m_iteration; ++i)
  {
    file << m_total_non_linear_solver_iteration-m_iteration+i << " " << m_residual[i] << "\n";
  }

  file.close();
}


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_NEWTONSOLVER(NewtonSolver,NewtonSolverService);
