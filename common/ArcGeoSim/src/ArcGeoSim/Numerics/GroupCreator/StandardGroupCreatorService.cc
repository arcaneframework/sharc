// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
/* Author : haeberlf at Fri Feb 20 11:24:08 2009
 * Generated by createNew
 */

#include "StandardGroupCreatorService.h"

#include <arcane/Directory.h>
#include <arcane/IVariableMng.h>
#include <boost/shared_ptr.hpp>

#include "ArcGeoSim/Utils/Utils.h"
#include "ArcGeoSim/Utils/ItemTools.h"
#include "ArcGeoSim/Utils/ItemGroupBuilder.h"
#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"
#include "ArcGeoSim/Mesh/Geometry/IGeometry2DMng.h"
#include "ArcGeoSim/Mesh/Geometry/ManualUpdateGeometryPolicy.h"

#include "ArcGeoSim/Numerics/Expressions/IExpressionMng.h"
#include "ArcGeoSim/Numerics/Expressions/IFunctionR3vR1.h"
#include "ArcGeoSim/Numerics/Expressions/ExpressionBuilder/ExpressionBuilderR3vR1Core.h"
#include "ArcGeoSim/Numerics/Expressions/IFunctionR2vR1.h"
#include "ArcGeoSim/Numerics/Expressions/ExpressionBuilder/ExpressionBuilderR2vR1Core.h"

#include "ArcGeoSim/Appli/IAppServiceMng.h"
#include "ArcGeoSim/Numerics/GroupCreator/IGroupCreator.h"
#include "ArcGeoSim/Physics/Units/IUnitsSystem.h"

#include <cmath>

using namespace Arcane;

#define PI 3.1416

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
StandardGroupCreatorService::
init()
{
  IAppServiceMng * app_service_mng = IAppServiceMng::instance(subDomain()->serviceMng());

  m_geometry_service = app_service_mng->find<IGeometryMng>(true);

  IUnitsSystem* units_system = app_service_mng->find<IUnitsSystem>(false) ;
  if(units_system)
    {
      m_unit_X = units_system->getMultFactor(IUnitsSystemProperty::X) ;
      m_unit_Y = units_system->getMultFactor(IUnitsSystemProperty::Y) ;
      m_unit_Z = units_system->getMultFactor(IUnitsSystemProperty::Z) ;
    }

  // Acces  aux gestionnaires globaux et locaux pour constante ou autre expression (NULL sinon)
  m_expression_mng = app_service_mng->find<IExpressionMng>(true) ;

  m_local_expression_mng = NULL;

  m_function_parser.init(m_expression_mng, m_local_expression_mng, traceMng());

  m_scalar_eval= options()->scalarEval();

  m_verbose = options()->verbose();

  m_filter_cell_tolerance = options()->filterCellTolerance();
  m_filter_face_tolerance = options()->filterFaceTolerance();

  // On cr���e des groupes vides car potentiellement utilis���s dans
  // d'autres services (Par exemple les conditions limites)
  // On a donc besoin qu'ils existent afin d'y faire porter
  // des propri���t���s g���om���triques

  // Create empty cell groups
  for(int i_cell_group = 0; i_cell_group < options()->cellgroup.size(); ++i_cell_group)
    {
      const String cell_group_name = options()->cellgroup[i_cell_group]->name();

      if(m_verbose) info() << "Create empty cell group named " << cell_group_name;

      ItemGroupBuilder<Cell> cell_group_builder(mesh(), cell_group_name);

      cell_group_builder.buildGroup();
    }

  // Create empty face groups
  for(int i_face_group = 0; i_face_group < options()->facegroup.size(); ++i_face_group)
    {
      const String face_group_name = options()->facegroup[i_face_group]->name();

      if(m_verbose) info() << "Create empty face group named " << face_group_name;

      ItemGroupBuilder<Face> face_group_builder(mesh(), face_group_name);

      face_group_builder.buildGroup();
    }
}

/*---------------------------------------------------------------------------*/

void
StandardGroupCreatorService::
prepare()
{
  m_geometry_service->addItemGroupProperty(allCells(), IGeometryProperty::PCenter, IGeometryProperty::PVariable);
  m_geometry_service->addItemGroupProperty(allFaces(), IGeometryProperty::PCenter, IGeometryProperty::PVariable);
  m_geometry_service->addItemGroupProperty(allFaces(), IGeometryProperty::PNormal, IGeometryProperty::PVariable);

  IGeometryPolicy *geometryPolicy = new ManualUpdateGeometryPolicy;
  m_geometry_service->setPolicyTolerance(true);
  m_geometry_service->update(geometryPolicy);
  delete geometryPolicy;
}

/*---------------------------------------------------------------------------*/

void
StandardGroupCreatorService::
apply()
{
  if(m_verbose) info() << "Apply Group Creator Service";

  m_timer_groupcreator_create.start();

  switch(m_geometry_service->dimension())
  {
  case IGeometryMng::Dimension::e2Dxy :
    create2DCellGroups();
    create2DFaceGroups();
    break ;
  case IGeometryMng::Dimension::e3Dxyz :
  default :
    createCellGroups();
    createFaceGroups();
    break ;
  }

  m_timer_groupcreator_create.stop();

  if(m_verbose) info() << "Group Creator Service Done";

  if (not options()->groupOutputDirectory().empty())
    {
      Directory output_directory = Directory(subDomain()->exportDirectory(),options()->groupOutputDirectory());
      output_directory.createDirectory();
      
      IPostProcessorWriter* post_processor = options()->groupOutputFormat();
      post_processor->setBaseDirectoryName(output_directory.path());
      RealSharedArray times; times.add(0);
      post_processor->setTimes(times);
      ItemGroupList groups;
      groups.add(mesh()->allCells());
      groups.add(mesh()->allFaces());
      post_processor->setGroups(groups);
      SharedArray<boost::shared_ptr<MeshVariableRef> > allocated_vars;
      VariableList variables;
      for(Integer i=0; i<options()->cellgroup.size(); ++i)
        {
          String group_name = options()->cellgroup[i]->name();
          CellGroup group = mesh()->cellFamily()->findGroup(group_name);
          VariableCellReal * var = new VariableCellReal(Arcane::VariableBuildInfo(mesh(),
                                                                                  String("CellGroup_")+group_name,
                                                                                  mesh()->cellFamily()->name(),
                                                                                  Arcane::IVariable::PNoDump|Arcane::IVariable::PNoNeedSync|IVariable::PNoRestore));
          allocated_vars.add(boost::shared_ptr<MeshVariableRef>(var));
          variables.add(var->variable());
          var->fill(0.);
          var->fill(1.,group);
        }
      for(Integer i=0; i<options()->facegroup.size(); ++i)
        {
          String group_name = options()->facegroup[i]->name();
          FaceGroup group = mesh()->faceFamily()->findGroup(group_name);
          VariableFaceReal * var = new VariableFaceReal(Arcane::VariableBuildInfo(mesh(),
                                                                                  String("FaceGroup_")+group_name,
                                                                                  mesh()->faceFamily()->name(),
                                                                                  Arcane::IVariable::PNoDump|Arcane::IVariable::PNoNeedSync|IVariable::PNoRestore));
          allocated_vars.add(boost::shared_ptr<MeshVariableRef>(var));
          variables.add(var->variable());
          var->fill(0.);
          var->fill(1.,group);
        }
      post_processor->setVariables(variables);
      IVariableMng * vm = subDomain()->variableMng();
      vm->writePostProcessing(post_processor);
      if(m_verbose) info() << "Group Creator Post-processing done in " << output_directory.path();
    }


  reportTimer();
}

/*---------------------------------------------------------------------------*/

void
StandardGroupCreatorService::
reportTimer()
{
  if(m_verbose) info() << "--------------------";
  if(m_verbose) info() << "Timer : " << m_timer_groupcreator_create.totalTime()   << " - Group Creator Apply" ;
  if(m_verbose) info() << "--------------------";
  if(m_verbose) info() << "Timer : " << m_timer_groupcreator_filter.totalTime()    << " - Group Creator Filter Items" ;
  if(m_verbose) info() << "Timer : " << m_timer_groupcreator_add.totalTime()      << " - Group Creator Select and Add Items" ;
  if(m_verbose) info() << "Timer : " << m_timer_groupcreator_build.totalTime() << " - Group Creator Build Item Group" ;
  if(m_verbose) info() << "--------------------";
}

/*---------------------------------------------------------------------------*/

void
StandardGroupCreatorService::
createCellGroups()
{
  if(m_verbose) info() << "Group Creator Service create Cell Groups";
  const IGeometryMng::Real3Variable & cell_centers = m_geometry_service->getReal3VariableProperty(allCells(), IGeometryProperty::PCenter);

  for(int cellgroup_nbr=0; cellgroup_nbr<options()->cellgroup.size(); cellgroup_nbr++)
    {
      String cellgroup_name = options()->cellgroup[cellgroup_nbr]->name();
      if(m_verbose) info() << "Found Cellgroup number " << cellgroup_nbr << " with name " << cellgroup_name;
      ItemGroupBuilder<Cell> cell_group_builder(mesh(), cellgroup_name);

      if(m_verbose) info() << "  Read Filter Expression";
      String filter_expression = options()->cellgroup[cellgroup_nbr]->filter();
      filter_expression = "(x,y,z)-> " + filter_expression;
      if(m_verbose) info() << "  expression=" << filter_expression;

      bool filter_test = options()->cellgroup[cellgroup_nbr]->filterTest();
      if(m_verbose) info() << "  filter_test=" << filter_test;

      if(m_verbose) info() << "  Parse expression";
      m_function_parser.parseString( filter_expression) ; //"(x,y,z)-> x+y*-sin(z)" );

      if(m_verbose) info() << "  Build Function filter";
      ExpressionBuilderR3vR1Core filter = ExpressionBuilderR3vR1Core(&m_function_parser);

      for(int area_nbr=0; area_nbr<options()->cellgroup[cellgroup_nbr]->area.size(); area_nbr++)
        {
          String area_name = options()->cellgroup[cellgroup_nbr]->area[area_nbr];
          if(m_verbose) info() << "  Found area number" << area_nbr << " with name " << area_name;

          // Check if area_name exists as a cellgroup otherwise return empty cellgroup
          CellGroup area_cellgroup  = mesh()->cellFamily()->findGroup(area_name,false);
          if (area_cellgroup.null())
            fatal() << "Undefined area with name " << area_name ;

          m_timer_groupcreator_filter.start();

          RealSharedArray cell_filter_value;

          cell_filter_value.resize(area_cellgroup.size());

          if(m_scalar_eval)
            {
              if(m_verbose) info() << "build cell group filter ";
              Integer index = 0;
              ENUMERATE_CELL(iCell,area_cellgroup)
                {
                  const Real3 cell_center = cell_centers[iCell];

                  filter.eval(cell_center.x/m_unit_X,cell_center.y/m_unit_Y,cell_center.z/m_unit_Z,cell_filter_value[index++]);
                }
            }
          else
            {
              if(m_verbose) info() << "build Cell filter array";
              // recopy
              // to be removed when IFunctionR3vR1 interCell implements eval(Real3,Real) method
              SharedArray<Real> x(area_cellgroup.size());
              SharedArray<Real> y(area_cellgroup.size());
              SharedArray<Real> z(area_cellgroup.size());
              {
                Integer iData = 0;
                ENUMERATE_CELL(iCell, area_cellgroup)
                  {
                    const Cell& cell = *iCell;
                    const Real3& center = cell_centers[cell];

                    x[iData] = center.x/m_unit_X;
                    y[iData] = center.y/m_unit_Y;
                    z[iData] = center.z/m_unit_Z;
                    iData++;
                  }
              }

              // Evaluate analytic solution
              filter.eval(x, y, z, cell_filter_value);
            }

          m_timer_groupcreator_filter.stop();

          //------------

          if(m_verbose) info() << "select and add cells ";
          m_timer_groupcreator_add.start();
          Integer index = 0;
          ENUMERATE_CELL(iCell,area_cellgroup)
            {
              const Real filter_result = cell_filter_value[index++];
              if ( (filter_result > m_filter_cell_tolerance) == filter_test )
                cell_group_builder.add(*iCell);
            }
          m_timer_groupcreator_add.stop();
        }

      if(m_verbose) info() << "build cell group ";
      m_timer_groupcreator_build.start();
      CellGroup cellgroup = cell_group_builder.buildGroup();
      m_timer_groupcreator_build.stop();

      if(m_verbose) info() << "New group created with name " << cellgroup_name << " with " << cellgroup.size() << " elements.";
    }
}

/*---------------------------------------------------------------------------*/

void
StandardGroupCreatorService::
createFaceGroups()
{
  if(m_verbose) info() << "Group Creator Service Create Face Groups";

  const IGeometryMng::Real3Variable & face_centers = m_geometry_service->getReal3VariableProperty(allFaces(), IGeometryProperty::PCenter);
  const IGeometryMng::Real3Variable & cell_centers = m_geometry_service->getReal3VariableProperty(allCells(), IGeometryProperty::PCenter);
  const IGeometryMng::Real3Variable & face_normals = m_geometry_service->getReal3VariableProperty(allFaces(), IGeometryProperty::PNormal);


  //Group of true boundary faces
  ItemGroupBuilder<Face> all_face_group_builder(mesh(), "GC_AllBoundaryFaces");
  {
    VariableFaceBool is_face_true_boundary(VariableBuildInfo(mesh(), "TmpFaceVar"));
    is_face_true_boundary.fill(false);

    ENUMERATE_FACE(iFace, outerFaces().own())
    {
      //Security check that boundary cell is own
      if (iFace->boundaryCell().isOwn())
        is_face_true_boundary[iFace] = true;
    }
    //synchronization to capture ghost boundary faces
    is_face_true_boundary.synchronize();
    ENUMERATE_FACE(iFace,outerFaces())
    {
      if (is_face_true_boundary[iFace]) {
        all_face_group_builder.add(*iFace);
      }
    }
  }
  FaceGroup GC_allBoundaryFaces_group = all_face_group_builder.buildGroup();



  for(int facegroup_nbr=0; facegroup_nbr<options()->facegroup.size(); facegroup_nbr++)
    {

      String facegroup_name = options()->facegroup[facegroup_nbr]->name();
      if(m_verbose) info() << "Found Facegroup number " << facegroup_nbr << " with name " << facegroup_name;
      ItemGroupBuilder<Face> face_group_builder(mesh(), facegroup_name);

      if(m_verbose) info() << "  Read Filter Expression";
      String filter_expression = options()->facegroup[facegroup_nbr]->filter();
      filter_expression = "(x,y,z)-> " + filter_expression;
      if(m_verbose) info() << "  expression=" << filter_expression;

      bool filter_test = options()->facegroup[facegroup_nbr]->filterTest();
      if(m_verbose) info() << "  filter_test=" << filter_test;

      bool use_normal = options()->facegroup[facegroup_nbr]->normalEval() ;
      if(use_normal)
      {
        Real teta = options()->facegroup[facegroup_nbr]->teta() ;
        Real phi = options()->facegroup[facegroup_nbr]->phi() ;
        Real tol = options()->facegroup[facegroup_nbr]->tol() ;
        Real cosphi = std::cos(PI*phi/180.) ;
        Real sinphi = std::sin(PI*phi/180.) ;
        Real costeta = std::cos(PI*teta/180.) ;
        Real sinteta = std::sin(PI*teta/180.) ;
        const Real3 dir(sinphi*costeta,sinphi*sinteta,cosphi) ;
        filter_test = false ;
        for(int area_nbr=0; area_nbr<options()->facegroup[facegroup_nbr]->area.size(); area_nbr++)
        {
          String area_name = options()->facegroup[facegroup_nbr]->area[area_nbr];
          if(m_verbose) info() << "  Found area number" << area_nbr << " with name " << area_name;

          FaceGroup area_facegroup;

          // Check if area_name exists as a cellgroup otherwise return empty cellgroup
          if(area_name=="GC_allBoundaryFaces")
            {
              //area_facegroup = outerFaces().own();
              area_facegroup = GC_allBoundaryFaces_group;
              Integer icount = 0;
              ENUMERATE_FACE(iFace,area_facegroup)
                {
                  //const Real3 face_normal = face_normals[iFace];
                  if(math::scaMul(face_normals[iFace],face_normals[iFace]) == 0.)
                    fatal() << "Null normal on face " << icount;
                  icount++;
                }
            }
          else
            {
              area_facegroup  = mesh()->faceFamily()->findGroup(area_name,false);
              if (area_facegroup.null())
                fatal() << "Undefined area with name " << area_name ;
            }

          // On parcourt le groupe toujours de la m���me mani���re, on peut donc utiliser
          // une structure de type Array
          // NB : Il n'est pas possible d'utiliser un ItemGroupMap car le groupe est own().
          // On peut contourner cela mais le co���t peut ���tre ���lev���
          RealSharedArray face_filter_value;

          face_filter_value.resize(area_facegroup.size());
          {
            m_timer_groupcreator_filter.start();
            Integer index = 0;
            ENUMERATE_FACE(iFace,area_facegroup)
              {
                //const Real3 face_normal = face_normals[iFace];
                const Cell& cell = (*iFace).boundaryCell() ;
                //const Real3 cell_center = cell_centers[cell] ;
                //const Real3 face_center = face_centers[iFace] ;

                Real3 face_normal = Real3(0,0,0);
                for (Integer i = 0 ; i < iFace->nbNode() ; i++){
                  const Node & node = iFace->node(i);
                  Real3 node_normal = Real3(0,0,0);
                  for(Integer j=0 ; j < node.nbFace() ; j++){
                    const Face & face = node.face(j);
                    Real3 cf = face_centers[face]-cell_centers[cell] ;
                    Integer sgn =(math::scaMul(cf,face_normals[face])>0?1:-1) ;
                    node_normal = node_normal + sgn*math::normalizeReal3(face_normals[face]); // ici on normalise pour ne pas avoir d'effet de l'aire
                                                                                              // des faces plus grandes sur les petites
                  }
                  face_normal = face_normal + node_normal;
                }

                Real3 cf = face_centers[iFace]-cell_centers[cell] ;
                Integer sgn =(math::scaMul(cf,face_normal)>0?1:-1) ;
                // cos de l'angle que fait la normale de la face avec la direction du groupe
                Real cos_angle = sgn*math::scaMul(math::normalizeReal3(face_normal),math::normalizeReal3(dir));
                // le vecteur formant une base directe avec face_normal et dir
                Real3 normal = math::vecMul(math::normalizeReal3(face_normal),math::normalizeReal3(dir));
                Real sin_angle = math::sqrt(math::scaMul(normal,normal)); // le sinus est toujours positif-> demonstration avec produit vectoriel
                Real angle = 0.;
                if(sin_angle >= 1.)
                  angle = PI/2;
                else
                  angle = asin(sin_angle);
                Real val = angle*180/PI;
                if(cos_angle < 0.)
                  val = 180. - val;

                face_filter_value[index++] = val ;
              }
            m_timer_groupcreator_filter.stop();
          }
          {
            //----------
            if(m_verbose) info() << "select and add faces";
            m_timer_groupcreator_add.start();
            Integer index = 0;
            ENUMERATE_FACE(iFace,area_facegroup)
              {
                const Real filter_result = face_filter_value[index++];
                if(filter_result < tol)
                  face_group_builder.add(*iFace);
              }
            m_timer_groupcreator_add.stop();
          }
        }
      }
      else
      {
        if(m_verbose) info() << "  Parse expression";
        m_function_parser.parseString( filter_expression) ; //"(x,y,z)-> 0." );

        if(m_verbose) info() << "  Build Function filter";
        ExpressionBuilderR3vR1Core filter = ExpressionBuilderR3vR1Core(&m_function_parser);



        for(int area_nbr=0; area_nbr<options()->facegroup[facegroup_nbr]->area.size(); area_nbr++)
          {
            String area_name = options()->facegroup[facegroup_nbr]->area[area_nbr];
            if(m_verbose) info() << "  Found area number" << area_nbr << " with name " << area_name;

            FaceGroup area_facegroup;

            // Check if area_name exists as a cellgroup otherwise return empty cellgroup
            if(area_name=="GC_allBoundaryFaces")
              {
                //area_facegroup = outerFaces().own();
                area_facegroup = GC_allBoundaryFaces_group;
              }
            else
              {
                area_facegroup  = mesh()->faceFamily()->findGroup(area_name,false);
                if (area_facegroup.null())
                  fatal() << "Undefined area with name " << area_name ;
              }

            // On parcourt le groupe toujours de la m���me mani���re, on peut donc utiliser
            // une structure de type Array
            // NB : Il n'est pas possible d'utiliser un ItemGroupMap car le groupe est own().
            // On peut contourner cela mais le co���t peut ���tre ���lev���
            RealSharedArray face_filter_value;

            face_filter_value.resize(area_facegroup.size());

            m_timer_groupcreator_filter.start();

            if(m_scalar_eval)
              {
                if(m_verbose) info() << "build face filter";
                Integer index = 0;
                ENUMERATE_FACE(iFace,area_facegroup)
                  {
                    const Real3 face_center = face_centers[iFace];

                    filter.eval(face_center.x/m_unit_X,face_center.y/m_unit_Y,face_center.z/m_unit_Z,face_filter_value[index++]);
                  }
              }

            else
              {
                if(m_verbose) info() << "build face filter array";
                // recopy
                // to be removed when IFunctionR3vR1 interface implements eval(Real3,Real) method
                SharedArray<Real> x(area_facegroup.size());
                SharedArray<Real> y(area_facegroup.size());
                SharedArray<Real> z(area_facegroup.size());
                {
                  Integer iData = 0;
                  ENUMERATE_FACE(iFace, area_facegroup)
                    {
                      const Real3& center = face_centers[iFace];

                      x[iData] = center.x/m_unit_X;
                      y[iData] = center.y/m_unit_Y;
                      z[iData] = center.z/m_unit_Z;
                      iData++;
                    }
                }

                // Evaluate analytic solution
                filter.eval(x, y, z, face_filter_value);
              }

            m_timer_groupcreator_filter.stop();

            //----------
            if(m_verbose) info() << "select and add faces";
            m_timer_groupcreator_add.start();
            Integer index = 0;
            ENUMERATE_FACE(iFace,area_facegroup)
              {
                const Real filter_result = face_filter_value[index++];
                if( (filter_result > m_filter_face_tolerance) == filter_test )
                  face_group_builder.add(*iFace);
              }
            m_timer_groupcreator_add.stop();
          }
        }

      if(m_verbose) info() << "build face group";
      m_timer_groupcreator_build.start();
      FaceGroup facegroup = face_group_builder.buildGroup();
      m_timer_groupcreator_build.stop();
      if(m_verbose) info() << "New group created with name " << facegroup_name << " with " << facegroup.size() << " elements.";
    }

}

void
StandardGroupCreatorService::
create2DCellGroups()
{
  if(m_verbose) info() << "Group Creator Service create Cell Groups";
  IGeometry2DMng* geometry2d_mng = dynamic_cast<IGeometry2DMng*>(m_geometry_service) ;
  const IGeometry2DMng::Real2Variable& cell_centers = geometry2d_mng->getReal2VariableProperty(allCells(), IGeometryProperty::PCenter);

  for(int cellgroup_nbr=0; cellgroup_nbr<options()->cellgroup.size(); cellgroup_nbr++)
    {
      String cellgroup_name = options()->cellgroup[cellgroup_nbr]->name();
      if(m_verbose) info() << "Found Cellgroup number " << cellgroup_nbr << " with name " << cellgroup_name;
      ItemGroupBuilder<Cell> cell_group_builder(mesh(), cellgroup_name);

      if(m_verbose) info() << "  Read Filter Expression";
      String filter_expression = options()->cellgroup[cellgroup_nbr]->filter();
      filter_expression = "(x,y)-> " + filter_expression;
      if(m_verbose) info() << "  expression=" << filter_expression;

      bool filter_test = options()->cellgroup[cellgroup_nbr]->filterTest();
      if(m_verbose) info() << "  filter_test=" << filter_test;

      if(m_verbose) info() << "  Parse expression";
      m_function_parser.parseString( filter_expression) ; //"(x,y,z)-> x+y*-sin(z)" );

      if(m_verbose) info() << "  Build Function filter";
      ExpressionBuilderR2vR1Core filter = ExpressionBuilderR2vR1Core(&m_function_parser);

      for(int area_nbr=0; area_nbr<options()->cellgroup[cellgroup_nbr]->area.size(); area_nbr++)
        {
          String area_name = options()->cellgroup[cellgroup_nbr]->area[area_nbr];
          if(m_verbose) info() << "  Found area number" << area_nbr << " with name " << area_name;

          // Check if area_name exists as a cellgroup otherwise return empty cellgroup
          CellGroup area_cellgroup  = mesh()->cellFamily()->findGroup(area_name,false);
          if (area_cellgroup.null())
            fatal() << "Undefined area with name " << area_name ;

          m_timer_groupcreator_filter.start();

          RealSharedArray cell_filter_value;

          cell_filter_value.resize(area_cellgroup.size());

          if(m_scalar_eval)
            {
              if(m_verbose) info() << "build cell group filter ";
              Integer index = 0;
              ENUMERATE_CELL(iCell,area_cellgroup)
                {
                  const Real2 cell_center = cell_centers[iCell];

                  filter.eval(cell_center.x/m_unit_X,cell_center.y/m_unit_Y,cell_filter_value[index++]);
                }
            }
          else
            {
              if(m_verbose) info() << "build Cell filter array";
              // recopy
              // to be removed when IFunctionR3vR1 interCell implements eval(Real3,Real) method
              SharedArray<Real> x(area_cellgroup.size());
              SharedArray<Real> y(area_cellgroup.size());
              {
                Integer iData = 0;
                ENUMERATE_CELL(iCell, area_cellgroup)
                  {
                    const Cell& cell = *iCell;
                    const Real2& center = cell_centers[cell];

                    x[iData] = center.x/m_unit_X;
                    y[iData] = center.y/m_unit_Y;
                    iData++;
                  }
              }

              // Evaluate analytic solution
              filter.eval(x, y, cell_filter_value);
            }

          m_timer_groupcreator_filter.stop();

          //------------

          if(m_verbose) info() << "select and add cells ";
          m_timer_groupcreator_add.start();
          Integer index = 0;
          ENUMERATE_CELL(iCell,area_cellgroup)
            {
              const Real filter_result = cell_filter_value[index++];
              if ( (filter_result > m_filter_cell_tolerance) == filter_test )
                cell_group_builder.add(*iCell);
            }
          m_timer_groupcreator_add.stop();
        }

      if(m_verbose) info() << "build cell group ";
      m_timer_groupcreator_build.start();
      CellGroup cellgroup = cell_group_builder.buildGroup();
      m_timer_groupcreator_build.stop();

      if(m_verbose) info() << "New group created with name " << cellgroup_name << " with " << cellgroup.size() << " elements.";
    }
}

/*---------------------------------------------------------------------------*/

void
StandardGroupCreatorService::
create2DFaceGroups()
{
  if(m_verbose) info() << "Group Creator Service Create Face Groups";
  IGeometry2DMng* geometry2d_mng = dynamic_cast<IGeometry2DMng*>(m_geometry_service) ;
  //const IGeometry2DMng::Real2Variable& cell_centers = geometry2d_mng->getReal2VariableProperty(allCells(), IGeometryProperty::PCenter);
  const IGeometry2DMng::Real2Variable& face_centers = geometry2d_mng->getReal2VariableProperty(allFaces(), IGeometryProperty::PCenter);
  //const IGeometry2DMng::Real2Variable& face_normals = geometry2d_mng->getReal2VariableProperty(allFaces(), IGeometryProperty::PNormal);

  //Group of true boundary faces
  ItemGroupBuilder<Face> all_face_group_builder(mesh(), "GC_AllBoundaryFaces");
  {
    VariableFaceBool is_face_true_boundary(VariableBuildInfo(mesh(), "TmpFaceVar"));
    is_face_true_boundary.fill(false);
    ENUMERATE_FACE(iFace, outerFaces().own())
    {
      //Security check that boundary cell is own
      if (iFace->boundaryCell().isOwn())
        is_face_true_boundary[iFace] = true;
    }
    //synchronization to capture ghost boundary faces
    is_face_true_boundary.synchronize();
    ENUMERATE_FACE(iFace,outerFaces())
    {
      if (is_face_true_boundary[iFace]) {
        all_face_group_builder.add(*iFace);
      }
    }
  }
  FaceGroup GC_allBoundaryFaces_group = all_face_group_builder.buildGroup();

  for(int facegroup_nbr=0; facegroup_nbr<options()->facegroup.size(); facegroup_nbr++)
    {

      String facegroup_name = options()->facegroup[facegroup_nbr]->name();
      if(m_verbose) info() << "Found Facegroup number " << facegroup_nbr << " with name " << facegroup_name;
      ItemGroupBuilder<Face> face_group_builder(mesh(), facegroup_name);

      if(m_verbose) info() << "  Read Filter Expression";
      String filter_expression = options()->facegroup[facegroup_nbr]->filter();
      filter_expression = "(x,y)-> " + filter_expression;
      if(m_verbose) info() << "  expression=" << filter_expression;

      bool filter_test = options()->facegroup[facegroup_nbr]->filterTest();
      if(m_verbose) info() << "  filter_test=" << filter_test;

  //    bool use_normal = options()->facegroup[facegroup_nbr]->normalEval() ;
      /*if(use_normal)
      {
        Real teta = options()->facegroup[facegroup_nbr]->teta() ;
        Real phi = options()->facegroup[facegroup_nbr]->phi() ;
        Real tol = options()->facegroup[facegroup_nbr]->tol() ;
        Real cosphi = std::cos(PI*phi/180.) ;
        Real sinphi = std::sin(PI*phi/180.) ;
        Real costeta = std::cos(PI*teta/180.) ;
        Real sinteta = std::sin(PI*teta/180.) ;
        const Real3 dir(sinphi*costeta,sinphi*sinteta,cosphi) ;
        filter_test = false ;
        for(int area_nbr=0; area_nbr<options()->facegroup[facegroup_nbr]->area.size(); area_nbr++)
        {
          String area_name = options()->facegroup[facegroup_nbr]->area[area_nbr];
          if(m_verbose) info() << "  Found area number" << area_nbr << " with name " << area_name;
          
          FaceGroup area_facegroup;

          // Check if area_name exists as a cellgroup otherwise return empty cellgroup
          if(area_name=="GC_allBoundaryFaces")
            {
              area_facegroup = outerFaces().own();
              Integer icount = 0;
              ENUMERATE_FACE(iFace,area_facegroup)
                {
                  //const Real3 face_normal = face_normals[iFace];
                  if(math::scaMul(face_normals[iFace],face_normals[iFace]) == 0.)
                    fatal() << "Null normal on face " << icount;
                  icount++;
                }
            }
          else
            {
              area_facegroup  = mesh()->faceFamily()->findGroup(area_name,false);
              if (area_facegroup.null())
                fatal() << "Undefined area with name " << area_name ;
            }
          
          // On parcourt le groupe toujours de la m���me mani���re, on peut donc utiliser
          // une structure de type Array
          // NB : Il n'est pas possible d'utiliser un ItemGroupMap car le groupe est own().
          // On peut contourner cela mais le co���t peut ���tre ���lev���
          RealSharedArray face_filter_value;

          face_filter_value.resize(area_facegroup.size());
          {
            m_timer_groupcreator_filter.start();
            Integer index = 0;
            ENUMERATE_FACE(iFace,area_facegroup)
              {
                //const Real3 face_normal = face_normals[iFace];
                const Cell& cell = (*iFace).boundaryCell() ;
                //const Real3 cell_center = cell_centers[cell] ;
                //const Real3 face_center = face_centers[iFace] ;

                Real2 face_normal = Real2(0,0);
                for (Integer i = 0 ; i < iFace->nbNode() ; i++){
                  const Node & node = iFace->node(i);
                  Real2 node_normal = Real2(0,0);
                  for(Integer j=0 ; j < node.nbFace() ; j++){
                    const Face & face = node.face(j);
                    Real2 cf = face_centers[face]-cell_centers[cell] ;
                    Integer sgn =(math::scaMul(cf,face_normals[face])>0?1:-1) ;
                    node_normal = node_normal + sgn*math::normalizeReal2(face_normals[face]); // ici on normalise pour ne pas avoir d'effet de l'aire
                                                                                              // des faces plus grandes sur les petites
                  }
                  face_normal = face_normal + node_normal;
                }

                Real2 cf = face_centers[iFace]-cell_centers[cell] ;
                Integer sgn =(math::scaMul(cf,face_normal)>0?1:-1) ;
                // cos de l'angle que fait la normale de la face avec la direction du groupe
                Real cos_angle = sgn*math::scaMul(math::normalizeReal2(face_normal),math::normalizeReal2(dir));
                // le vecteur formant une base directe avec face_normal et dir
                Real2 normal = math::vecMul(math::normalizeReal2(face_normal),math::normalizeReal2(dir));
                Real sin_angle = math::sqrt(math::scaMul(normal,normal)); // le sinus est toujours positif-> demonstration avec produit vectoriel
                Real angle = 0.;
                if(sin_angle >= 1.)
                  angle = PI/2;
                else
                  angle = asin(sin_angle);
                Real val = angle*180/PI;
                if(cos_angle < 0.)
                  val = 180. - val;
                
                face_filter_value[index++] = val ;
              }
            m_timer_groupcreator_filter.stop();
          }
          {
            //----------
            if(m_verbose) info() << "select and add faces";
            m_timer_groupcreator_add.start();
            Integer index = 0;
            ENUMERATE_FACE(iFace,area_facegroup)
              {
                const Real filter_result = face_filter_value[index++];
                if(filter_result < tol)
                  face_group_builder.add(*iFace);
              }
            m_timer_groupcreator_add.stop();
          }
        }
      }
      else */
      {
        if(m_verbose) info() << "  Parse expression";
        m_function_parser.parseString( filter_expression) ; //"(x,y)-> 0." );

        if(m_verbose) info() << "  Build Function filter";
        ExpressionBuilderR2vR1Core filter = ExpressionBuilderR2vR1Core(&m_function_parser);



        for(int area_nbr=0; area_nbr<options()->facegroup[facegroup_nbr]->area.size(); area_nbr++)
          {
            String area_name = options()->facegroup[facegroup_nbr]->area[area_nbr];
            if(m_verbose) info() << "  Found area number" << area_nbr << " with name " << area_name;

            FaceGroup area_facegroup;

            // Check if area_name exists as a cellgroup otherwise return empty cellgroup
            if(area_name=="GC_allBoundaryFaces")
              {
                //area_facegroup = outerFaces().own();
                area_facegroup = GC_allBoundaryFaces_group;
              }
            else
              {
                area_facegroup  = mesh()->faceFamily()->findGroup(area_name,false);
                if (area_facegroup.null())
                  fatal() << "Undefined area with name " << area_name ;
              }

            // On parcourt le groupe toujours de la m���me mani���re, on peut donc utiliser
            // une structure de type Array
            // NB : Il n'est pas possible d'utiliser un ItemGroupMap car le groupe est own().
            // On peut contourner cela mais le co���t peut ���tre ���lev���
            RealSharedArray face_filter_value;

            face_filter_value.resize(area_facegroup.size());

            m_timer_groupcreator_filter.start();

            if(m_scalar_eval)
              {
                if(m_verbose) info() << "build face filter";
                Integer index = 0;
                ENUMERATE_FACE(iFace,area_facegroup)
                  {
                    const Real2 face_center = face_centers[iFace];

                    filter.eval(face_center.x/m_unit_X,face_center.y/m_unit_Y,face_filter_value[index++]);
                  }
              }

            else
              {
                if(m_verbose) info() << "build face filter array";
                // recopy
                // to be removed when IFunctionR3vR1 interface implements eval(Real3,Real) method
                SharedArray<Real> x(area_facegroup.size());
                SharedArray<Real> y(area_facegroup.size());
                {
                  Integer iData = 0;
                  ENUMERATE_FACE(iFace, area_facegroup)
                    {
                      const Real2& center = face_centers[iFace];

                      x[iData] = center.x/m_unit_X;
                      y[iData] = center.y/m_unit_Y;
                      iData++;
                    }
                }

                // Evaluate analytic solution
                filter.eval(x, y, face_filter_value);
              }

            m_timer_groupcreator_filter.stop();

            //----------
            if(m_verbose) info() << "select and add faces";
            m_timer_groupcreator_add.start();
            Integer index = 0;
            ENUMERATE_FACE(iFace,area_facegroup)
              {
                const Real filter_result = face_filter_value[index++];
                if( (filter_result > m_filter_face_tolerance) == filter_test )
                  face_group_builder.add(*iFace);
              }
            m_timer_groupcreator_add.stop();
          }
        }

      if(m_verbose) info() << "build face group";
      m_timer_groupcreator_build.start();
      FaceGroup facegroup = face_group_builder.buildGroup();
      m_timer_groupcreator_build.stop();
      if(m_verbose) info() << "New group created with name " << facegroup_name << " with " << facegroup.size() << " elements.";
    }

}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_STANDARDGROUPCREATOR(StandardGroupCreator,StandardGroupCreatorService);
