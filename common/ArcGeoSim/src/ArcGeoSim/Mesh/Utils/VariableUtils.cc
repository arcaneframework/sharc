// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "VariableUtils.h"
/* Author : dechaiss at Wed Jun  8 16:40:38 2011
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/

#include <arcane/IVariableMng.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/ISubDomain.h>
#include <arcane/IMesh.h>
#include <arcane/VariableBuildInfo.h>
#include <arcane/IItemFamily.h>

#include "ArcGeoSim/Mesh/Utils/StringToItemUtils.h"
#include "ArcGeoSim/Mesh/Utils/ArrayMngT.h"

using namespace Arcane;

BEGIN_ARCGEOSIM_NAMESPACE


namespace VariableUtils {

/*---------------------------------------------------------------------------*/

IVariable*
cloneVariable(IVariable* const source_variable, const String& clone_name, int clone_property)
{
  // Create variable
  IVariable* copy_variable;
  if (source_variable->itemKind() == IK_Unknown) copy_variable = createVariable(clone_name,
                                                                                source_variable->dataType(),
                                                                                source_variable->dimension(),
                                                                                source_variable->subDomain(),
                                                                                clone_property);
  else copy_variable = createMeshVariable(clone_name,
                                          source_variable->dataType(),
                                          source_variable->itemKind(),
                                          source_variable->dimension(),
                                          source_variable->isPartial(),
                                          source_variable->itemGroup(),
                                          clone_property);

  // Copy data
  copy_variable->data()->copy(source_variable->data());

  return copy_variable;
}

/*---------------------------------------------------------------------------*/

Arcane::IVariable*
createVariable(const String& name, const eDataType& data_type, const Integer dimension, ISubDomain* const sub_domain, int property)
{
  // Add IVariable::PPersistant property.
  property |= Arcane::IVariable::PPersistant;

  // Find if exists
  Arcane::IVariable* variable = sub_domain->variableMng()->findVariable(name);
  if (variable)
    {
      if (variable->dataType() != data_type || variable->dimension() != dimension)
        {
          throw FatalErrorException(String::format("Variable {0} already exists but has different dataType or dimension",name));
        }
      sub_domain->traceMng()->info() << String::format("Variable creation: variable {0} already exists)",name);
      return variable;
    }
  else
    {
      return _switchVariable(name,data_type,dimension,sub_domain,property)->variable();
    }
}

/*---------------------------------------------------------------------------*/

Arcane::VariableRef*
createVariableRef(const String& name, const eDataType& data_type, const Integer dimension, ISubDomain* const sub_domain, int property)
{

  // Find if exists
  Arcane::IVariable* variable = sub_domain->variableMng()->findVariable(name);
  if (variable)
    {
      if (variable->dataType() != data_type || variable->dimension() != dimension)
        {
          throw FatalErrorException(String::format("Variable {0} already exists but has different dataType or dimension",name));
        }
      sub_domain->traceMng()->info() << String::format("Variable creation: variable {0} already exists)",name);
    }
  return _switchVariable(name,data_type,dimension,sub_domain,property);
}

/*---------------------------------------------------------------------------*/

IVariable*
createMeshVariable(const String& name, const eDataType& data_type,
                   const eItemKind& item_kind, const Integer dimension,
                   const bool is_partial, const ItemGroup& item_group, int property)
{
  // Add IVariable::PPersistant property.
  property |= Arcane::IVariable::PPersistant;

  // Check group
  if (item_group.null()) throw FatalErrorException(String::format(
      "MeshVariable {0} cannot be created since null group was given in argument",name));

  // Check kind
  if (item_group.itemKind() != item_kind ) throw FatalErrorException(String::format(
      "MeshVariable {0} cannot be created since group kind {1} is different from item kind {2}",
      name, StringToItemUtils::itemKindToString(item_group.itemKind()),StringToItemUtils::itemKindToString(item_kind)));

  // Find if exists
  IVariable* variable = item_group.mesh()->variableMng()->findMeshVariable(item_group.mesh(),name);
  if (variable)
    {
      if (variable->dataType() != data_type || variable->itemKind() != item_kind ||
          variable->isPartial() != is_partial || variable->dimension() != dimension)
        throw FatalErrorException(String::format(
            "MeshVariable {0} already exists but has different dataType, itemKind, group or dimension",name));

      item_group.mesh()->variableMng()->traceMng()->info() << String::format("MeshVariable creation: variable {0} already exists)",name);
      return variable;
    }
  else
    {
      return _switchMeshVariable(name,data_type,item_kind,dimension,is_partial,item_group,property)->variable();
    }
}

/*---------------------------------------------------------------------------*/

Arcane::VariableRef*
createMeshVariableRef(const String& name, const eDataType& data_type,
                      const eItemKind& item_kind, const Integer dimension,
                      const bool is_partial, const ItemGroup& item_group, int property)
{
  // Check group
  if (item_group.null()) throw FatalErrorException(String::format(
      "MeshVariable {0} cannot be created since null group was given in argument",name));

  // Check kind
  if (item_group.itemKind() != item_kind ) throw FatalErrorException(String::format(
      "MeshVariable {0} cannot be created since group kind {1} is different from item kind {2}",
      name, StringToItemUtils::itemKindToString(item_group.itemKind()),StringToItemUtils::itemKindToString(item_kind)));

  // Find if exists
  IVariable* variable = item_group.mesh()->variableMng()->findMeshVariable(item_group.mesh(),name);
  if (variable)
    {
      if (variable->dataType() != data_type || variable->itemKind() != item_kind ||
          variable->isPartial() != is_partial || variable->dimension() != dimension)
        throw FatalErrorException(String::format(
            "MeshVariable {0} already exists but has different dataType, itemKind, group or dimension",name));
      item_group.mesh()->variableMng()->traceMng()->info() << String::format("MeshVariable creation: variable {0} already exists)",name);
    }
  return _switchMeshVariable(name,data_type,item_kind,dimension,is_partial,item_group,property);
}

/*---------------------------------------------------------------------------*/

SharedArray<IVariable*>
extractArrayComponents(IVariable* const source_array_variable)
{
  // Check wheter mesh variable or not
  if (source_array_variable->dimension() == 1 && source_array_variable->itemKind() == IK_Unknown)
    return _extractVariableArrayComponents(source_array_variable);
  else if (source_array_variable->dimension() == 2)
    return _extractMeshVariableArrayComponents(source_array_variable);
  else throw FatalErrorException(String::format("Variable {0} is not an array. Cannot extract components",
                                                source_array_variable->name()));
  return SharedArray<IVariable*>();
}

/*---------------------------------------------------------------------------*/

void
meshVariableArraySize(IData* mesh_array_variable_data, Integer& item_number, Integer& array_size)
{
  // Check if mesh array variable data
  if (mesh_array_variable_data->dimension() != 2)
    throw Arcane::FatalErrorException(String::format("Invalid variable dimension {0}. Mesh Array variable expected.",
                                                      mesh_array_variable_data->dimension()));

  // Not very nice, cast as a IArray2DataT to reach these information

  // G�n�ration automatique des cas
#define TYPE_ARRAY_CASE(enum_type,type) \
    case enum_type : \
    {\
      IArray2DataT<type>* iarray2 = static_cast<IArray2DataT<type> * > (mesh_array_variable_data); \
      array_size = iarray2->view().dim2Size(); \
      item_number = iarray2->view().dim1Size(); \
      break;\
    }\

  switch (mesh_array_variable_data->dataType())
  {
    TYPE_ARRAY_CASE(DT_Real,Real)
    TYPE_ARRAY_CASE(DT_Real3,Real3)
    TYPE_ARRAY_CASE(DT_Int32,Int32)
    TYPE_ARRAY_CASE(DT_Int64,Int64)
    TYPE_ARRAY_CASE(DT_Byte,Byte)
    default :
      throw Arcane::FatalErrorException(String::format("data type {0} not implemented",dataTypeName(mesh_array_variable_data->dataType())));
  }

}

/*---------------------------------------------------------------------------*/

void
resizeMeshVariableArray(Arcane::IVariable* mesh_array_variable, Arcane::Integer dim2_size)
{
  Arcane::IData* mesh_array_variable_data = mesh_array_variable->data();
  // Check if mesh array variable data
  if (mesh_array_variable_data->dimension() != 2)
    throw Arcane::FatalErrorException(String::format("Invalid variable dimension {0}. Mesh Array variable expected.",
                                                      mesh_array_variable_data->dimension()));

  // Not very nice, cast as a IArray2DataT to reach these information

  // G�n�ration automatique des cas
#define TYPE_MESH_ARRAY_RESIZE_CASE(enum_type,type) \
    case enum_type : \
    {\
      IArray2DataT<type>* iarray2 = static_cast<IArray2DataT<type> * > (mesh_array_variable_data); \
      iarray2->value().resize(iarray2->view().dim1Size(),dim2_size); \
      break;\
    }\

  switch (mesh_array_variable_data->dataType())
  {
    TYPE_MESH_ARRAY_RESIZE_CASE(DT_Real,Real)
    TYPE_MESH_ARRAY_RESIZE_CASE(DT_Real3,Real3)
    TYPE_MESH_ARRAY_RESIZE_CASE(DT_Int32,Int32)
    TYPE_MESH_ARRAY_RESIZE_CASE(DT_Int64,Int64)
    TYPE_MESH_ARRAY_RESIZE_CASE(DT_Byte,Byte)
    default :
      throw Arcane::FatalErrorException(String::format("data type {0} not implemented",dataTypeName(mesh_array_variable_data->dataType())));
  }
}

/*---------------------------------------------------------------------------*/

void
resizeVariableArray(Arcane::IVariable* array_variable, Arcane::Integer size)
{
  Arcane::IData* array_variable_data = array_variable->data();
  // Check if mesh array variable data
  if (array_variable_data->dimension() != 1)
    throw Arcane::FatalErrorException(String::format("Invalid variable dimension {0}. Array variable expected.",
                                                      array_variable_data->dimension()));

  // Not very nice, cast as a IArrayDataT to reach these information

  // G�n�ration automatique des cas
#define TYPE_ARRAY_RESIZE_CASE(enum_type,type) \
    case enum_type : \
    {\
      IArrayDataT<type>* iarray = static_cast<IArrayDataT<type> * > (array_variable_data); \
      iarray->resize(size); \
      break;\
    }\

  switch (array_variable_data->dataType())
  {
    TYPE_ARRAY_RESIZE_CASE(DT_Real,Real)
    TYPE_ARRAY_RESIZE_CASE(DT_Real3,Real3)
    TYPE_ARRAY_RESIZE_CASE(DT_Int32,Int32)
    TYPE_ARRAY_RESIZE_CASE(DT_Int64,Int64)
    TYPE_ARRAY_RESIZE_CASE(DT_Byte,Byte)
    default :
      throw Arcane::FatalErrorException(String::format("data type {0} not implemented",dataTypeName(array_variable_data->dataType())));
  }
}



/*---------------------------------------------------------------------------*/

void
deleteUnreferencedVariable(IVariable* const unreferenced_variable,ITraceMng* const trace_mng)
{
  // Delete unreferenced variable creating and deleting a non persistent reference (property put to 0) on it
  if (unreferenced_variable)
    {
      // First check if not referenced
      if (unreferenced_variable->nbReference() != 0)
        {
          trace_mng->warning() << String::format("variable {0} is still referenced, can not be deleted",unreferenced_variable->name());
          return;
        }
      // Create a reference
      Arcane::VariableRef* variable_ref;
      // Check if mesh variable or not
      if (unreferenced_variable->itemKind() == IK_Unknown)
        variable_ref = _switchVariable(unreferenced_variable->name(),unreferenced_variable->dataType(),
                        unreferenced_variable->dimension(),unreferenced_variable->subDomain());
      else
        variable_ref = _switchMeshVariable(unreferenced_variable->name(),unreferenced_variable->dataType(),
                            unreferenced_variable->itemKind(),unreferenced_variable->dimension(),
                            unreferenced_variable->isPartial(), unreferenced_variable->itemGroup());
      // Delete the unique reference to delete the variable
      delete variable_ref;
    }
  else throw FatalErrorException(String::format("variable {0} is NULL, can not be deleted"));
}

/*---------------------------------------------------------------------------*/

void
deleteVariableFromRef(Arcane::VariableRef*& variable_ref, Arcane::ITraceMng* const trace_mng)
{
  if (variable_ref)
    {
      // First check if not referenced
      if (variable_ref->variable()->nbReference() != 1)
        {
          trace_mng->warning() << String::format("variable {0} has more than one reference, can not be deleted",variable_ref->name());
          return;
        }
      delete variable_ref;
      variable_ref = NULL;
    }
  else throw FatalErrorException(String::format("variable given is NULL, can not be deleted"));
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

Arcane::VariableRef *
_switchVariable(const String& name, const eDataType& data_type, const Integer dimension, ISubDomain* const sub_domain, int property)
{
  // Construct variable builder
  VariableBuildInfo builder(sub_domain,name,property);
  switch(dimension)
  {
    case 0 :
      return _switchDataTypeT<VariableRefScalarT>(data_type,builder);
      break;
    case 1 :
      return _switchDataTypeT<VariableRefArrayT>(data_type,builder);
      break;
    default :
      throw Arcane::FatalErrorException(String::format("Invalid variable dimension {0}. To create mesh variable, use createMeshVariable()",
                                                       dimension));
  }
  return NULL;
}

/*---------------------------------------------------------------------------*/

Arcane::VariableRef *
_switchMeshVariable(const String& name, const eDataType& data_type, const eItemKind& item_kind, const Integer dimension,
                    const bool is_partial, const ItemGroup& item_group,int property)
{
  if (is_partial)
    {
      // Create Mesh Variable builder
      VariableBuildInfo builder(item_group.mesh(),name,item_group.itemFamily()->name(),item_group.name(),property);
      switch(dimension)
      {
        case 1 :
          return _switchMeshDataTypeT<ItemPartialVariableScalarRefT>(data_type,item_kind,builder);
          break;
        case 2 :
          return _switchMeshDataTypeT<ItemPartialVariableArrayRefT>(data_type,item_kind,builder);
          break;
        default :
          throw Arcane::FatalErrorException(String::format("Invalid mesh variable dimension {0}.",dimension));
      }
    }
  else
    {
	  // Special handling for particle families
	  Arcane::IItemFamily * item_family;
	  if (item_kind == IK_Particle)
	  {
	    item_family = item_group.mesh()->findItemFamily(IK_Particle,"Particle",true);
	  }
	  else{
	    item_family = item_group.mesh()->itemFamily(item_kind);
	  }

      // Create Mesh Variable builder
      VariableBuildInfo builder(item_group.mesh(),name,item_family->name(),property);
      switch(dimension)
          {
            case 1 :
              return _switchMeshDataTypeT<ItemVariableScalarRefT>(data_type,item_kind,builder);
              break;
            case 2 :
              return _switchMeshDataTypeT<ItemVariableArrayRefT>(data_type,item_kind,builder);
              break;
            default :
              throw Arcane::FatalErrorException(String::format("Invalid mesh variable dimension {0}. To create scalar variable, use createVariable()",
                                                               dimension));
          }
    }
  return NULL;
}

/*---------------------------------------------------------------------------*/

template< template<typename> class VariableT>
Arcane::VariableRef *
_switchDataTypeT(const eDataType& data_type, const VariableBuildInfo& builder)
{
  // G�n�ration automatique des cas
#define TYPE_CASE(enum_type,type) \
    case enum_type : \
    {\
      VariableT<type>* variable = new VariableT<type>(builder); \
      variable->variable()->data()->fillDefault();\
      return variable; \
      break;\
    }\

  switch(data_type)
  {
    TYPE_CASE(DT_Real,Real)
    TYPE_CASE(DT_Real3,Real3)
    TYPE_CASE(DT_Int32,Int32)
    TYPE_CASE(DT_Int64,Int64)
    TYPE_CASE(DT_Byte,Byte)
  default :
    throw Arcane::FatalErrorException(String::format("data type {0} not implemented",dataTypeName(data_type)));
  }
  return NULL;
}


/*---------------------------------------------------------------------------*/

template< template<typename> class VariableT>
Arcane::VariableRef *
_switchMeshDataTypeT(const eDataType& data_type, const eItemKind& item_kind, const VariableBuildInfo& builder)
{

  // G�n�ration automatique des cas
#define MESH_TYPE_CASE(enum_type,type,kind) \
    case enum_type : \
    {\
      VariableT<type>* variable = new VariableT<type>(builder,kind); \
      variable->variable()->data()->fillDefault();\
      return variable; \
      break;\
    }\

  switch(data_type)
    {
      MESH_TYPE_CASE(DT_Real,Real,item_kind)
      MESH_TYPE_CASE(DT_Real3,Real3,item_kind)
      MESH_TYPE_CASE(DT_Int32,Int32,item_kind)
      MESH_TYPE_CASE(DT_Int64,Int64,item_kind)
      MESH_TYPE_CASE(DT_Byte,Byte,item_kind)
      default :
      throw Arcane::FatalErrorException(String::format("data type {0} not implemented",dataTypeName(data_type)));
    }
  return NULL;
}

/*---------------------------------------------------------------------------*/

SharedArray<IVariable*>
_extractVariableArrayComponents(IVariable* const source_array_variable)
{
  throw NotImplementedException("Sorry not yet implemented");
  return SharedArray<IVariable*>();
}

/*---------------------------------------------------------------------------*/

SharedArray<IVariable*>
_extractMeshVariableArrayComponents(IVariable* const source_array_variable)
{
  ARCANE_ASSERT((source_array_variable->dimension()==2),(String::format("Variable {0} is not an array on mesh. Cannot extract components",
                                                                        source_array_variable->name()).localstr()));
  // Get array size and create typed values
  ArrayMng* typed_data;
  Integer dim2_size;
  Integer dim1_size;

  meshVariableArraySize(source_array_variable->data(),dim1_size,dim2_size);

  // G�n�ration automatique des cas
#define TYPE_EXTRACTION_CASE(enum_type,type) \
    case enum_type : \
    {\
      typed_data = new ArrayMngT<type>(source_array_variable->subDomain()); \
      break;\
    }\

  switch (source_array_variable->dataType())
  {
    TYPE_EXTRACTION_CASE(DT_Real,Real)
    TYPE_EXTRACTION_CASE(DT_Real3,Real3)
    TYPE_EXTRACTION_CASE(DT_Int32,Int32)
    TYPE_EXTRACTION_CASE(DT_Int64,Int64)
    TYPE_EXTRACTION_CASE(DT_Byte,Byte)
    default :
      throw Arcane::FatalErrorException(String::format("data type {0} not implemented",dataTypeName(source_array_variable->dataType())));
  }

  // Return object IVariable SharedArray
    SharedArray<IVariable*> extracted_variables(dim2_size);

  // Loop over components
  for (Integer dim2 = 0; dim2 < dim2_size; ++dim2)
    {
      // Create variable storing current component
      String name = String::concat(source_array_variable->name(),dim2);
      IVariable* component_variable = createMeshVariable(name,
                                                         source_array_variable->dataType(),
                                                         source_array_variable->itemKind(),1,
                                                         source_array_variable->isPartial(),
                                                         source_array_variable->itemGroup(),
                                                         source_array_variable->property());
      // Extract data
      //--first get indexes within IData
      // Extracted Data indexes : all the data (a method to fill the complete data should be added in ITypedData)
      IntegerSharedArray idata_extracted_indexes(dim1_size);
      for (Integer i =0 ; i< dim1_size; ++i) idata_extracted_indexes[i] = i;
      // Extract source data : the component dim2 of the array data
      ArrayMng::DataKey array_values_key = typed_data->extractData(source_array_variable->data(),idata_extracted_indexes);
      // Select in the extracted array referenced by values array_values_key, the values of the current component
      // Source Data indexes: the data are written first in dim2, then in dim1
      IntegerSharedArray current_component_values_indexes(dim1_size);
      for (Integer index = dim2, i =0 ; index< dim1_size*dim2_size; index+= dim2_size,++i) current_component_values_indexes[i] = index;
      ArrayMng::DataKey current_component_values_key = typed_data->extractSubData(array_values_key,current_component_values_indexes);
      // Fill the created variable with this values
      typed_data->fillData(component_variable->data(),idata_extracted_indexes,current_component_values_key);
      // Add the created variable
      extracted_variables[dim2] = component_variable;
    }
  delete typed_data;

  return extracted_variables;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

}  // namespace VariableUtils definition

END_ARCGEOSIM_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
