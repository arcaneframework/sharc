// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_MESH_UTILS_VARIABLEVIEW_H
#define ARCGEOSIM_ARCGEOSIM_MESH_UTILS_VARIABLEVIEW_H
/* Author : dechaiss at Wed Nov  7 13:27:03 2012
 * Generated by createNew
 */

#include <arcane/utils/TraceMessage.h>

#include "ArcGeoSim/Utils/ArcGeoSim.h"
#include "ArcGeoSim/Mesh/Utils/ArrayMng.h"
#include "ArcGeoSim/Mesh/Utils/ArrayMngT.h"
#include "ArcGeoSim/Mesh/Utils/ArrayMngT.h"
#include "ArcGeoSim/Utils/ParallelUtils.h"

BEGIN_ARCGEOSIM_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*! Classe VariableView : pour obtenir une vue sur une variable et la manipuler
 * sans en connaitre le type (portï¿½e par le maillage ou non, partielle, scalaire,
 * vectorielle...) et sans connaitre le type de donnees.
 *
 * Testee dans ArcaneDemo/UtilsTestModule
 */

namespace VariableUtils{

/*---------------------------------------------------------------------------*/

class GenericArray;

class VariableData
{
public:
  VariableData(const Arcane::IntegerSharedArray& data_indexes, Arcane::IData* idata)
    : m_data_indexes(data_indexes)
    , m_idata(idata) {}

  void operator=(const GenericArray& array);

private:
  Arcane::IData* _data() {return m_idata;}
  const Arcane::IntegerSharedArray _dataIndexes() const {return m_data_indexes;}

private:
  const Arcane::IntegerSharedArray m_data_indexes;
  Arcane::IData* m_idata;

  friend class GenericArray;
};

/*---------------------------------------------------------------------------*/

class VariableView
{
public:
  /** Constructeur de la classe */
  VariableView(Arcane::IVariable* ivariable) : m_ivariable(ivariable){}

  /** Destructeur de la classe */
  virtual ~VariableView() {}

  VariableData operator[] (const Arcane::ItemGroup& items);

  Arcane::IVariable* variable() const {return m_ivariable;}

private:
  Arcane::IVariable* m_ivariable;

//  friend std::ostream& operator<< (std::ostream& o, const ArcGeoSim::VariableUtils::VariableView& variable_view);
};

/*---------------------------------------------------------------------------*/

class GenericArray
{
public:
  typedef std::pair<ArrayMng::DataKey,ArrayMng* > ArrayInternal;
public:
  GenericArray();
  GenericArray(ArrayMng* array_mng);
  GenericArray(ArrayInternal array_internal);
  GenericArray(ArrayMng* array_mng, const Arcane::String& values);
  GenericArray(ArrayMng* array_mng,
               const Arcane::String& filename,
               const Arcane::String& file_position,
               ArcGeoSim::ParallelUtils& parallel_utils);
  template <class DataType>
  GenericArray(Arcane::SharedArray<DataType> array, Arcane::ISubDomain* subdomain){
    ArcGeoSim::ArrayMngT<DataType>* array_mng = new ArcGeoSim::ArrayMngT<DataType>(subdomain);
    m_array_mng = array_mng;
    m_const_array_mng = m_array_mng;
    m_data_key = array_mng->registerArray(array);
    m_handle_memory = true;
  }

  virtual ~GenericArray();

  void operator= (VariableData variable_data);

  GenericArray operator[] (Arcane::IntegerSharedArray indexes); // Extract a sub array

  bool empty() {return (m_data_key.empty());}

  void print(std::ostream & o) const {return m_array_mng->print(o,m_data_key);}
  Arcane::Integer size() const {return m_array_mng->dataSize(m_data_key);}

  // Conversion operator : to build a concrete array ex: RealArray array(generic_array)
  operator Arcane::RealSharedArray() const {return array<Arcane::Real>();}
  operator Arcane::Real3x3SharedArray() const {return array<Arcane::Real3x3>();}
  operator Arcane::Real3SharedArray() const {return array<Arcane::Real3>();}
  operator Arcane::Real2SharedArray() const {return array<Arcane::Real2>();}
  operator Arcane::Real2x2SharedArray() const {return array<Arcane::Real2x2>();}
  operator Arcane::Int32SharedArray() const {return array<Arcane::Int32>();}
  operator Arcane::Int64SharedArray() const {return array<Arcane::Int64>();}
  operator Arcane::ByteSharedArray() const {return array<Arcane::Byte>();}
  operator ArrayMng::DataKey() const {return m_data_key;} // Used for array interpolation in ArrayMng
  template<typename DataType> Arcane::SharedArray<DataType> array() const;

private:
  ArrayMng* m_array_mng;
  const ArrayMng* m_const_array_mng;
  ArrayMng::DataKey m_data_key;
  bool m_handle_memory;

private:
  ArrayMng* _arrayMng(){return m_array_mng;}
  const ArrayMng* _constArrayMng() const {return m_const_array_mng;}
  const ArrayMng::DataKey _dataKey() const {return m_data_key;}

  friend class VariableData;
};

/*---------------------------------------------------------------------------*/
// Arcane::info() operators
/*---------------------------------------------------------------------------*/

// Use VariableView with arcane info()
inline std::ostream& operator<< (std::ostream& o, const ArcGeoSim::VariableUtils::VariableView& variable_view)
{
  variable_view.variable()->print(o); // Rque pour l'instant ne fonctionne pas avec les MeshArrayVariable cf Scarab Arc201
  return o;
}
// Use GenericArray with arcane info()
inline std::ostream& operator<< (std::ostream& o, const ArcGeoSim::VariableUtils::GenericArray& array)
{
  array.print(o);
  return o;
}


/*---------------------------------------------------------------------------*/
// Template method implementation
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

template<typename DataType>
Arcane::SharedArray<DataType>
GenericArray::
array() const
{
  Arcane::eDataType cast_type = Arcane::DataTypeTraitsT<DataType>::type();
  Arcane::eDataType original_type = m_const_array_mng->dataType();
  Arcane::String error_msg = String::format("Cannot cast Generic Array of type {0} into type {1}",
                                            Arcane::dataTypeName(cast_type), Arcane::dataTypeName(original_type));
  ARCANE_ASSERT((cast_type == original_type), (error_msg.localstr()));
  return dynamic_cast<ArrayMngT<DataType>* >(m_array_mng)->array(m_data_key);
}

/*---------------------------------------------------------------------------*/

} // namespace VariableUtils : VariableView declaration

END_ARCGEOSIM_NAMESPACE


#endif /* ARCGEOSIM_ARCGEOSIM_MESH_UTILS_VARIABLEVIEW_H */
