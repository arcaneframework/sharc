// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_MESH_UTILS_VARIABLEUTILS_H
#define ARCGEOSIM_MESH_UTILS_VARIABLEUTILS_H
/* Author : dechaiss at Wed Jun  8 16:40:38 2011
 * Generated by createNew
 */

#include <arcane/datatype/DataTypes.h>
#include <arcane/IData.h>
#include <arcane/VariableTypes.h>

#include "ArcGeoSim/Utils/ArcGeoSim.h"


using namespace Arcane;

BEGIN_ARCGEOSIM_NAMESPACE

/*---------------------------------------------------------------------------*/

//! Utilitaire de manipulation des variables arcane
/*! Permet de manipuler les variables arcane portees ou non par le maillage
 * (copies, extraction d'un tableau ..). Les methodes retournent des IVariable
 * a partir desquelles on peut creer des references (VariableRef).
 * Si la reference est construite avec un VariableBuildInfo sans preciser de propriete,
 * les proprietes seront perdues et en particulier la variable sera detruite avec la reference
 * (perte de la propriete IVariable::PPersistant). Il est donc conseille de construire
 * la reference directement a partir de l'IVariable ou en utilisant ivariable->property en
 * entree dans le VariableBuildInfo, ou alors d'utiliser la fonction createVariableRef et
 * de stocker la reference. Dans le cas des methodes ou l'on retrourne la reference, les
 * variables ne sont pas construites avec la propriete IVariable::PPersistant. Dans ce cas la,
 * Les variables seront detruites quand un delete sera effectue sur le pointeur.
 * Pour detruire la variable on peut annuler la propriete IVariable::Persistant a partir
 * d'une VariableRef :
 * VariableRef ref(ivariable); ref.unsetProperty(IVariable::Persistant);
 * La variable sera alors detruit avec la reference.
 * Ces utilitaires sont testes dans ArcaneDemo/src/UtilsTest/UtilsTestModule.cc*/
namespace VariableUtils {

//! Copie une variable. Les proprietes de la variable source ne sont pas conservees. Elles peuvent etre redefinies.
Arcane::IVariable* cloneVariable(Arcane::IVariable* const source_variable, const String& clone_name, int clone_property=0);

//! Cree une variable. La variable a la propriete IVariable::PPersistant.
Arcane::IVariable* createVariable(const String& name, const eDataType& data_type, const Integer dimension, ISubDomain* const sub_domain, int property=0);

//! Cree une variable et en retourne la reference. La variable n'a la propriete IVariable::PPersistant. Sa persistance est obtenue en stockant le pointeur VariableRef*
Arcane::VariableRef* createVariableRef(const String& name, const eDataType& data_type, const Integer dimension, ISubDomain* const sub_domain, int property=0);

//! Cree une variable portee par le maillage. La variable a la propriete IVariable::PPersistant.
Arcane::IVariable* createMeshVariable(const String& name, const eDataType& data_type, const eItemKind& item_kind, const Integer dimension,
                                      const bool is_partial, const ItemGroup& group, int property = 0);

//! Cree une variable portee par le maillage et retourne la reference. La variable n'a pas la propriete IVariable::PPersistant.Sa persistance est obtenue en stockant le pointeur VariableRef*
Arcane::VariableRef* createMeshVariableRef(const String& name, const eDataType& data_type, const eItemKind& item_kind, const Integer dimension,
                                           const bool is_partial, const ItemGroup& group, int property = 0);

//! Extrait les composantes d'une variable tableau. Cree une variable pour chaque composante, de nom source_name_i
Arcane::SharedArray<Arcane::IVariable*> extractArrayComponents(Arcane::IVariable* const source_array_variable);

//! Detruit des variables persistantes n'etant plus referencees
void deleteUnreferencedVariable(Arcane::IVariable* const unreferenced_variable, Arcane::ITraceMng* const trace_mng);

//! Detruit une variable obtenue par createVariableRef ou createMeshVariableRef. Il ne doit pas y avoir d'autre reference active
//! que celle fournie par la fonction create
void deleteVariableFromRef(Arcane::VariableRef*& variable_ref, Arcane::ITraceMng* const trace_mng);

//! Tailles de la donnee \a mesh_array_variable_data d'une variable tableau sur le maillage.
/* \a item_number donne le nombre d'item et \a array_size la dimension du tableau.*/
void meshVariableArraySize(Arcane::IData* mesh_array_variable_data, Integer& item_number, Integer& array_size);

//! Redimensionne le tableau d'une variable tableau portee par le maillage.
void resizeMeshVariableArray(Arcane::IVariable* mesh_array_variable, Arcane::Integer dim2_size);

//! Redimensionne le tableau d'une variable tableau non portee par le maillage
void resizeVariableArray(Arcane::IVariable* array_variable, Arcane::Integer size);

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

// Private tools
inline Arcane::VariableRef * _switchVariable(const String& name, const eDataType& data_type, const Integer dimension, ISubDomain* const sub_domain, int property = 0);
inline Arcane::VariableRef * _switchMeshVariable(const String& name, const eDataType& data_type, const eItemKind& item_kind, const Integer dimension,
                                const bool is_partial, const ItemGroup& group, int property = 0);

template< template<typename> class VariableT> inline Arcane::VariableRef * _switchDataTypeT(const eDataType& data_type,const VariableBuildInfo& builder);
template< template<typename> class VariableT> inline Arcane::VariableRef * _switchMeshDataTypeT(const eDataType& data_type,const eItemKind& item_kind ,
                                                                                                const VariableBuildInfo& builder);
inline Arcane::SharedArray<Arcane::IVariable*> _extractVariableArrayComponents(Arcane::IVariable* const source_array_variable);
inline Arcane::SharedArray<Arcane::IVariable*> _extractMeshVariableArrayComponents(Arcane::IVariable* const source_array_variable);


}  // namespace VariableUtilsPrivateTools definition


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_ARCGEOSIM_NAMESPACE

#endif /* ARCGEOSIM_MESH_UTILS_VARIABLEUTILS_H */
