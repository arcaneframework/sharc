// -*- C++ -*-
#ifndef ARCGEOSIM_MESH_IXMTOOLS_IXMTOOLS_H
#define ARCGEOSIM_MESH_IXMTOOLS_IXMTOOLS_H
/* Author : dechaiss at Tue May 31 15:52:18 2011
 * Generated by createNew
 */

#include <list>
//DEBUG
#include <iostream>

#include <arcane/IMesh.h>
#include <arcane/ItemTypeMng.h>
#include <arcane/ItemTypeInfo.h>

#include "ArcGeoSim/Utils/ArcGeoSim.h"
#include "ArcGeoSim/Utils/DataTypeUtils.h"
#include "ArcGeoSim/Mesh/Utils/StringToItemUtils.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMItemConnections.h"

#define BEGIN_IXM_NAMESPACE namespace IXMTools{
#define END_IXM_NAMESPACE }

#define USING_IXM_NAMESPACE using namespace IXMTools;

BEGIN_ARCGEOSIM_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_IXM_NAMESPACE


// Mesh file Format info

enum eIXMDataFormat
{
  hdf, split_hdf, xml
};

inline Arcane::String ixmDataFormatName(const eIXMDataFormat& data_format)
{
  Arcane::String name;
  switch (data_format)
  {
    case hdf:
      name = "hdf";
      break;
    case split_hdf:
      name = "split_hdf";
      break;
    case xml:
      name = "xml";
      break;
  }
  return name;
}


// Structure to store mesh dimension
struct IXMMeshDimension
{
  IXMMeshDimension(const Arcane::String& dimension_name) : dimension_name(dimension_name)
    {
      if (dimension_name == "3Dxyz") dimension = 3;
      else dimension  = 2;
    }
  Arcane::Integer operator() () const {return dimension;}
  Arcane::String name() const {return dimension_name;}
  Arcane::String dimension_name;
  Arcane::Integer dimension;
};

/*---------------------------------------------------------------------------*/

// Class for on the fly check while reading
class IXMMeshInfo
{
public:


  IXMMeshInfo(Integer dimension,bool check)
      : m_dimension(dimension), m_check(check)
    {
      // Construct ItemType dimension table
      Arcane::ItemTypeMng * typeMng = Arcane::ItemTypeMng::singleton();
      const Arcane::Integer nb_type = typeMng->nbBasicItemType();
      m_type_dimension.resize(nb_type);
      for(Arcane::Integer i_type=0;i_type<nb_type;++i_type)
        {
          Arcane::ItemTypeInfo* type_info = typeMng->typeFromId(i_type);
          if (type_info->nbLocalNode() <= 1)
            m_type_dimension[i_type] = 0;
          else if (type_info->nbLocalEdge() == 0)
            m_type_dimension[i_type] = 1;
          else if (type_info->nbLocalEdge() == type_info->nbLocalFace())
            m_type_dimension[i_type] = 2;
          else
            m_type_dimension[i_type] = 3;
        }

    }

  void setMeshDimension(const Arcane::Integer mesh_dimension) {m_dimension = mesh_dimension;} // sometimes not available when building instance (e.g. in a Service constructor)

  Arcane::Integer dimension() const {return m_dimension;}

  void enableCheck(bool check) {this->m_check = check;}

  bool  isCheckEnabled() const {return m_check;}

  Arcane::IntegerConstArrayView typeDimension() const {return m_type_dimension;}

  Integer coordDimension() const {return m_coord_dimension;}

  private:

  Arcane::Integer m_dimension;

  bool m_check;


  Arcane::IntegerSharedArray m_type_dimension;

  const static Integer m_coord_dimension; //<! Correspond aux nombres composantes des coordonn���������es : ici toujours 3 valeurs (x,y,z) m���������me en 2D.
  //<! Initialise dans IXMMeshBuilderBase.cc
};


template<typename InfoType>
struct IXMItemData
{
  Arcane::Int64SharedArray item_ids;
  InfoType item_infos;
};

/*---------------------------------------------------------------------------*/

typedef IXMItemData<Arcane::Int64SharedArray> IXMCellData ;
typedef IXMItemData<Arcane::Int64SharedArray> IXMEdgeData ;
typedef IXMItemData<Arcane::Real3SharedArray> IXMNodeData;
typedef IXMItemData<Arcane::Int64SharedArray> IXMClonedNodeData ;
typedef IXMItemData<Arcane::Int64SharedArray> IXMNodeIncrementData ;
typedef IXMItemData<Arcane::Int64SharedArray> IXMConnectionData;

/*---------------------------------------------------------------------------*/

struct IXMCellIncrementData
{
  IXMCellData removed_cell_data;
  IXMCellData changed_cell_data;
  IXMCellData new_cell_data;
};

/*---------------------------------------------------------------------------*/

 struct IXMFaceData
{
  typedef IXMItemData<Arcane::IntegerSharedArray> IXMFaceDataType;
  IXMFaceDataType faces; // Face ids and face node number
  Arcane::Int64SharedArray node_ids; // Face node ids
};


/*---------------------------------------------------------------------------*/

struct IXMParticleData
{
  typedef IXMItemData<Arcane::IntegerSharedArray> IXMParticleDataType;
  IXMParticleDataType particles; // Particle ids and particle type
  IXMNodeData xyz; // cell id an xyz
};

/*---------------------------------------------------------------------------*/

struct IXMUpdateNodeData
{
  IXMNodeData added_nodes;
  IXMClonedNodeData cloned_nodes;
};

/*---------------------------------------------------------------------------*/

struct IXMGroupData
{
  Arcane::eItemKind kind;
  Arcane::String name;
  Arcane::Int64SharedArray ids;
};

typedef std::list<IXMGroupData> IXMGroupDataList;

/*---------------------------------------------------------------------------*/

struct IXMGroupIncrementData
{
  IXMGroupData group_data;
  Arcane::String mode;
};

typedef std::list<IXMGroupIncrementData> IXMGroupIncrementDataList;

/*---------------------------------------------------------------------------*/

struct IXMPropertyValuesData
{
  enum eDataStringContent {DataArray, DataFileAddress, DataUndefined}; // indicates if the data string contains directly data array or only data file address

  static Arcane::String dataStringContentName(const eDataStringContent& data_string_content)
    {
      Arcane::String name;
      switch (data_string_content) {
        case DataArray:
          name = "DataArray";
          break;
        case DataFileAddress:
          name= "DataFileAddress";
          break;
        default:
        	name = "DataUndefined";
      }
      return name;
    }

  static eDataStringContent dataStringContentFromName(const Arcane::String & name)
  {
    if ("DataArray" == name) return DataArray;
    if ("DataFileAddress" == name) return DataFileAddress;
    throw Arcane::FatalErrorException(A_FUNCINFO,"No such DataStringContent name");
  }

  IXMPropertyValuesData() : is_empty(true) {}
  IXMPropertyValuesData(const Arcane::String& data_string,
                        const eDataStringContent content)
    : data_string(data_string)
    , data_string_content(content)
    , is_empty(false) {}

  Arcane::String data_string;
  eDataStringContent data_string_content;
  bool is_empty;

  void push_back(const IXMPropertyValuesData& values_data)
  {
    data_string = values_data.data_string;
    data_string_content = values_data.data_string_content;
    is_empty = false;
  }

  bool empty() const {return is_empty;}
};

struct IXMPropertyIncrementValuesData : public IXMPropertyValuesData
{
  IXMPropertyIncrementValuesData(){}
  IXMPropertyIncrementValuesData(const Arcane::Real& time,
                        const Arcane::String& data_string,
                        const eDataStringContent data_string_content)
    : IXMPropertyValuesData(data_string,data_string_content)
    , time(time) {}

  Arcane::Real time;
};

typedef std::list<IXMPropertyIncrementValuesData > IXMPropertyIncrementValuesDataList;

/*---------------------------------------------------------------------------*/

struct IXMPropertyDataBase
{
  Arcane::String kind;
  Arcane::String name;
  Arcane::String group_name;
  Arcane::String data_type;
  Arcane::Integer data_array_size;
};

/*---------------------------------------------------------------------------*/

struct IXMPropertyData : public IXMPropertyDataBase
{
  IXMItemData<IXMPropertyValuesData> support_and_values; // item_ids = support ; item_infos = IXMPropertyValuesData)
};

typedef std::list<IXMPropertyData> IXMPropertyDataListImpl;

struct IXMPropertyDataList : public IXMPropertyDataListImpl
{
  static Arcane::String mesh_type;
  typedef IXMPropertyData PropertyDataType;
  typedef IXMPropertyValuesData PropertyValuesDataType;

  static IXMPropertyValuesData build(const Arcane::String& data_string,const IXMPropertyValuesData::eDataStringContent data_string_content)
    {return IXMPropertyValuesData(data_string, data_string_content);}
  static IXMPropertyValuesData build(const Arcane::Real time, const Arcane::String& data_string,const IXMPropertyValuesData::eDataStringContent data_string_content)
    {return IXMPropertyValuesData();} // return empty object. Wrong usage (necessary to compile template property reading).
};

/*---------------------------------------------------------------------------*/

struct IXMPropertyIncrementData : public IXMPropertyDataBase
{
  IXMItemData<IXMPropertyIncrementValuesDataList> support_and_values; // item_ids = support ; item_infos = IXMPropertyIncrementValuesDataList
};

typedef std::list<IXMPropertyIncrementData> IXMPropertyIncrementDataListImpl;

struct IXMPropertyIncrementDataList : public IXMPropertyIncrementDataListImpl
{
  static Arcane::String mesh_type;
  typedef IXMPropertyIncrementData PropertyDataType;
  typedef IXMPropertyIncrementValuesData PropertyValuesDataType;

  static IXMPropertyIncrementValuesData build(const Arcane::Real time,const Arcane::String& data_string,const IXMPropertyValuesData::eDataStringContent data_string_content)
    {return IXMPropertyIncrementValuesData(time,data_string, data_string_content);}
  static IXMPropertyIncrementValuesData build(const Arcane::String& data_string,const IXMPropertyValuesData::eDataStringContent data_string_content)
    { return IXMPropertyIncrementValuesData();} // return empty object. Wrong usage : time is needed. (necessary to compile template property reading).
};

/*---------------------------------------------------------------------------*/

typedef IXMItemData<Arcane::Real3SharedArray> IXMGeometryIncrementData;

/*---------------------------------------------------------------------------*/

struct IXMCellPartitionInfo
{
  Arcane::Int64SharedArray connectivity_infos;
  Arcane::Int32SharedArray connectivity_owners;
};

/*---------------------------------------------------------------------------*/

struct IXMCellIncrementPartitionInfo
{
  IXMCellPartitionInfo new_cells;
  IXMCellPartitionInfo changed_cells;
  Arcane::Int32SharedArray new_cell_owners;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
// IXMProperty tools

namespace IXMPropertyExceptions {

// Exception handling
  struct SkippedPropertyException : public Arcane::Exception
  {
    SkippedPropertyException(const Arcane::String & property_name, const Arcane::String & message)
     : Exception("SkippedPropertyException",
                  A_FUNCINFO,
                  Arcane::String::format("WARNING: skip Property {0} cause: {1} ", property_name, message)) {}
    inline const Arcane::String print() const {return message();}
  };

  struct InconsistentPropertyDescriptionException : public Arcane::Exception
  {
    InconsistentPropertyDescriptionException(const Arcane::String& property_name,const Arcane::String & message)
    : Exception("InconsistentPropertyDescriptionException",
                  A_FUNCINFO,
                  Arcane::String::format("WARNING: inconsistent description of Property {0} cause: {1}",property_name,message)) {}
    inline const Arcane::String print() const {return message();}
  };

}  // namespace IXMPropertyExceptions

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

inline Arcane::String dataTypeIXMName(const Arcane::eDataType& data_type)
{
  if (Arcane::DT_Byte == data_type) return "bool";
  return ArcGeoSim::DataTypeConversion::dataTypeToString(data_type).lower();
}

/*---------------------------------------------------------------------------*/

inline Arcane::eDataType dataTypeFromIXMName(const Arcane::String& ixm_name)
{
  if (ixm_name == "bool") return Arcane::DT_Byte;
  Arcane::StringSharedArray ixm_name_array(2);
  ixm_name_array[0] = ixm_name.substring(0,1).upper();
  ixm_name_array[1] = ixm_name.substring(1);
  return ArcGeoSim::DataTypeConversion::stringToDataType(Arcane::String::concat(ixm_name_array[0],ixm_name_array[1]));
}

/*---------------------------------------------------------------------------*/

inline Arcane::eItemKind itemKindFromIXMName(const Arcane::String& ixm_kind_name)
{
  if (ixm_kind_name == "connection") return ItemConnectionImpl::kind();
  return ArcGeoSim::StringToItemUtils::stringToItemKind(ixm_kind_name);
}

/*---------------------------------------------------------------------------*/

inline Arcane::String itemKindIXMName(const Arcane::eItemKind& item_kind)
{
#if (ARCANE_VERSION >= 30003)
  if (item_kind == Arcane::IK_DoF) return "connection";
#endif
  if (item_kind == ItemConnectionImpl::kind()) return "connection";
  return ArcGeoSim::StringToItemUtils::itemKindToString(item_kind);
}

/*---------------------------------------------------------------------------*/

inline bool hasAbstractIds(const Arcane::eItemKind& item_kind)
{
  bool has_aids = false;
  if (Arcane::IK_Face == item_kind) has_aids = true;
  if (ItemConnectionImpl::kind() == item_kind) has_aids = true;
  return has_aids;
}

/*---------------------------------------------------------------------------*/

inline Arcane::String allConnectionsGroupName() {return "AllConnections";}

/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_IXM_NAMESPACE

END_ARCGEOSIM_NAMESPACE

// include IXM Tools

#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMItemAidMapper.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMItemConnections.h"


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/



#endif /* ARCGEOSIM_MESH_IXMTOOLS_IXMTOOLS_H */
