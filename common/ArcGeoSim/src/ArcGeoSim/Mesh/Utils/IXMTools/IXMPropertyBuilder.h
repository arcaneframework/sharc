// -*- C++ -*-
#ifndef ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMPROPERTYBUILDER_H
#define ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMPROPERTYBUILDER_H
/* Author : dechaiss at Mon Apr 11 16:04:39 2011
 * Generated by createNew
 */

#include <map>
#include <list>
#include <set>
#include <iostream>
#include <cassert>

#include <arcane/utils/UtilsTypes.h>
#include <arcane/utils/Real3.h>
#include <arcane/utils/Array.h>
#include <arcane/XmlNode.h>
#include <arcane/XmlNodeList.h>
#include <arcane/MeshVariable.h>
#include <arcane/IVariable.h>
#include <arcane/IMesh.h>
#include <arcane/IItemFamily.h>
#include <arcane/ItemVector.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/ISubDomain.h>
#include <arcane/IData.h>
#include <arcane/ItemGroup.h>
#include <arcane/utils/ValueConvert.h>
#include <arcane/VariableBuildInfo.h>

using namespace Arcane;

#include "ArcGeoSim/Mesh/Utils/StringToItemUtils.h"
//#include "ArcGeoSim/Mesh/EvolutiveMesh/IEvolutiveMesh.h"
#include "ArcGeoSim/Mesh/Utils/ArrayMng.h"
#include "ArcGeoSim/Mesh/Utils/ArrayMngT.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMTools.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMMeshReaderTools.h"

#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMUidToLidMng.h"
#include "ArcGeoSim/Mesh/Utils/VariableView.h"

BEGIN_ARCGEOSIM_NAMESPACE

using namespace IXMTools;

/*---------------------------------------------------------------------------*/
// Class IXMPropertyBuilderImpl
/*---------------------------------------------------------------------------*/

class IXMPropertyBuilderImpl
{
public:
  
  //!Constructeur de la classe, cas maillage evolutif
  //IXMPropertyBuilderImpl(IEvolutiveMesh* const evolutive_mesh, IMesh* const mesh);

  //!Constructeur de la classe, cas maillage static
  IXMPropertyBuilderImpl(IMesh* const mesh);

#if (ARCANE_VERSION >= 30003)
  void setGraph(IGraph2* graph) {
    m_graph = graph ;
  }
#endif
  /** Destructeur de la classe */
  virtual ~IXMPropertyBuilderImpl();

  // Pre-declaration
  class PropertyDescription;
  class PropertyValues;

public:

  //! Positionne le repertoire de maillage
  void setMeshDirectory(const Arcane::String& mesh_directory_name){m_mesh_directory_name = mesh_directory_name;}

#ifdef USE_EVOLUTIF
  //! Charge l'�v�nement courant
  void loadEvent(const IXMPropertyIncrementDataList& properties, const Real& event_begin_time, const Real& event_end_time);

  //! Charge les propri�t�s de l'�v�nement courant
  void loadProperty(const IXMPropertyIncrementDataList& properties, const IXMUidToLidMng& aid_to_lids,bool is_step_replayed, const bool check_property_existence);
#endif
  //! Remplit les propri�t�s � remplir de l'�v�nement courant
  bool setProperty();

#ifdef USE_EVOLUTIF
  //! Remplit les propri�t�s � remplir de l'�v�nement courant
  bool computePropertyEvolution(const Real& end_timestep);
#endif

  //! Retourne une propri�t� d�crivant l'�tat de remplissage de la propri�t�s
  const Arcane::VariableItemByte propertyFilledItemVariable(const String& property_name, bool& has_filled_items) const;

  //! Indique si la propri�t� a chang� au cours de l'�v�nement
  bool hasPropertyChanged(const Arcane::String& property_name) const;

  //! Affichage des infos pour le debug
  void printInfos() const;

#ifdef USE_EVOLUTIF
  //! Declenche par un observeur sur le maillage evolutif pour mettre a jour avec les nouveaux items
  //! la variable indiquant l'etat de remplissage de la propriete
  void updateFilledItemVariables();
#endif

  //! Creation des proprietes dans le cas d'un maillage statique. Toutes les autres methodes concernent le maillage evolutif
  void createAndFillProperties(const IXMPropertyDataList& properties, const IXMUidToLidMng& aid_to_lids);

protected:

  /*!
  *  Classe d'information sur une propri�t� modifi�e par IXMPropertyBuilder.
  *  Le champ m_filled_item_variable est une variable portee par le maillage indiquant les items de la proprietes ayant ete remplis.
  *  Cette variable est de type Byte, d�fini sur tout le maillage. Son type d'item est celui de la propri�t�.
  *  Chaque �l�ment modifi� est mis � true.
  *  Si la propriete n'est pas portee par le maillage, le champ m_filled_item_variable = NULL
  */
  class ModifiedProperty
  {
  public:
    ModifiedProperty(const Arcane::String& property_name, Arcane::IVariableMng* variable_mng);
    ModifiedProperty(const Arcane::String& property_name);
    ModifiedProperty(const PropertyDescription& property_description);
    operator bool() {return (!m_is_empty);}
    operator Arcane::VariableItemByte();
    operator Arcane::IVariable*() const {return m_filled_item_variable;}
    bool operator== (const ModifiedProperty& modified_property);
    bool operator< (const ModifiedProperty& modified_property) const;
    const Arcane::String name() const {return m_property_name;}
  private:
    bool m_is_empty;
    Arcane::IVariable* m_filled_item_variable;
    Arcane::String m_property_name;
    Arcane::IVariableMng* m_variable_mng;
  };

  /*! Ensemble de propri�t�s modifi�s par IXMPropertyBuilder*/
  class ModifiedProperties
  {
  private:
    typedef std::set<ModifiedProperty > ModifiedPropertiesType;
    ModifiedPropertiesType m_properties;
    Arcane::IVariableMng* m_variable_mng;
  public:
    typedef ModifiedPropertiesType::const_iterator const_iterator;
    typedef ModifiedPropertiesType::iterator iterator;
  public:
    ModifiedProperties(Arcane::IVariableMng* variable_mng) : m_variable_mng(variable_mng){}
    ModifiedProperty operator[](const Arcane::String& property_name) const;
    void add(const PropertyDescription& property_description) {m_properties.insert(property_description);}
    void clear() {m_properties.clear();} // free memory
    iterator begin() {return m_properties.begin();}
    iterator end() {return m_properties.end();}
  };

  // Modified Properties : during the current event or through the whole simulation
  ModifiedProperties m_current_modified_properties; //!<Propriete modifiee au cours de l'evenement courant.
  ModifiedProperties m_modified_property_history; //!<Historiques des proprietes modifies au travers des evenements.

  typedef std::list<PropertyDescription* > DescriptionContainer;
  DescriptionContainer m_current_property_description;//!<Descriptions de toutes les propri�t�s de l'�v�nement courant

  //IEvolutiveMesh* const m_evolutive_mesh; //!<Interface du service contenant le PropertyManager. Pour suivre les ajouts d'items.


  // Event Information
  Real m_event_begin_time; //!<Temps initial de l'�v�nement courant. Utilis�s pour l'interpolation.
  Real m_event_end_time; //!<Temps final de l'�v�nement courant. Utilis� pour l'interpolation.

  // Check tools
  bool m_is_event_loaded = false;
  bool m_is_event_conform = false;
  bool m_is_property_loaded = false;
  typedef std::map<String,bool> PropertyConformityType;
  PropertyConformityType m_is_property_conform;//!<Conformit� de chacune des propri�t�s de l'�v�nement courant

  // State information
  bool m_has_face_property;

  // Arcane tools
  IMesh* m_mesh = nullptr;
#if (ARCANE_VERSION >= 30003)
  IGraph2* m_graph = nullptr ;
#endif
  ITraceMng* m_trace_mng = nullptr;

  Arcane::String m_mesh_directory_name;

#ifdef USE_EVOLUTIF
  void _unloadEvent();
  void _unloadProperty();
  void _checkPeriodEventConformity(const IXMPropertyIncrementDataList& properties, const Real& event_begin_time, const Real& event_end_time);
  void _checkDateEventConformity(const IXMPropertyIncrementDataList& properties, const Real& event_time);
#endif

  void _createPropertyData(const PropertyDescription& description);
  bool _handleErrorStatus(bool has_error,const String & message);
  void _storePropertyVariableRef(Arcane::VariableRef* const created_property_variable_ref);
#ifdef USE_EVOLUTIF
  void _updateFilledItemVariable(Arcane::IVariable* filled_item_ivariable);
#endif
  void _addModifiedProperty(const ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription& property_description);
  bool _isPropertyInitialized(const PropertyDescription& description, const Arcane::ItemGroup& item_group);


public:

  class BaseProperty
  {
  public :
    BaseProperty(Arcane::IMesh* const mesh)
    : m_mesh(mesh)
    {}

#if (ARCANE_VERSION >= 22200)
    void setGraph(IGraph2* graph) {
      m_graph = graph ;
    }
#endif

    Arcane::IItemFamily* itemFamily(Arcane::eItemKind item_kind)
    {
#if (ARCANE_VERSION >= 22200)
      if (item_kind == Arcane::IK_Particle)
      {
        return m_mesh->findItemFamily(IK_Particle,"Particle",true);
      }
      if (item_kind == ItemConnectionImpl::ik_type)
      {
        assert(m_graph!=nullptr) ;
        return m_graph->linkFamily() ;
      }
      else
      {
        return m_mesh->itemFamily(item_kind);
      }
#else
      if (item_kind == Arcane::IK_Particle)
      {
        return m_mesh->findItemFamily(IK_Particle,"Particle",true);
      }
      else
      {
        return m_mesh->itemFamily(item_kind);
      }
#endif
    }
  protected :
    IMesh* const m_mesh = nullptr ;
#if (ARCANE_VERSION >= 22200)
    IGraph2* m_graph = nullptr ;
#endif
  } ;

  class PropertyDescription : public BaseProperty
  {
  public:
    using BaseType = BaseProperty ;
#if (ARCANE_VERSION >= 30003)
    PropertyDescription(Arcane::IMesh* const mesh, Arcane::IGraph2* graph) noexcept(false) ;
#else
    PropertyDescription(Arcane::IMesh* const mesh) noexcept(false) ;
#endif
    /*
    PropertyDescription(const IXMPropertyIncrementData& property,
                        IEvolutiveMesh* const evolutive_mesh,
                        Arcane::IMesh* const mesh,
#if (ARCANE_VERSION >= 22200)
                        Arcane::IGraph2* graph,
#endif
                        const bool check_property_existence) noexcept(false) ;
    */

    PropertyDescription(const IXMPropertyData& property,
#if (ARCANE_VERSION >= 30003)
                        Arcane::IMesh* const mesh, Arcane::IGraph2* graph) noexcept(false) ;
#else
                        Arcane::IMesh* const mesh) noexcept(false) ;
#endif
  public:

    virtual ~PropertyDescription();

  public:
#ifdef USE_EVOLUTIF
    void createPropertyValues(const Real& begin_event_time, const Real& end_event_time,
                              const IXMPropertyIncrementValuesDataList& values_list, const Int64Array& support,
                              const IXMUidToLidMng& aid_to_lids, const Arcane::String& mesh_directory_name) noexcept(false) ;
#endif
    void createPropertyValues(const IXMPropertyValuesData& values, const Int64Array& support,
                              const IXMUidToLidMng& aid_to_lids, const Arcane::String& mesh_directory_name) noexcept(false) ;

    IVariable* filledItemVariable() const {return m_filled_item_variable;}

    void saveInitialPropertyVariable();

    virtual void saveModifiedItems(const ItemGroup& modified_items);// save filled items in an allMesh Arcane Variable

    const String name() const {return m_name;}

    PropertyValues* settedPropertyValues() {return m_setted_property_values;}

    PropertyValues* evolvingPropertyValues() {return m_evolving_property_values;}

    ItemGroup group() {return m_group;}

    eItemKind itemKind() {return ArcGeoSim::IXMTools::itemKindFromIXMName(m_kind);}

    const String dataType() {return m_type;}

    IVariable* const variable() {return m_property_variable;}

    void printInfos() const;

    static const String modifiedItemsVariableName(const String& property_name) {return String::concat(property_name,"_modified_items");}

    Arcane::VariableRef* createdPropertyVariableRef() {return m_created_property_variable_ref;}

    Arcane::Integer arraySize() {return m_array_size;}

    bool isGlobal() {return m_is_global;}

  protected:
    String m_name;
    String m_type;
    String m_group_name;
    String m_kind;
    IVariable* m_property_variable = nullptr;//!<Variable Arcane de la propri�t� courante
    IVariable* m_initial_property_variable = nullptr;//!<Variable copie de la propri�t� au d�but de l'�v�nement
    PropertyValues* m_setted_property_values = nullptr;//!<Jeu de Valeurs de la propri�t� lue courante
    PropertyValues* m_evolving_property_values = nullptr;//!<Jeu de Valeurs de la propri�t� interpol�e courante
    IVariable* m_filled_item_variable = nullptr;//!<Variable indiquant les �l�ments remplis (mis � true).
    //IEvolutiveMesh* const m_evolutive_mesh;
    ITraceMng* m_trace_mng  = nullptr ;
    bool m_is_initial_property_saved = false;
    Integer m_dimension;
    Integer m_array_size;
    VariableRef* m_created_property_variable_ref = nullptr;//!<VariableRef Arcane de la propri�t�s Utilis� uniquement si la propri�t�s est cr�che.
    Arcane::ItemGroup m_group;
    bool m_is_global;

  protected:
    void _loadPropertyVariable(const bool check_property_existence) noexcept(false) ;
    void _loadMeshVariable(const bool check_property_existence) noexcept(false) ;
    void _loadGlobalVariable(const bool check_property_existence) noexcept(false) ;
    void _checkPropertyDescription() const noexcept(false) ;
#ifdef USE_EVOLUTIF
    const IXMPropertyIncrementValuesData _findValuesData(const IXMPropertyIncrementValuesDataList& values_list,const Real& time) const;
#endif
    template <class PropertyValuesData>
    bool _isPropertyEmpty(const PropertyValuesData& values_list, const Arcane::Int64Array& support) const;
    void _deleteInitialPropertyVariable();
    void _deletePropertyValues();
    void _setPropertyDimension(const Arcane::Integer& property_data_array_size);
  };

  class PropertyValues : public BaseProperty
  {
  public:
    PropertyValues(PropertyDescription* const parent_description,
                   IVariable* const property,
                   IMesh* const mesh,
#if (ARCANE_VERSION >= 30003)
                   Arcane::IGraph2* graph,
#endif
                   const Arcane::String& mesh_directory_name);
    /*
    PropertyValues(const IXMPropertyIncrementValuesData& property_values,
                   const Int64Array& support,
                   const IXMUidToLidMng& aid_to_lids,
                   PropertyDescription* const parent_description,
                   IVariable* const property,
                   const String & status,
                   IEvolutiveMesh* const evolutive_mesh,
                   IMesh* const mesh,
#if (ARCANE_VERSION >= 30003)
                   Arcane::IGraph2* graph,
#endif
                   const Arcane::String& mesh_directory_name);*/

    PropertyValues(const IXMPropertyValuesData& property_values,
                   const Int64Array& support,
                   const IXMUidToLidMng& aid_to_lids,
                   PropertyDescription* const parent_description,
                   IVariable* const property,
                   const String & status,
                   IMesh* const mesh,
#if (ARCANE_VERSION >= 30003)
                   Arcane::IGraph2* graph,
#endif
                   const Arcane::String& mesh_directory_name);

    virtual ~PropertyValues(){delete m_values_mng;if (m_item_values_indexes) delete m_item_values_indexes;};

  public:
    enum eFillPropertyChoice {WithInterpolatedValues, WithReadValues};

  public:
    void fillPropertyVariable(const eFillPropertyChoice& fill_property_choice);

    void saveInitialProperty(IVariable* const initial_variable){m_initial_property = initial_variable;}

    void extractPropertyVariableInitialValues();

    void computeInterpolatedValues(const Real& end_timestep,const Real& event_begin_time,const Real& event_end_time);

    void updateLocalValues();

    void printInfos() const;

    Arcane::ItemGroup support() const {return m_support_group;}

  protected:
    String m_values_status;//!< evolving ou setted
    ArcGeoSim::ArrayMng* m_values_mng = nullptr;
    ArcGeoSim::VariableUtils::GenericArray m_values;
    ArcGeoSim::VariableUtils::GenericArray m_local_values;
    ArcGeoSim::VariableUtils::GenericArray m_initial_values;
    ArcGeoSim::VariableUtils::GenericArray m_interpolated_values;
    Real m_time = 0.;
    ArcGeoSim::VariableUtils::VariableView m_property;
    ArcGeoSim::VariableUtils::VariableView m_initial_property;
    PropertyDescription* const m_parent_property_description  = nullptr;
    //IEvolutiveMesh* const m_evolutive_mesh;
    ITraceMng* m_trace_mng = nullptr;
    ItemGroup m_support_group;
    Arcane::PartialVariableItemArrayInt64* m_item_values_indexes = nullptr;
    Arcane::String m_mesh_directory_name;

  protected:
    void _buildSupportGroup(const Int64ConstArrayView& support_uids, const IXMUidToLidMng& aid_to_lids);
    template <class PropertyValuesData>
    void _buildPropertyValues(const PropertyValuesData& values_data,
                              const Int64Array& support_uids,
                              const IXMUidToLidMng& aid_to_lids);
    template <class PropertyValuesData>
    void _registerValues(const PropertyValuesData& property_values);
    void _checkItemsInVariableGroup(const Arcane::ItemVectorView& variable_group, const Arcane::Int32Array& items, const Arcane::Int64Array& item_uids);
    Arcane::String _supportGroupName() {return String::format("property_{0}_{1}_values",m_parent_property_description->name(),m_values_status);}
    Arcane::String _itemValuesIndexesVariableName() {return String::format("{0}{1}ValuesItemValuesIndexesVariable",m_parent_property_description->name(),m_values_status);}
  };

};


template<class PropertyValuesData>
bool
IXMPropertyBuilderImpl::PropertyDescription::
_isPropertyEmpty(const PropertyValuesData& values_data, const Arcane::Int64Array& support) const
{
  if (values_data.empty() && support.empty()) return true;
  else return false;
}


template <class PropertyValuesData>
void
IXMPropertyBuilderImpl::PropertyValues::
_buildPropertyValues(const PropertyValuesData& property_values,
                     const Int64Array& support_uids,
                     const IXMUidToLidMng& aid_to_lids)
{
  using namespace ArcGeoSim::IXMTools::IXMPropertyExceptions;
  // Read values node
  _registerValues(property_values);

  // m_trace_mng->info() << "--------------m_values--------------------";

  // m_trace_mng->info() << m_values;

  // Check support/values coherence
  Arcane::Integer support_size = (m_parent_property_description->isGlobal()) ? 1 :support_uids.size();
  Arcane::Integer total_size = support_size*m_parent_property_description->arraySize();
  if (total_size != m_values.size()) throw InconsistentPropertyDescriptionException (
      m_parent_property_description->name(),
      Arcane::String::format("number of elements in values {0} is not correct. Support = {1}, support uids {2}",m_values.size(),support_size, support_uids.size() ));

  // Build support item group
  _buildSupportGroup(support_uids,aid_to_lids);
}


template <class PropertyValuesData>
void
IXMPropertyBuilderImpl::PropertyValues::
_registerValues(const PropertyValuesData& property_values)
{
  using namespace ArcGeoSim::IXMTools::IXMPropertyExceptions;
  Arcane::eDataType data_type = ArcGeoSim::IXMTools::dataTypeFromIXMName(m_parent_property_description->dataType());
  switch (data_type) {
    case Arcane::DT_Byte:
      m_values_mng = new ArcGeoSim::ArrayMngT<Byte> (this->m_mesh->subDomain());
      break;
    case Arcane::DT_Int32:
      m_values_mng = new ArcGeoSim::ArrayMngT<Int32> (this->m_mesh->subDomain());
      break;
    case Arcane::DT_Int64:
      m_values_mng = new ArcGeoSim::ArrayMngT<Int64> (this->m_mesh->subDomain());
      break;
    case Arcane::DT_Real:
      m_values_mng = new ArcGeoSim::ArrayMngT<Real> (this->m_mesh->subDomain());
      break;
    case Arcane::DT_Real2:
      m_values_mng = new ArcGeoSim::ArrayMngT<Real2> (this->m_mesh->subDomain());
      break;
    case Arcane::DT_Real2x2:
      m_values_mng = new ArcGeoSim::ArrayMngT<Real2x2> (this->m_mesh->subDomain());
      break;
    case Arcane::DT_Real3:
      m_values_mng = new ArcGeoSim::ArrayMngT<Real3> (this->m_mesh->subDomain());
      break;
    case Arcane::DT_Real3x3:
      m_values_mng = new ArcGeoSim::ArrayMngT<Real3x3> (this->m_mesh->subDomain());
      break;
    case Arcane::DT_String:
      throw InconsistentPropertyDescriptionException(m_parent_property_description->name(),"string not allowed as a ixm property data type");
      break;
    case Arcane::DT_Unknown:
      throw InconsistentPropertyDescriptionException(m_parent_property_description->name(),"unknown ixm property data type");
      break;
  }

  // Get string
  String values_string = property_values.data_string;

  if (values_string.empty()) throw InconsistentPropertyDescriptionException(
      m_parent_property_description->name(),
      "property values is empty");

  // Set GenericArray

  // Initial values (filled later)
  m_initial_values = ArcGeoSim::VariableUtils::GenericArray(m_values_mng);

  // Property values
  // Extract data from string or from file in m_typed_data and store a reference on it in m_values_key
  // Case where the string directly contains the array
  if (property_values.data_string_content == IXMTools::IXMPropertyValuesData::DataArray)
    m_values = ArcGeoSim::VariableUtils::GenericArray(m_values_mng,values_string);
  // Case where the string contains the address of the file containing the data
  else if (property_values.data_string_content == IXMTools::IXMPropertyValuesData::DataFileAddress)
    {
      Arcane::String filename;
      Arcane::String file_position;
          ArcGeoSim::fileNameAndPositionFromHdfString(values_string, this->m_mesh_directory_name, filename, file_position);
      ArcGeoSim::ParallelUtils parallel_utils(this->m_mesh->subDomain()->parallelMng());
      m_values = ArcGeoSim::VariableUtils::GenericArray(m_values_mng,filename,file_position,parallel_utils);
    }
}

/*---------------------------------------------------------------------------*/
//! Static mesh property builder
/*---------------------------------------------------------------------------*/

class IXMStaticPropertyBuilder
{
public:
  IXMStaticPropertyBuilder(Arcane::IMesh* mesh) : m_impl(mesh){}

  virtual ~IXMStaticPropertyBuilder() {}

public:
#if (ARCANE_VERSION >= 30003)
  void setGraph(Arcane::IGraph2* graph)
  {
    m_impl.setGraph(graph) ;
  }
#endif
  //! Positionne le repertoire de maillage
  void setMeshDirectory(const Arcane::String& mesh_directory_name){m_impl.setMeshDirectory(mesh_directory_name);}

  //! Creation et remplissage des proprietes statiques
  void createAndFillProperties(const IXMPropertyDataList& properties, const IXMUidToLidMng& aid_to_lids)
    {m_impl.createAndFillProperties(properties,aid_to_lids);}

private:
  IXMPropertyBuilderImpl m_impl;
};

/*---------------------------------------------------------------------------*/
//! Evolutive mesh property builder
/*---------------------------------------------------------------------------*/
#ifdef USE_EVOLUTIVE
class IXMEvolutivePropertyBuilder
{
public:

  //!Constructeur de la classe, cas maillage evolutif
  IXMEvolutivePropertyBuilder(IEvolutiveMesh* const evolutive_mesh, IMesh* const mesh)
  : m_impl(evolutive_mesh,mesh){}

  /** Destructeur de la classe */
  virtual ~IXMEvolutivePropertyBuilder(){}

public:
#if (ARCANE_VERSION >= 30003)
  void setGraph(Arcane::IGraph2* graph)
  {
    m_impl.setGraph(graph) ;
  }
#endif

  //! Positionne le repertoire de maillage
  void setMeshDirectory(const Arcane::String& mesh_directory_name){m_impl.setMeshDirectory(mesh_directory_name);}

  //! Charge l'�v�nement courant
  void loadEvent(const IXMPropertyIncrementDataList& properties, const Real& event_begin_time, const Real& event_end_time)
    {m_impl.loadEvent(properties,event_begin_time,event_end_time);}

  //! Charge les propri�t�s de l'�v�nement courant
  void loadProperty(const IXMPropertyIncrementDataList& properties, const IXMUidToLidMng& aid_to_lids,bool is_step_replayed,
                    const bool check_property_existence)
  {m_impl.loadProperty(properties,aid_to_lids,is_step_replayed,check_property_existence);}

  //! Remplit les propri�t�s � remplir de l'�v�nement courant
  bool setProperty() {return m_impl.setProperty();}

  //! Remplit les propri�t�s � remplir de l'�v�nement courant
  bool computePropertyEvolution(const Real& end_timestep) {return m_impl.computePropertyEvolution(end_timestep);}

  //! Retourne une propri�t�s d�crivant l'�tat de remplissage de la propri�t�
  const Arcane::VariableItemByte propertyFilledItemVariable(const String& property_name, bool& has_filled_items) const
    {return m_impl.propertyFilledItemVariable(property_name,has_filled_items);}

  //! Affichage des infos pour le debug
  void printInfos() const {m_impl.printInfos();}

  //! Declenche par un observeur sur le maillage evolutif pour mettre a jour avec les nouveaux items
  //! la variable indiquant l'etat de remplissage de la propriete
  void updateFilledItemVariables() {m_impl.updateFilledItemVariables();}

  //! Indique si la propri�t� a chang� au cours de l'�v�nement
  bool hasPropertyChanged(const Arcane::String& property_name) const {return m_impl.hasPropertyChanged(property_name);}

private:
  IXMPropertyBuilderImpl m_impl;
};
#endif

END_ARCGEOSIM_NAMESPACE


#endif /* ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMPROPERTYBUILDER_H */
