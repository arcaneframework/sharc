// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMV3MESHREADER_H
#define ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMV3MESHREADER_H
/* Author : dechaiss at Wed Jun 27 09:49:35 2012
 * Generated by createNew
 */

#include <boost/shared_ptr.hpp>

#include <arcane/IIOMng.h>
#include <arcane/IXmlDocumentHolder.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/IMesh.h>
#include <arcane/IParallelMng.h>

// TEMPORAIRE
#include <arcane/XmlNodeList.h>

#include "ArcGeoSim/Utils/ArcGeoSim.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IIXMMeshReader.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMTools.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMMeshReaderTools.h"


BEGIN_ARCGEOSIM_NAMESPACE

class IXMV3MeshReader 
: public IIXMMeshReader
{
public:
  
  /** Constructeur de la classe */
  IXMV3MeshReader(Arcane::IIOMng* io_mng,
                  Arcane::IParallelMng* parallel_mng,
                  Arcane::ITraceMng* trace_mng, bool get_group_name=false);
  
  /** Destructeur de la classe */
  virtual ~IXMV3MeshReader();
  
public:

  //! === Interface IIXMMeshReaderBase ===

  //! Chargement du fichier de maillage. Retourne le rï¿½pertoire du fichier de maillage
  Arcane::String loadMeshFile(const IXMMeshFile mesh_file);

  //! === Interface IIXMEvolutiveMeshReader ===

  bool hasMeshData() { return m_has_mesh_data;}

  //! Type de grille
  Arcane::String meshType();

  //! Dimension de la grille
  IXMMeshDimension meshDimension();

  //! === Interface IIXMEvolutiveMeshReader ===

  //! Nombre d'evenement d'increment de maillage
#ifdef USE_EVOLUTIF
  Arcane::Integer meshIncrementNumber();
  //! Information sur l'evenement d'increment de maillage \a mesh_increment_number
  IXMMeshIncrementInfo meshIncrementInfo(const Arcane::Integer& mesh_increment_number,bool synch);

  //! Chargement en interne de l'increment de maillage decrit par \a mesh_increment_info pendant l'evenement decrit par \a event_info
  void loadMeshIncrement(const IXMMeshIncrementInfo& mesh_increment_info, const IXMLoadInfo& load_info);

  //! Desalloue l'increment de maillage charge.
  void unloadMeshIncrement();

  //! Informations sur l'increment de maillage
  bool hasTopologyIncrement() {return m_has_topology_increment;}
  bool hasGeometryIncrement() {return m_has_geometry_increment;}
  bool hasPropertyIncrement() {return m_has_property_increment;}

  //! Lecture des donnees de l'increment de maillage
  void readCellIncrementData(IXMCellIncrementData& cell_increment_data,const IXMMeshInfo& check_mesh_info);
  void readUpdateNodeData(IXMUpdateNodeData& update_node_data, const IXMMeshInfo& check_mesh_info);
  void readGeometryIncrementData(IXMGeometryIncrementData& geometry_data, const IXMMeshInfo& check_mesh_info);
  //! Lecture collective des informations de groupes et des proprietes : tous les processus doivent lire ces informations.
  void collectiveReadGroupIncrementData(IXMGroupIncrementDataList& group_increment_data_list, ParallelUtils parallel_utils);
  void collectiveReadPropertyIncrementData(IXMPropertyIncrementDataList& property_increment_data_list, ParallelUtils parallel_utils);
#endif
  //! === Interface IIXMStaticMeshReader ===
  // No static mesh build in V3. Only empty groups can be created. To use static mesh go on V4.

  //! Lecture des donnees du maillage
  void readCellData(IXMCellData& cell_data, const IXMMeshInfo& check_mesh_info) {};
  void readNodeData(IXMNodeData& node_data, const IXMMeshInfo& check_mesh_info) {};

  //! Lecture collective des informations de groupes et de proprietes : tous les processus doivent lire ces informations.
  void collectiveReadGroupData(IXMGroupDataList& group_data_list, ParallelUtils parallel_utils);
  void collectiveReadPropertyData(IXMPropertyDataList& property_data_list, ParallelUtils parallel_utils) {};

  //! === Interface IIXMMeshReaderBase ===
  // Methods shared in static and evolutive mesh
  void readFaceData(IXMFaceData& face_data,const IXMMeshInfo& check_mesh_info);
  void readEdgeData(IXMEdgeData& edge_data,const IXMMeshInfo& check_mesh_info);
  // No connections in V3 format. Nothing to do in readConnectionData
  void readConnectionData(IXMConnectionData& connection_data) {}

protected:

#ifdef USE_EVOLUTIF
  void _faceData(IXMFaceData& face_data, const IXMMeshInfo& check_mesh_info);
  void _faceDataDebug(IXMFaceData& face_data, const IXMMeshInfo& check_mesh_info);
  void _cellIncrementData(IXMCellIncrementData& cell_increment_data, const IXMMeshInfo& check_mesh_info);
  void _cellIncrementDataDebug(IXMCellIncrementData& cell_increment_data, const IXMMeshInfo& check_mesh_info);
  void _updateNodeData(IXMUpdateNodeData& update_node_data, const IXMMeshInfo& check_mesh_info);
  void _updateNodeDataDebug(IXMUpdateNodeData& update_node_data, const IXMMeshInfo& check_mesh_info);
  void _groupIncrementData(IXMGroupIncrementDataList& group_increment_data_list, const Arcane::XmlNodeList& group_nodes);
  void _groupIncrementDataDebug(IXMGroupIncrementDataList& group_increment_data_list, const Arcane::XmlNodeList& group_nodes);
  void _geometryIncrementDataDebug(IXMGeometryIncrementData& geometry_data, const Arcane::XmlNode& geometry_node);
  void _geometryIncrementData(IXMGeometryIncrementData& geometry_data, const Arcane::XmlNode& geometry_node, const IXMMeshInfo& mesh_info);

  bool _isTopologyIncrementLoaded();
  bool _isGeometryIncrementLoaded();
  bool _isPropertyIncrementLoaded();


  Arcane::XmlNode _getEventDataRootNode(Arcane::XmlNode& current_event, const Arcane::Integer event_tag);
#endif
  template<typename T> Arcane::SharedArray<T> _readDirectIndirectArray(const Arcane::XmlNode& direct_node, const Arcane::XmlNode& indirect_node, const Arcane::String& error_message);
  Arcane::String _readDirectIndirectString(const Arcane::XmlNode& direct_node, const Arcane::XmlNode& indirect_node);
  void _readCellInfos(const Arcane::XmlNodeList& cell_list_node, const String& block_name, ItemTypeMng * typeMng,
                        Arcane::Int64Array & cell_uids, Arcane::Int64Array & cell_infos,const IXMMeshInfo& check_mesh_info);

  void _broadcastGroupData(Arcane::XmlNode& root_node, Arcane::IXmlDocumentHolder * group_holder, ParallelUtils parallel_utils,const Arcane::String& mesh_type) ;
  void _readGroupData(ArcGeoSim::IXMTools::IXMGroupData& group_data, const Arcane::XmlNode& group_node, ParallelUtils& parallel_utils) ;
  void _readTopologyNode(Arcane::XmlNode& topology_node, const Arcane::String mesh_type) ;

  void _broadcastGroupData(Arcane::XmlNode& group_node, Arcane::IXmlDocumentHolder * group_holder, ParallelUtils parallel_utils);

  void _includePropertyExternNodes();
  Arcane::String _getValuesString(const Arcane::XmlNode& values_node,const IXMPropertyIncrementData property_data);
  Arcane::String allItemGroupName(const Arcane::String& item_kind);

protected:

  // Arcane Tools
  Arcane::IIOMng* m_io_mng = nullptr;
  Arcane::IParallelMng* m_parallel_mng = nullptr ;
  Arcane::ITraceMng* m_trace_mng = nullptr;

  bool m_get_group_name = false;

  // Mesh file tools
  Arcane::IXmlDocumentHolder * m_xmldoc = nullptr;

#ifdef USE_EVOLUTIF
  // Xml Data
  IXMMeshIncrementXmlNode* m_mesh_increment_xml_node = nullptr;
#endif
  // Grid info
  Arcane::String m_grid_type;
  IXMMeshDimension m_grid_dimension;
  IXMMeshVersion m_supported_version;
  bool m_is_debug_event = false;

  // Increment info
#ifdef USE_EVOLUTIF
  bool m_has_topology_increment = false;
  bool m_has_geometry_increment = false;
  bool m_has_property_increment = false;
#endif

  // Mesh (for static) and Event (for evolutive) data
  Arcane::XmlNodeList m_events_data;
  Integer             m_events_data_size = 0;
  Arcane::XmlNode     m_mesh_data;
  bool                m_has_mesh_data = false;

};

template<typename T>
Arcane::SharedArray<T>
ArcGeoSim::IXMV3MeshReader::
_readDirectIndirectArray(const Arcane::XmlNode& direct_node, const Arcane::XmlNode& indirect_node, const Arcane::String& error_message)
{
  Arcane::String local_string = _readDirectIndirectString(direct_node,indirect_node);
  Arcane::SharedArray<T> local_array;
  bool check_error = builtInGetValue(local_array,local_string);
  if (check_error)
    m_trace_mng->fatal() << error_message;
  return local_array;
}

END_ARCGEOSIM_NAMESPACE

#endif /* ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMV3MESHREADER_H */
