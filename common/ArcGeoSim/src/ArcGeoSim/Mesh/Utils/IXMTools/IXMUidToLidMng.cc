#include "IXMUidToLidMng.h"
/* Author : dechaiss at Tue Mar 19 09:33:42 2013
 * Generated by createNew
 */

#include <arcane/IItemFamily.h>
#include <arcane/ISubDomain.h>
#include <arcane/IParallelMng.h>
#include <arcane/IMeshUtilities.h>
#include <arcane/MeshUtils.h>
#include <arcane/utils/UserDataList.h>
#include <arcane/utils/IUserData.h>
#include <arcane/utils/AutoDestroyUserData.h>
#include <arcane/packages/Variable.h>

#include "ArcGeoSim/Mesh/Utils/MeshUtils.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMItemConnections.h"

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMUidToLidMng::
IXMUidToLidMng(Arcane::IMesh* mesh,ArcGeoSim::ParallelUtils& parallel_utils, const bool use_memory, Arcane::ITraceMng* trace_mng)
  : m_mesh(mesh)
{
  Arcane::eItemKind connection_kind = ItemConnectionImpl::kind();
  Arcane::VariableArrayInt64 * face_aid_memory = _ItemAidMemoryVariable(use_memory,Arcane::IK_Face);
  Arcane::VariableArrayInt64 * edge_aid_memory = _ItemAidMemoryVariable(use_memory,Arcane::IK_Edge);
  Arcane::VariableArrayInt64 * connection_aid_memory = _ItemAidMemoryVariable(use_memory,connection_kind);
  Arcane::VariableArrayInt64 * particle_aid_memory = _ItemAidMemoryVariable(use_memory,Arcane::IK_Particle);

  m_face_aid_mapper = new ArcGeoSim::IXMItemAidToUidMapper(trace_mng,
                                                           mesh,
                                                           parallel_utils.parallelMng(),parallel_utils.masterId(),
                                                           use_memory,
                                                           face_aid_memory,
                                                           Arcane::IK_Face);

  m_edge_aid_mapper = new ArcGeoSim::IXMItemAidToUidMapper(trace_mng,
                                                           mesh,
                                                           parallel_utils.parallelMng(),parallel_utils.masterId(),
                                                           use_memory,
                                                           edge_aid_memory,
                                                           Arcane::IK_Edge);


  m_particle_aid_mapper = new ArcGeoSim::IXMItemAidToUidMapper(trace_mng,
                                                                 mesh,
                                                                 parallel_utils.parallelMng(),parallel_utils.masterId(),
                                                                 use_memory,
                                                                 particle_aid_memory,
                                                                 Arcane::IK_Particle);


  m_connection_aid_mapper = new ArcGeoSim::IXMItemAidToUidMapper(trace_mng,
                                                                 mesh,
                                                                 parallel_utils.parallelMng(),parallel_utils.masterId(),
                                                                 use_memory,
                                                                 connection_aid_memory,
                                                                 connection_kind);

  }

#if (ARCANE_VERSION >= 30003)
void ArcGeoSim::IXMUidToLidMng::setGraph(Arcane::IGraph2* graph)
{
    m_graph = graph ;
    m_connection_aid_mapper->setGraph(graph) ;
}
#endif


/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMUidToLidMng::
itemsUniqueIdToLocalId(Arcane::Int32ArrayView item_lids, Arcane::Int64ConstArrayView item_uids, const Arcane::eItemKind item_kind, const bool do_fatal) const
{
  ARCANE_ASSERT((item_lids.size() == item_uids.size()),("item_lids and item_uids arrays must have same size."))

  if (item_kind == Arcane::IK_Face)
    m_face_aid_mapper->itemAbstractIdToLocalId(item_lids,item_uids,do_fatal);
  else if (item_kind == Arcane::IK_Particle)
    m_mesh->findItemFamily(Arcane::IK_Particle,"Particle",true)->itemsUniqueIdToLocalId(item_lids,item_uids,do_fatal) ;
  else if (item_kind == ItemConnectionImpl::kind())
    m_connection_aid_mapper->itemAbstractIdToLocalId(item_lids,item_uids,do_fatal);
  else
    m_mesh->itemFamily(item_kind)->itemsUniqueIdToLocalId(item_lids,item_uids,do_fatal);

  return;
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMUidToLidMng::
localItemsUniqueIdToLocalId(Arcane::Int32SharedArray& local_item_lids,
                            Arcane::Int64SharedArray& local_item_uids,
                            Arcane::Int64ConstArrayView all_item_uids,
                            const Arcane::eItemKind item_kind,
                            const bool do_fatal) const
{
  Arcane::Integer all_item_size = all_item_uids.size();
  local_item_lids.resize(all_item_size);
  // Convert aids to lids
  itemsUniqueIdToLocalId(local_item_lids,all_item_uids,item_kind,do_fatal);
  bool are_ids_abstract = ArcGeoSim::IXMTools::hasAbstractIds(item_kind);
  // if do_fatal = false : skip non local item, if are_ids_abstract : convert aids to uids
  if (!do_fatal && !are_ids_abstract)
    {
      local_item_uids.reserve(all_item_size);
      Arcane::Integer repos_index = 0;
      for(Arcane::Integer i=0;i<all_item_size;++i)
        {
          if (local_item_lids[i] != Arcane::NULL_ITEM_LOCAL_ID)
            {
              local_item_lids[repos_index++] = local_item_lids[i];
              local_item_uids.add(all_item_uids[i]);
            }
        }
      local_item_lids.resize(repos_index);
    }
  else if (!do_fatal && are_ids_abstract)
    {
      Arcane::Integer repos_index = 0;
      for(Arcane::Integer i=0;i<all_item_size;++i)
        {
          if (local_item_lids[i] != Arcane::NULL_ITEM_LOCAL_ID)
            {
              local_item_lids[repos_index++] = local_item_lids[i];
            }
        }
      local_item_lids.resize(repos_index);
      _lidToUid(local_item_uids,local_item_lids,item_kind);
    }
  else if (do_fatal && !are_ids_abstract) local_item_uids = all_item_uids;
  else if (do_fatal && are_ids_abstract) _lidToUid(local_item_uids,local_item_lids,item_kind);
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMUidToLidMng::
_lidToUid(Arcane::Int64Array& uids,Arcane::Int32ConstArrayView lids,const Arcane::eItemKind& item_kind) const
{
  uids.resize(lids.size());
#if (ARCANE_VERSION >= 30003)
  if(item_kind==ItemConnectionImpl::ik_type)
  {
    Arcane::ItemVectorView items = m_graph->linkFamily()->view(lids);
    Arcane::Integer i = 0;
    ENUMERATE_ITEM(iItem,items)
    {
      uids[i++] = (iItem->uniqueId().asInt64());
    }
  }
  else
  {
    Arcane::ItemVectorView items = m_mesh->itemFamily(item_kind)->view(lids);
    Arcane::Integer i = 0;
    ENUMERATE_ITEM(iItem,items)
    {
      uids[i++] = (iItem->uniqueId().asInt64());
    }
  }
#else
  Arcane::ItemVectorView items = m_mesh->itemFamily(item_kind)->view(lids);
  Arcane::Integer i = 0;
  ENUMERATE_ITEM(iItem,items)
  {
    uids[i++] = (iItem->uniqueId().asInt64());
  }
#endif
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMUidToLidMng::
loadFaceAidMapping(const ArcGeoSim::IXMTools::IXMFaceData& face_data, const bool do_check, const bool is_parallel)
{
  // Get lids from connectivity
  const Arcane::Integer nb_face = face_data.faces.item_ids.size();
  Arcane::IntegerSharedArray face_local_ids(nb_face);

  // On ne peut faire un check strict qu'en s���quentiel, sinon tout n'est jamais connu sur un seul proc
  const bool strict_check = (m_mesh->subDomain()->parallelMng()->commSize() == 1);
//  bool is_master = m_mesh->subDomain()->parallelMng()->commRank() == 0 ;

  Arcane::IMeshUtilities* mu = m_mesh->utilities();
  mu->localIdsFromConnectivity(Arcane::IK_Face, face_data.faces.item_infos, face_data.node_ids, face_local_ids, !strict_check);

  // build mapping
  m_face_aid_mapper->buildAidToLidMapping(face_data.faces.item_ids,face_local_ids,do_check,is_parallel);
}




/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMUidToLidMng::
loadEdgeAidMapping(const ArcGeoSim::IXMTools::IXMEdgeData& edge_data, const bool do_check, const bool is_parallel)
{
  // Get lids from connectivity
  const Arcane::Integer nb_edge = edge_data.item_ids.size();
  Arcane::IntegerSharedArray edge_local_ids(nb_edge);
  edge_local_ids.fill(-1);

  // On ne peut faire un check strict qu'en s���quentiel, sinon tout n'est jamais connu sur un seul proc
  const bool strict_check = (m_mesh->subDomain()->parallelMng()->commSize() == 1);
//  bool is_master = m_mesh->subDomain()->parallelMng()->commRank() == 0 ;

  Arcane::IntegerSharedArray nb_nodes(nb_edge);

  for (int i=0;i<nb_edge;i++) nb_nodes[i] = 2;

  localEdgeIdsFromConnectivity(nb_nodes, edge_data.item_infos, edge_local_ids, !strict_check);

  m_edge_aid_mapper->buildAidToLidMapping(edge_data.item_ids,edge_local_ids,do_check,is_parallel);
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMUidToLidMng::
localEdgeIdsFromConnectivity(IntegerConstArrayView items_nb_node,
		Int64ConstArrayView items_connectivity,
		Int32ArrayView local_ids,
		bool allow_null)
{
	//const char* func_name ="IXMUidToLidMng::localEdgeIdsFromConnectivity";

	Integer nb_item = items_nb_node.size();

	Integer item_connectivity_index = 0;

	Arcane::Int64SharedArray buf;
	buf.reserve(256);

	Arcane::ItemInternalList nodes(m_mesh->itemsInternal(Arcane::IK_Node));

	for( Integer i=0; i<nb_item; ++i ){

		Integer current_nb_node = items_nb_node[i];
		Int64ConstArrayView current_nodes(current_nb_node,items_connectivity.unguardedBasePointer()+item_connectivity_index);
		item_connectivity_index += current_nb_node;

		buf.resize(current_nb_node);

		Arcane::mesh_utils::reorderNodesOfFace(current_nodes,buf);

		Int64 first_node_uid = buf[0];
		Int64ArrayView first_node_uid_array(1,&first_node_uid);

		Int32 first_node_lid = buf[0];
		Int32ArrayView first_node_lid_array(1,&first_node_lid);

		m_mesh->nodeFamily()->itemsUniqueIdToLocalId(first_node_lid_array,first_node_uid_array,!allow_null);

		if (first_node_lid == Arcane::NULL_ITEM_LOCAL_ID)
		{
			if (allow_null){
				local_ids[i] = Arcane::NULL_ITEM_LOCAL_ID;
			}
			else {
				/*
				 * Arcane::StringBuilder sb("Face with nodes (");
				for(Integer j=0;j<current_nb_node;++j) {
					if (j != 0) sb += " ";
					sb += current_nodes[j];
				}
				sb += ") not found (first node ";
				sb += first_node_uid;
				sb += " not found)";
				throw Arcane::FatalErrorException(func_name,sb.toString());
				*/
			}
			continue;
		}

		Node node(nodes[first_node_lid]);

		Edge edge(ArcGeoSim::Mesh::getEdgeFromNodesUnique(node,buf));


		if (edge.null())
		{
			if (allow_null){
				local_ids[i] = Arcane::NULL_ITEM_LOCAL_ID;
			}
			else {
				/*
				 * Arcane::StringBuilder sb("Face with nodes (");
				for(Integer j=0;j<current_nb_node;++j) {
					if (j != 0) sb += " ";
					sb += current_nodes[j];
				}
				sb += ") not found";
				throw Arcane::FatalErrorException(func_name,sb.toString());
				*/
			}
		}
		else
			local_ids[i] = edge.localId();
	}

}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMUidToLidMng::
loadConnectionAidMapping(const ArcGeoSim::IXMTools::IXMConnectionData& connection_data, const bool do_check, const bool is_parallel)
{
  // Get local ids
  const Arcane::Integer nb_connection = connection_data.item_ids.size();
  Arcane::IntegerSharedArray connection_local_ids(nb_connection);

  // On ne peut faire un check strict qu'en s���quentiel, sinon tout n'est jamais connu sur un seul proc
  const bool strict_check = (m_mesh->subDomain()->parallelMng()->commSize() == 1);

#if (ARCANE_VERSION >= 30003)
  m_graph->linkFamily()->itemsUniqueIdToLocalId(connection_local_ids,connection_data.item_infos,strict_check);
#else
  m_mesh->itemFamily(ItemConnectionImpl::kind())->itemsUniqueIdToLocalId(connection_local_ids,connection_data.item_infos,strict_check);
#endif
  // build mapping
  m_connection_aid_mapper->buildAidToLidMapping(connection_data.item_ids,connection_local_ids,do_check);

  // update connection uids
 // ArcGeoSim::IXMItemUidToAidMapper uid_mapper(m_mesh,m_mesh->subDomain()->parallelMng(),m_mesh->subDomain()->variableMng(),ItemConnectionImpl::kind());

#if (ARCANE_VERSION >= 30003)
  ArcGeoSim::IXMItemUidToAidLinkVariable::set(m_mesh,m_graph);
#else
  ArcGeoSim::IXMItemUidToAidVariable::set(m_mesh,ItemConnectionImpl::kind());
#endif
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMUidToLidMng::
endUsingAidMapping()
{
  m_face_aid_mapper->clearAidMapping();
  m_connection_aid_mapper->clearAidMapping();
}

/*---------------------------------------------------------------------------*/

Arcane::VariableArrayInt64 *
ArcGeoSim::IXMUidToLidMng::
_ItemAidMemoryVariable(const bool use_memory, const Arcane::eItemKind item_kind) const
{
  Arcane::VariableArrayInt64 * aid_memory = nullptr;
  if (use_memory)
  {
    Arcane::IVariableMng* variable_mng = m_mesh->subDomain()->variableMng();

    String aid_memory_name =  ArcGeoSim::IXMItemAidToUidMapper::itemAidMemoryVariableName(m_mesh, item_kind);
    Arcane::IVariable* variable = variable_mng->findVariable(aid_memory_name);
    if (variable)
    {
      aid_memory = new Arcane::VariableArrayInt64(variable);
    }
    else
    {
      aid_memory =
          new Arcane::VariableArrayInt64(Arcane::VariableBuildInfo(m_mesh->subDomain(), aid_memory_name,
                                                                   (Arcane::IVariable::PNoDump & Arcane::IVariable::PNoNeedSync)));
      m_mesh->userDataList()->setData(aid_memory_name,
          new Arcane::AutoDestroyUserData<Arcane::VariableArrayInt64>(aid_memory));
    }
  }
  return aid_memory;
}


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMLidToUidMng::
IXMLidToUidMng(Arcane::IMesh* mesh)
  : m_mesh(mesh)
{
  if (m_mesh)
    {
      m_parallel_mng = mesh->subDomain()->parallelMng();
      m_variable_mng = mesh->subDomain()->variableMng();
    }
  else
    {
      m_parallel_mng = NULL;
      m_variable_mng = NULL;
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMLidToUidMng::
itemsUniqueId(Arcane::Int64SharedArray& item_uids, Arcane::ItemVectorView items, Arcane::eItemKind item_kind)
{
  ARCANE_ASSERT((item_uids.size() == items.size()),("item_uids et items must have same size"))

  Arcane::Integer i = 0;
  ENUMERATE_ITEM(iitem,items)
  {
    item_uids[i] = iitem->uniqueId();
    ++i;
  }
  if (ArcGeoSim::IXMTools::hasAbstractIds(item_kind))
    {
      Arcane::Int64SharedArray item_aids;
      ArcGeoSim::IXMItemUidToAidMapper uid2aid(m_mesh,m_parallel_mng,m_variable_mng,item_kind);
      uid2aid.itemUniqueIdToAbstractId(item_aids,item_uids);
      if (!item_aids.empty())
        {
          item_uids = item_aids;
        }
    }
}



/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
