#include "IXMV3MeshReader.h"
/* Author : dechaiss at Wed Jun 27 09:49:35 2012
 * Generated by createNew
 */

#ifdef WIN32
#include <ciso646>
#endif

#include <arcane/utils/ValueConvert.h>
#include <arcane/ItemTypeMng.h>
#include <arcane/IXmlDocumentHolder.h>
#include <arcane/utils/OStringStream.h>
#include <arcane/DomUtils.h>
#include <arcane/XmlException.h>
#include <arcane/ArcaneTypes.h>

ARCANE_BEGIN_NAMESPACE
ARCANE_BEGIN_NAMESPACE_DOMUTILS

extern "C++" ARCANE_CORE_EXPORT void
removeAllChildren(const dom::Node& parent);

extern "C++" ARCANE_CORE_EXPORT bool
writeNode(std::ostream& ostr,const dom::Node&);

extern "C++" ARCANE_CORE_EXPORT bool
writeNodeChildren(std::ostream& ostr,const dom::Node&);

ARCANE_END_NAMESPACE_DOMUTILS
ARCANE_END_NAMESPACE

#include "ArcGeoSim/Mesh/Utils/IXMTools/ixm_v3_xsd.h"
#include "ArcGeoSim/Mesh/Utils/StringToItemUtils.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace ArcGeoSim::IXMTools::IXMPropertyExceptions;

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMV3MeshReader::
IXMV3MeshReader(Arcane::IIOMng* io_mng,
                Arcane::IParallelMng* parallel_mng,
                Arcane::ITraceMng* trace_mng, bool get_group_name)
  : m_io_mng(io_mng)
  , m_parallel_mng(parallel_mng)
  , m_trace_mng(trace_mng)
  , m_get_group_name(get_group_name)
  , m_grid_type("NoGrid")
  , m_grid_dimension("NoGrid")
  , m_supported_version("V3")
{}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMV3MeshReader::
~IXMV3MeshReader()
{
  if (m_xmldoc) delete m_xmldoc;
#ifdef USE_EVOLUTIF
  if (m_mesh_increment_xml_node) delete m_mesh_increment_xml_node;
#endif
}

/*---------------------------------------------------------------------------*/

Arcane::String
ArcGeoSim::IXMV3MeshReader::
loadMeshFile(IXMMeshFile mesh_file)
{
  if(m_parallel_mng->commRank()==0)
  {

    //integrated xsd parse
    m_xmldoc << mesh_file(m_io_mng,"ixm_v3.xsd",Arcane::ByteConstArrayView(strlen((const char*) ixm_v3_xsd), ixm_v3_xsd));

    Arcane::XmlNode rootNode;
   String dimension ;

    // Static only
    if (!(rootNode = m_xmldoc->documentNode().child("extern")).null())
    {
      m_mesh_data = rootNode.child("topology");
      m_grid_dimension = ArcGeoSim::IXMTools::IXMMeshDimension("3Dxyz");
      dimension = "3Dxyz" ;
    }
    // Static + evolutive
    else if(!(rootNode = m_xmldoc->documentNode().child("mesh")).null())
    {
      Arcane::XmlNode gridRoot = rootNode.child("grid");

      // Check grid attributes
      m_grid_type = gridRoot.attrValue("type");
      if (m_grid_type != "unstructured-grid")
        m_trace_mng->fatal() << String::format("Cannot read {0} grid type. Only unstructured-grids are supported",m_grid_type);
      dimension = gridRoot.attrValue("dimension");
      m_grid_dimension = dimension ;

      // Check version number ALREADY CHECKED IN PARALLEL
      //ArcGeoSim::IXMMeshVersion mesh_version = mesh_file.version(m_io_mng,m_parallel_mng);
      //if (mesh_version != m_supported_version)
      //  m_trace_mng->fatal() << Arcane::String::format("Cannot read {0} mesh file version. Supported mesh version is {1}.",mesh_version.str(),m_supported_version.str());

      // Static mesh
      XmlNode initialMeshNode = gridRoot.child("initial-mesh");
      m_mesh_data =  initialMeshNode.child("topology");
      m_has_mesh_data = !m_mesh_data.null() ;
      // Evolutive mesh
      m_events_data = gridRoot.children("event");

      // Check unicity of event names
      std::set<String> event_names;
      for(Integer iEvent=0;iEvent<m_events_data.size();++iEvent)
        {
          const String current_name = m_events_data[iEvent].attr("name").value();
          const bool is_new_name = event_names.insert(current_name).second;
          if (not is_new_name) m_trace_mng->error() << "Event name '" << current_name << "' is duplicated";
        }
      if ((Integer)event_names.size() != m_events_data.size())
        m_trace_mng->fatal() << "Incorrect event definition: see errors above";
    }
    m_events_data_size = m_events_data.size() ;
    m_has_mesh_data = ! m_mesh_data.null() ;
    m_parallel_mng->broadcastString(dimension,0) ;
    SharedArray<Integer> buffer(2) ;
    buffer[0] = m_has_mesh_data?1:0 ;
    buffer[1] = m_events_data_size ;
    m_parallel_mng->broadcast(buffer,0) ;
  }
  else
  {
    String dimension ;
    m_parallel_mng->broadcastString(dimension,0) ;
    m_grid_dimension = dimension ;
    SharedArray<Integer> buffer(2) ;
    m_parallel_mng->broadcast(buffer,0) ;
    m_has_mesh_data = buffer[0]!=0 ;
    m_events_data_size = buffer[1] ;
  }

  return mesh_file.path();
}
/*---------------------------------------------------------------------------*/

Arcane::String
ArcGeoSim::IXMV3MeshReader::
meshType()
{
  return m_grid_type;
}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMMeshDimension
ArcGeoSim::IXMV3MeshReader::
meshDimension()
{
  return m_grid_dimension;
}

/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
Arcane::Integer
ArcGeoSim::IXMV3MeshReader::meshIncrementNumber()
{
  return m_events_data_size ;
}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IIXMEvolutiveMeshReader::IXMMeshIncrementInfo
ArcGeoSim::IXMV3MeshReader::
meshIncrementInfo(const Arcane::Integer& mesh_increment_number,bool synch)
{
   Arcane::Real begin_time = 0;
   Arcane::Real end_time = 0 ;
   Arcane::String name("");
   if(m_parallel_mng->commRank()==0)
   {
    ARCANE_ASSERT((!m_events_data.empty()),("No mesh file loaded in IXM V3 reader."))
    ARCANE_ASSERT((mesh_increment_number < m_events_data.size()),("Number of mesh increment is exceeded, in IXM V3 reader"))
    // Get mesh increment info
    Arcane::XmlNode& current_mesh_increment = m_events_data[mesh_increment_number];
    Arcane::XmlNode beginTimeNode = current_mesh_increment.attr("begin-time");
    Arcane::XmlNode endTimeNode = current_mesh_increment.attr("end-time");
    begin_time = beginTimeNode.valueAsReal();
    end_time = endTimeNode.valueAsReal();
    name = current_mesh_increment.attr("name").value();
  }
  if(synch)
  {
    SharedArray<Real> buffer(2) ;
    buffer[0] = begin_time ;
    buffer[1] = end_time ;
    m_parallel_mng->broadcast(buffer,0) ;
    begin_time = buffer[0] ;
    end_time = buffer[1] ;
    m_parallel_mng->broadcastString(name,0) ;
  }
  return IIXMEvolutiveMeshReader::IXMMeshIncrementInfo(begin_time,end_time,name,mesh_increment_number);
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
loadMeshIncrement(const IIXMEvolutiveMeshReader::IXMMeshIncrementInfo& mesh_increment_info, const IXMLoadInfo& load_info)
{
  ARCANE_ASSERT((!m_events_data.empty()),("No mesh file loaded in IXM V3 reader."))
  ARCANE_ASSERT((mesh_increment_info.id < m_events_data.size()),("Number of mesh increment is exceeded, cannot load increment. In IXM V3 reader"))

  // Create mesh increment xml node
  if (m_mesh_increment_xml_node) delete m_mesh_increment_xml_node;
  m_mesh_increment_xml_node = new ArcGeoSim::IXMMeshIncrementXmlNode(mesh_increment_info);


  Arcane::XmlNode current_event;
  Arcane::XmlNode event_content;
  Arcane::XmlNode topology;
  Arcane::XmlNode geometry;
  Arcane::XmlNode properties;

  current_event = m_events_data[mesh_increment_info.id];
  // Root node of the event
  event_content = _getEventDataRootNode(current_event, mesh_increment_info.id);

  // Topology
  topology = event_content.child("topology");
  if (!topology.null()) m_has_topology_increment = true;
  if ( (load_info & LoadTopology) == LoadTopology) m_mesh_increment_xml_node->topology_node.reset(new Arcane::XmlNode(topology));

  // Geometry
  geometry = event_content.child("geometry");
  if (!geometry.null()) m_has_geometry_increment = true;
  if ( (load_info & LoadGeometry) == LoadGeometry) m_mesh_increment_xml_node->geometry_node.reset(new Arcane::XmlNode(geometry));

  // Properties
  properties = event_content.child("properties");
  if (!properties.null()) m_has_property_increment = true;
  if ( (load_info & LoadProperties) == LoadProperties) m_mesh_increment_xml_node->property_node.reset(new Arcane::XmlNode(properties));

}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
unloadMeshIncrement()
{
  m_has_topology_increment = false;
  m_has_geometry_increment = false;
  m_has_property_increment = false;
  if (m_mesh_increment_xml_node)
    {
      delete m_mesh_increment_xml_node;
      m_mesh_increment_xml_node = NULL;
    }
  else 
    {
      m_trace_mng->warning() << "Cannot unload mesh increment : was not loaded. Ignoring";
    }
}

/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMV3MeshReader::
_isTopologyIncrementLoaded()
{
  if (m_mesh_increment_xml_node) return static_cast<bool>(m_mesh_increment_xml_node->topology_node);
  return false;
}

/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMV3MeshReader::
_isGeometryIncrementLoaded()
{
  if (m_mesh_increment_xml_node) return static_cast<bool>(m_mesh_increment_xml_node->geometry_node);
  return false;
}

/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMV3MeshReader::
_isPropertyIncrementLoaded()
{
  if (m_mesh_increment_xml_node) return static_cast<bool>(m_mesh_increment_xml_node->property_node);
  return false;
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
readCellIncrementData(ArcGeoSim::IXMTools::IXMCellIncrementData& cell_increment_data,const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  if (m_is_debug_event) _cellIncrementDataDebug(cell_increment_data,check_mesh_info);
  else _cellIncrementData(cell_increment_data,check_mesh_info);
}
#endif
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
readFaceData(ArcGeoSim::IXMTools::IXMFaceData& face_data,const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
#ifdef USE_EVOLUTIF
  if (!m_mesh_increment_xml_node) // static mesh case
    {
      // No action : no static mesh build in v3.
    }
  else
    {
      if (m_is_debug_event)
        _faceDataDebug(face_data,check_mesh_info);
      else
        _faceData(face_data,check_mesh_info);
    }
#endif
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
readEdgeData(ArcGeoSim::IXMTools::IXMEdgeData& edge_data,const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  // Since IXM v3 XSD does not support edge, warning is useless (will be filtered by grammar if occurs)
  // m_trace_mng->warning() << "It is not possible yet to read edge data in IXM V3 files";

}


/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMV3MeshReader::
readUpdateNodeData(ArcGeoSim::IXMTools::IXMUpdateNodeData& update_node_data, const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  if (m_is_debug_event) _updateNodeDataDebug(update_node_data,check_mesh_info);
  else _updateNodeData(update_node_data,check_mesh_info);
}
#endif
/*---------------------------------------------------------------------------*/
/*
void
ArcGeoSim::IXMV3MeshReader::
collectiveReadGroupData(ArcGeoSim::IXMTools::IXMGroupDataList& group_data_list, ParallelUtils parallel_utils)
{
  if (!m_mesh_data.null())
    {
      XmlNodeList groupList = m_mesh_data.children("group");
      for (Arcane::XmlNodeList::const_iterator iGroupList = groupList.begin(); iGroupList
           != groupList.end(); ++iGroupList)
        {
          const Arcane::String group_name = (*iGroupList).attr("name").value();
          const Arcane::String item_kind_string = (*iGroupList).attr("kind").value();
          const Arcane::eItemKind item_kind = ArcGeoSim::StringToItemUtils::stringToItemKind(item_kind_string);

          m_trace_mng->info() << ">>> " << group_name;

          // Group must be empty
          if (!(iGroupList->child("group-id").null()) || !(iGroupList->child("group-id-ascii-file-path").null()))
            m_trace_mng->fatal()
            << "Groups defined in initial mesh: must be empty. (No tag group-id or group-id-ascii-file-path)";

          IXMGroupData group_data;
          group_data.name = group_name;
          group_data.kind = item_kind;
          group_data_list.push_back(group_data);
        }
    }
}
*/

void
ArcGeoSim::IXMV3MeshReader::
_broadcastGroupData(Arcane::XmlNode& root_node, Arcane::IXmlDocumentHolder * group_holder, ParallelUtils parallel_utils,const Arcane::String& mesh_type)
{
  bool is_master = (parallel_utils.parallelMng()->commRank() == parallel_utils.parallelMng()->masterIORank());
  if (parallel_utils.parallelMng()->commSize() == 1)
    {
      _readTopologyNode(root_node,mesh_type);
    }
  else
    { // Diffusion des infos de groupes
      Arcane::ByteSharedArray bytes;
      if (is_master)
        {
          Arcane::XmlNode localRootNode;
          _readTopologyNode(localRootNode,mesh_type);
          Arcane::OStringStream oss;
          oss() << "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?><groups>"; // prefix
          Arcane::XmlNodeList groups = localRootNode.children("group");
          for (Arcane::XmlNodeList::const_iterator i_group = groups.begin(); i_group != groups.end(); ++i_group)
            {
              Arcane::domutils::writeNode(oss(),(*i_group).domNode());
            }
          oss() << "</groups>"; // suffix
          bytes = oss.str().utf8();
        }
      parallel_utils.multiBroadcast(bytes,parallel_utils.parallelMng()->masterIORank());

      group_holder = m_io_mng->parseXmlBuffer(bytes,"dumped-groups");
      root_node = group_holder->documentNode().child("groups"); // c'est la nuance avec l'algo s�quentiel
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
_readGroupData(ArcGeoSim::IXMTools::IXMGroupData& group_data, const Arcane::XmlNode& group_node, ParallelUtils& parallel_utils)
{

      const Arcane::String group_name = group_node.attr("name").value();
      const Arcane::String item_kind_string = group_node.attr("kind").value();
      const Arcane::eItemKind item_kind = ArcGeoSim::StringToItemUtils::stringToItemKind(item_kind_string);

      m_trace_mng->info() << ">>> " << group_name;

      // Group must be empty
      if (!(group_node.child("group-id").null()) || !(group_node.child("group-id-ascii-file-path").null()))
        m_trace_mng->fatal()
        << "Groups defined in initial mesh: must be empty. (No tag group-id or group-id-ascii-file-path)";

      group_data.name = group_name;
      group_data.kind = item_kind;
}

void
ArcGeoSim::IXMV3MeshReader::
_readTopologyNode(Arcane::XmlNode& topology_node, const Arcane::String mesh_type)
{
#ifdef USE_EVOLUTIF
  if ("evolutive" == mesh_type)
    {
      ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV3MeshReader"))
      ARCANE_ASSERT((_isTopologyIncrementLoaded()),("Topology Increment not loaded in the IXMV3MeshReader"))
      topology_node = *(m_mesh_increment_xml_node->topology_node.get());
    }
  else
#endif
    if ("static" == mesh_type)
    {
      ARCANE_ASSERT((!m_mesh_data.null()),("No mesh file loaded in IXM V3 reader."))
      topology_node = m_mesh_data;
    }
  else throw Arcane::FatalErrorException(String::format("Unknown ixm mesh type {0} in load topology node",mesh_type));
}

/*---------------------------------------------------------------------------*/



void
ArcGeoSim::IXMV3MeshReader::
collectiveReadGroupData(ArcGeoSim::IXMTools::IXMGroupDataList& group_data_list, ParallelUtils parallel_utils)
{
  // Broadcast group xml node to all processes
  Arcane::IXmlDocumentHolder * group_holder = NULL;
  Arcane::XmlNode rootNode;

  _broadcastGroupData(rootNode,group_holder,parallel_utils,"static");

  Arcane::XmlNodeList group_nodes = rootNode.children("group");

  for (Arcane::XmlNodeList::const_iterator iGroupList = group_nodes.begin(); iGroupList != group_nodes.end(); ++iGroupList)
    {
      IXMGroupData group_data;
      _readGroupData(group_data,*iGroupList,parallel_utils);
      group_data_list.push_back(group_data);
    }

  delete group_holder;
}
/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMV3MeshReader::
collectiveReadGroupIncrementData(ArcGeoSim::IXMTools::IXMGroupIncrementDataList& group_increment_data_list, ParallelUtils parallel_utils)
{

  // Broadcast group xml node to all processes
  Arcane::IXmlDocumentHolder * group_holder = NULL;
  Arcane::XmlNode rootNode;

  _broadcastGroupData(rootNode,group_holder,parallel_utils);

  Arcane::XmlNodeList groups = rootNode.children("group");

  if (m_is_debug_event) _groupIncrementDataDebug(group_increment_data_list,groups);
  else _groupIncrementData(group_increment_data_list,groups);

  delete group_holder;
}




/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
collectiveReadPropertyIncrementData(ArcGeoSim::IXMTools::IXMPropertyIncrementDataList& property_increment_data_list, ParallelUtils parallel_utils)
{
  // Get Property node
  Arcane::XmlNode property_node;
  Arcane::IXmlDocumentHolder* xml_doc = NULL;

  // Broadcast Property data to all
  if (parallel_utils.parallelMng()->commSize() == 1) // sequential bypass
    {
      // Deal with extern nodes
      _includePropertyExternNodes();
      // take local node
      ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV3MeshReader"))
      ARCANE_ASSERT((_isPropertyIncrementLoaded()),("Property Increment not loaded in the IXMV3MeshReader"))
      property_node = *(m_mesh_increment_xml_node->property_node.get());
    }
  else
    {
      // Broadcast to every process property node (including extern nodes if exist)
      Arcane::ByteSharedArray bytes;
      if (parallel_utils.parallelMng()->commRank() == parallel_utils.parallelMng()->masterIORank())
        {
          // Deal with extern nodes
          _includePropertyExternNodes();
          // Dump 'properties' node into stream
          ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV3MeshReader"))
          ARCANE_ASSERT((_isPropertyIncrementLoaded()),("Property Increment not loaded in the IXMV3MeshReader"))
          Arcane::XmlNode localRootNode = *(m_mesh_increment_xml_node->property_node.get());
          Arcane::OStringStream oss;
          oss() << "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>"; // prefix
          if (!localRootNode.null())
            Arcane::domutils::writeNode(oss(),localRootNode.domNode());
          else
            oss() << "<properties></properties>"; // corps de remplacement
          bytes = oss.str().utf8();
        }
      parallel_utils.multiBroadcast(bytes,parallel_utils.parallelMng()->masterIORank());
      // Get Property Node in every parallel process
      xml_doc = m_io_mng->parseXmlBuffer(bytes,"property-node");
      property_node = xml_doc->documentNode().child("properties");
    }

  // Fill property data list
  Arcane::XmlNodeList propertyNodeList = property_node.children("property");
  for (XmlNodeList::const_iterator iProperty = propertyNodeList.begin(); iProperty!= propertyNodeList.end(); ++iProperty)
    {
      IXMPropertyIncrementData property_data;
      property_data.name = iProperty->attrValue("name");
      property_data.data_type = iProperty->attrValue("type");
      // For V3 : group name not used in general case: use AllItems(item_kind)
      if (m_get_group_name == true)
    	  property_data.group_name = iProperty->attrValue("group-name");
      else
    	  property_data.group_name = allItemGroupName(iProperty->attrValue("kind"));

      property_data.kind = iProperty->attrValue("kind");
      property_data.data_array_size = 1; // Array property not supported in V3
      // Read Support
      Arcane::XmlNode support_node = iProperty->child("support");
      String support_string = support_node.value();
      if (!support_string.empty())
        {
          bool support_hasError = builtInGetValue(property_data.support_and_values.item_ids, support_string);
          if (support_hasError) throw InconsistentPropertyDescriptionException(
              property_data.name,
              "Error in building property support uids array from xml read string");
        }
      // Read Values
      Arcane::XmlNodeList values_nodes = iProperty->children("values");
      Arcane::String values_string;
      Arcane::Real values_time;
      for (XmlNodeList::const_iterator iValues = values_nodes.begin(); iValues != values_nodes.end(); ++iValues)
        {
          values_time = iValues->attr("time").valueAsReal();
          values_string = _getValuesString(*iValues,property_data);
          // Indicate values data string content : ie data array or string with data file address : in V3 always data array
          // since extern files have been pre processed
          IXMPropertyValuesData::eDataStringContent data_string_content = IXMPropertyValuesData::DataArray;
          property_data.support_and_values.item_infos.push_back(IXMPropertyIncrementValuesData(values_time,values_string,data_string_content));
        }
      property_increment_data_list.push_back(property_data);
    }

  delete xml_doc;
}
#endif
/*---------------------------------------------------------------------------*/

Arcane::String
ArcGeoSim::IXMV3MeshReader::
allItemGroupName(const Arcane::String& item_kind)
{
  Arcane::String item_kind_name = itemKindName(ArcGeoSim::StringToItemUtils::stringToItemKind(item_kind));
  Arcane::StringBuilder str_builder("All");
  str_builder += item_kind_name;
  str_builder += "s";
  Arcane::String all_item_group_name = str_builder.toString();
  return all_item_group_name;

}

/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMV3MeshReader::
readGeometryIncrementData(ArcGeoSim::IXMTools::IXMGeometryIncrementData& geometry_data, const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV3MeshReader"))
  ARCANE_ASSERT((_isGeometryIncrementLoaded()),("Geometry Increment not loaded in the IXMV3MeshReader"))

  Arcane::XmlNode geometry_node = *(m_mesh_increment_xml_node->geometry_node.get());

  if (m_is_debug_event) _geometryIncrementDataDebug(geometry_data, geometry_node);
  else _geometryIncrementData(geometry_data,geometry_node,check_mesh_info);

}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
_cellIncrementData(ArcGeoSim::IXMTools::IXMCellIncrementData& cell_increment_data, const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{

  ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV3MeshReader"))
  ARCANE_ASSERT((_isTopologyIncrementLoaded()),("Topology Increment not loaded in the IXMV3MeshReader"))

  Arcane::XmlNode rootNode = *(m_mesh_increment_xml_node->topology_node.get());

  // Get managers
  ItemTypeMng * typeMng = ItemTypeMng::singleton();

  { // Handle deleted cells
    Arcane::XmlNodeList delete_cell_list = rootNode.children("delete-cells");
    for (Arcane::XmlNodeList::const_iterator iCellList = delete_cell_list.begin();
         iCellList != delete_cell_list.end(); ++iCellList)
      { // Read delete-cells node
        Arcane::Int64SharedArray cell_ids = _readDirectIndirectArray<Int64>(iCellList->child("cells-id"),
                                                              iCellList->child("cell-id-ascii-file-path"),
                                                              "Error while reading delete-cells uids");
        cell_increment_data.removed_cell_data.item_ids.addRange(cell_ids);
      }
  }

  { // Handle created cells
    _readCellInfos(rootNode.children("create-cells"),
                     "create-cells",
                     typeMng,
                     cell_increment_data.new_cell_data.item_ids,
                     cell_increment_data.new_cell_data.item_infos,
                     check_mesh_info);
  }

  {// Handle modified cells
    _readCellInfos(rootNode.children("change-cells"),
                     "change-cells",
                     typeMng,
                     cell_increment_data.changed_cell_data.item_ids,
                     cell_increment_data.changed_cell_data.item_infos,
                     check_mesh_info);
  }
}
#endif
/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMV3MeshReader::
_faceData(ArcGeoSim::IXMTools::IXMFaceData& face_data,const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{

  ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV3MeshReader"))
  ARCANE_ASSERT((_isTopologyIncrementLoaded()),("Topology Increment not loaded in the IXMV3MeshReader"))

  Arcane::XmlNode rootNode = *(m_mesh_increment_xml_node->topology_node.get());

  Arcane::XmlNodeList facesList = rootNode.children("faces");

  // Iterate on "faces" xml node (minOccurs=0, maxOccurs=1)
  for (Arcane::XmlNodeList::const_iterator iFacesList = facesList.begin();
       iFacesList != facesList.end(); ++iFacesList)
    { // Read faces infos
      Arcane::IntegerSharedArray node_number = _readDirectIndirectArray<Arcane::Integer>(
          iFacesList->child("nodes-number"),
          iFacesList->child("nodes-number-ascii-file-path"),
          "Error while reading faces nodes-number");
      Arcane::Int64SharedArray face_id = _readDirectIndirectArray<Arcane::Int64>(
          iFacesList->child("faces-id"),
          iFacesList->child("face-id-ascii-file-path"),
          "Error while reading faces faces-id");
      Arcane::Int64SharedArray node_id = _readDirectIndirectArray<Arcane::Int64>(
          iFacesList->child("nodes-id"),
          iFacesList->child("node-id-ascii-file-path"),
          "Error while reading faces nodes-id");

      // Check sizes for node number and faces
      Arcane::Integer nb_faces = face_id.size();
      if (node_number.size() != nb_faces) {
          m_trace_mng->info() << " node_number.size() =  " << node_number.size() << " face_id.size() = " << face_id.size() ;
        m_trace_mng->fatal() << "Different number of cell types and cell id";
      }

      // Check (only in strict check mode) if node number does not contain values lower to 3
      if (check_mesh_info.isCheckEnabled() && check_mesh_info.dimension()>2)
        {
          for (Arcane::IntegerSharedArray::iterator ite = node_number.begin(); ite != node_number.end(); ++ite)
            {
              if (*ite < 3)
                m_trace_mng->fatal() << "Face described with less than 3 nodes in <faces>/<nodes-number>";
            }
        }

      // Check node number
      Integer total_nb_node = 0;
      for (Arcane::IntegerSharedArray::const_iterator ite = node_number.begin(); ite != node_number.end(); ++ite)
        total_nb_node += *ite;

      if (total_nb_node != node_id.size())
        m_trace_mng->fatal() << "Inconsistent total node number not equal to face number times face node number. Total node number expected ="
                << total_nb_node << " Total node number received = " << node_id.size();

      // Save infos into main containers
      face_data.faces.item_ids.addRange(face_id);
      face_data.faces.item_infos.addRange(node_number);
      face_data.node_ids.addRange(node_id);
    }
}
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
_updateNodeData(ArcGeoSim::IXMTools::IXMUpdateNodeData& update_node_data, const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)

{
  ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV3MeshReader"))
  ARCANE_ASSERT((_isTopologyIncrementLoaded()),("Topology Increment not loaded in the IXMV3MeshReader"))

  Arcane::XmlNode rootNode = *(m_mesh_increment_xml_node->topology_node.get());

  Arcane::XmlNodeList updateNodesList = rootNode.children("update-nodes");
  for (Arcane::XmlNodeList::const_iterator iNodeList = updateNodesList.begin();
      iNodeList != updateNodesList.end(); ++iNodeList)
    { // Read nodes id and coord
      // Update node by cloning existing node
      Arcane::XmlNode clone_listNode = iNodeList->child("clone-list");
      if (!clone_listNode.null())
        {
          Arcane::Int64SharedArray clone_update_node_uids_tmp = _readDirectIndirectArray<Int64>(
              iNodeList->child("nodes-id-clone"),
              iNodeList->child("node-id-clone-ascii-file-path"),
              "Error while reading update-nodes node-id-clone");
          Arcane::Int64SharedArray clone_update_node_cloned_uids_tmp =  _readDirectIndirectArray<Int64>(
              clone_listNode.child("id"),
              clone_listNode.child("id-ascii-file-path"),
              "Error while reading update-nodes id");

          // Check size
          if (clone_update_node_uids_tmp.size() != clone_update_node_cloned_uids_tmp.size())
            m_trace_mng->fatal() << Arcane::String::format("Inconsistent size between nodes-id-clone ({0}) and id ({1}) sizes in clone-list",
                                      clone_update_node_uids_tmp.size(),
                                      clone_update_node_cloned_uids_tmp.size());
          update_node_data.cloned_nodes.item_ids.addRange(clone_update_node_uids_tmp);
          update_node_data.cloned_nodes.item_infos.addRange(clone_update_node_cloned_uids_tmp);
        }

      // Update node by setting coordinates
      Arcane::XmlNode coordsNode = iNodeList->child("coords");
      if (!coordsNode.null())
        {
          Arcane::Int64SharedArray coord_update_node_uids_tmp = _readDirectIndirectArray<Int64>(
              iNodeList->child("nodes-id-coords"),
              iNodeList->child("node-id-coords-ascii-file-path"),
              "Error while reading update-nodes node-id-coord");
          Arcane::RealSharedArray xyz = _readDirectIndirectArray<Real>(
              coordsNode.child("xyz"),
              coordsNode.child("xyz-ascii-file-path"),
              "Error while reading update-nodes xyz");

          if (coord_update_node_uids_tmp.size() * check_mesh_info.coordDimension() != xyz.size())
            m_trace_mng->fatal() << "Inconsistent number of nodes coordinates :"
            << " Node number = " << coord_update_node_uids_tmp.size() << " in dimension " << check_mesh_info.coordDimension() << ".\n"
            << " Expected  " << coord_update_node_uids_tmp.size() * check_mesh_info.coordDimension() << " values for node coordinates,"
            << " Received " << xyz.size() << " values"
            << " NB: coordinates are always (x,y,z) even for 2D topologic mesh";

          const Arcane::Integer node_coords_count = coord_update_node_uids_tmp.size();
          Arcane::Integer coord_update_node_coords_index = update_node_data.added_nodes.item_infos.size(); // start from last position
          update_node_data.added_nodes.item_infos.addRange(Arcane::Real3::null(),node_coords_count);
          for (Integer i = 0, current_node_position=0; i < node_coords_count; ++i)
            {
              update_node_data.added_nodes.item_infos[coord_update_node_coords_index].x = xyz[current_node_position];
              update_node_data.added_nodes.item_infos[coord_update_node_coords_index].y = xyz[current_node_position+ 1];
              update_node_data.added_nodes.item_infos[coord_update_node_coords_index].z = xyz[current_node_position+ 2];
              current_node_position += 3;
              coord_update_node_coords_index += 1;
            }
          update_node_data.added_nodes.item_ids.addRange(coord_update_node_uids_tmp);
        }
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
_groupIncrementData(ArcGeoSim::IXMTools::IXMGroupIncrementDataList& group_increment_data_list, const Arcane::XmlNodeList& group_nodes)
{
  for (Arcane::XmlNodeList::const_iterator iGroupList = group_nodes.begin(); iGroupList != group_nodes.end(); ++iGroupList)
    {
      const String group_name = (*iGroupList).attr("name").value();
      const String group_kind = (*iGroupList).attr("kind").value();
      const String group_mode = (*iGroupList).attr("mode").value();

      // Il est ici autoris� d'avoir une liste vide (blanche) sur group-id
      // Toutes les autres balises l'excluent.
      // Si ce comportement change il sera possible d'utiliser _readDirectIndirectArray.
      Int64SharedArray group_id;
      String group_id_string = _readDirectIndirectString(
          iGroupList->child("group-id"),
          iGroupList->child("group-id-ascii-file-path"));
      if (not group_id_string.empty())
        {
          bool group_id_hasError = builtInGetValue(group_id, group_id_string);
          if (group_id_hasError)
            m_trace_mng->fatal() << String::format("Error while reading group '{0}' ids",group_name);
        }

      const Arcane::eItemKind item_kind = ArcGeoSim::StringToItemUtils::stringToItemKind(group_kind);

      IXMGroupIncrementData group_increment_data;
      group_increment_data.group_data.name = group_name;
      group_increment_data.group_data.kind = item_kind;
      group_increment_data.group_data.ids = group_id;
      group_increment_data.mode = group_mode;

      group_increment_data_list.push_back(group_increment_data);
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
_geometryIncrementData(ArcGeoSim::IXMTools::IXMGeometryIncrementData& geometry_data, const Arcane::XmlNode& geometry_node, const ArcGeoSim::IXMTools::IXMMeshInfo& mesh_info)
{
  Arcane::Integer node_count;
  Arcane::XmlNode moveNodeRoot = geometry_node.child("move-node-to");
  if (not moveNodeRoot.null())
    {
      geometry_data.item_ids = _readDirectIndirectArray<Int64>(moveNodeRoot.child("nodes-id"),
          moveNodeRoot.child("node-id-ascii-file-path"),
          "Error while reading move-node-to node ids");
      node_count = geometry_data.item_ids.size();

      Arcane::XmlNode coords_node = moveNodeRoot.child("coords");
      Arcane::RealSharedArray xyz = _readDirectIndirectArray<Real>(coords_node.child("xyz"),
          coords_node.child("xyz-ascii-file-path"),
          "Error while reading move-node-to node coords");

      // Check compatibility between read uids and coords
      if (node_count * mesh_info.coordDimension() != xyz.size())
        m_trace_mng->fatal() << "Inconsistent number of nodes coordinates :"
        << " Node number = " << node_count << " in dimension " << mesh_info.coordDimension() << ".\n"
        << " Expected  " << node_count * mesh_info.coordDimension() << " values for node coordinates,"
        << " Received " << xyz.size() << " values."
        << " NB: coordinates are always (x,y,z) even for 2D topologic mesh";

      // Fill moved nodes coords
      geometry_data.item_infos.resize(node_count);
      for (Arcane::Integer i = 0, current_node_position = 0; i < node_count; ++i)
        {
          geometry_data.item_infos[i].x = xyz[current_node_position   ];
          geometry_data.item_infos[i].y = xyz[current_node_position+ 1];
          geometry_data.item_infos[i].z = xyz[current_node_position+ 2];
          current_node_position += 3;
        }
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
_cellIncrementDataDebug(ArcGeoSim::IXMTools::IXMCellIncrementData& cell_increment_data,const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV3MeshReader"))
  ARCANE_ASSERT((_isTopologyIncrementLoaded()),("Topology Increment not loaded in the IXMV3MeshReader"))

  Arcane::XmlNode rootNode = *(m_mesh_increment_xml_node->topology_node.get());

  // dimension of current mesh (used for checking type compatibility)
  const Integer mesh_dimension = check_mesh_info.dimension();

  // Get managers
  ItemTypeMng * typeMng = ItemTypeMng::singleton();

  { // Gestion des suppressions de cellules
    Arcane::XmlNodeList addCellsList = rootNode.children("delete-cells");
    for (Arcane::XmlNodeList::const_iterator iCellList = addCellsList.begin(); iCellList
           != addCellsList.end(); ++iCellList)
      {
        Arcane::XmlNodeList cellList = (*iCellList).children("id");
        for (Arcane::XmlNodeList::const_iterator icell = cellList.begin(); icell != cellList.end(); ++icell)
          {
            cell_increment_data.removed_cell_data.item_ids.add(icell->valueAsInt64());
          }
      }
  }

  { // Gestion des nouvelles cellules
    Arcane::XmlNodeList addCellsList = rootNode.children("create-cells");
    for (Arcane::XmlNodeList::const_iterator iCellList = addCellsList.begin(); iCellList
           != addCellsList.end(); ++iCellList)
      {
        Arcane::XmlNodeList cellList = (*iCellList).children("cell");
        for (Arcane::XmlNodeList::const_iterator icell = cellList.begin(); icell != cellList.end(); ++icell)
          {
            const Integer cell_type_id = ArcGeoSim::StringToItemUtils::stringToItemType(icell->attr("type").value());
            // Check type compatibility with mesh dimesnion
            if (check_mesh_info.typeDimension()[cell_type_id] != mesh_dimension)
              m_trace_mng->fatal() << icell->attr("type").value() << " cell is not allowed in " << mesh_dimension << "d mesh in <" << iCellList->xpathFullName() << ">";
            cell_increment_data.new_cell_data.item_infos.add(cell_type_id);
            const Int64 cell_uid = icell->attr("id").valueAsInt64();
            cell_increment_data.new_cell_data.item_infos.add(cell_uid);
            cell_increment_data.new_cell_data.item_ids.add(cell_uid);
            auto cell_type = typeMng->typeFromId(cell_type_id);
            const Integer current_cell_nb_node = cell_type->nbLocalNode();
            Arcane::XmlNodeList nodeList = (*icell).children("node-id");
            if (nodeList.size() != current_cell_nb_node)
              throw XmlException("FileDriverEvolutiveMeshV3Service::compute",
                                 String::format("Wrong node count for cell uid={0} ; received={1} requested={2}",
                                                cell_uid,nodeList.size(),current_cell_nb_node));
            for (Integer i = 0; i < current_cell_nb_node; ++i)
              {
                const Int64 node_uid = nodeList[i].valueAsInt64();
                cell_increment_data.new_cell_data.item_infos.add(node_uid);
              }
          }
      }
  }

  { // Gestion des cellules modifi�es
    Arcane::XmlNodeList changeCellsList = rootNode.children("change-cells");
    for (Arcane::XmlNodeList::const_iterator iCellList = changeCellsList.begin(); iCellList
           != changeCellsList.end(); ++iCellList)
      {
        Arcane::XmlNodeList cellList = (*iCellList).children("cell");
        for (Arcane::XmlNodeList::const_iterator icell = cellList.begin(); icell != cellList.end(); ++icell)
          {
            const Integer cell_type_id = ArcGeoSim::StringToItemUtils::stringToItemType(icell->attr("type").value());
            // Check type compatibility with mesh dimesnion
            if (check_mesh_info.typeDimension()[cell_type_id] != mesh_dimension)
              m_trace_mng->fatal() << icell->attr("type").value() << " cell is not allowed in " << mesh_dimension << "d mesh in <" << iCellList->xpathFullName() << ">";
            cell_increment_data.changed_cell_data.item_infos.add(cell_type_id);
            const Int64 cell_uid = icell->attr("id").valueAsInt64();
            cell_increment_data.changed_cell_data.item_infos.add(cell_uid);
            cell_increment_data.changed_cell_data.item_ids.add(cell_uid);
            auto cell_type = typeMng->typeFromId(cell_type_id);
            const Integer current_cell_nb_node = cell_type->nbLocalNode();
            Arcane::XmlNodeList nodeList = (*icell).children("node-id");
            if (nodeList.size() != current_cell_nb_node)
              throw XmlException("FileDriverEvolutiveMeshV3Service::compute",
                                 String::format("Wrong node count for cell uid={0} ; received={1} requested={2}",
                                                cell_uid,nodeList.size(),current_cell_nb_node));
            for (Integer i = 0; i < current_cell_nb_node; ++i)
              {
                const Int64 node_uid = nodeList[i].valueAsInt64();
                cell_increment_data.changed_cell_data.item_infos.add(node_uid);
              }
          }
      }
  }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
_faceDataDebug(ArcGeoSim::IXMTools::IXMFaceData& face_data,const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV3MeshReader"))
  ARCANE_ASSERT((_isTopologyIncrementLoaded()),("Topology Increment not loaded in the IXMV3MeshReader"))

  Arcane::XmlNode rootNode = *(m_mesh_increment_xml_node->topology_node.get());

  Arcane::XmlNodeList facesList = rootNode.children("faces");

  for (Arcane::XmlNodeList::const_iterator iFacesList = facesList.begin();
      iFacesList != facesList.end(); ++iFacesList)
    {
      Arcane::XmlNodeList faceList = (*iFacesList).children("face");
      for (Arcane::XmlNodeList::const_iterator iface = faceList.begin(); iface != faceList.end(); ++iface)
        {
          face_data.faces.item_ids.add(iface->attr("aid").valueAsInteger());
          Arcane::XmlNodeList nodeList = (*iface).children("node-id");
          const Integer current_face_nb_node = nodeList.size();
          face_data.faces.item_infos.add(current_face_nb_node);
          for (Integer i = 0; i < current_face_nb_node; ++i)
            face_data.node_ids.add(nodeList[i].valueAsInt64());
        }
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
_updateNodeDataDebug(ArcGeoSim::IXMTools::IXMUpdateNodeData& update_node_data, const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV3MeshReader"))
  ARCANE_ASSERT((_isTopologyIncrementLoaded()),("Topology Increment not loaded in the IXMV3MeshReader"))

  Arcane::XmlNode rootNode = *(m_mesh_increment_xml_node->topology_node.get());

  Arcane::XmlNodeList updateNodesList = rootNode.children("update-nodes");
  for (Arcane::XmlNodeList::const_iterator iNodeList = updateNodesList.begin();
       iNodeList != updateNodesList.end(); ++iNodeList)
    {
      Arcane::XmlNodeList nodeList = (*iNodeList).children("node");
      const Integer nodeCount = nodeList.size();
      for (Integer i = 0; i < nodeCount; ++i)
        {
          const Arcane::XmlNode & node = nodeList[i];
          if (not node.child("coord").null())
            {
              const Arcane::XmlNode coordNode = node.child("coord");
              update_node_data.added_nodes.item_ids.add(node.attr("id").valueAsInt64());
              const Real x = coordNode.child("x").valueAsReal();
              const Real y = coordNode.child("y").valueAsReal();
              const Real z = coordNode.child("z").valueAsReal();
              update_node_data.added_nodes.item_infos.add(Real3(x,y,z));
            }
          else if (not node.child("clone").null())
            {
            update_node_data.cloned_nodes.item_ids.add(node.attr("id").valueAsInt64());
            update_node_data.cloned_nodes.item_infos.add(node.child("clone").valueAsInt64());
            }
        }
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
_groupIncrementDataDebug(ArcGeoSim::IXMTools::IXMGroupIncrementDataList& group_increment_data_list, const Arcane::XmlNodeList& group_nodes)
{

  for (Arcane::XmlNodeList::const_iterator iGroupList = group_nodes.begin();
      iGroupList != group_nodes.end(); ++iGroupList)
    {
      const String group_name = (*iGroupList).attr("name").value();
      const eItemKind item_kind = ArcGeoSim::StringToItemUtils::stringToItemKind((*iGroupList).attr("kind").value());
      const String group_mode = (*iGroupList).attr("mode").value();

      IXMGroupIncrementData group_increment_data;
      group_increment_data.group_data.name = group_name;
      group_increment_data.group_data.kind = item_kind;
      group_increment_data.mode = group_mode;

      Arcane::XmlNodeList idList = (*iGroupList).children("id");
      const Integer idCount = idList.size();
//      Int64SharedArray uids(idCount);
      group_increment_data.group_data.ids.resize(idCount);
      for (Integer i = 0; i < idCount; ++i)
        {
          group_increment_data.group_data.ids[i] = idList[i].valueAsInt64();
        }

      group_increment_data_list.push_back(group_increment_data);
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
_geometryIncrementDataDebug(ArcGeoSim::IXMTools::IXMGeometryIncrementData& geometry_data, const Arcane::XmlNode& geometry_node)
{
  Arcane::XmlNodeList nodeList = geometry_node.children("move-node-to");
  const Arcane::Integer node_count = nodeList.size();
  geometry_data.item_ids.resize(node_count);
  geometry_data.item_infos.resize(node_count);
  for (Arcane::Integer i = 0; i < node_count; ++i)
    {
      const Arcane::XmlNode & node = nodeList[i];
      geometry_data.item_ids[i] = node.attr("id").valueAsInt64();
      if (not node.child("coord").null())
        {
          const Arcane::XmlNode coordNode = node.child("coord");
          geometry_data.item_infos[i].x = coordNode.child("x").valueAsReal();
          geometry_data.item_infos[i].y = coordNode.child("y").valueAsReal();
          geometry_data.item_infos[i].z = coordNode.child("z").valueAsReal();
        }
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

Arcane::XmlNode
ArcGeoSim::IXMV3MeshReader::
_getEventDataRootNode(Arcane::XmlNode& current_event, const Arcane::Integer event_tag)
{

  // Explore event choice : extern, intern or intern debug
  Arcane::XmlNode extern_file = current_event.child("extern-file");
  Arcane::XmlNode intern = current_event.child("intern");
  Arcane::XmlNode intern_debug = current_event.child("intern-debug");
  if (!extern_file.null())
    {
      Arcane::IXmlDocumentHolder * xml_doc = m_mesh_increment_xml_node->xmldoc_holder = m_io_mng->parseXmlFile(extern_file.value(),
          "ixm_v3.xsd", Arcane::ByteConstArrayView(strlen((const char*) ixm_v3_xsd), ixm_v3_xsd));
      Arcane::XmlNode local_event_content = xml_doc->documentNode().child("extern");
      Arcane::XmlNode local_event_content_debug = xml_doc->documentNode().child("extern-debug");
      if (!local_event_content.null())
        {
          m_is_debug_event = false;
          return local_event_content;
        }
      else if (!local_event_content_debug.null()) // old format for debug
        {
          m_is_debug_event = true;
          return local_event_content_debug;
        }
    }
  // intern node
  else if (!intern.null())
    {
      m_is_debug_event = false;
      return intern;
    }
  else // case intern debug
    {
      m_is_debug_event = true;
      return intern_debug;
    }
  throw Arcane::FatalErrorException(A_FUNCINFO,Arcane::String::format("Cannot find root of event element {0}",current_event.attrValue("name")));
}
#endif
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/

Arcane::String
ArcGeoSim::IXMV3MeshReader::
_readDirectIndirectString(const Arcane::XmlNode& direct_node, const Arcane::XmlNode& indirect_node)
{
  // Select what node contains data
  if (!direct_node.null())
    return direct_node.value();
  else if (!indirect_node.null())
    {
      Arcane::ByteSharedArray file_content;
      m_io_mng->localRead(indirect_node.value(), file_content);
      file_content.add(0); // Necessary step to read byte array in a String cf Arcane doc
      return Arcane::String(file_content);
    }
  else
    {
      return Arcane::String();
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV3MeshReader::
_readCellInfos(const Arcane::XmlNodeList& cell_list_node,
                 const String& block_name,
                 ItemTypeMng * typeMng,
                 Arcane::Int64Array & cell_uids,
                 Arcane::Int64Array & cell_infos,
                 const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  for (Arcane::XmlNodeList::const_iterator iCellList = cell_list_node.begin();
      iCellList != cell_list_node.end(); ++iCellList)
    {
      // Read each block of data (types, cell ids, cell node ids)
      Arcane::StringSharedArray cell_types = _readDirectIndirectArray<Arcane::String>(
          iCellList->child("cells-type"),
          iCellList->child("cells-type-ascii-file-path"),
          Arcane::String::format("Error while reading {0} types",block_name));

      Arcane::Int64SharedArray cell_ids = _readDirectIndirectArray<Arcane::Int64>(
          iCellList->child("cells-id"),
          iCellList->child("cell-id-ascii-file-path"),
          Arcane::String::format("Error while reading {0} ids",block_name));

      Arcane::Int64SharedArray node_ids = _readDirectIndirectArray<Arcane::Int64>(
            iCellList->child("nodes-id"),
            iCellList->child("node-id-ascii-file-path"),
            Arcane::String::format("Error while reading {0} node ids",block_name));

      // Check sizes for cells types and id
      if (cell_types.size() != cell_ids.size())
        m_trace_mng->fatal() << "Inconsistent number of cell types (" << cell_ids.size() << ") and cell ids (" << cell_types.size() << ") in " << block_name << " block";

      const Arcane::Integer event_nb_new_cells = cell_types.size();
      Arcane::Integer event_nb_new_nodes = 0;
      // Parse types
      Arcane::IntegerSharedArray cell_type_ids(event_nb_new_cells); // type id of each cell
      Arcane::IntegerSharedArray cell_nb_nodes(event_nb_new_cells); // number of nodes for each cell
      const Arcane::Integer mesh_dimension = check_mesh_info.dimension(); // dimension of current mesh
      for (Arcane::Integer i = 0; i < event_nb_new_cells; ++i)
        {
          // store type id
          cell_type_ids[i] = ArcGeoSim::StringToItemUtils::stringToItemType(cell_types[i]);
          if (check_mesh_info.typeDimension()[cell_type_ids[i]] != mesh_dimension)
            m_trace_mng->fatal() << cell_types[i] << " cell is not allowed in " << mesh_dimension << "d mesh in <" << iCellList->xpathFullName() << ">";
          // increment new node number
          auto current_cell_type = typeMng->typeFromId(cell_type_ids[i]);
          cell_nb_nodes[i] = current_cell_type->nbLocalNode();
          event_nb_new_nodes += cell_nb_nodes[i];
        }
      // Check size for node id
      if (node_ids.size() != event_nb_new_nodes)
          m_trace_mng->fatal()
              << "Inconsistent total node number not equal to cell number times cell node number. Total node number expected ="
              << event_nb_new_nodes << " Total node number received = " << node_ids.size();
      // Add cells info
      cell_uids.addRange(cell_ids);
      cell_infos.reserve(cell_infos.size() + 2*event_nb_new_cells + event_nb_new_nodes); // optimisation d'allocation
      for (Arcane::Integer i = 0, current_node_position = 0; i < event_nb_new_cells; ++i)
        {
          cell_infos.add(cell_type_ids[i]);
          cell_infos.add(cell_ids[i]);
          cell_infos.addRange(node_ids.subConstView(current_node_position,cell_nb_nodes[i]));
          current_node_position += cell_nb_nodes[i];
        }
    }
}

/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMV3MeshReader::
_includePropertyExternNodes()
{
  ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV3MeshReader"))
  Arcane::XmlNodeList property_node_list = m_mesh_increment_xml_node->property_node.get()->children("property");
  //
  for (Arcane::XmlNodeList::iterator iProperty = property_node_list.begin(); iProperty!=property_node_list.end();++iProperty )
    {
      // Support node
      Arcane::XmlNode extern_support_node = iProperty->child("extern-support");
      if (!extern_support_node.null())
        {
          // Get Remote node
          IXmlDocumentHolder* xml_doc;
          xml_doc = m_io_mng->parseXmlFile(extern_support_node.value(),
                                           "ixm_v3.xsd",
                                           ByteConstArrayView(strlen((const char*) ixm_v3_xsd), ixm_v3_xsd));
          Arcane::XmlNode root_node = xml_doc->documentNode();
          Arcane::String support_string = root_node.child("external-property-support").value();
          // copy it into existing tree
          Arcane::XmlNode intern_support_node = iProperty->createNode(Arcane::XmlNode::ELEMENT,"support",support_string);
          iProperty->append(intern_support_node);
          delete xml_doc;
          }
      // Data node
      Arcane::XmlNodeList values_node_list = iProperty->children("values");
      for (Arcane::XmlNodeList::iterator iValues = values_node_list.begin(); iValues!= values_node_list.end();++iValues)
        {
          // data node
          Arcane::XmlNode extern_data_node = iValues->child("extern-data");
          if (!extern_data_node.null())
            {
            // Get Remote node
            IXmlDocumentHolder* xml_doc;
            xml_doc = m_io_mng->parseXmlFile(extern_data_node.value(),
                "ixm_v3.xsd",
                ByteConstArrayView(strlen((const char*) ixm_v3_xsd), ixm_v3_xsd));
            Arcane::XmlNode root_node = xml_doc->documentNode();
            // Get typed data
            Arcane::XmlNode external_property_data_node = root_node.child("external-property-data");
            Arcane::String typed_data_string;
            Arcane::String typed_data_name;
            if (!external_property_data_node.child("real-data").null())
              {
                typed_data_string = external_property_data_node.child("real-data").value();
                typed_data_name = "real-data";
              }
            else if (!external_property_data_node.child("real3-data").null())
              {
                typed_data_string = external_property_data_node.child("real3-data").value();
                typed_data_name = "real3-data";
              }
            else if (!external_property_data_node.child("int32-data").null())
              {
                typed_data_string = external_property_data_node.child("int32-data").value();
                typed_data_name = "int32-data";
              }
            else if (!external_property_data_node.child("int64-data").null())
              {
                typed_data_string = external_property_data_node.child("int64-data").value();
                typed_data_name = "int64-data";
              }
            else if (!external_property_data_node.child("integer-data").null())
              {
                typed_data_string = external_property_data_node.child("integer-data").value();
                typed_data_name = "integer-data";
              }
            else if (!external_property_data_node.child("bool-data").null())
              {
                typed_data_string = external_property_data_node.child("bool-data").value();
                typed_data_name = "bool-data";
              }
            // copy it into existing tree
            Arcane::XmlNode intern_data_node = iValues->createNode(Arcane::XmlNode::ELEMENT,"data","");
            Arcane::XmlNode intern_typed_data_node = iValues->createNode(Arcane::XmlNode::ELEMENT,typed_data_name,typed_data_string);
            intern_data_node.append(intern_typed_data_node);
            iValues->append(intern_data_node);
            delete xml_doc;
        }
    }
  }
}
#endif
/*---------------------------------------------------------------------------*/

Arcane::String
ArcGeoSim::IXMV3MeshReader::
_getValuesString(const Arcane::XmlNode& values_node, const ArcGeoSim::IXMTools::IXMPropertyIncrementData property_data)
{
  Arcane::String typed_data_tag_name;
  if (property_data.data_type == "Integer")    typed_data_tag_name = "integer-data";
  else if (property_data.data_type == "Real")  typed_data_tag_name = "real-data";
  else if (property_data.data_type == "Real3") typed_data_tag_name = "real3-data";
  else if (property_data.data_type == "Bool")  typed_data_tag_name = "bool-data";
  else if (property_data.data_type == "Int64") typed_data_tag_name = "int64-data";
  else if (property_data.data_type == "Int32") typed_data_tag_name = "int32-data";
  // Check XmlNode ok
  if (values_node.child("data").null())
    throw InconsistentPropertyDescriptionException (
        property_data.name,
        "data node not available for property");

  if (values_node.child("data").child(typed_data_tag_name).null())
    throw InconsistentPropertyDescriptionException (
        property_data.name,
        "property type defined in data node is different from type defined in property node");

  // Get string
  Arcane::String values_string = values_node.child("data").child(typed_data_tag_name).value();
  return values_string;
}

/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMV3MeshReader::
_broadcastGroupData(Arcane::XmlNode& group_node, Arcane::IXmlDocumentHolder * group_holder, ParallelUtils parallel_utils)
{
  bool is_master = (parallel_utils.parallelMng()->commRank() == parallel_utils.parallelMng()->masterIORank());
  if (parallel_utils.parallelMng()->commSize() == 1)
    {
      ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV3MeshReader"))
      group_node = *(m_mesh_increment_xml_node->topology_node.get());
    }
  else
    { // Diffusion des infos de groupes
      Arcane::ByteSharedArray bytes;
      if (is_master)
        {
          ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV3MeshReader"))
          Arcane::XmlNode localRootNode = *(m_mesh_increment_xml_node->topology_node.get());
          Arcane::OStringStream oss;
          oss() << "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?><groups>"; // prefix
          Arcane::XmlNodeList groups = localRootNode.children("group");
          for (Arcane::XmlNodeList::const_iterator i_group = groups.begin(); i_group != groups.end(); ++i_group)
            {
              Arcane::domutils::writeNode(oss(),(*i_group).domNode());
            }
          oss() << "</groups>"; // suffix
          bytes = oss.str().utf8();
        }
      parallel_utils.multiBroadcast(bytes,parallel_utils.parallelMng()->masterIORank());

      group_holder = m_io_mng->parseXmlBuffer(bytes,"evolutive-group");
      group_node = group_holder->documentNode().child("groups"); // c'est la nuance avec l'algo s�quentiel
    }
}
#endif
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
