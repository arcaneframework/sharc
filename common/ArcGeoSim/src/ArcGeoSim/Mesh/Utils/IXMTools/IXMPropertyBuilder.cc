#include "IXMPropertyBuilder.h"
/* Author : dechaiss at Mon Apr 11 16:04:39 2011
 * Generated by createNew
 */

#include <exception>
#include <iostream>
#include <algorithm>
#include <cassert>

#include <arcane/XmlNodeList.h>
#include <arcane/IVariableMng.h>
#include <arcane/IItemFamily.h>
#include <arcane/ItemGroup.h>
#include <arcane/ItemInternal.h>
#include <arcane/IMeshUtilities.h>
#include <arcane/IParallelMng.h>
#include <arcane/utils/UserDataList.h>
#include <arcane/utils/IUserData.h>
#include <arcane/utils/AutoDestroyUserData.h>

#include "ArcGeoSim/Mesh/Utils/VariableUtils.h"
#include "ArcGeoSim/Utils/DataTypeUtils.h"
#include "ArcGeoSim/Utils/ParallelUtils.h"
//#include "ArcGeoSim/Mesh/EvolutiveMesh/IEvolutiveMeshObserver.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMMeshReaderTools.h"

using namespace ArcGeoSim::IXMTools;
using namespace ArcGeoSim::IXMTools::IXMPropertyExceptions;




/*---------------------------------------------------------------------------*/
// Class IXMPropertyBuilderImpl
/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
ArcGeoSim::IXMPropertyBuilderImpl::
IXMPropertyBuilderImpl(IEvolutiveMesh* const evolutive_mesh, IMesh* const mesh)
  : m_current_modified_properties(mesh->subDomain()->variableMng())
  , m_modified_property_history(mesh->subDomain()->variableMng())
  , m_evolutive_mesh(evolutive_mesh)
  , m_is_event_loaded(false)
  , m_is_event_conform(false)
  , m_is_property_loaded(false)
  , m_has_face_property(false)
  , m_mesh(mesh)
  , m_trace_mng(mesh->subDomain()->traceMng())
  , m_mesh_directory_name()

{
  // Add observer on evolutive_mesh
  m_evolutive_mesh->addObserver(newEvolutiveMeshObserverT(this,&IXMPropertyBuilderImpl::updateFilledItemVariables),IEvolutiveMesh::AfterTopology);
}
#endif
/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMPropertyBuilderImpl::
IXMPropertyBuilderImpl(IMesh* const mesh)
  : m_current_modified_properties(mesh->subDomain()->variableMng())
  , m_modified_property_history(mesh->subDomain()->variableMng())
  , m_is_event_loaded(false)
  , m_is_event_conform(false)
  , m_is_property_loaded(false)
  , m_has_face_property(false)
  , m_mesh(mesh)
  , m_trace_mng(mesh->subDomain()->traceMng())
  , m_mesh_directory_name()

{}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMPropertyBuilderImpl::
~IXMPropertyBuilderImpl()
{
  for (DescriptionContainer::iterator idescription = m_current_property_description.begin(); idescription != m_current_property_description.end(); ++idescription)
    {
      delete (*idescription);
    }
  m_current_modified_properties.clear();
}

/*---------------------------------------------------------------------------*/
#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMPropertyBuilderImpl::
loadEvent(const IXMPropertyIncrementDataList& properties, const Real& event_begin_time, const Real& event_end_time)
{
  if (m_is_event_loaded) _unloadEvent();

  if (event_begin_time == event_end_time) _checkDateEventConformity(properties, event_end_time);
  else _checkPeriodEventConformity(properties, event_begin_time, event_end_time);
  m_is_event_loaded = true;
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::
loadProperty(const IXMPropertyIncrementDataList& properties,const IXMUidToLidMng& aid_to_lids, bool is_step_replayed, const bool check_property_existence)
{
  String event_status_info = String::concat(
      String::format(
      "Event occurring at time [{0},{1}] has non conform property. Property is not loaded",
      m_event_begin_time, m_event_end_time),
      " (incorrect time attribute, tag values occurrence or non real values for interpolation)");
  // Handle non conforming event in debug (fatal) or release (ignore property) mode
  if (_handleErrorStatus(!m_is_event_conform,event_status_info)) return;

  // Load Property
  if(m_is_property_loaded && (!is_step_replayed)) _unloadProperty();
  if (!is_step_replayed)
    {
      m_is_property_loaded = true;
      // Loop over different properties
      for (IXMPropertyIncrementDataList::const_iterator iProperty = properties.begin(); iProperty!= properties.end(); ++iProperty)
        {
          try
          {
            // Check property conformity
            String name = iProperty->name;
            if (! m_is_property_conform[name]) throw InconsistentPropertyDescriptionException(
                  name, String::concat(String::format(
                  "property has a non conform description in event [{0},{1}]",
                  m_event_begin_time, m_event_end_time),
                  " (incorrect time attribute, tag values occurrence or non real values for interpolation)"));
            // Create Property description and associated property values
#if (ARCANE_VERSION >= 30003)
            PropertyDescription* description = new PropertyDescription(*iProperty, m_evolutive_mesh, m_mesh, m_graph, check_property_existence);
#else
            PropertyDescription* description = new PropertyDescription(*iProperty, m_evolutive_mesh, m_mesh, check_property_existence);
#endif
            description->createPropertyValues(m_event_begin_time,m_event_end_time,
                iProperty->support_and_values.item_infos,
                iProperty->support_and_values.item_ids,aid_to_lids,m_mesh_directory_name);
            m_current_property_description.push_back(description);
            // Store property variable ref if property is created
            _storePropertyVariableRef(description->createdPropertyVariableRef());
          }
          catch (SkippedPropertyException& e) // authorized property skip
          {
            m_trace_mng->info() << e.print();
          }
          catch (InconsistentPropertyDescriptionException& e) // illegal property description, catch only in release mode
          {
#ifdef ARCANE_DEBUG
            throw;
#else
            m_trace_mng->info() << e.print();
#endif
          }
        }
    }
}
#endif
/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMPropertyBuilderImpl::
setProperty()
{
  bool is_property_set = false; // there is at least one property set
  String property_status_info = String::format(
      "Property is not loaded in Event occurring at time [{0},{1}]. Property set is ignored."
      ,m_event_begin_time, m_event_end_time);
  // Handle non conforming event in debug (fatal) or release (ignore property) mode
  if (_handleErrorStatus(!m_is_property_loaded,property_status_info)) return is_property_set;

  // Loop over property
  DescriptionContainer::iterator iPropertyDescription = m_current_property_description.begin();
  for (; iPropertyDescription != m_current_property_description.end(); ++iPropertyDescription)
    {
      // Get Property Description
      PropertyDescription& property_description = (*(*iPropertyDescription));
      // Get PropertyValues
      PropertyValues* property_values = property_description.settedPropertyValues();
      // Check if has setted property values
      if (property_values)
        {
          property_values->updateLocalValues(); // Take into account potential support_group change
          // Fill Property Variable
          property_values->fillPropertyVariable(PropertyValues::WithReadValues);
          // Register Property Variable name along with a variable containing the modified elements
          _addModifiedProperty(property_description);
          is_property_set = true;
        }
    }
  return is_property_set;
}

/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
bool
ArcGeoSim::IXMPropertyBuilderImpl::
computePropertyEvolution(const Real& end_timestep)
{
  bool is_property_computed = false;// there is at least one property computed
  String property_status_info = String::format(
      "Property is not loaded in Event occurring at time [{0},{1}]. Property is not computed."
      ,m_event_begin_time, m_event_end_time);
  // Handle non conforming event in debug (fatal) or release (ignore property) mode
  if (_handleErrorStatus(!m_is_property_loaded,property_status_info)) return is_property_computed;

  // Loop over property description
  DescriptionContainer::iterator iPropertyDescription = m_current_property_description.begin();
  for (; iPropertyDescription != m_current_property_description.end(); ++iPropertyDescription)
    {
      // Get Property Description
      PropertyDescription& property_description = (*(*iPropertyDescription));
      // Get PropertyValues
      PropertyValues* property_values = property_description.evolvingPropertyValues();
      // Check if has evolving property values
      if (property_values)
        {
          property_values->updateLocalValues(); // Take into account potential support_group changes
          // Check property initialization on target group
          if (!_isPropertyInitialized(property_description,property_values->support())) continue;
          // Save Property Variable as Initial Property
          property_description.saveInitialPropertyVariable();
          // Extract Property Variable initial values
          property_values->extractPropertyVariableInitialValues();
          // Compute interpolated values
          property_values->computeInterpolatedValues(end_timestep, m_event_begin_time,m_event_end_time);
          // Fill Property Variable
          property_values->fillPropertyVariable(PropertyValues::WithInterpolatedValues);
          // Register Property Variable name along with a variable containing the modified elements
          _addModifiedProperty(property_description);
          is_property_computed = true;
        }
      }
  return is_property_computed;
}
#endif
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::
_addModifiedProperty(const ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription& property_description)
{
  m_current_modified_properties.add(property_description);
  m_modified_property_history.add(property_description);
}

/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMPropertyBuilderImpl::
_isPropertyInitialized(const PropertyDescription& description, const Arcane::ItemGroup& support_group)
{
  ArcGeoSim::IXMPropertyBuilderImpl::ModifiedProperty modified_property = m_modified_property_history[description.name()];

  bool is_initialized = modified_property;
  try
  {
    if (!is_initialized) throw InconsistentPropertyDescriptionException(description.name()," is not initialized, thus interpolation is impossible.");

    if (!support_group.empty()) // Mesh variable case
      {
        Arcane::VariableItemByte filled_item_var = modified_property;
        ENUMERATE_ITEM(iItem,support_group)
        {
          if (!filled_item_var[iItem]) throw InconsistentPropertyDescriptionException(description.name(),
              String::format("is not initialized on item with unique id {0}, thus interpolation is impossible.",iItem->uniqueId()));
        }
      }
  }
  catch (InconsistentPropertyDescriptionException& e)
       {
   #ifdef ARCANE_DEBUG
         throw;
   #else
         m_trace_mng->info() << e.print();
         is_initialized = false;
   #endif
       }

  return is_initialized;
}

/*---------------------------------------------------------------------------*/

const ItemVariableScalarRefT<Byte>
ArcGeoSim::IXMPropertyBuilderImpl::
propertyFilledItemVariable(const String& property_name, bool& has_filled_items) const
{
  ArcGeoSim::IXMPropertyBuilderImpl::ModifiedProperty modified_property = m_modified_property_history[property_name];
  has_filled_items = modified_property;
  return modified_property;
}

/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMPropertyBuilderImpl::
hasPropertyChanged(const Arcane::String& property_name) const
{
  return m_current_modified_properties[property_name];
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::
printInfos() const
{
  for (DescriptionContainer::const_iterator ite = m_current_property_description.begin();
      ite != m_current_property_description.end() ; ++ite)
    {
      (*ite)->printInfos();
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::
createAndFillProperties(const IXMPropertyDataList& properties, const IXMUidToLidMng& aid_to_lids)
{
  for (IXMPropertyDataList::const_iterator iProperty = properties.begin(); iProperty != properties.end(); ++iProperty)
    {
      try
      {
          // Create Property description and associated property values
#if (ARCANE_VERSION >= 30003)
          PropertyDescription description(*iProperty,m_mesh,m_graph);
#else
          PropertyDescription description(*iProperty,m_mesh);
#endif
          description.createPropertyValues(iProperty->support_and_values.item_infos,iProperty->support_and_values.item_ids,aid_to_lids, m_mesh_directory_name);
          // Store property variable ref if property is created
          _storePropertyVariableRef(description.createdPropertyVariableRef());
          // Get PropertyValues
          PropertyValues* property_values = description.settedPropertyValues();
          // Check if has setted property values
          if (property_values)
            {
              property_values->updateLocalValues(); // Take into account potential support_group change
              // Fill Property Variable
              property_values->fillPropertyVariable(PropertyValues::WithReadValues);
            }
      }
      catch (SkippedPropertyException& e) // authorized property skip
      {
          m_trace_mng->info() << e.print();
      }
      catch (InconsistentPropertyDescriptionException& e) // illegal property description, catch only in release mode
      {
#ifdef ARCANE_DEBUG
          throw;
#else
          m_trace_mng->info() << e.print();
#endif
      }
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMPropertyBuilderImpl::
_unloadEvent()
{
  m_is_event_loaded = false;
  m_is_event_conform = false;
  m_current_modified_properties.clear(); // store only properties modified within the current event
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::
_unloadProperty()
{
  if (!m_is_property_loaded) m_trace_mng->info() << String::format(
      "Property is not loaded in Event occurring at time [{0},{1}]. Unload Property is ignored.",
      m_event_begin_time, m_event_end_time);
  else
    {
      // Delete PropertyValues
      for (DescriptionContainer::iterator iDescription = m_current_property_description.begin();
           iDescription != m_current_property_description.end(); ++iDescription)
        {
          delete (*iDescription);
        }
      // Clear PropertyDescription
      m_current_property_description.clear();
      // Inform unload
      m_is_property_loaded = false;
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::
_checkDateEventConformity(const IXMPropertyIncrementDataList& properties, const Real& event_time)
{
  // Date Event conformity :
  // x- at most one values tag (may not have)
  // x- if the values tag exist its time attribute must be equal to event_time

  m_is_event_conform = true;

  // Check time attribute values
  Integer nb_false_property = 0;
  for (IXMPropertyIncrementDataList::const_iterator iProperty = properties.begin(); iProperty != properties.end(); ++iProperty)
    {
      String name = iProperty->name;
      m_is_property_conform[name] = true;
      Integer values_tag_number = iProperty->support_and_values.item_infos.size();
      if ( values_tag_number > 1)
        {
          m_is_property_conform[name] = false;
          ++nb_false_property;
        }
      else if (values_tag_number == 1)
        {
          if (iProperty->support_and_values.item_infos.front().time != event_time)
            {
              m_is_property_conform[name] = false;
              ++nb_false_property;
            }
        }
    }
  // Save current event times
  m_event_begin_time = event_time;
  m_event_end_time = event_time;
  // Event is not conformed if all the properties are not conformed
  Arcane::Integer property_size = properties.size();
  if ( property_size > 0 && (nb_false_property == property_size)) m_is_event_conform = false;
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::
_checkPeriodEventConformity(const IXMPropertyIncrementDataList& properties, const Real& event_begin_time,const Real& event_end_time)
{
  // Period Event Conformity :
  // x- at most 2 values tags (0 and 1 are OK)
  // x- time attribute values must belong to {event_begin_time,event_end_time}
  // x- the two tags with the same time value is forbidden :
  // i.e one must have (first_time == begin_time and second_time == end_time) or (first_time = end_time and second_time = begin)
  // x- non Real based values (Real or Real3) for interpolation

  m_is_event_conform = true;

  // Check time attribute values
  Integer nb_false_property = 0;
  for (IXMPropertyIncrementDataList::const_iterator iProperty = properties.begin(); iProperty != properties.end(); ++iProperty)
    {
      m_is_property_conform[iProperty->name] = true;
      Integer values_tag_number = iProperty->support_and_values.item_infos.size();
      if (values_tag_number > 2)
        {
          m_is_property_conform[iProperty->name] = false;
          ++nb_false_property;
        }
      else if (values_tag_number == 1)
        {
          Real time = iProperty->support_and_values.item_infos.front().time;
          if (time != event_begin_time && time != event_end_time)
            {
              m_is_property_conform[iProperty->name] = false ;
              ++nb_false_property;
            }
          else if (time == event_end_time &&
                   (ArcGeoSim::DataTypeConversion::basicDataType(ArcGeoSim::IXMTools::dataTypeFromIXMName(iProperty->data_type)) != DT_Real) ) // Non real based values for interpolation
            {
              m_is_property_conform[iProperty->name] = false ;
              ++nb_false_property;
            }
        }
      else if (values_tag_number == 2)
        {
          Real first_time = iProperty->support_and_values.item_infos.front().time;
          Real second_time = iProperty->support_and_values.item_infos.back().time;
          if ( (first_time != event_begin_time || second_time != event_end_time) &&
               (first_time != event_end_time || second_time != event_begin_time))
            {
              m_is_property_conform[iProperty->name] = false;
              ++nb_false_property;
            }
          else if (ArcGeoSim::DataTypeConversion::basicDataType(ArcGeoSim::IXMTools::dataTypeFromIXMName(iProperty->data_type)) != DT_Real) // Non real based values for interpolation
            {
              m_is_property_conform[iProperty->name] = false;
              ++nb_false_property;
            }
        }
    }

  // Save current event times
  m_event_begin_time = event_begin_time;
  m_event_end_time = event_end_time;
  // Event is not conformed if all the properties are not conformed
  Arcane::Integer property_size = properties.size();
  if ( property_size > 0 && (nb_false_property == property_size)) m_is_event_conform = false;
}
#endif
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::
_storePropertyVariableRef(Arcane::VariableRef* const created_property_variable_ref)
{
  if (created_property_variable_ref)
    m_mesh->userDataList()->setData(created_property_variable_ref->variable()->fullName(),
        new Arcane::AutoDestroyUserData<Arcane::VariableRef>(created_property_variable_ref));
}

/*---------------------------------------------------------------------------*/
#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMPropertyBuilderImpl::
updateFilledItemVariables()
{
  // Update with new items variable indicating modified values in properties
  Arcane::IVariableMng* var_mng = m_mesh->subDomain()->variableMng();
  for (ModifiedProperties::iterator ite = m_modified_property_history.begin() ; ite != m_modified_property_history.end(); ++ite) {
      Arcane::IVariable* var = *ite;
      // update only if var still exists and if var non null (only for mesh variables)
      if (var_mng->findMeshVariable(m_mesh,ite->name()) && var) _updateFilledItemVariable(var);
  }
}

/*---------------------------------------------------------------------------*/
void
ArcGeoSim::IXMPropertyBuilderImpl::
_updateFilledItemVariable(Arcane::IVariable* filled_item_ivariable)
{
  ARCANE_ASSERT((filled_item_ivariable),("Cannot update empty filled item variable"))
  if (filled_item_ivariable->itemKind() == Arcane::IK_Unknown) return; // Global variable case
  // Update variables indicating property evolution (FilledItemVariables) with new created items
  // Set the variables to false on these new items
  ItemGroup new_items;
  // Get new items potentially added in IEvolutiveMesh transformations
  switch (filled_item_ivariable->itemKind()) {
  case IK_Cell:
    new_items = m_evolutive_mesh->newCells();
    break;
  case IK_Face:
    new_items = m_evolutive_mesh->newFaces();
    break;
  case IK_Node:
    new_items = m_evolutive_mesh->newNodes();
    break;
  default:
    m_trace_mng->fatal() << "Unsupported item kind for evolutive mesh properties.";
    break;
  }
  Arcane::VariableItemByte filled_item_variable (filled_item_ivariable);
  // Put to false new items if needed
  if (!new_items.null())
    {
      filled_item_variable.fill(false,new_items);
      m_trace_mng->debug() << "IXMPropertyBuilder:: " << filled_item_variable.name() << " updated with new items ";
    }
}
#endif
/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMPropertyBuilderImpl::
_handleErrorStatus(bool has_error, const String& message)
{
  bool do_exit_method = false;
#ifdef ARCANE_DEBUG
  if (has_error) m_trace_mng->fatal() << message;
#else
  if (has_error)
    {
      m_trace_mng->info() << message;
      do_exit_method = true;
    }
#endif
  return do_exit_method;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/* ModifiedProperty Class. Tool to manage modified property */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMPropertyBuilderImpl::ModifiedProperty::
ModifiedProperty(const Arcane::String& property_name, Arcane::IVariableMng* variable_mng)
  : m_is_empty(true)
  , m_filled_item_variable(NULL)
  , m_property_name(property_name)
  , m_variable_mng(variable_mng)
{}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMPropertyBuilderImpl::ModifiedProperty::
ModifiedProperty(const Arcane::String& property_name)
  : m_is_empty(true)
  , m_filled_item_variable(NULL)
  , m_property_name(property_name)
  , m_variable_mng(NULL)
{}


/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMPropertyBuilderImpl::ModifiedProperty::
ModifiedProperty(const ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription& property_description)
  : m_is_empty(false)
  , m_filled_item_variable(property_description.filledItemVariable())
  , m_property_name(property_description.name())
  , m_variable_mng(NULL)
{}

/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMPropertyBuilderImpl::ModifiedProperty::
operator== (const ModifiedProperty& modified_property)
{
  return (m_property_name == modified_property.m_property_name);
}

/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMPropertyBuilderImpl::ModifiedProperty::
operator< (const ModifiedProperty& modified_property) const
{
  return (m_property_name < modified_property.m_property_name);
}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMPropertyBuilderImpl::ModifiedProperty::
operator Arcane::VariableItemByte()
{
  // Property not modified
  if (m_is_empty)
    {
      // Construct the ItemVariableScalarRefT<Byte> with all elements to false
      // Get property IVariable (used to have item kind)
      ARCANE_ASSERT((m_variable_mng),(String::format("Cannot determine if Property {0} does exist. Cannot give filled item information.",m_property_name).localstr()));
      IVariable* property_variable = m_variable_mng->findMeshVariable(m_variable_mng->subDomain()->defaultMesh(),m_property_name);
      ARCANE_ASSERT((property_variable),(String::format("Property {0} does not exist",m_property_name).localstr()));
      property_variable->subDomain()->traceMng()->info()<< String::format("Property {0} has not been modified.",m_property_name);
      ARCANE_ASSERT((property_variable->itemKind() != Arcane::IK_Unknown),(String::format("Property {0} is not defined on mesh. Cannot give filled item indicator variable",
                                                                                          m_property_name).localstr()));
      // Create item variable
      String variable_name = PropertyDescription::modifiedItemsVariableName(m_property_name);
      Arcane::VariableItemByte filled_item_variable(VariableBuildInfo(m_variable_mng->subDomain()->defaultMesh(),variable_name,IVariable::PPersistant),property_variable->itemKind());
      filled_item_variable.fill(false);
      return filled_item_variable;
    }
  else
    {
      ARCANE_ASSERT((m_filled_item_variable),(Arcane::String::format("IVariable indicating property {0} changes is NULL.",
                                                                     m_property_name).localstr()));
      ARCANE_ASSERT((m_filled_item_variable->itemKind() != Arcane::IK_Unknown),(String::format("Property {0} is not defined on mesh. Cannot give a modified item indicator variable",
                                                                                               m_property_name).localstr()));
      Arcane::VariableItemByte variable(m_filled_item_variable);
      return variable;
    }
}

/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* ModifiedProperties Class. ModifiedProperty container */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMPropertyBuilderImpl::ModifiedProperty
ArcGeoSim::IXMPropertyBuilderImpl::ModifiedProperties::
operator[](const Arcane::String& property_name) const
{
  auto ite = m_properties.find(property_name);
  if (ite == m_properties.end()) return ArcGeoSim::IXMPropertyBuilderImpl::ModifiedProperty(property_name,m_variable_mng);
  else return *ite;
}


/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/* PropertyDescription Class */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
#if (ARCANE_VERSION >= 30003)
PropertyDescription(Arcane::IMesh* const mesh, Arcane::IGraph2* const graph)
#else
PropertyDescription(Arcane::IMesh* const mesh)
#endif
 noexcept(false)
    : BaseProperty(mesh)
    , m_trace_mng(mesh->subDomain()->traceMng())
    , m_dimension(1)
    , m_array_size(1)
{
#if (ARCANE_VERSION >= 30003)
  setGraph(graph) ;
#endif
}

#ifdef USE_EVOLUTIF
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
PropertyDescription(const IXMPropertyIncrementData& property,
                    IEvolutiveMesh* const evolutive_mesh,
                    IMesh* const mesh,
#if (ARCANE_VERSION >= 30003)
                    IGraph2* graph,
#endif
                    const bool check_property_existence)
noexcept(false)
    : BaseProperty(mesh)
    , m_name(property.name)
    , m_type(property.data_type)
    , m_group_name(property.group_name)
    , m_kind(property.kind)
    , m_property_variable(NULL)
    , m_initial_property_variable(NULL)
    , m_setted_property_values(NULL)
    , m_evolving_property_values(NULL)
    , m_filled_item_variable(NULL)
    , m_evolutive_mesh(evolutive_mesh)
    , m_trace_mng(mesh->subDomain()->traceMng())
    , m_is_initial_property_saved(false)
    , m_dimension(1)
    , m_array_size(1)
    , m_created_property_variable_ref(NULL)
    , m_is_global(property.kind == "global")
{
#if (ARCANE_VERSION >= 30003)
  setGraph(graph) ;
#endif
  // Handle array property
  _setPropertyDimension(property.data_array_size);

  if (_isPropertyEmpty(property.support_and_values.item_infos,property.support_and_values.item_ids)) throw SkippedPropertyException(m_name,"Empty property");

  _loadPropertyVariable(check_property_existence);
  _checkPropertyDescription();
}
#endif
/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
#if (ARCANE_VERSION >= 30003)
PropertyDescription(const IXMPropertyData& property, Arcane::IMesh* const mesh, Arcane::IGraph2* const graph)
#else
PropertyDescription(const IXMPropertyData& property, Arcane::IMesh* const mesh)
#endif
 noexcept(false)
    : BaseProperty(mesh)
    , m_name(property.name)
    , m_type(property.data_type)
    , m_group_name(property.group_name)
    , m_kind(property.kind)
    , m_trace_mng(mesh->subDomain()->traceMng())
    , m_dimension(1)
    , m_array_size(1)
    , m_is_global(property.support_and_values.item_ids.empty())
{
#if (ARCANE_VERSION >= 30003)
  setGraph(graph) ;
#endif

  // Handle array property
  _setPropertyDimension(property.data_array_size);

  if (_isPropertyEmpty(property.support_and_values.item_infos,property.support_and_values.item_ids)) throw SkippedPropertyException(m_name,"Empty property");

  bool check_property_existence = false;
  _loadPropertyVariable(check_property_existence);

  _checkPropertyDescription();
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
_setPropertyDimension(const Arcane::Integer& property_data_array_size)
{
  // Handle array property
  if (m_group_name.empty() )
    {
      if (property_data_array_size > 0) m_array_size = property_data_array_size;
      else m_dimension = 0;
    }
  // Handle mesh array property
  else
    {
      if (property_data_array_size > 1)
        {
          m_dimension = 2;
          m_array_size = property_data_array_size;
        }
    }
}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
~PropertyDescription()
{
  _deleteInitialPropertyVariable();
  _deletePropertyValues();
}
/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
createPropertyValues(const Real& event_begin_time,const Real& event_end_time,
                     const IXMPropertyIncrementValuesDataList& values_list,
                     const Int64Array& support,
                     const IXMUidToLidMng& aid_to_lids,
                     const Arcane::String& mesh_directory_name) noexcept(false)
{
  // Get values node at begin and end event time and create corresponding PropertyValues
  IXMPropertyIncrementValuesData set_property_data = _findValuesData(values_list,event_begin_time);
  IXMPropertyIncrementValuesData evolving_property_data;
  if (event_begin_time != event_end_time) evolving_property_data = _findValuesData(values_list,event_end_time);

  // Empty property already treated => if values is empty = error
  if (set_property_data.data_string.empty() && evolving_property_data.data_string.empty()) throw InconsistentPropertyDescriptionException(m_name, "no values tag");


  if (!set_property_data.data_string.empty()) m_setted_property_values = new PropertyValues(set_property_data,support,
                                                                                              aid_to_lids,this,
                                                                                              m_property_variable,
                                                                                              "setted",
                                                                                              m_evolutive_mesh,
                                                                                              this->m_mesh,
  #if (ARCANE_VERSION >= 30003)
                                                                                              this->m_graph,
  #endif
                                                                                              mesh_directory_name);
    if (!evolving_property_data.data_string.empty()) m_evolving_property_values = new PropertyValues(evolving_property_data,support,
                                                                                                     aid_to_lids,this,m_property_variable,
                                                                                                     "evolving",
                                                                                                     m_evolutive_mesh,
                                                                                                     this->m_mesh,
  #if (ARCANE_VERSION >= 30003)
                                                                                                     this->m_graph,
  #endif
                                                                                                     mesh_directory_name);
}
#endif
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
createPropertyValues(const IXMPropertyValuesData& values,
                     const Int64Array& support,
                     const IXMUidToLidMng& aid_to_lids,
                     const Arcane::String& mesh_directory_name) noexcept(false)
{
  // Empty property already treated => if values is empty = error
  if (values.data_string.empty()) throw InconsistentPropertyDescriptionException(m_name,"no values tag");

  m_setted_property_values = new PropertyValues(values,
                                                support,
                                                aid_to_lids,
                                                this,
                                                m_property_variable,
                                                "setted",
                                                this->m_mesh,
#if (ARCANE_VERSION >= 30003)
                                                this->m_graph,
#endif
                                                mesh_directory_name);
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
_deletePropertyValues()
{
  if (m_setted_property_values) delete m_setted_property_values;
  if (m_evolving_property_values) delete m_evolving_property_values;
  m_setted_property_values = NULL;
  m_evolving_property_values = NULL;
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
saveInitialPropertyVariable()
{
  if (!m_is_initial_property_saved)
    {
      // Copy Property variable in a new arcane variable to store its initial state
      String name = String::concat(m_name, "_initial");
      m_initial_property_variable = ArcGeoSim::VariableUtils::cloneVariable(m_property_variable,name);
      m_evolving_property_values->saveInitialProperty(m_initial_property_variable);
      m_is_initial_property_saved = true;
     }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
_deleteInitialPropertyVariable()
{
  // Using Variable Utils
  if (m_initial_property_variable)
    {
      ArcGeoSim::VariableUtils::deleteUnreferencedVariable(m_initial_property_variable,m_trace_mng);
      m_initial_property_variable = NULL;
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
printInfos() const
{
  m_trace_mng->debug() << "===AFFICHAGE PROPRIETE====";
  m_trace_mng->debug() << String::format("Property {0} of kind {1} of type {2} on group {3} ",
                                         m_name, m_kind, m_type, m_group_name);
  if (m_setted_property_values) m_setted_property_values->printInfos();
  if (m_evolving_property_values) m_evolving_property_values->printInfos();
  m_trace_mng->debug() << "===FIN AFFICHAGE PROPRIETE====";
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
_loadPropertyVariable(const bool check_property_existence) noexcept(false)
{
  m_trace_mng->info()<<"PropertyDescription:: GROUP NAME"<<m_group_name;
  // If no support load globalVariable (not on mesh) else load MeshVariable
  if (m_group_name.empty()) _loadGlobalVariable(check_property_existence);
  else _loadMeshVariable(check_property_existence);
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
_loadMeshVariable(const bool check_property_existence) noexcept(false)
{
  // Get property IVariable
  IVariable* variable = this->m_mesh->subDomain()->variableMng()->findMeshVariable(this->m_mesh, m_name);

  // Store item group
  m_group = this->m_mesh->findGroup(m_group_name);
  m_trace_mng->info()<<"PropertyDescription:: GROUP SIZE("<<m_group_name<<")="<<m_group.size();
  if (m_group.null()) throw InconsistentPropertyDescriptionException(m_name,Arcane::String::format("property group {0} does not exist",m_group_name));
  m_trace_mng->debug() << Arcane::String::format("Property {0} group name : {1}", m_name, m_group_name);

  // Check property existence
  if (!variable)
    if (check_property_existence) throw SkippedPropertyException(m_name, "property variable does not exist.");
    else // Create variable
      {
        // Properties are created on ItemGroup (may be partial)
        Arcane::eItemKind item_kind = itemKind();
        // is Partial ?
        bool is_partial = (!m_group.isAllItems());

#if (ARCANE_VERSION >= 30003)
        if(item_kind==ItemConnectionImpl::ik_type)
        {
            m_created_property_variable_ref = ArcGeoSim::VariableUtils::createMeshVariableRef(m_name,
                                                                                              ArcGeoSim::IXMTools::dataTypeFromIXMName(m_type),
                                                                                              IK_DoF,m_dimension,is_partial,m_group);
        }
        else
        {
            m_created_property_variable_ref = ArcGeoSim::VariableUtils::createMeshVariableRef(m_name,
                                                                                              ArcGeoSim::IXMTools::dataTypeFromIXMName(m_type),
                                                                                              item_kind,m_dimension,is_partial,m_group);
        }
#else
        m_created_property_variable_ref = ArcGeoSim::VariableUtils::createMeshVariableRef(m_name,
                                                                                          ArcGeoSim::IXMTools::dataTypeFromIXMName(m_type),
                                                                                          item_kind,m_dimension,is_partial,m_group);
#endif
        // Handle array property
        if (m_dimension == 2) ArcGeoSim::VariableUtils::resizeMeshVariableArray(m_created_property_variable_ref->variable(),m_array_size);

        // Property manager keeps a reference on the variable during its whole life to ensure variable is not destroyed
        m_property_variable = m_created_property_variable_ref->variable();
      }
  else
    {
      // Check variable group if existing variable is partial
      if (variable->isPartial())
        {
          if (variable->itemGroup() != m_group) throw InconsistentPropertyDescriptionException(m_name,
              Arcane::String::format("property variable exist but is defined on {0} while ixm mesh file defines it on {1}",
                                     variable->itemGroup().name(),m_group_name));
        }
      // Store the property IVariable
      variable->setUsed(true); // to handle property declared in axl and not yet allocated
      // Handle array property if not sized (possible if the property was only declared in axl
      if (m_dimension ==  2) ArcGeoSim::VariableUtils::resizeMeshVariableArray(variable,m_array_size);
      m_property_variable = variable;
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
_loadGlobalVariable(const bool check_property_existence) noexcept(false)
{
  // Get property IVariable
  IVariable* variable = this->m_mesh->subDomain()->variableMng()->findVariable(m_name);
  // If not found check it does not exist under the name default_mesh_name_variable_name
  // Come from problem in axl declared global variable, see ARC220
  if (!variable) variable = this->m_mesh->subDomain()->variableMng()->findMeshVariable(this->m_mesh,m_name);

  // Check property existence
  if (!variable)
    if (check_property_existence) throw SkippedPropertyException(m_name, "property variable does not exist.");
    else // Create variable
      {
        m_created_property_variable_ref = ArcGeoSim::VariableUtils::createVariableRef(m_name,ArcGeoSim::IXMTools::dataTypeFromIXMName(m_type),
                                                                                      m_dimension,this->m_mesh->subDomain());
        // Handle array property
        if (m_dimension == 1) ArcGeoSim::VariableUtils::resizeVariableArray(m_created_property_variable_ref->variable(),m_array_size);

        // Property manager keeps a reference on the variable during its whole life to ensure variable is not destroyed
        m_property_variable = m_created_property_variable_ref->variable();
      }
  else
    {
      // Store the property IVariable
      variable->setUsed(true);// to handle property declared in axl and not yet allocated
      // Handle array property if not sized (possible if the property was only declared in axl
      if (m_dimension ==  1) ArcGeoSim::VariableUtils::resizeVariableArray(variable,m_array_size);
      m_property_variable = variable;
    }
}


/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
_checkPropertyDescription() const noexcept(false)
{
  // Handle Integer string case
  String type = m_type;

  // Check data type
  if (type.empty()) throw InconsistentPropertyDescriptionException(m_name,"property has no data type");
  // Check data type, item kind, skip property if not ok
  if (ArcGeoSim::IXMTools::dataTypeFromIXMName(type) != m_property_variable->dataType()) throw InconsistentPropertyDescriptionException(
      m_name,
      String::format("property is declared in mesh to be a {0} variable while it is a {1} variable",
                      type, ArcGeoSim::IXMTools::dataTypeIXMName(m_property_variable->dataType())));

  if (m_kind != ArcGeoSim::IXMTools::itemKindIXMName(m_property_variable->itemKind())) throw InconsistentPropertyDescriptionException(
      m_name,
      String::format("property is declared in mesh to be a {0} variable while it is a {1} variable.",
                      m_kind, ArcGeoSim::IXMTools::itemKindIXMName(m_property_variable->itemKind())) );

  // Check array size
  if (m_dimension == 2) // mesh array variable
    {
      Arcane::Integer item_number, array_size;
      ArcGeoSim::VariableUtils::meshVariableArraySize(m_property_variable->data(),item_number,array_size);
      if (array_size != m_array_size) throw InconsistentPropertyDescriptionException(
          m_name,
          String::format("property is an existing mesh array variable of size {0} but is declared as a mesh array variable of size {1}",
                         array_size, m_array_size));
    }
  else if (m_dimension == 1 && m_property_variable->itemKind() == Arcane::IK_Unknown) // array variable (not on mesh)
    {
      if (m_array_size != m_property_variable->nbElement())
        throw InconsistentPropertyDescriptionException(m_name, String::format(" global property size is {0} while we expected {1}",
                                                                              m_property_variable->nbElement(),
                                                                              m_array_size));
    }
  else if ( (m_dimension == 1 && m_property_variable->itemKind() != Arcane::IK_Unknown) && m_array_size>1 ) // mesh scalar variable
    {
      throw InconsistentPropertyDescriptionException(m_name, String::format(" property is scalar on mesh and array size is not equal to 1 but to {0}",
                                                                            m_array_size));
    }
  else if (m_dimension == 0 && m_array_size > 1) // scalar variable (not on mesh)
    {
      throw InconsistentPropertyDescriptionException(m_name, String::format(" property is a scalar array size is not equal to 1 but to {0}",
                                                                            m_array_size));

    }

}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
saveModifiedItems(const ItemGroup& modified_items)
{
  if (modified_items.null()) return;

  String variable_name = modifiedItemsVariableName(m_name);

  // Create (if needed) and fill ItemVariable<Byte> to indicate modified items

  // Check if modified item variable already created
  IVariable* filled_item_variable = this->m_mesh->subDomain()->variableMng()->findMeshVariable(this->m_mesh,variable_name);

  // Potential new items group
  ItemGroup new_items;

  // Create if does not exist
  if (!filled_item_variable)
    {
       Arcane::IItemFamily * item_family = this->itemFamily(itemKind()) ;
      // Create Mesh Variable builder
      VariableBuildInfo builder(this->m_mesh,variable_name,item_family->name(),IVariable::PPersistant);
      ItemVariableScalarRefT<Byte> filled_item_variable(builder,item_family->itemKind());
      filled_item_variable.fill(false);
      m_filled_item_variable = filled_item_variable.variable();
    }
  else
    {
      m_filled_item_variable = filled_item_variable;
      // Get new items potentially added in IEvolutiveMesh transformations
#ifdef USE_EVOLUTIF
      if (m_evolutive_mesh) {
        switch (itemKind()) {
          case IK_Cell:
            new_items = m_evolutive_mesh->newCells();
            break;
          case IK_Face:
            new_items = m_evolutive_mesh->newFaces();
            break;
          case IK_Node:
            new_items = m_evolutive_mesh->newNodes();
            break;
          default:
            m_trace_mng->fatal() << "Unsupported item kind for evolutive mesh properties.";
            break;
        }
      }
#endif
    }

#ifdef USE_EVOLUTIF
  // Update filled item variable
  ItemVariableScalarRefT<Byte> modified_item_variable (m_filled_item_variable);
  // Put to false new items if needed. This is not redundant with what is done in updateFilledItemVariable() in a case
  // where the filled item variable exist and is not registered in IXMPropertyBuilder::m_property_filled
  // (i.e. created by the user before the corresponding property is modified).
  if (!new_items.null()) modified_item_variable.fill(false,new_items);

  // Put to true modified items
  modified_item_variable.fill(true,modified_items);
#endif
}

/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
const IXMPropertyIncrementValuesData
ArcGeoSim::IXMPropertyBuilderImpl::PropertyDescription::
_findValuesData(const IXMPropertyIncrementValuesDataList& values_list, const Real& values_time) const
{
  Integer values_tag_number = values_list.size();
  if (values_tag_number >= 1 && values_list.front().time == values_time)
    return values_list.front();
  if (values_tag_number == 2 && values_list.back().time == values_time)
    return values_list.back();
  // No values tag
  return IXMPropertyIncrementValuesData();
}
#endif
/*---------------------------------------------------------------------------*/



/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/* PropertyValues Class */
/*---------------------------------------------------------------------------*/
// Constructor for static case
ArcGeoSim::IXMPropertyBuilderImpl::PropertyValues::
PropertyValues(PropertyDescription* const parent_description,
               IVariable* const property,
               IMesh* const mesh,
#if (ARCANE_VERSION >= 30003)
               Arcane::IGraph2* const graph,
#endif
               const Arcane::String& mesh_directory_name)
: BaseProperty(mesh)
, m_property(property)
, m_initial_property(nullptr)
, m_parent_property_description(parent_description)
, m_trace_mng(mesh->traceMng())
, m_mesh_directory_name(mesh_directory_name)
{
#if (ARCANE_VERSION >= 30003)
  setGraph(graph) ;
#endif
}

/*---------------------------------------------------------------------------*/
#ifdef USE_EVOLUTIF
// Constructor for evolutive case
ArcGeoSim::IXMPropertyBuilderImpl::PropertyValues::
PropertyValues(const IXMPropertyIncrementValuesData& property_values, const Int64Array& support_uids,
               const IXMUidToLidMng& aid_to_lids,PropertyDescription* const parent_description,
               IVariable* const property, const String& values_status, IEvolutiveMesh* const evolutive_mesh,
               IMesh* const mesh,
#if (ARCANE_VERSION >= 30003)
               Arcane::IGraph2* const graph,
#endif
               const Arcane::String& mesh_directory_name)
: BaseProperty(mesh)
, m_values_status(values_status)
, m_time(property_values.time)
, m_property(property)
, m_initial_property(NULL)
, m_parent_property_description(parent_description)
, m_evolutive_mesh(evolutive_mesh)
, m_trace_mng(mesh->traceMng())
, m_item_values_indexes(NULL)
, m_mesh_directory_name(mesh_directory_name)
{
#if (ARCANE_VERSION >= 30003)
  setGraph(graph) ;
#endif
  _buildPropertyValues(property_values,support_uids,aid_to_lids);
}
#endif
/*---------------------------------------------------------------------------*/

// Constructor for static case
ArcGeoSim::IXMPropertyBuilderImpl::PropertyValues::
PropertyValues(const IXMPropertyValuesData& property_values,
               const Int64Array& support_uids,
               const IXMUidToLidMng& aid_to_lids,
               PropertyDescription* const parent_description,
               IVariable* const property,
               const String & values_status,
               IMesh* const mesh,
#if (ARCANE_VERSION >= 30003)
               Arcane::IGraph2* const graph,
#endif
               const Arcane::String& mesh_directory_name)
: BaseProperty(mesh)
, m_values_status(values_status)
, m_property(property)
, m_initial_property(nullptr)
, m_parent_property_description(parent_description)
, m_trace_mng(mesh->traceMng())
, m_mesh_directory_name(mesh_directory_name)
{
#if (ARCANE_VERSION >= 30003)
  setGraph(graph) ;
#endif
  _buildPropertyValues(property_values,support_uids,aid_to_lids);
}

/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyValues::
fillPropertyVariable(const PropertyValues::eFillPropertyChoice& fill_property_choice)
{
  switch (fill_property_choice) {
    case PropertyValues::WithReadValues:
      m_property[m_support_group] = m_local_values;
      break;
    case PropertyValues::WithInterpolatedValues:
      m_property[m_support_group] = m_interpolated_values;
      break;
  }
  // Save modified items
  m_parent_property_description->saveModifiedItems(m_support_group);
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyValues::
extractPropertyVariableInitialValues()
{
  m_initial_values = m_initial_property[m_support_group];
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyValues::
computeInterpolatedValues(const Real& end_timestep,const Real& event_begin_time,const Real& event_end_time)
{
  m_interpolated_values = m_values_mng->interpolateData(end_timestep,
                            ArcGeoSim::ArrayMng::DataInterpolationPoint(m_initial_values,event_begin_time),
                            ArcGeoSim::ArrayMng::DataInterpolationPoint(m_local_values,event_end_time));
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyValues::
updateLocalValues()
{
  if (m_parent_property_description->isGlobal()) // Global variable case
    {
      m_local_values = m_values;
      return;
    }
  // Get indexes within the values array of support items
  // (some items may have left or join the current process)
  Integer array_size = m_parent_property_description->arraySize();
  Integer total_nb_elements = m_support_group.size()*array_size;
  IntegerSharedArray local_values_indexes(total_nb_elements);
  Integer index = 0;
  ENUMERATE_ITEM(iitem,m_support_group)
    {
      for (Integer i = 0; i < array_size ; ++i)
        {
          local_values_indexes[index*array_size+i] = (*m_item_values_indexes)[iitem][i];
        }
      ++index;
    }
  m_local_values = m_values[local_values_indexes];
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyValues::
printInfos() const
{
  // Values
  m_trace_mng->debug() << "AFFICHAGE DES VALEURS";
  m_trace_mng->debug() << m_values;
  if (m_parent_property_description->isGlobal()) return; // Global variable case
  // Support
  SharedArray<Int64> support_uids;
  ENUMERATE_ITEM(iitem,m_support_group)
    {
      support_uids.add((*iitem).uniqueId().asInt64());
    }
  if (ArcGeoSim::IXMTools::hasAbstractIds(m_support_group.itemKind()))
    {
      // Convert uids to aids
      IXMItemUidToAidMapper uid2aid(this->m_mesh,this->m_mesh->subDomain()->parallelMng(),this->m_mesh->subDomain()->variableMng(),m_support_group.itemKind());
      Int64SharedArray support_aids;
      uid2aid.itemUniqueIdToAbstractId(support_aids,support_uids);
      if (support_aids.empty()) m_trace_mng->debug() << m_support_group.itemKind() << "AIDS NON CONNUS.";
      else support_uids = support_aids;
    }
  m_trace_mng->debug() << "AFFICHAGE DU SUPPORT";
  m_trace_mng->debug() << support_uids;

}

/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyValues::
_buildSupportGroup(const Int64ConstArrayView& support_uids,const IXMUidToLidMng& aid_to_lids)
{
  if (m_parent_property_description->isGlobal()) return; // Global variable case

  Arcane::eItemKind item_kind = m_parent_property_description->itemKind();

  // Get ItemFamily
  IItemFamily* item_family = this->itemFamily(m_parent_property_description->itemKind()) ;
  ItemGroup all_item_group = item_family->allItems();

  // Get local ids for items local to subDomain
  Int32SharedArray local_items_lids(support_uids.size()); // local ids of items to modify belonging to the current process
  Int64SharedArray local_items_uids; // unique ids of items to modify belonging to the current process

  // Get Local ids
  bool sequential_check = (this->m_mesh->parallelMng()->commSize() == 1);
  if (m_parent_property_description->itemKind() == IK_Particle){
	  item_family->itemsUniqueIdToLocalId(local_items_lids, support_uids,sequential_check);
  }
  else
	  aid_to_lids.itemsUniqueIdToLocalId(local_items_lids, support_uids,item_kind ,sequential_check);

  // Filter non present items (used only in parallel)
  Arcane::Integer i = 0;
  Arcane::Integer repos_index = 0;
  Arcane::IntegerSharedArray local_items_indexes;
  for (Int32SharedArray::iterator ite = local_items_lids.begin(); ite != local_items_lids.end(); ++ite, ++i)
    {
      if (*ite != NULL_ITEM_LOCAL_ID)
        {
          local_items_lids[repos_index++] = *ite;
          local_items_uids.add(support_uids[i]);
          local_items_indexes.add(i);
        }
    }
  local_items_lids.resize(repos_index);

  // Check items belong to variable group
  _checkItemsInVariableGroup(m_parent_property_description->group().view(),local_items_lids,local_items_uids);

  // Create support group. Unique for each values set of the property (to prepare evolution to one support per values tag)
  m_support_group = item_family->createGroup(_supportGroupName(),local_items_lids,true);
  // Create variable storing item indexes within values array
  m_item_values_indexes = new Arcane::PartialVariableItemArrayInt64(Arcane::VariableBuildInfo(this->m_mesh,_itemValuesIndexesVariableName(),
                                                                                              item_family->name(),
                                                                                              m_support_group.name()),
                                                                    m_support_group.itemKind());
  Arcane::Integer array_size = m_parent_property_description->arraySize();
  m_item_values_indexes->resize(array_size);
  i = 0;
  ENUMERATE_ITEM(iitem,m_support_group)
  {
    // Check group is enumerated in the order given at creation (warning check cannot be done on uid since uids in local_item_uids can be abstract ids).
    ARCANE_ASSERT((iitem->localId()==local_items_lids[i]),("Group not enumerated in the original order. Algorithm invalidated. Exiting"))
    for (Arcane::Integer j = 0 ; j < array_size; ++j) (*m_item_values_indexes)[iitem][j] = local_items_indexes[i]*array_size+j;
    ++i;
  }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMPropertyBuilderImpl::PropertyValues::
_checkItemsInVariableGroup(const Arcane::ItemVectorView& variable_group, const Arcane::Int32Array& item_lids, const Arcane::Int64Array& item_uids)
{
  Arcane::IntegerConstArrayView view = variable_group.localIds();
  std::set<Arcane::Integer> variable_group_set(view.begin(),view.end());
  Arcane::Integer i = 0;
  for (Arcane::Int32SharedArray::const_iterator ite = item_lids.begin(); ite != item_lids.end(); ++ite, ++i)
    {
      if (variable_group_set.find(*ite) == variable_group_set.end())
        throw InconsistentPropertyDescriptionException(m_parent_property_description->name(),
          Arcane::String::format("Error in property {0} support : item with unique id {1} does not belong to group {2}",
                                 m_parent_property_description->name(),item_uids[i],m_parent_property_description->group().name()));
    }
}

/*---------------------------------------------------------------------------*/



/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
