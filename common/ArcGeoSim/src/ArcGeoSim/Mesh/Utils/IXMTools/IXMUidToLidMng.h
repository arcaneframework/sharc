// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMUIDTOLIDMNG_H
#define ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMUIDTOLIDMNG_H
/* Author : dechaiss at Tue Mar 19 09:33:42 2013
 * Generated by createNew
 */

#include <arcane/IMesh.h>
#include <arcane/ISubDomain.h>
#include <arcane/utils/ITraceMng.h>

#include "ArcGeoSim/Utils/ArcGeoSim.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMTools.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMItemAidMapper.h"
#include "ArcGeoSim/Utils/ParallelUtils.h"

BEGIN_ARCGEOSIM_NAMESPACE


/*! Classe surchargeant IItemFamily::itemsUniqueIdToLocalIds() afin de traiter de fa�on identique des items d�crits dans
 *  le maillage ixm par des identifants uniques et des items d�crits par des identifiants abstraits (aids).
 *  La classe utilise la classe IXMAidToLidMapper pour les items d�crits par des aids et IITemFamily pour les items d�crits par leurs uids.
 *  Attention a la port�e de validit� de cette classe. Les correspondances pour les items d�crits par les aids sont charg�es par l'utilisateur :
 *  m�thodes loadFaceAidMapping() ou loadConnectionAidMapping() et ne sont valables que si les local_ids ne changent pas.
 *  Pour invalider l'objet lorque les local_ids sont susceptibles de changer utiliser endUsingAidMapping().
 */
class IXMUidToLidMng
{
public:
  
  /** Constructeur de la classe */
  IXMUidToLidMng(Arcane::IMesh* mesh, ArcGeoSim::ParallelUtils& parallel_utils, const bool use_memory, Arcane::ITraceMng* trace_mng);
  
  /** Destructeur de la classe */
  virtual ~IXMUidToLidMng()
  {
    if (m_face_aid_mapper) delete m_face_aid_mapper;
    if (m_edge_aid_mapper) delete m_edge_aid_mapper;
    if (m_connection_aid_mapper) delete m_connection_aid_mapper;
    if (m_particle_aid_mapper) delete m_particle_aid_mapper;
  }

#if (ARCANE_VERSION >= 30003)
  void setGraph(Arcane::IGraph2* graph);
#endif
  
public:
  Int64 getFaceAidMax() const {
    if(m_face_aid_mapper)
      return m_face_aid_mapper->getItemAidMax() ;
    else
      return -1 ;
  }

  Int64 getLinkAidMax() const {
    if(m_connection_aid_mapper)
      return m_connection_aid_mapper->getItemAidMax() ;
    else
      return -1 ;
  }

  Int64 getParticleAidMax() const {
    if(m_particle_aid_mapper)
      return m_particle_aid_mapper->getItemAidMax() ;
    else
      return -1 ;
  }

  /*! Charge la correspondance aid->lid pour les faces ou les connections.
   *  Permet d'utiliser la methode IXMUidToLidMng::itemsUniqueIdToLocalId().
   *  L'utilisateur doit s'assurer qu'il n'y a pas de changement d'identifiant locaux.
   *  Lorsque la correspondance cesse d'etre valable (changement d'identifiant locaux possibles),
   *  la detruire par un appel a endUsingAidMapping() */
  void loadFaceAidMapping(const ArcGeoSim::IXMTools::IXMFaceData& face_data, const bool do_check, const bool is_parallel=true); // build aid->lid mapping (with data from last load, or from all previous load if use_memory was set true)
  void loadEdgeAidMapping(const ArcGeoSim::IXMTools::IXMEdgeData& edge_data, const bool do_check, const bool is_parallel=true);
  void loadConnectionAidMapping(const ArcGeoSim::IXMTools::IXMConnectionData& connection_data, const bool do_check, const bool is_parallel=true);
  void endUsingAidMapping(); // clear aid->lid mapping

  /*! Obtention des identifiants locaux a partir des identifiants uniques ou abstraits (cas des items face et link).
   * \param item_lids etre dimentionne a la taille de item_uids
   * \param do_fatal une exception est levee lorqu'un item n'est pas trouve si ce parametre vaut true
   */
  void itemsUniqueIdToLocalId(Arcane::Int32ArrayView item_lids, Arcane::Int64ConstArrayView item_uids, const Arcane::eItemKind item_kind, const bool do_fatal=true) const;

  /*! Dans cet appel on ne conserve que les items locaux au sous-domaine. /param item_lids ne contiendra donc que des local_id valides.
   * /param local_item_uids contiendra les unique_id correspondant, et ce meme si au depart /param all_item_uids contenait des identifiants abstraits (face, connexions).
   *  \param do_fatal declenche un echec si l'item n'est pas trouve.
   */
  void localItemsUniqueIdToLocalId(Arcane::Int32SharedArray& local_item_lids,
                                   Arcane::Int64SharedArray& local_item_uids,
                                   Arcane::Int64ConstArrayView all_item_uids,
                                   const Arcane::eItemKind item_kind,
                                   const bool do_fatal=false) const;

private:
  Arcane::IMesh* m_mesh = nullptr;
#if (ARCANE_VERSION >= 30003)
  Arcane::IGraph2* m_graph = nullptr ;
#endif
  ArcGeoSim::IXMItemAidToUidMapper* m_face_aid_mapper = nullptr;
  ArcGeoSim::IXMItemAidToUidMapper* m_edge_aid_mapper = nullptr;
  ArcGeoSim::IXMItemAidToUidMapper* m_connection_aid_mapper = nullptr;
  ArcGeoSim::IXMItemAidToUidMapper* m_particle_aid_mapper = nullptr;
  bool m_use_memory;

  void _lidToUid(Arcane::Int64Array& uids,Arcane::Int32ConstArrayView lids,const Arcane::eItemKind& item_kind) const;
  Arcane::VariableArrayInt64 * _ItemAidMemoryVariable(const bool use_memory, const Arcane::eItemKind item_kind) const;

  void localEdgeIdsFromConnectivity(Arcane::IntegerConstArrayView items_nb_node,
		  	  	  	  	  	  	  	Arcane::Int64ConstArrayView items_connectivity,
		  	  	  	  	  	  	  	Arcane::Int32ArrayView local_ids,
		  	  	  	  	  	  	  	bool allow_null);

};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*! Classe permettant d'obtenir les identifiants uniques ou abstraits (s'ils existent) a partir des items
 *  de leurs identifiants locaux.
 */

class IXMLidToUidMng
{
public:

  IXMLidToUidMng(Arcane::IMesh* mesh);

  virtual ~IXMLidToUidMng(){}

public:

  /*! Obtention des identifiants uniques ou abstraits d'un vecteur d'items.
   *  Si les items concernes disposent d'une identification par identifiant abstrait,
   *  ce sont ces identifiants qui sont retournes, et non les identifiants uniques arcane.
   *  Les tableaux item_uids et items doivent avoir la meme taille.
   */
  void itemsUniqueId(Arcane::Int64SharedArray& item_uids, Arcane::ItemVectorView items, Arcane::eItemKind item_kind);

private:
  Arcane::IMesh* m_mesh;
  Arcane::IParallelMng* m_parallel_mng;
  Arcane::IVariableMng* m_variable_mng;

};

END_ARCGEOSIM_NAMESPACE

#endif /* ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMUIDTOLIDMNG_H */
