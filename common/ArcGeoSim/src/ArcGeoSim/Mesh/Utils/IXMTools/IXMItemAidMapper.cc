#include "IXMItemAidMapper.h"
/* Author : havep at Mon Aug 22 15:03:51 2011
 * Generated by createNew
 */

#include <arcane/ArcaneTypes.h>
#include <arcane/IItemFamily.h>
#include <arcane/ItemPrinter.h>
#include <arcane/IParallelMng.h>
#include <arcane/IMeshUtilities.h>
#include <arcane/ItemEnumerator.h>
#include <arcane/packages/Variable.h>
#include <arcane/IMesh.h>
#include <arcane/ISubDomain.h>

#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMTools.h"

#include <cassert>

using namespace Arcane;

/*---------------------------------------------------------------------------*/
/* Class FaceAidToUidMapper */
/*---------------------------------------------------------------------------*/

// #error TODO: constructeur unique; mode reload depuis la variable arcane; toujours sauver dans la variable arcane (pour pp); lid2aid (ie fin de localNewLocalFaceAid) ?
// #error TODO: variable arcane meme sur les slaves (pour le reload).
// Modif SdC : constructeur unique fait. Le maitre construit le mapping et le transmet aux esclaves. Le maitre et les esclaves connaissent le mapping
// complet gr�ce � la variable face_aid_memory
/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMItemAidToUidMapper::
IXMItemAidToUidMapper(Arcane::ITraceMng * traceMng,
                      Arcane::IMesh * mesh,
                      Arcane::IParallelMng * parallelMng,
                      Arcane::Integer masterId,
                      bool useMemory,
                      Arcane::VariableArrayInt64* item_aid_memory,
                      Arcane::eItemKind item_kind)
  : Arcane::TraceAccessor(traceMng)
  , m_mesh(mesh)
  , m_parallel_mng(parallelMng)
  , m_master_id(masterId)
  , m_use_memory(useMemory)
  , m_item_aid_memory(item_aid_memory)
  , m_item_kind(item_kind)
{
  m_is_master = (m_master_id == m_parallel_mng->commRank());
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMItemAidToUidMapper::
buildAidToLidMapping(Arcane::Int64ConstArrayView abstract_ids, Arcane::ConstArrayView<LocalIdType> local_ids, const bool do_check, const bool is_parallel)
{
  if (m_use_memory) _buildAidToLidMappingWithMemory(abstract_ids,local_ids,do_check,is_parallel);
  else _buildAidToLidMapping(abstract_ids,local_ids,do_check);
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMItemAidToUidMapper::
_buildAidToLidMapping(Arcane::Int64ConstArrayView abstract_ids, Arcane::ConstArrayView<LocalIdType> local_ids, const bool do_check)
{
   Arcane::Integer nb_items = local_ids.size();
   ARCANE_ASSERT((nb_items == abstract_ids.size()),("Abstract and local ids arrays have different sizes. Exiting"))
   ARCANE_ASSERT((m_aid_to_lids.empty()),("Clear aid mapping before rebuilding it. Exiting"))

   // Famille des items (et leurs ItemInternal's)
   IItemFamily * item_family = m_mesh->itemFamily(m_item_kind);
   ItemInternalArrayView item_internals = item_family->itemsInternal();

   // Structure de contr�le de red�finition d'une face (uniquement utilis�e en mode check)
   typedef std::map<Integer, Int64> Lid2AidMap;
   Integer nerror = 0;


   for (Integer i = 0; i < nb_items; ++i)
     {
       if (local_ids[i] != NULL_ITEM_LOCAL_ID)
         {
           if (do_check) debug(Trace::Highest) << m_item_kind << " aid=" << abstract_ids[i] << " is " << FullItemPrinter(item_internals[local_ids[i]]);
           // Add item
           std::pair<Aid2LidMap::iterator,bool> inserter = m_aid_to_lids.insert(Aid2LidMap::value_type(abstract_ids[i],local_ids[i]));
           if (!inserter.second)
             {
               if (inserter.first->second != local_ids[i])
                 {
                   error() << m_item_kind << " aid=" << abstract_ids[i] << " has two different definition:\n"
                           << FullItemPrinter(item_internals[local_ids[i]])
                           << FullItemPrinter(item_internals[inserter.first->second]);
                   ++nerror;
                 }
               else
                 {
                   if (do_check)
                     warning() << "Duplicated item aid " << abstract_ids[i];
                 }
             }
         }
     }

   if (do_check && nerror)
     fatal() << m_item_kind << " aid definition has " << String::plural(nerror,"error") << " (see detail above)";
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMItemAidToUidMapper::
_buildAidToLidMappingWithMemory(Arcane::Int64ConstArrayView abstract_ids, Arcane::ConstArrayView<LocalIdType> local_ids, const bool do_check, const bool is_parallel)
{
#ifdef ARCANE_DEBUG_ASSERT
  Arcane::Integer nb_items = local_ids.size();
#endif
  ARCANE_ASSERT((nb_items == abstract_ids.size()),("Abstract and local ids arrays have different sizes. Exiting"))
  ARCANE_ASSERT((m_aid_to_lids.empty()),("Clear aid mapping before rebuilding it. Exiting"))


  // Famille des items(et leurs ItemInternal's)
#if (ARCANE_VERSION >= 30003)
  IItemFamily * item_family = nullptr ;
  if(m_item_kind == IK_DoF)
  {
    assert(m_graph!=nullptr) ;
    item_family = m_graph->linkFamily() ;
  }
  else
    item_family = m_mesh->itemFamily(m_item_kind);
#else
  IItemFamily * item_family = m_mesh->itemFamily(m_item_kind);
#endif
  //ItemInternalArrayView item_internals = item_family->itemsInternal();

  void computeItemIdInfo();
  Int64SharedArray own_item_ids;
  own_item_ids.add(0); // emplacement pr�visionnel pour la taille du buffer
  ItemVectorView own_items = item_family->view(local_ids);
  ENUMERATE_ITEM(iItem, own_items)
  {
    if (iItem.localId() != NULL_ITEM_LOCAL_ID && iItem->isOwn())
      {
        // Envoi en mode entrelac� (aid1,uid1)(aid2,uid2)...
        own_item_ids.add(abstract_ids[iItem.index()]);
        own_item_ids.add(iItem->uniqueId());
      }
  }
  own_item_ids[0] = own_item_ids.size()-1;

  Int64SharedArray all_item_ids;
  if(is_parallel)
    m_parallel_mng->gatherVariable(own_item_ids,all_item_ids,m_master_id);
  else
    all_item_ids = own_item_ids ;

  if (m_is_master)
    {
      // Rechargement des associations aid->uid pr�c�dents
      typedef std::map<Int64,Int64> Aid2UidMap;
      Aid2UidMap aid_to_uids;
      VariableArrayInt64 & item_aid_memory = *m_item_aid_memory;
      const Integer memory_size = item_aid_memory.arraySize()/2;

      for(Integer i=0;i<memory_size;++i)
        {
          // Relecture en mode bloc (aid1,aid2...)(uid1,uid2...)
          const Int64 aid = item_aid_memory[i];
          const Int64 uid = item_aid_memory[i+memory_size];
          aid_to_uids[aid] = uid;
        }

      // Ajout des nouveaux identifiants
      const Integer nbSubDomain =  is_parallel?m_parallel_mng->commSize():1;
      for(Integer isd=0, offset = 0;isd<nbSubDomain;++isd)
        {
          const Integer size = (Integer)all_item_ids[offset]; // downcast Int64 to Integer
          Int64ConstArrayView item_ids = all_item_ids.subConstView(offset+1, size);
          ARCANE_ASSERT((size%2==0),("Bad data size"));
          const Integer size2 = size/2;
          for(Integer i=0;i<size2;++i)
            {
              // R�ception en mode entrelac� (aid1,uid1)(aid2,uid2)...
              const Int64 aid = item_ids[2*i+0];
              const Int64 uid = item_ids[2*i+1];

              if ( do_check )
              {
            	  // Version avec contr�le
            	  std::pair<Aid2UidMap::const_iterator,bool> inserter = aid_to_uids.insert(Aid2UidMap::value_type(aid,uid));
            	  if (!inserter.second)
            	  {
            		  if (inserter.first->second != uid)
            			  fatal() << "Incompatible "<< m_item_kind << " aid " << aid << " redefinition : was uid " << uid << " and now " << inserter.first->second;
            	  }
              }
              else
              {
            	  // Version sans contr�le
            	  aid_to_uids[aid] = uid;
              }

            }
          offset += size+1;
        }
      all_item_ids.dispose(); // on n'en a plus besoin

      // M�morise la nouvelle base des aids et s�rialize les infos � envoyer
      const Integer new_memory_size = aid_to_uids.size();
      item_aid_memory.resize(2*new_memory_size);

      {
        Integer index = 0;
        for(Aid2UidMap::const_iterator it=aid_to_uids.begin(); it != aid_to_uids.end(); ++it,++index)
          {
            // Ecriture en mode bloc (aid1,aid2...)(uid1,uid2...)
            const Int64 aid = it->first;
            const Int64 uid = it->second;
            item_aid_memory[index] = aid;
            item_aid_memory[index+new_memory_size] = uid;
          }
      }

      // Diffusion de la taille
      Integer full_size = item_aid_memory.size();
      if(is_parallel)
        m_parallel_mng->broadcast(IntegerArrayView(1,&full_size),m_master_id);
    }

  else // esclaves
    {
      // Reception de la taille
      Integer full_size;
      m_parallel_mng->broadcast(IntegerArrayView(1,&full_size),m_master_id);
      m_item_aid_memory->resize(full_size);
    }

  // Update face_aid_memory on slave : broadcast from master to slaves (aid1,aid2...)(uid1,uid2...)
  if(is_parallel)
    m_parallel_mng->broadcast(m_item_aid_memory->asArray(),m_master_id);

  // Int�gration de nouvelles donn�es
  {
    const Integer size = m_item_aid_memory->size()/2;
    Int64ConstArrayView aids = m_item_aid_memory->subView(0,size);
    Int64ConstArrayView uids = m_item_aid_memory->subView(size,size+size);
    Int32SharedArray lids(size);
    item_family->itemsUniqueIdToLocalId(lids,uids,false);
    for(Integer i=0;i<size;++i)
      {
        // Relecture en mode bloc (aid1,aid2...)(uid1,uid2...)
        const Int64 aid = aids[i];
        // const Int64 uid = all_face_id_view[i+size];
        const Int32 lid = lids[i];
        if (lid != NULL_ITEM_LOCAL_ID)
          m_aid_to_lids[aid] = lid;
      }
  }
}

Arcane::Int64 ArcGeoSim::IXMItemAidToUidMapper::getItemAidMax() const
{
  if(m_use_memory)
  {
    VariableArrayInt64 & item_aid_memory = *m_item_aid_memory;
    const Integer memory_size = item_aid_memory.arraySize()/2;
    Int64 aid_max = -1 ;
    for(Integer i=0;i<memory_size;++i)
      {
        const Int64 aid = item_aid_memory[i];
        aid_max = std::max(aid_max,aid) ;
      }
    return aid_max ;
  }
  return -1 ;
}
/*---------------------------------------------------------------------------*/

Arcane::Integer
ArcGeoSim::IXMItemAidToUidMapper::
_findLocalId(Arcane::Int64 aid) const
{
  Aid2LidMap::const_iterator finder = m_aid_to_lids.find(aid);
  if (finder == m_aid_to_lids.end())
    return NULL_ITEM_LOCAL_ID;
  else
    return finder->second;
}

/*---------------------------------------------------------------------------*/

Arcane::Integer
ArcGeoSim::IXMItemAidToUidMapper::
_findLocalIdOrExit(Arcane::Int64 aid) const
{
  Aid2LidMap::const_iterator finder = m_aid_to_lids.find(aid);
  if (finder == m_aid_to_lids.end())
    fatal() << Arcane::String::format("Cannot find {0} with abstract id {1}",m_item_kind,aid);
  return finder->second;
}


/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMItemAidToUidMapper::
itemAbstractIdToLocalId(Arcane::Int32ArrayView face_local_ids, const Arcane::Int64ConstArrayView face_abstract_ids, const bool do_fatal) const
{
  ARCANE_ASSERT((face_local_ids.size()==face_abstract_ids.size()),("local id and abstract id arrays must have same size"));
  Arcane::Integer i = 0;
  if (do_fatal)
    {
      for (Arcane::Int64ArrayView::const_iterator ite = face_abstract_ids.begin(); ite != face_abstract_ids.end();++ite,++i)
        {
          face_local_ids[i] = _findLocalIdOrExit(*ite);
        }
    }
  else
    {
      for (Arcane::Int64ArrayView::const_iterator ite = face_abstract_ids.begin(); ite != face_abstract_ids.end();++ite,++i)
        {
          face_local_ids[i] = _findLocalId(*ite);
        }
    }
}


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* Class IXMItemUidToAidMapper */
/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMItemUidToAidMapper::
IXMItemUidToAidMapper(Arcane::IMesh* mesh,Arcane::IParallelMng * parallel_mng, Arcane::IVariableMng* variable_mng, const Arcane::eItemKind& item_kind)
  : m_parallel_mng(parallel_mng)
  , m_variable_mng(variable_mng)
  , m_item_kind(item_kind)
{
  // Get Aid memory variable if exists
  IVariable* variable = m_variable_mng->findVariable(IXMItemAidToUidMapper::itemAidMemoryVariableName(mesh,m_item_kind));
  if (variable)
    {
      // Create map and compute max of aid
      Arcane::VariableArrayInt64 item_aid_memory(variable);
      const Integer size = item_aid_memory.size()/2;
      Int64ConstArrayView aids = item_aid_memory.subView(0,size);
      Int64ConstArrayView uids = item_aid_memory.subView(size,size+size);
      m_itemAidMax = -1 ;
      for (Arcane::Integer i = 0; i < size; ++i)
      {
          m_uid2aid[uids[i]] = aids[i];
          m_itemAidMax = std::max(m_itemAidMax,aids[i]);
      }

    }
}

#if (ARCANE_VERSION >= 30003)
ArcGeoSim::IXMItemUidToAidMapper::
IXMItemUidToAidMapper(Arcane::IMesh* mesh, Arcane::IGraph2* graph,Arcane::IParallelMng * parallel_mng, Arcane::IVariableMng* variable_mng, const Arcane::eItemKind& item_kind)
  : m_parallel_mng(parallel_mng)
  , m_variable_mng(variable_mng)
  , m_item_kind(item_kind)
{
  // Get Aid memory variable if exists
  IVariable* variable = m_variable_mng->findVariable(IXMItemAidToUidMapper::itemAidMemoryVariableName(mesh,m_item_kind));
  if (variable)
    {
      // Create map and compute max of aid
      Arcane::VariableArrayInt64 item_aid_memory(variable);
      const Integer size = item_aid_memory.size()/2;
      Int64ConstArrayView aids = item_aid_memory.subView(0,size);
      Int64ConstArrayView uids = item_aid_memory.subView(size,size+size);
      m_itemAidMax = -1 ;
      for (Arcane::Integer i = 0; i < size; ++i)
      {
          m_uid2aid[uids[i]] = aids[i];
          m_itemAidMax = std::max(m_itemAidMax,aids[i]);
      }

    }
}
#endif
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMItemUidToAidMapper::
itemUniqueIdToAbstractId(Arcane::Int64Array& item_abstract_ids, const Arcane::Int64ConstArrayView item_unique_ids) const
{
  ARCANE_ASSERT((item_abstract_ids.empty()),("Given abstract id result array must be empty"));
  if (!(m_uid2aid.empty()))
    {
      item_abstract_ids.resize(item_unique_ids.size());
      Arcane::Integer i = 0;
      Arcane::Int64ConstArrayView::const_iterator ite = item_unique_ids.begin();
      for (; ite != item_unique_ids.end(); ++ite,++i)
        {
          Arcane::Int64 uid = *ite;
          UidToAidMap::const_iterator aid_found = m_uid2aid.find(uid);
          if (aid_found != m_uid2aid.end())
            {
              item_abstract_ids[i] = aid_found->second;
            }
          //  else item_abstract_ids[i] = NULL_ITEM_UNIQUE_ID;
          else item_abstract_ids[i] = m_itemAidMax  + uid + 1;
        }
    }
}

Int64
ArcGeoSim::IXMItemUidToAidMapper::
itemUniqueIdToAbstractId( Int64 uid) const
{
 if (m_uid2aid.empty())
    return uid ;
  else
  {

    UidToAidMap::const_iterator aid_found = m_uid2aid.find(uid);
    if (aid_found != m_uid2aid.end())
    {
      return aid_found->second;
    }
    else
      // return NULL_ITEM_UNIQUE_ID;
      return  m_itemAidMax  + uid + 1;
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/* Class IXMItemUidToAidVariable */
/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMItemUidToAidVariable* ArcGeoSim::IXMItemUidToAidVariable::m_instance = NULL;

void
ArcGeoSim::IXMItemUidToAidVariable::
set(Arcane::IMesh* mesh,const Arcane::eItemKind& kind)
{
  if (m_instance) delete m_instance;
  ArcGeoSim::IXMItemUidToAidMapper uid_mapper(mesh,mesh->subDomain()->parallelMng(),mesh->subDomain()->variableMng(),kind);
  m_instance = new ArcGeoSim::IXMItemUidToAidVariable(mesh,uid_mapper,kind);
}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMItemUidToAidVariable*
ArcGeoSim::IXMItemUidToAidVariable::
get()
{
  ARCANE_ASSERT((m_instance),("Cannot access to ItemConnectionUids : has not be created. Exiting"))
  return m_instance;
}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMItemUidToAidVariable::
IXMItemUidToAidVariable(Arcane::IMesh* mesh, const ArcGeoSim::IXMItemUidToAidMapper& uid_mapper, const Arcane::eItemKind& kind)
  : m_aids(Arcane::VariableBuildInfo(mesh,_variableName(kind)),kind)
{
  Arcane::ItemGroup all_items = mesh->itemFamily(kind)->allItems();
  Arcane::Int64SharedArray item_uids(all_items.size());
  Arcane::Integer i = 0;
  ENUMERATE_ITEM(iitem,all_items) { item_uids[i] = iitem->uniqueId();++i;}
  Arcane::Int64SharedArray item_aids;
  uid_mapper.itemUniqueIdToAbstractId(item_aids,item_uids);
  i = 0;
  ENUMERATE_ITEM(iitem,all_items) { m_aids[iitem] = item_aids[i];++i;}
}

#if (ARCANE_VERSION >= 30003)
ArcGeoSim::IXMItemUidToAidLinkVariable* ArcGeoSim::IXMItemUidToAidLinkVariable::m_instance = NULL;

void
ArcGeoSim::IXMItemUidToAidLinkVariable::
set(Arcane::IMesh* mesh,Arcane::IGraph2* graph)
{
  if (m_instance) delete m_instance;
  ArcGeoSim::IXMItemUidToAidMapper uid_mapper(mesh,graph,mesh->subDomain()->parallelMng(),mesh->subDomain()->variableMng(),IK_DoF);
  m_instance = new ArcGeoSim::IXMItemUidToAidLinkVariable(mesh,graph,uid_mapper);
}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMItemUidToAidLinkVariable*
ArcGeoSim::IXMItemUidToAidLinkVariable::
get()
{
  ARCANE_ASSERT((m_instance),("Cannot access to ItemConnectionUids : has not be created. Exiting"))
  return m_instance;
}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMItemUidToAidLinkVariable::
IXMItemUidToAidLinkVariable(Arcane::IMesh* mesh, Arcane::IGraph2* graph,const ArcGeoSim::IXMItemUidToAidMapper& uid_mapper)
  : m_aids(Arcane::VariableBuildInfo(mesh,_variableName(Arcane::IK_DoF),graph->linkFamily()->name()),Arcane::IK_DoF)
{
  Arcane::ItemGroup all_items = graph->linkFamily()->allItems();
  Arcane::Int64SharedArray item_uids(all_items.size());
  Arcane::Integer i = 0;
  ENUMERATE_ITEM(iitem,all_items) { item_uids[i] = iitem->uniqueId();++i;}
  Arcane::Int64SharedArray item_aids;
  uid_mapper.itemUniqueIdToAbstractId(item_aids,item_uids);
  i = 0;
  ENUMERATE_ITEM(iitem,all_items) { m_aids[iitem] = item_aids[i];++i;}
}

#endif

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
