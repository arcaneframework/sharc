#include "IXMMeshBuilderBase.h"
/* Author : dechaiss at Fri Jul 13 14:08:12 2012
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
#ifdef WIN32
#include <ciso646>
#endif
#include <cassert>
#include <map>

#include <arcane/Connectivity.h>
#include <arcane/ISubDomain.h>
#include <arcane/IItemFamily.h>
#include <arcane/IMeshModifier.h>
#include <arcane/MeshToMeshTransposer.h>
#include <arcane/mesh/DynamicMeshKindInfos.h>
#include <arcane/mesh/FaceFamily.h>
#include <arcane/mesh/NodeFamily.h>
#include <arcane/mesh/EdgeFamily.h>
#include <arcane/ArcaneException.h>
#include <arcane/XmlException.h>
#if (ARCANE_VERSION >= 30003)
#include <arcane/mesh/GraphDoFs.h>
#include <arcane/mesh/GraphBuilder.h>
#else
#include <arcane/IGraph.h>
#include <arcane/IGraphModifier.h>
#endif
#ifdef USE_ARCANE_V3
#include <arcane/mesh/DualUniqueIdMng.h>
#else
#include <arcane/utils/DualUniqueIdMng.h>
#endif
#include <arcane/IMeshPartitionConstraintMng.h>
#include <arcane/ItemPrinter.h>
#include <arcane/SerializeBuffer.h>

#include <arcane/mesh/DynamicMesh.h>

#include "ArcGeoSim/Utils/MixedCollectiveCommunications.h"
#include "ArcGeoSim/Utils/ItemGroupBuilder.h"

#include "ArcGeoSim/Mesh/Utils/MeshUtils.h"
//#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMEvolutiveMeshBuilder.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMUidToLidMng.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMItemConnections.h"
#include "ArcGeoSim/Mesh/MeshPartitioner/PartitionConstraints/ItemConnectionGroupPartitionConstraint.h"

#include <memory>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

//! Correspond aux nombres composantes des coordonn�es : ici toujours 3 valeurs (x,y,z) m�me en 2D
const Integer ArcGeoSim::IXMTools::IXMMeshInfo::m_coord_dimension = 3;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMMeshBuilderBase::
IXMMeshBuilderBase(Arcane::IMesh * mesh, 
                   Arcane::ITraceMng * traceMng, 
                   Arcane::IParallelMng * parallelMng)
  : Arcane::TraceAccessor(traceMng)
  , m_parallel_mng(parallelMng)
  , m_is_initialized(false)
  , m_parallel_utils(m_parallel_mng)
  , m_changed_group_collection(List<ItemGroup>())
{

}
/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMMeshBuilderBase::
notifyEvolutiveMeshObservers(IEvolutiveMesh::eStatus status)
{
  if (m_evolutive_mesh_observer_mng) m_evolutive_mesh_observer_mng->notifyObservers(status);
}
#endif
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
staticInit(Arcane::IPrimaryMesh * mesh)
{
  if (m_is_initialized) return;
  m_is_initialized = true;

  // Rque PH : On doit pouvoir r�duire le nombre de groupe en fonction du contexte (status)
  // Ils ne servent pas tous en meme temps.
  m_old_cells = mesh->cellFamily()->createGroup("IXMStaticMesh_toRemoveCells");
  m_new_cells = mesh->cellFamily()->createGroup("IXMStaticMesh_newCells");
  m_new_nodes = mesh->nodeFamily()->createGroup("IXMStaticMesh_newNodes");
  m_new_edges = mesh->edgeFamily()->createGroup("IXMStaticMesh_newEdges");
  m_new_faces = mesh->faceFamily()->createGroup("IXMStaticMesh_newFaces");
  m_twin_nodes = mesh->nodeFamily()->createGroup("IXMStaticMesh_twinNodes");
  m_twin_edges = mesh->edgeFamily()->createGroup("IXMStaticMesh_twinEdges");
  m_twin_faces = mesh->faceFamily()->createGroup("IXMStaticMesh_twinFaces");
  m_updated_cells = mesh->cellFamily()->createGroup("IXMStaticMesh_updatedCells");
  m_updated_nodes = mesh->nodeFamily()->createGroup("IXMStaticMesh_updatedNodes");
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
evolutiveInit(Arcane::IPrimaryMesh * mesh)
{
  if (m_is_initialized) return;
  m_is_initialized = true;

  // Rque PH : On doit pouvoir r�duire le nombre de groupe en fonction du contexte (status)
  // Ils ne servent pas tous en meme temps.
  m_old_cells = mesh->cellFamily()->createGroup("IXMEvolutiveMesh_toRemoveCells");
  m_new_cells = mesh->cellFamily()->createGroup("IXMEvolutiveMesh_newCells");
  m_new_nodes = mesh->nodeFamily()->createGroup("IXMEvolutiveMesh_newNodes");
  m_new_edges = mesh->edgeFamily()->createGroup("IXMEvolutiveMesh_newEdges");
  m_new_faces = mesh->faceFamily()->createGroup("IXMEvolutiveMesh_newFaces");
  m_twin_nodes = mesh->nodeFamily()->createGroup("IXMEvolutiveMesh_twinNodes");
  m_twin_edges = mesh->edgeFamily()->createGroup("IXMEvolutiveMesh_twinEdges");
  m_twin_faces = mesh->faceFamily()->createGroup("IXMEvolutiveMesh_twinFaces");
  m_updated_cells = mesh->cellFamily()->createGroup("IXMEvolutiveMesh_updatedCells");
  m_updated_nodes = mesh->nodeFamily()->createGroup("IXMEvolutiveMesh_updatedNodes");
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
applyMeshPartitionConstraints(Arcane::IPrimaryMesh * mesh)
{
  // add cell cell constraints geoxim dual medium approach
  
  // no graph no connections
  if(m_graph==nullptr)
    return;
  // get cell cell connections group convention by name TiedCellCellConnections
  ArcGeoSim::ItemConnectionMng item_connections(mesh, m_graph);
  ArcGeoSim::ItemConnectionGroup cell_cell_connections = item_connections.findConnectionGroup("TiedCellCellConnections");
  // add constraint if group exist
  if(!cell_cell_connections.null() && !cell_cell_connections.empty())
  {
    ItemConnectionGroupPartitionConstraint* partition_constraint = new ItemConnectionGroupPartitionConstraint(m_graph, cell_cell_connections); // delete is handled by partition_constraint_mng
    IMeshPartitionConstraintMng* partition_constraint_mng = mesh->partitionConstraintMng();
    partition_constraint_mng->addConstraint(partition_constraint);
  }
}

/*---------------------------------------------------------------------------*/

Arcane::CellGroup
ArcGeoSim::IXMMeshBuilderBase::
toRemoveCells()
{
  return m_old_cells;
}

/*---------------------------------------------------------------------------*/

Arcane::CellGroup
ArcGeoSim::IXMMeshBuilderBase::
newCells()
{
  return m_new_cells;
}

/*---------------------------------------------------------------------------*/

Arcane::NodeGroup
ArcGeoSim::IXMMeshBuilderBase::
newNodes()
{
  return m_new_nodes;
}

/*---------------------------------------------------------------------------*/

Arcane::NodeGroup
ArcGeoSim::IXMMeshBuilderBase::
twinNodes()
{
  return m_twin_nodes;
}

/*---------------------------------------------------------------------------*/

Arcane::FaceGroup
ArcGeoSim::IXMMeshBuilderBase::
newFaces()
{
  return m_new_faces;
}

/*---------------------------------------------------------------------------*/

Arcane::FaceGroup
ArcGeoSim::IXMMeshBuilderBase::
twinFaces()
{
  return m_twin_faces;
}


/*---------------------------------------------------------------------------*/

Arcane::CellGroup
ArcGeoSim::IXMMeshBuilderBase::
updatedCells()
{
  return m_updated_cells;
}

/*---------------------------------------------------------------------------*/

Arcane::NodeGroup
ArcGeoSim::IXMMeshBuilderBase::
updatedNodes()
{
  return m_updated_nodes;
}

/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
Arcane::ItemGroupCollection
ArcGeoSim::IXMMeshBuilderBase::
changedGroups()
{
  return m_changed_group_collection;
}
#endif
/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMMeshBuilderBase::
hasChangedGroup(const Arcane::ItemGroup group)
{
  return (groupChangeTypes(group) != EvolutiveMeshProperty::None);
}
/*---------------------------------------------------------------------------*/

Arcane::Integer
ArcGeoSim::IXMMeshBuilderBase::
groupChangeTypes(const Arcane::ItemGroup group)
{
  GroupChangeMap::iterator ifinder = m_changed_groups.find(group.internal());
  if (ifinder == m_changed_groups.end()) return EvolutiveMeshProperty::None;
  return ifinder->second.m_info;
}

/*---------------------------------------------------------------------------*/

Arcane::ItemVector
ArcGeoSim::IXMMeshBuilderBase::
groupChanges(const ItemGroup group, EvolutiveMeshProperty::eGroupEvent event, const bool check)
{
  GroupChangeMap::iterator ifinder = m_changed_groups.find(group.internal());
  if (ifinder == m_changed_groups.end()) return Arcane::ItemVector();
  GroupChangeInfo & group_change_info = ifinder->second;
  Arcane::Int64SharedArray * uids = NULL;

  switch (event)
  {
  case EvolutiveMeshProperty::Add:
    uids = &group_change_info.m_added_items;
    break;
  case EvolutiveMeshProperty::Delete:
    uids = &group_change_info.m_deleted_items;
    break;
  case EvolutiveMeshProperty::Reset:
  default:
    fatal() << "Bad event [" << event << "] for groupChanges";
  }

  Arcane::Int32SharedArray lids(uids->size());
  Arcane::IItemFamily * item_family = group.itemFamily();
  item_family->itemsUniqueIdToLocalId(lids, *uids, check);
  return Arcane::ItemVector(item_family, lids);
}

/*---------------------------------------------------------------------------*/
#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMMeshBuilderBase::
resetIncrement()
{

  m_new_nodes.clear();
  m_twin_nodes.clear();
  m_new_edges.clear();
  m_twin_edges.clear();
  m_new_faces.clear();
  m_twin_faces.clear();
  m_new_cells.clear();
  m_updated_cells.clear();
  m_updated_nodes.clear();
  m_old_cells.clear();

  m_changed_group_collection = List<Arcane::ItemGroup>();
  m_changed_groups.clear();
}
#endif

/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMMeshBuilderBase::
manageCellOperations(Arcane::IPrimaryMesh * mesh, 
                     const ArcGeoSim::IXMTools::IXMCellData& new_cells,
                     const ArcGeoSim::IXMTools::IXMCellData& removed_cells,
                     const ArcGeoSim::IXMTools::IXMCellData& changed_cells,
                     const ArcGeoSim::IXMTools::IXMCellIncrementPartitionInfo& cell_partition_info,
                     const bool check)
{
  ARCANE_ASSERT((m_is_initialized),("IXMMeshBuilder is not initialized. Exiting."))

  // Working arrays
  const auto & to_remove_cell_uids = removed_cells.item_ids;
  const auto & new_cell_uids = new_cells.item_ids;
  const auto & new_cell_infos = new_cells.item_infos;
  const auto & new_cell_connectivity_infos = cell_partition_info.new_cells.connectivity_infos;
  const auto & new_cell_owners = cell_partition_info.new_cell_owners;
  const auto & new_cell_connectivity_owners = cell_partition_info.new_cells.connectivity_owners;
  const auto & changed_cell_uids = changed_cells.item_ids;
  const auto & changed_cell_infos = changed_cells.item_infos;
  const auto & changed_cell_connectivity_infos = cell_partition_info.changed_cells.connectivity_infos;
  const auto & changed_cell_connectivity_owners = cell_partition_info.changed_cells.connectivity_owners;

  const bool has_edge = Arcane::Connectivity(mesh->connectivity()).hasEdge();
//
  // Reduction parall�le sur les d�cisions de modifications collectives
  bool global_has_cell_to_remove, global_has_cell_to_change, global_has_cell_to_add;
  MixedCollective::Comm<Integer>::reduce(m_parallel_mng, Arcane::Parallel::ReduceMax,
                                         MixedCollective::Data(global_has_cell_to_remove = not to_remove_cell_uids.empty(),
                                                               global_has_cell_to_change = not changed_cell_uids.empty(),
                                                               global_has_cell_to_add    = not new_cell_uids.empty()));
  Int32SharedArray changed_cell_owners;
  bool topology_has_changed = false;

  Arcane::Int64SharedArray newfacesOfChangedCells;
  Arcane::Int64SharedArray newnodesOfChangedCells;
  Arcane::Int64SharedArray newedgesOfChangedCells;

  Arcane::Int64SharedArray twinfaces_uids;
  Arcane::Int64SharedArray twinnodes_uids;

  // Pr�traitements concernant les cellules qui seront supprim�es
  // on d�tache les cellules � supprimer et on supprime des groupes les faces des cellules � supprimer

  Int32SharedArray main_removed_cell_lids;

  Arcane::SharedArray<RemovedCellData> removed_cell_datas;

  Arcane::Integer removed_cell_datas_size = 0;

  if ( global_has_cell_to_remove )
  {
      // * 0 - Identification des structures de sous-maillages (cas des cellules supprim�es)

      Arcane::mesh::CellFamily * main_cell_family = dynamic_cast<Arcane::mesh::CellFamily*>(mesh->cellFamily());
      
      {
        std::set<IItemFamily*> scanned_families; // structure auxilaire 'anti-doublon'
        _findAllCellChildFamilies(main_cell_family, removed_cell_datas, scanned_families);
        ARCANE_ASSERT((removed_cell_datas.size()>0),("Bad cell child families size"));
      }
      const Arcane::Integer nb_removed_cells = to_remove_cell_uids.size();

      removed_cell_datas_size = removed_cell_datas.size();

      //* 1- Identification des cellules � supprimer
      RemovedCellData & main_removed_cell_data = removed_cell_datas[0];
      //auto & main_removed_cell_lids = main_removed_cell_data.old_removed_cell_lids;
      main_removed_cell_lids = main_removed_cell_data.old_removed_cell_lids;
      main_removed_cell_data.old_removed_cell_uids = to_remove_cell_uids;
      main_removed_cell_lids.resize(nb_removed_cells);
      ARCANE_ASSERT((main_cell_family->hasUniqueIdMap()), ("UniqueId Map not available on CellFamily"));
      main_cell_family->itemsUniqueIdToLocalId(main_removed_cell_data.old_removed_cell_lids, to_remove_cell_uids, check);
      Arcane::ItemVectorView main_removed_cells = main_cell_family->view(main_removed_cell_lids);

      //* 1'- Identification des sous-maillages impact�s
      for(Arcane::Integer i_family = 1; i_family < removed_cell_datas.size(); ++i_family)
      { // On saute la position 0 qui contient main_cell_family
          RemovedCellData & removed_cell_data = removed_cell_datas[i_family];
          Arcane::IItemFamily * cell_family = removed_cell_data.cell_family;
          Arcane::ItemVector child_cells = Arcane::MeshToMeshTransposer::transpose(main_cell_family->mesh(),cell_family->mesh(),main_removed_cells);
          ENUMERATE_ITEM(icell,child_cells)
          {
            const Arcane::Int32 child_lid = icell.localId();
            if (child_lid != NULL_ITEM_LOCAL_ID)
              {
                ARCANE_ASSERT((icell->uniqueId() == main_removed_cells[icell.index()].uniqueId()),("Incoherent uniqueId order"));
                removed_cell_data.old_removed_cell_lids.add(child_lid);
                removed_cell_data.old_removed_cell_uids.add(icell->uniqueId());
              }
          }
      }

      //* 2- Notification des observers

      //notifyEvolutiveMeshObservers(IEvolutiveMesh::BeforeUpdateCell);

      // on d�tache les cellules � supprimer

      //* 3- D�tachement des cellules � supprimer (sous-maillages inclus)
      // SDC Attention le d�tachement supprime les connectivit�s : on ne pourra plus ensuite faire la mise � jour des propri�taires. DEBUG ATTENTION IL FAUT FAIRE LES MISES A JOUR DE OWNER D'ABORD
      // En effet cette derni�re n�cessite de conna�tres les sous-items des mailles enlev�es...

      //* 3-1 Mise � jour des propri�taires : Il existe en parall�le des cas limite o� des sous-items
      // n'ont plus de cellules de m�me propri�taire � proximit� suite � des suppressions de mailles
      m_old_cells.setItems(main_removed_cell_lids);
      _updateNeighborOwners(mesh, m_old_cells);

      for(Arcane::Integer i_family = 0; i_family < removed_cell_datas.size(); ++i_family)
      {
          RemovedCellData & removed_cell_data = removed_cell_datas[i_family];
          Arcane::mesh::CellFamily * cell_family = removed_cell_data.cell_family;
          ENUMERATE_CELL(icell,cell_family->view(removed_cell_data.old_removed_cell_lids))
          {
            const Arcane::Cell & cell = *icell;
            Arcane::ItemInternal * cell_internal = cell.internal();
            cell_family->detachCell(cell_internal);
            cell_internal->unsetUniqueId(); // permet d'�viter que deux items aient le m�me uniqueId m�me temporairement
          }

      }


      // on calcule  les faces � supprimer

      std::set<Arcane::Int32> set_removed_cell_ids(main_removed_cell_lids.begin(),main_removed_cell_lids.end());

      Arcane::CellVectorView ncells( mesh->cellFamily()->itemsInternal(), main_removed_cell_lids);

      std::set<Arcane::Int32> set_removed_face_lids;

      ENUMERATE_CELL(icell, ncells)
      {
        Arcane::FaceVectorView faces = (*icell).faces();

        ENUMERATE_FACE(iface, faces)
        {
          CellVectorView cells = (*iface).cells();
          bool to_be_removed = true;
          ENUMERATE_CELL(iicell, cells)
          {
            std::set<Arcane::Int32>::const_iterator finder = set_removed_cell_ids.find((*iicell).localId());

            if (finder == set_removed_cell_ids.end())
              {
                to_be_removed = false;
              }
          }
          if ( to_be_removed == true)
            set_removed_face_lids.insert((*iface).localId());
        }
      }

      // on supprime  les faces des groupes

      Arcane::mesh::FaceFamily * facefamily = dynamic_cast<Arcane::mesh::FaceFamily*>(mesh->faceFamily());

      Int32SharedArray array_faces(set_removed_face_lids.size());

      std::copy(set_removed_face_lids.begin(), set_removed_face_lids.end(), array_faces.begin());

      Arcane::ItemGroupCollection coll_faces = facefamily->groups();

      for (ItemGroupCollection::Iterator i = coll_faces.begin(); i != coll_faces.end(); ++i)
        {
          ItemGroup group = *i;
          if (group.isAllItems()) continue;
          if (group.internal()->hasComputeFunctor()) continue;
          group.removeItems(array_faces,false);

        }

  }


  // Traitement des cellules modifi�es
  if (global_has_cell_to_change)
    {
      const Arcane::Integer nb_changed_cells = changed_cell_uids.size();

      /* Proc�dure compos�e de :
       *            Conservation de l'�tat initial des groupes de faces, de noeuds et d'edges
       * 0-         Identification des structures de sous-maillages
       * 1-         Identification des cellules � modifier (topologiquement)
       * 2-         Notification des observers
       * 3-         D�tachement des cellules � changer
       *            Permet de ne pas perdre les items associ�s (faces, nodes...)
       *            Pour aussi permettre une r�utilisation de l'uid, l'uid associ� est
       *            retir� de la table de hachage de la famille apr�s avoir �t� invalid�
       *            dans l'ItemInternal
       * 4-         Ajout des nouvelles cellules (qui s'appuyent par d�faut sur les
       *            items des cellules pr�c�demment d�tach�es)
       * 4bis-      Cr�ation du tableau des faces ayant de nouveaux id
       * 4ter-      Cr�ation du tableau des noeuds ayant de nouveaux id
       * 4quater-   Cr�ation du tableau des edges ayant de nouveaux id
       * 5-         Conservation des groupes de cellules (suivant option du axl)
       * 5bis-      Conservation des groupes de faces
       * 5ter-      Conservation des groupes de noeuds
       * 5quater-   Conservation des groupes de noeuds
       * 6-         Mise � jour de la famille de cellules (et du groupe des cellules modifi�es)
       * 6bis-      Mise � jour de la famille de faces
       * 6ter-      Mise � jour de la famille de noeuds
       * 6quater-   Mise � jour de la famille de edges
       * 7-         Copie des valeurs aux mailles aux nouveaux emplacements
       *            (encore associ�s aux cellules d�tach�es)
       * 7bis-      Copie des valeurs aux faces aux nouveaux emplacements
       * 7ter-      Copie des valeurs aux noeuds aux nouveaux emplacements
       * 7quater-   Copie des valeurs aux edges aux nouveaux emplacements
       * 8-         Suppression des cellules d�tach�es
       */

      // Conservation de l'�tat initial des groupes de faces, de noeuds et d'edges

      std::set<Int32> faces_lid;

      ENUMERATE_FACE(iface,mesh->allFaces())
      {
        faces_lid.insert(iface->localId());
      }

      std::set<Int32> nodes_lid;

      ENUMERATE_NODE(inode,mesh->allNodes())
      {
        nodes_lid.insert(inode->localId());
      }

      std::set<Int32> edges_lid;

      ENUMERATE_EDGE(iedge,mesh->allEdges())
      {
        edges_lid.insert(iedge->localId());
      }

      // * 0- Identification des structures de sous-maillages

      Arcane::IItemFamily * main_cell_family = mesh->cellFamily();

      Arcane::SharedArray<ChangedCellData> changed_cell_datas;
      {
        std::set<IItemFamily*> scanned_families; // structure auxilaire 'anti-doublon'
        _findAllCellChildFamilies(main_cell_family, changed_cell_datas, scanned_families);
        ARCANE_ASSERT((changed_cell_datas.size()>0),("Bad cell child families size"));
      }
      const Arcane::Integer changed_cell_data_size = changed_cell_datas.size();

      Arcane::IItemFamily * main_face_family = mesh->faceFamily();

      Arcane::SharedArray<ChangedFaceData> changed_face_datas;
            {
              std::set<IItemFamily*> scanned_families; // structure auxilaire 'anti-doublon'
              _findAllFaceChildFamilies(main_face_family, changed_face_datas, scanned_families);
              ARCANE_ASSERT((changed_face_datas.size()>0),("Bad face child families size"));
            }

      const Arcane::Integer changed_face_data_size = changed_face_datas.size();

      ARCANE_ASSERT((changed_cell_data_size == changed_face_data_size),("Child face and cell families have different sizes"));

      Arcane::IItemFamily * main_node_family = mesh->nodeFamily();

      Arcane::SharedArray<ChangedNodeData> changed_node_datas;
      {
        std::set<IItemFamily*> scanned_families; // structure auxilaire 'anti-doublon'
        _findAllNodeChildFamilies(main_node_family, changed_node_datas, scanned_families);
        ARCANE_ASSERT((changed_node_datas.size()>0),("Bad node child families size"));
      }

      const Arcane::Integer changed_node_data_size = changed_node_datas.size();

      Arcane::IItemFamily * main_edge_family = mesh->edgeFamily();

      Arcane::SharedArray<ChangedEdgeData> changed_edge_datas;
      {
        std::set<IItemFamily*> scanned_families; // structure auxilaire 'anti-doublon'
        _findAllEdgeChildFamilies(main_edge_family, changed_edge_datas, scanned_families);
        ARCANE_ASSERT((changed_edge_datas.size()>0),("Bad edge child families size"));
      }

      const Arcane::Integer changed_edge_data_size = changed_edge_datas.size();


      { //* 1- Identification des cellules � modifier (topologiquement)
        ChangedCellData & main_changed_cell_data = changed_cell_datas[0];
        auto & main_changed_cell_lids = main_changed_cell_data.old_changed_cell_lids;
        main_changed_cell_data.old_changed_cell_uids = changed_cell_uids;
        main_changed_cell_lids.resize(nb_changed_cells);
        ARCANE_ASSERT((main_cell_family->hasUniqueIdMap()), ("UniqueId Map not available on CellFamily"));
        main_cell_family->itemsUniqueIdToLocalId(main_changed_cell_data.old_changed_cell_lids, changed_cell_uids, check);
        Arcane::ItemVectorView main_changed_cells = main_cell_family->view(main_changed_cell_lids);

        // Marquage des propri�taires originaux
        changed_cell_owners.resize(nb_changed_cells);
        ENUMERATE_ITEM(iitem, main_changed_cells)
        {
          changed_cell_owners[iitem.index()] = iitem->owner();
        }

        //* 1'- Identification des sous-maillages impact�s
        for(Arcane::Integer i_family = 1; i_family < changed_cell_data_size; ++i_family)
          { // On saute la position 0 qui contient main_cell_family
            ChangedCellData & changed_cell_data = changed_cell_datas[i_family];
            Arcane::IItemFamily * cell_family = changed_cell_data.cell_family;
            Arcane::ItemVector child_cells = Arcane::MeshToMeshTransposer::transpose(main_cell_family->mesh(),cell_family->mesh(),main_changed_cells);
            ENUMERATE_ITEM(icell,child_cells)
            {
              const Arcane::Int32 child_lid = icell.localId();
              if (child_lid != NULL_ITEM_LOCAL_ID)
                {
                  ARCANE_ASSERT((icell->uniqueId() == main_changed_cells[icell.index()].uniqueId()),("Incoherent uniqueId order"));
                  changed_cell_data.old_changed_cell_lids.add(child_lid);
                  changed_cell_data.old_changed_cell_uids.add(icell->uniqueId());
                }
              }
          }
      }

      //* 2- Notification des observers
      m_updated_cells.setItems(changed_cell_datas[0].old_changed_cell_lids);
#ifdef USE_EVOLUTIVE
      notifyEvolutiveMeshObservers(IEvolutiveMesh::BeforeUpdateCell);
#endif
      //* 3- D�tachement des cellules � changer (sous-maillages inclus)
      for(Arcane::Integer i_family = 0; i_family < changed_cell_data_size; ++i_family)
        {
          ChangedCellData & changed_cell_data = changed_cell_datas[i_family];
          Arcane::mesh::CellFamily * cell_family = changed_cell_data.cell_family;
          ENUMERATE_CELL(icell,cell_family->view(changed_cell_data.old_changed_cell_lids))
          {
            const Arcane::Cell & cell = *icell;
            Arcane::ItemInternal * cell_internal = cell.internal();
            cell_family->detachCell(cell_internal);
            cell_internal->unsetUniqueId(); // permet d'�viter que deux items aient le m�me uniqueId m�me temporairement
          }

        }

      //* 4- Ajout des nouvelles cellules
      {
        auto new_changed_cell_lids = _addCells(mesh,has_edge,
                                               changed_cell_uids,
                                               changed_cell_infos,
                                               changed_cell_connectivity_infos,
                                               changed_cell_connectivity_owners);
        m_updated_cells.setItems(new_changed_cell_lids);
      }


      // 4bis Cr�ation du tableau des faces ayant de nouveaux id

      bool cellTypeNotChanged = false;

      for(Arcane::Integer i_family = 0; i_family < changed_cell_data_size; ++i_family)
        {
          ChangedCellData & changed_cell_data = changed_cell_datas[i_family];
          Arcane::mesh::CellFamily * cell_family = changed_cell_data.cell_family;

          ENUMERATE_CELL(icell, cell_family->view(changed_cell_data.old_changed_cell_lids) )
          {
            const Arcane::Cell & old_cell = *icell;
            Arcane::ItemInternal * old_cell_internal = old_cell.internal();

            ItemGroupImpl * group = m_updated_cells.internal();

            Int32 index = group->itemsLocalId()[icell.index()];


            if ( index < cell_family->itemsInternal().size() )
              {
                const Arcane::Cell & newCell = cell_family->itemsInternal()[index];

                if ( old_cell_internal->typeId() == newCell->type() ) {

                    cellTypeNotChanged = true;

                    FaceVectorView facesOldCell = old_cell.faces();

                    FaceVectorView facesNewCell = newCell.faces();

                    int oldId,newId;

                    for (int i=0;i<facesOldCell.size();i++)
                      {
                        oldId = facesOldCell.localIds()[i];

                        newId = facesNewCell.localIds()[i];

                        if ( oldId != newId)
                          {
                            changed_face_datas[i_family].old_changed_face_lids.add(oldId);
                            changed_face_datas[i_family].new_changed_face_lids.add(newId);
                          }

                      }
                }

              }

          }

        }


      // 4ter Cr�ation du tableau des nodes ayant de nouveaux id


            for(Arcane::Integer i_family = 0; i_family < changed_cell_data_size; ++i_family)
              {
                ChangedCellData & changed_cell_data = changed_cell_datas[i_family];
                Arcane::mesh::CellFamily * cell_family = changed_cell_data.cell_family;

                ENUMERATE_CELL(icell, cell_family->view(changed_cell_data.old_changed_cell_lids) )
                {
                  const Arcane::Cell & old_cell = *icell;
                  Arcane::ItemInternal * old_cell_internal = old_cell.internal();

                  ItemGroupImpl * group = m_updated_cells.internal();

                  Int32 index = group->itemsLocalId()[icell.index()];


                  if ( index < cell_family->itemsInternal().size() )
                    {
                      const Arcane::Cell & newCell = cell_family->itemsInternal()[index];

                      if ( old_cell_internal->typeId() == newCell->type() ) {

                          NodeVectorView nodesOldCell = old_cell.nodes();

                          NodeVectorView nodesNewCell = newCell.nodes();

                          int oldId,newId;

                          for (int i=0;i<nodesOldCell.size();i++)
                            {
                              oldId = nodesOldCell.localIds()[i];

                              newId = nodesNewCell.localIds()[i];

                              if ( oldId != newId)
                                {
                                  changed_node_datas[i_family].old_changed_node_lids.add(oldId);
                                  changed_node_datas[i_family].new_changed_node_lids.add(newId);
                                }
                            }
                      }

                    }

                }

            }

            // 4quater Cr�ation du tableau des edges ayant de nouveaux id


            for(Arcane::Integer i_family = 0; i_family < changed_cell_data_size; ++i_family)
              {
                ChangedCellData & changed_cell_data = changed_cell_datas[i_family];
                Arcane::mesh::CellFamily * cell_family = changed_cell_data.cell_family;

                ENUMERATE_CELL(icell, cell_family->view(changed_cell_data.old_changed_cell_lids) )
                {
                  const Arcane::Cell & old_cell = *icell;
                  Arcane::ItemInternal * old_cell_internal = old_cell.internal();

                  ItemGroupImpl * group = m_updated_cells.internal();

                  Int32 index = group->itemsLocalId()[icell.index()];


                  if ( index < cell_family->itemsInternal().size() )
                    {
                      const Arcane::Cell & newCell = cell_family->itemsInternal()[index];

                      if ( old_cell_internal->typeId() == newCell->type() ) {

                          EdgeVectorView edgesOldCell = old_cell.edges();

                          EdgeVectorView edgesNewCell = newCell.edges();

                          int oldId,newId;

                          for (int i=0;i<edgesOldCell.size();i++)
                            {
                              oldId = edgesOldCell.localIds()[i];

                              newId = edgesNewCell.localIds()[i];

                              if ( oldId != newId)
                                {
                                  changed_edge_datas[i_family].old_changed_edge_lids.add(oldId);
                                  changed_edge_datas[i_family].new_changed_edge_lids.add(newId);
                                }
                            }
                      }

                    }

                }

              }

      //* 5- Conservation des groupes de cellules
      // On doit m�moriser les modifs avant les endUpdate (avec r�ordonnement pr�alable)
      for(Arcane::Integer i_family = 0; i_family < changed_cell_data_size; ++i_family)
        {
          ChangedCellData & changed_cell_data = changed_cell_datas[i_family];
          Arcane::mesh::ItemFamily * cell_family = changed_cell_data.cell_family;
          const auto & old_changed_cell_lids = changed_cell_data.old_changed_cell_lids;
          const auto & old_changed_cell_uids = changed_cell_data.old_changed_cell_uids;
          auto & new_changed_cell_lids = changed_cell_data.new_changed_cell_lids;

          new_changed_cell_lids = cell_family->infos().addedItems();
          Arcane::ItemInternalList internals = cell_family->itemsInternal();

          ARCANE_ASSERT((new_changed_cell_lids.size() == old_changed_cell_lids.size()),
                        ("Incoherent changed items size : %d vs %d",
                            new_changed_cell_lids.size(),old_changed_cell_lids.size()));
          const Arcane::Integer changed_cell_size = new_changed_cell_lids.size();
          std::map<Int64,Int32> uid_to_old_lid; // map pour r�ordonnement des new_cell_lids
          std::map<Int32, Int32> detached_cells_map; // map de transition old_lid -> new_lid
          for(Arcane::Integer i=0;i<changed_cell_size;++i)
            {
              const Arcane::Int32 new_cell_lid = new_changed_cell_lids[i];
              uid_to_old_lid[internals[new_cell_lid]->uniqueId()] = new_cell_lid;
            }
          for(Arcane::Integer i=0;i<changed_cell_size;++i)
            {
              const Arcane::Int32 old_cell_lid = old_changed_cell_lids[i];
              const Arcane::Int64 old_cell_uid = old_changed_cell_uids[i];
              std::map<Int64,Int32>::const_iterator finder = uid_to_old_lid.find(old_cell_uid);
              ARCANE_ASSERT((finder!=uid_to_old_lid.end()),("Cannot map old cell to new cell"));
              const Arcane::Int32 new_cell_lid = finder->second;
              new_changed_cell_lids[i] = new_cell_lid;
              detached_cells_map[old_cell_lid] = new_cell_lid;
            }

          Int32SharedArray new_cell_add, new_cell_del;
          new_cell_add.reserve(nb_changed_cells);
          new_cell_del.reserve(nb_changed_cells);
          Arcane::ItemGroupCollection coll = cell_family->groups();
          for (ItemGroupCollection::Iterator i = coll.begin(); i != coll.end(); ++i)
            {
              ItemGroup group = *i;
              if (group.isAllItems()) continue;
              if (group.internal()->hasComputeFunctor()) continue;
#ifdef ARCANE_DEBUG_ASSERT
              Integer group_size = group.size();
#endif
              new_cell_del.clear();
              new_cell_add.clear();
              ENUMERATE_CELL(icell,group)
                {
                  std::map<Int32, Int32>::const_iterator finder = detached_cells_map.find(icell.localId());
                  if (finder != detached_cells_map.end())
                    {
                      new_cell_del.add(finder->first);
                      new_cell_add.add(finder->second);
                    }
                }
              group.addItems(new_cell_add, false);

              if (!new_cell_del.empty())
                {
                  // group.localIdToIndex() reconstruit syst�matiquement la table, ce n'est donc pas un crit�re fiable quant � son existence
                  Int32SharedArray destination_remap, source_remap; // utilise une num�rotation en index (et non en localId pour les variables partielles)
                    
                  VariableList vars;
                  cell_family->usedVariables(vars);
                  for( VariableList::Enumerator i(vars); ++i; ){
                    IVariable* var = *i;
                    if (var->isPartial() and var->itemGroup() == group)
                      {
                        if (destination_remap.empty()) // lazy computation of remapping
                          {
                            GroupIndexTable & group_index_table = *group.localIdToIndex();
                            const Int32Array & destination = new_cell_add;
                            const Int32Array & source = new_cell_del;
                            ARCANE_ASSERT((source.size()==destination.size()),("Incompatible changed ids sizes"));
                            const Integer size = source.size();
                            destination_remap.resize(size);
                            source_remap.resize(size);

                            for(Integer i=0;i<size;++i) {
                              destination_remap[i] = group_index_table[destination[i]];
                              ARCANE_ASSERT((destination_remap[i] != -1),("Cannot find destination localId %d in group %s",destination[i],group.name().localstr()));
                              source_remap[i] = group_index_table[source[i]];
                              ARCANE_ASSERT((source_remap[i] != -1),("Cannot find source localId %d in group %s",source[i],group.name().localstr()));
                            }
                          }

                        debug(Trace::High) << "copyItemsValues on group " << group.name() << " partial variable '" << var->name() << "'";
                        var->copyItemsValues(source_remap, destination_remap);
                      }
                  }
                }

              group.removeItems(new_cell_del, true);
              ARCANE_ASSERT((group_size == group.size()),
                            ("Unconsistent size on group %s", group.name().localstr()));
            }
        }


      //* 5bis- Conservation des groupes de faces
      // On doit m�moriser les modifs avant les endUpdate (avec r�ordonnement pr�alable)

      bool twinFacesExist = false;

      if (cellTypeNotChanged == true)
      {

          for(Arcane::Integer i_family = 0; i_family < changed_face_data_size; ++i_family)
            {
              ChangedFaceData & changed_face_data = changed_face_datas[i_family];
              Arcane::mesh::ItemFamily * face_family = changed_face_data.face_family;
              const Arcane::Int32Array & old_changed_face_lids = changed_face_data.old_changed_face_lids;
              Arcane::Int32Array & new_changed_face_lids = changed_face_data.new_changed_face_lids;

              ARCANE_ASSERT((new_changed_face_lids.size() == old_changed_face_lids.size()),
                  ("Incoherent changed items size : %d vs %d",
                      new_changed_face_lids.size(),old_changed_face_lids.size()));
              const Arcane::Integer changed_face_size = new_changed_face_lids.size();

              std::map<Int32, Int32> detached_faces_map; // map de transition old_lid -> new_lid

              // twin faces

              std::set<Arcane::Int32> set_twin_faces;

              for(Arcane::Integer i=0;i<changed_face_size;++i)
                {
                  const Arcane::Int32 old_face_lid = old_changed_face_lids[i];

                  const Arcane::Int32 new_face_lid = new_changed_face_lids[i];

                  detached_faces_map[old_face_lid] = new_face_lid;

                  if ( i_family == 0 )
                    {
                      std::set<Int32>::const_iterator finder = faces_lid.find(new_face_lid);
                      if (finder == faces_lid.end())   // on sait que c'est une nouvelle face
                        {
                          // dans ce cas on peut l'initialiser avec l'ancienne face qu'elle remplace
                          set_twin_faces.insert(new_face_lid);
                        }
                      // sinon, elle porte d�j� des valeurs, on ne l'initialise pas
                    }
                }


              if (set_twin_faces.size() > 0)
                twinFacesExist = true;

              Arcane::Int32SharedArray twin_faces_lids;


              if ( i_family == 0 )
                {
                  twin_faces_lids.resize(set_twin_faces.size());

                  std::set<Arcane::Int32>::iterator it;

                  int count = 0;
                  for (it = set_twin_faces.begin(); it != set_twin_faces.end(); ++it)
                    {
                      twin_faces_lids[count] = *it;
                      count++;
                    }

                  twinfaces_uids.reserve(count);

                  Arcane::FaceVectorView nfaces( mesh->faceFamily()->itemsInternal(), twin_faces_lids);
                  twinfaces_uids = Arcane::Int64SharedArray(nfaces.size());
                  ENUMERATE_FACE(i_face, nfaces)
                  {
                    twinfaces_uids[i_face.index()] = (*i_face).uniqueId();
                  }
                }

              // parcours des groupes de faces

              Arcane::Int32UniqueArray new_face_add;
              Arcane::Int32UniqueArray old_face_del;

              new_face_add.reserve(changed_face_size);

              old_face_del.reserve(changed_face_size);

              Arcane::ItemGroupCollection coll = face_family->groups();
              for (ItemGroupCollection::Iterator i = coll.begin(); i != coll.end(); ++i)
                {
                  ItemGroup group = *i;
                  if (group.isAllItems()) continue;
                  if (group.internal()->hasComputeFunctor()) continue;
//#ifdef ARCANE_DEBUG_ASSERT
//                  Integer group_size = group.size();
//#endif

                  new_face_add.clear();
                  old_face_del.clear();

                  ENUMERATE_FACE(iface,group)
                  {
                    std::map<Int32, Int32>::const_iterator finder = detached_faces_map.find(iface.localId());
                    if (finder != detached_faces_map.end())
                      {
                        old_face_del.add(finder->first);
                        new_face_add.add(finder->second);
                      }
                  }

                  // restriction aux faces nouvellement apparues (resultan de noeuds splitt�s ou merg�s avec des noeuds existants)
                  Int32SharedArray new_face_add_reduced;
                  Int32SharedArray old_face_del_reduced;

                  new_face_add_reduced.resize(new_face_add.length());
                  old_face_del_reduced.resize(old_face_del.length());

                  int count = 0;
                  for(Int32 i=0;i<new_face_add.length();i++)
                    {
                      std::set<Int32>::const_iterator finder = faces_lid.find(new_face_add[i]);
                      if (finder == faces_lid.end())
                        {
                          new_face_add_reduced[count] = new_face_add[i];
                          old_face_del_reduced[count] = old_face_del[i];
                          count++;
                        }
                    }
                  new_face_add_reduced.resize(count);
                  old_face_del_reduced.resize(count);

                  typedef std::map<IVariable*, std::unique_ptr<ISerializer>> MapSerializer;
                  MapSerializer mapSerializer;


                  if (!old_face_del_reduced.empty())
                    {
                      // construit la liste des index des localids du tableau old_face_del_reduced

                      Int32SharedArray source_remap; // utilise une num�rotation en index (et non en localId pour les variables partielles)

                      GroupIndexTable & group_index_table = *group.localIdToIndex();

                      const Int32SharedArray & source = old_face_del_reduced;

                      const Integer size = source.size();

                      source_remap.resize(size);

                      for(Integer i=0;i<size;++i) {
                          source_remap[i] = group_index_table[source[i]];
                          ARCANE_ASSERT((source_remap[i] != -1),("Cannot find source localId %d in group %s",source[i],group.name().localstr()));
                      }

                      // parcours des variables

                      VariableList vars;
                      face_family->usedVariables(vars);

                      for( VariableList::Enumerator i(vars); ++i; ){
                          IVariable* variable = *i;
                          if (variable->isPartial() and variable->itemGroup() == group)
                            {
                              // On passe par un SerializeBuffer pour m�moriser les valeurs utiles depuis le IData de la variable
                              IData * data = variable->data();
                              data = variable->data();

                              std::unique_ptr<ISerializer> serializer(new SerializeBuffer());

                              serializer->setMode(ISerializer::ModeReserve);
                              data->serialize(serializer.get(),source_remap,0);
                              serializer->allocateBuffer();
                              serializer->setMode(ISerializer::ModePut);
                              data->serialize(serializer.get(), source_remap,0);

                              mapSerializer[variable] = std::move(serializer);

                            }
                      }
                    }

                  group.removeItems(old_face_del, true);

                  group.addItems(new_face_add, true);

                  group.internal()->localIdToIndex()->update();

                  if (!old_face_del_reduced.empty())
                    {
                      // construit la liste des index des localids du tableau new_face_add_reduced

                      Int32SharedArray destination_remap;

                      GroupIndexTable & group_index_table = *group.localIdToIndex();

                      const Int32SharedArray & destination = new_face_add_reduced;

                      const Integer size = destination.size();

                      destination_remap.resize(size);

                      for(Integer i=0;i<size;++i) {
                          destination_remap[i] = group_index_table[destination[i]];
                          ARCANE_ASSERT((destination_remap[i] != -1),("Cannot find destination localId %d in group %s",destination[i],group.name().localstr()));
                      }

                      VariableList vars;
                      face_family->usedVariables(vars);

                      for( VariableList::Enumerator i(vars); ++i; ){
                          IVariable* variable = *i;
                          if (variable->isPartial() and variable->itemGroup() == group)
                            {
                              IData * data = variable->data();
                              data = variable->data();

                              MapSerializer::const_iterator finder = mapSerializer.find(variable);

                              ARCANE_ASSERT((finder!=mapSerializer.end()),("Cannot find variable"));

                              const std::unique_ptr<ISerializer> & serializer = finder->second;

                              //std::unique_ptr<ISerializer> serializer = mapSerializer.find(variable)->second;

                              serializer->setMode(ISerializer::ModeGet);
                              data->serialize(serializer.get(), destination_remap,0);
                            }


                      }
                    }

                }
            }
      }

      //* 5ter- Conservation des groupes de nodes
      // On doit m�moriser les modifs avant les endUpdate (avec r�ordonnement pr�alable)

      bool twinNodesExist = false;

      if (cellTypeNotChanged == true)
      {

        for(Arcane::Integer i_family = 0; i_family < changed_node_data_size; ++i_family)
          {
            ChangedNodeData & changed_node_data = changed_node_datas[i_family];
            Arcane::mesh::ItemFamily * node_family = changed_node_data.node_family;
            const Arcane::Int32Array & old_changed_node_lids = changed_node_data.old_changed_node_lids;
            Arcane::Int32Array & new_changed_node_lids = changed_node_data.new_changed_node_lids;

            ARCANE_ASSERT((new_changed_node_lids.size() == old_changed_node_lids.size()),
                ("Incoherent changed items size : %d vs %d",
                    new_changed_node_lids.size(),old_changed_node_lids.size()));
            const Arcane::Integer changed_node_size = new_changed_node_lids.size();

            std::map<Int32, Int32> detached_nodes_map; // map de transition old_lid -> new_lid

            // twin nodes

            std::set<Arcane::Int32> set_twin_nodes;

            for(Arcane::Integer i=0;i<changed_node_size;++i)
              {
                const Arcane::Int32 old_node_lid = old_changed_node_lids[i];

                const Arcane::Int32 new_node_lid = new_changed_node_lids[i];

                detached_nodes_map[old_node_lid] = new_node_lid;

                if ( i_family == 0 )
                  {
                    std::set<Int32>::const_iterator finder = nodes_lid.find(new_node_lid);

                    if (finder == nodes_lid.end())   // on sait que c'est un nouveau noeud
                      {
                        // dans ce cas on peut l'initialiser avec l'ancien noeud qu'elle remplace
                        set_twin_nodes.insert(new_node_lid);
                      }
                    // sinon, elle porte d�j� des valeurs, on ne l'initialise pas
                  }

              }

            if (set_twin_nodes.size() > 0)
              twinNodesExist = true;

            Arcane::Int32SharedArray twin_nodes_lids;

            if ( i_family == 0 )
              {
                twin_nodes_lids.resize(set_twin_nodes.size());

                std::set<Arcane::Int32>::iterator it;

                int count = 0;
                for (it = set_twin_nodes.begin(); it != set_twin_nodes.end(); ++it)
                  {
                    twin_nodes_lids[count] = *it;
                    count++;
                  }

                twinnodes_uids.reserve(count);

                Arcane::NodeVectorView nnodes( mesh->nodeFamily()->itemsInternal(), twin_nodes_lids);
                twinnodes_uids = Arcane::Int64SharedArray(nnodes.size());
                ENUMERATE_NODE(i_node, nnodes)
                {
                  twinnodes_uids[i_node.index()] = (*i_node).uniqueId();
                }
              }

            // parcours des groupes de noeuds

            Arcane::Int32UniqueArray new_node_add;
            Arcane::Int32UniqueArray old_node_del;

            new_node_add.reserve(changed_node_size);

            old_node_del.reserve(changed_node_size);

            Arcane::ItemGroupCollection coll = node_family->groups();
            for (ItemGroupCollection::Iterator i = coll.begin(); i != coll.end(); ++i)
              {
                ItemGroup group = *i;
                if (group.isAllItems()) continue;
                if (group.internal()->hasComputeFunctor()) continue;
//#ifdef ARCANE_DEBUG_ASSERT
//                Integer group_size = group.size();
//#endif

                new_node_add.clear();
                old_node_del.clear();


                ENUMERATE_NODE(inode,group)
                {
                  std::map<Int32, Int32>::const_iterator finder = detached_nodes_map.find(inode.localId());
                  if (finder != detached_nodes_map.end())
                    {
                      old_node_del.add(finder->first);
                      new_node_add.add(finder->second);
                    }
                }

                group.addItems(new_node_add, true);

                // restriction aux noeuds nouvellement apparus (split)

                Int32SharedArray new_node_add_reduced;
                Int32SharedArray old_node_del_reduced;

                new_node_add_reduced.resize(new_node_add.length());
                old_node_del_reduced.resize(old_node_del.length());

                int count = 0;
                for(Int32 i=0;i<new_node_add.length();i++)
                  {
                    std::set<Int32>::const_iterator finder = nodes_lid.find(new_node_add[i]);
                    if (finder == nodes_lid.end())
                      {
                        new_node_add_reduced[count] = new_node_add[i];
                        old_node_del_reduced[count] = old_node_del[i];
                        count++;
                      }
                  }
                new_node_add_reduced.resize(count);
                old_node_del_reduced.resize(count);


                if (!old_node_del_reduced.empty())
                  {
                    // group.localIdToIndex() reconstruit syst�matiquement la table, ce n'est donc pas un crit�re fiable quant � son existence
                    Arcane::Int32UniqueArray destination_remap, source_remap; // utilise une num�rotation en index (et non en localId pour les variables partielles)

                    VariableList vars;
                    node_family->usedVariables(vars);
                    for( VariableList::Enumerator i(vars); ++i; ){
                        IVariable* var = *i;
                        if (var->isPartial() and var->itemGroup() == group)
                          {
                            if (destination_remap.empty()) // lazy computation of remapping
                              {
                                GroupIndexTable & group_index_table = *group.localIdToIndex();
                                const Int32Array & destination = new_node_add_reduced;
                                const Int32Array & source = old_node_del_reduced;
                                ARCANE_ASSERT((source.size()==destination.size()),("Incompatible changed ids sizes"));
                                const Integer size = source.size();
                                destination_remap.resize(size);
                                source_remap.resize(size);

                                for(Integer i=0;i<size;++i) {
                                    destination_remap[i] = group_index_table[destination[i]];
                                    ARCANE_ASSERT((destination_remap[i] != -1),("Cannot find destination localId %d in group %s",destination[i],group.name().localstr()));
                                    source_remap[i] = group_index_table[source[i]];
                                    ARCANE_ASSERT((source_remap[i] != -1),("Cannot find source localId %d in group %s",source[i],group.name().localstr()));
                                }
                              }

                            debug(Trace::High) << "copyItemsValues on group " << group.name() << " partial variable '" << var->name() << "'";
                            var->copyItemsValues(source_remap, destination_remap);
                          }
                    }
                  }

                group.removeItems(old_node_del, true);
                group.internal()->localIdToIndex()->update();

              }
          }
      }


      //* 5quater- Conservation des groupes de edges
      // On doit m�moriser les modifs avant les endUpdate (avec r�ordonnement pr�alable)

      bool twinEdgesExist = false;

      if (cellTypeNotChanged == true)
        {

          for(Arcane::Integer i_family = 0; i_family < changed_edge_data_size; ++i_family)
            {
              ChangedEdgeData & changed_edge_data = changed_edge_datas[i_family];
              Arcane::mesh::ItemFamily * edge_family = changed_edge_data.edge_family;
              const Arcane::Int32Array & old_changed_edge_lids = changed_edge_data.old_changed_edge_lids;
              Arcane::Int32Array & new_changed_edge_lids = changed_edge_data.new_changed_edge_lids;

              ARCANE_ASSERT((new_changed_edge_lids.size() == old_changed_edge_lids.size()),
                  ("Incoherent changed items size : %d vs %d",
                      new_changed_edge_lids.size(),old_changed_edge_lids.size()));
              const Arcane::Integer changed_edge_size = new_changed_edge_lids.size();

              std::map<Int32, Int32> detached_edges_map; // map de transition old_lid -> new_lid

              for(Arcane::Integer i=0;i<changed_edge_size;++i)
                {
                  const Arcane::Int32 old_edge_lid = old_changed_edge_lids[i];

                  const Arcane::Int32 new_edge_lid = new_changed_edge_lids[i];

                  detached_edges_map[old_edge_lid] = new_edge_lid;
                }

              if (!detached_edges_map.empty())
                twinEdgesExist = true;

              Int32SharedArray new_edge_add;
              Int32SharedArray old_edge_del;

              new_edge_add.reserve(changed_edge_size);

              old_edge_del.reserve(changed_edge_size);

              Arcane::ItemGroupCollection coll = edge_family->groups();
              for (ItemGroupCollection::Iterator i = coll.begin(); i != coll.end(); ++i)
                {
                  ItemGroup group = *i;
                  if (group.isAllItems()) continue;
                  if (group.internal()->hasComputeFunctor()) continue;
//#ifdef ARCANE_DEBUG_ASSERT
//                  Integer group_size = group.size();
//#endif

                  new_edge_add.clear();
                  old_edge_del.clear();

                  ENUMERATE_EDGE(iedge,group)
                  {
                    std::map<Int32, Int32>::const_iterator finder = detached_edges_map.find(iedge.localId());
                    if (finder != detached_edges_map.end())
                      {
                        old_edge_del.add(finder->first);
                        new_edge_add.add(finder->second);
                      }
                  }

                  group.addItems(new_edge_add, true);

                  // restriction aux edges nouvellement apparus (split)

                  Int32SharedArray new_edge_add_reduced;
                  Int32SharedArray old_edge_del_reduced;

                  new_edge_add_reduced.resize(new_edge_add.length());
                  old_edge_del_reduced.resize(old_edge_del.length());

                  int count = 0;
                  for(Int32 i=0;i<new_edge_add.length();i++)
                    {
                      std::set<Int32>::const_iterator finder = edges_lid.find(new_edge_add[i]);
                      if (finder == edges_lid.end())
                        {
                          new_edge_add_reduced[count] = new_edge_add[i];
                          old_edge_del_reduced[count] = old_edge_del[i];
                          count++;
                        }
                    }
                  new_edge_add_reduced.resize(count);
                  old_edge_del_reduced.resize(count);


                  if (!old_edge_del_reduced.empty())
                    {
                      // group.localIdToIndex() reconstruit syst�matiquement la table, ce n'est donc pas un crit�re fiable quant � son existence
                      Arcane::Int32UniqueArray destination_remap, source_remap; // utilise une num�rotation en index (et non en localId pour les variables partielles)

                      VariableList vars;
                      edge_family->usedVariables(vars);
                      for( VariableList::Enumerator i(vars); ++i; ){
                          IVariable* var = *i;
                          if (var->isPartial() and var->itemGroup() == group)
                            {
                              if (destination_remap.empty()) // lazy computation of remapping
                                {
                                  GroupIndexTable & group_index_table = *group.localIdToIndex();
                                  const Int32Array & destination = new_edge_add_reduced;
                                  const Int32Array & source = old_edge_del_reduced;
                                  ARCANE_ASSERT((source.size()==destination.size()),("Incompatible changed ids sizes"));
                                  const Integer size = source.size();
                                  destination_remap.resize(size);
                                  source_remap.resize(size);

                                  for(Integer i=0;i<size;++i) {
                                      destination_remap[i] = group_index_table[destination[i]];
                                      ARCANE_ASSERT((destination_remap[i] != -1),("Cannot find destination localId %d in group %s",destination[i],group.name().localstr()));
                                      source_remap[i] = group_index_table[source[i]];
                                      ARCANE_ASSERT((source_remap[i] != -1),("Cannot find source localId %d in group %s",source[i],group.name().localstr()));
                                  }
                                }

                              debug(Trace::High) << "copyItemsValues on group " << group.name() << " partial variable '" << var->name() << "'";
                              var->copyItemsValues(source_remap, destination_remap);
                            }
                      }
                    }

                  group.removeItems(old_edge_del, true);
                  group.internal()->localIdToIndex()->update();

                }
            }

        }


      { // Les faces ...
        Arcane::mesh::FaceFamily * faceFamily = dynamic_cast<Arcane::mesh::FaceFamily*> (mesh->faceFamily());
        const Arcane::mesh::DynamicMeshKindInfos & infos = faceFamily->infos();
        Arcane::Int32ConstArrayView addedFaces = infos.addedItems();

        Arcane::FaceVectorView nfaces( mesh->faceFamily()->itemsInternal(), addedFaces);
        newfacesOfChangedCells = Arcane::Int64SharedArray(nfaces.size());

        ENUMERATE_FACE(i_face, nfaces)
        {
          newfacesOfChangedCells[i_face.index()] = (*i_face).uniqueId();
        }

      }

      { // Les noeuds ...
        Arcane::mesh::NodeFamily * nodeFamily = dynamic_cast<Arcane::mesh::NodeFamily*> (mesh->nodeFamily());
        const Arcane::mesh::DynamicMeshKindInfos & infos = nodeFamily->infos();
        Arcane::Int32ConstArrayView addedNodes = infos.addedItems();

        Arcane::NodeVectorView nnodes( mesh->nodeFamily()->itemsInternal(), addedNodes);
        newnodesOfChangedCells = Arcane::Int64SharedArray(nnodes.size());

        ENUMERATE_NODE(i_node, nnodes)
        {
          newnodesOfChangedCells[i_node.index()] = (*i_node).uniqueId();
        }

      }

      { // Les edges ...
        Arcane::mesh::EdgeFamily * edgeFamily = dynamic_cast<Arcane::mesh::EdgeFamily*> (mesh->edgeFamily());
        const Arcane::mesh::DynamicMeshKindInfos & infos = edgeFamily->infos();
        Arcane::Int32ConstArrayView addededges = infos.addedItems();

        Arcane::EdgeVectorView nedges( mesh->edgeFamily()->itemsInternal(), addededges);
        newedgesOfChangedCells = Arcane::Int64SharedArray(nedges.size());

        ENUMERATE_EDGE(i_edge, nedges)
        {
          newedgesOfChangedCells[i_edge.index()] = (*i_edge).uniqueId();
        }

      }

      //* 6- Mise � jour de la famille de cellules

      for(Arcane::Integer i_family = 0; i_family < changed_cell_data_size; ++i_family)
        {
          ChangedCellData & changed_cell_data = changed_cell_datas[i_family];
          Arcane::IItemFamily * cell_family = changed_cell_data.cell_family;
          cell_family->partialEndUpdate();
#ifdef USE_ARCANE_V3
          cell_family->resizeVariables(true);
#else
	  cell_family->resizeVariables();
#endif
        }

      //* 6bis- Mise � jour de la famille de faces

      for(Arcane::Integer i_family = 0; i_family < changed_face_data_size; ++i_family)
        {
          ChangedFaceData & changed_face_data = changed_face_datas[i_family];
          Arcane::IItemFamily * face_family = changed_face_data.face_family;
          face_family->partialEndUpdate();
#ifdef USE_ARCANE_V3
          face_family->resizeVariables(true);
#else
	  face_family->resizeVariables();
#endif
        }

      //* 6ter- Mise � jour de la famille de noeuds

      for(Arcane::Integer i_family = 0; i_family < changed_node_data_size; ++i_family)
        {
          ChangedNodeData & changed_node_data = changed_node_datas[i_family];
          Arcane::IItemFamily * node_family = changed_node_data.node_family;
          node_family->partialEndUpdate();
#ifdef USE_ARCANE_V3
          node_family->resizeVariables(true);
#else
	  node_family->resizeVariables();
#endif
        }

      //* 6quater- Mise � jour de la famille de edges

      for(Arcane::Integer i_family = 0; i_family < changed_edge_data_size; ++i_family)
        {
          ChangedEdgeData & changed_edge_data = changed_edge_datas[i_family];
          Arcane::IItemFamily * edge_family = changed_edge_data.edge_family;
          edge_family->partialEndUpdate();
#ifdef USE_ARCANE_V3
          edge_family->resizeVariables(true);
#else
	  edge_family->resizeVariables();
#endif
        }

      //* 7- Copie des valeurs aux mailles aux nouveaux emplacements
      // Warning up to now this option does not work for ItemGroupMap as it is not a IVariable
      // therefore copyItemValues has no action on it
      for(Integer i_family = 0; i_family < changed_cell_data_size; ++i_family)
        {
          ChangedCellData & changed_cell_data = changed_cell_datas[i_family];
          IItemFamily * cell_family = changed_cell_data.cell_family;
          // On n'utilise pas directement IItemFamily::copyItemValues qui ne g�re pas correctement les variables en plus 
          // de ne pas �tre adapt� au cas actuel o� les groupes ont d�j� �t� retaill�s
          debug() << "copyItemsValues on family " << cell_family->name() << " " << cell_family->mesh()->name();

          VariableList vars;
          cell_family->usedVariables(vars);
          for( VariableList::Enumerator i(vars); ++i; ){
              IVariable* var = *i;
              if (!var->isPartial())
                {
                  debug(Trace::High) << "copyItemsValues full variable '" << var->name() << "'";
                  var->copyItemsValues(changed_cell_data.old_changed_cell_lids, changed_cell_data.new_changed_cell_lids);
                }
          }
        }


      //* 7bis- Copie des valeurs aux faces aux nouveaux emplacements
      // Warning up to now this option does not work for ItemGroupMap as it is not a IVariable
      // therefore copyItemValues has no action on it
      if (cellTypeNotChanged == true  && twinFacesExist == true )
        {
          for(Integer i_family = 0; i_family < changed_face_data_size; ++i_family)
            {
              ChangedFaceData & changed_face_data = changed_face_datas[i_family];
              IItemFamily * face_family = changed_face_data.face_family;
              // On n'utilise pas directement IItemFamily::copyItemValues qui ne g�re pas correctement les variables en plus
              // de ne pas �tre adapt� au cas actuel o� les groupes ont d�j� �t� retaill�s
              debug() << "copyItemsValues on family " << face_family->name() << " " << face_family->mesh()->name();

              // restriction aux faces nouvellement apparues (split)

              Arcane::Int32UniqueArray old_changed_face_lids;
              Arcane::Int32UniqueArray new_changed_face_lids;

              old_changed_face_lids.resize(changed_face_data.old_changed_face_lids.length());
              new_changed_face_lids.resize(changed_face_data.new_changed_face_lids.length());

              Int32 count=0;
              for(int i=0;i<changed_face_data.new_changed_face_lids.length();i++)
                {
                  Int32 face_id = changed_face_data.new_changed_face_lids[i];

                  std::set<Int32>::const_iterator finder = faces_lid.find(face_id);
                  if (finder == faces_lid.end())
                    {
                      old_changed_face_lids[count] = changed_face_data.old_changed_face_lids[i] ;
                      new_changed_face_lids[count] = changed_face_data.new_changed_face_lids[i] ;
                      count++;
                    }

                }
              old_changed_face_lids.resize(count);
              new_changed_face_lids.resize(count);

              if (count > 0)
                {
                  VariableList vars;
                  face_family->usedVariables(vars);
                  for( VariableList::Enumerator i(vars); ++i; ){
                      IVariable* var = *i;
                      if (!var->isPartial())
                        {
                          debug(Trace::High) << "copyItemsValues full variable '" << var->name() << "'";
                          var->copyItemsValues(old_changed_face_lids, new_changed_face_lids);

                        }
                  }
                }
            }
        }

      //* 7ter- Copie des valeurs aux noeuds aux nouveaux emplacements
      // Warning up to now this option does not work for ItemGroupMap as it is not a IVariable
      // therefore copyItemValues has no action on it

      if (cellTypeNotChanged == true && twinNodesExist == true)
        {
          for(Integer i_family = 0; i_family < changed_node_data_size; ++i_family)
            {
              ChangedNodeData & changed_node_data = changed_node_datas[i_family];
              IItemFamily * node_family = changed_node_data.node_family;
              // On n'utilise pas directement IItemFamily::copyItemValues qui ne g�re pas correctement les variables en plus
              // de ne pas �tre adapt� au cas actuel o� les groupes ont d�j� �t� retaill�s
              debug() << "copyItemsValues on family " << node_family->name() << " " << node_family->mesh()->name();


              // restriction aux noeuds nouvellement apparus (split)

              Arcane::Int32UniqueArray old_changed_node_lids;
              Arcane::Int32UniqueArray new_changed_node_lids;

              old_changed_node_lids.resize(changed_node_data.old_changed_node_lids.length());
              new_changed_node_lids.resize(changed_node_data.new_changed_node_lids.length());

              Int32 count=0;
              for(int i=0;i<changed_node_data.new_changed_node_lids.length();i++)
                {
                  Int32 node_id = changed_node_data.new_changed_node_lids[i];
                  std::set<Int32>::const_iterator finder = nodes_lid.find(node_id);
                  if (finder == nodes_lid.end())
                    {
                      old_changed_node_lids[count] = changed_node_data.old_changed_node_lids[i] ;
                      new_changed_node_lids[count] = changed_node_data.new_changed_node_lids[i] ;
                      count++;
                    }

                }
              old_changed_node_lids.resize(count);
              new_changed_node_lids.resize(count);

              if (count > 0)
                {
                  VariableList vars;
                  node_family->usedVariables(vars);
                  for( VariableList::Enumerator i(vars); ++i; ){
                      IVariable* var = *i;
                      if (!var->isPartial())
                        {
                          debug(Trace::High) << "copyItemsValues full variable '" << var->name() << "'";
                          //var->copyItemsValues(changed_node_data.old_changed_node_lids, changed_node_data.new_changed_node_lids);
                          var->copyItemsValues(old_changed_node_lids, new_changed_node_lids);
                        }
                  }
                }
            }
        }

      //* 7quater- Copie des valeurs aux edges aux nouveaux emplacements
      // Warning up to now this option does not work for ItemGroupMap as it is not a IVariable
      // therefore copyItemValues has no action on it

      if (cellTypeNotChanged == true && twinEdgesExist == true)
        {
          for(Integer i_family = 0; i_family < changed_edge_data_size; ++i_family)
            {
              ChangedEdgeData & changed_edge_data = changed_edge_datas[i_family];
              IItemFamily * edge_family = changed_edge_data.edge_family;
              // On n'utilise pas directement IItemFamily::copyItemValues qui ne g�re pas correctement les variables en plus
              // de ne pas �tre adapt� au cas actuel o� les groupes ont d�j� �t� retaill�s
              debug() << "copyItemsValues on family " << edge_family->name() << " " << edge_family->mesh()->name();

              // restriction aux edges nouvellement apparus (split)

              Arcane::Int32UniqueArray old_changed_edge_lids;
              Arcane::Int32UniqueArray new_changed_edge_lids;

              old_changed_edge_lids.resize(changed_edge_data.old_changed_edge_lids.length());
              new_changed_edge_lids.resize(changed_edge_data.new_changed_edge_lids.length());

              Int32 count=0;
              for(int i=0;i<changed_edge_data.new_changed_edge_lids.length();i++)
                {
                  Int32 edge_id = changed_edge_data.new_changed_edge_lids[i];
                  std::set<Int32>::const_iterator finder = edges_lid.find(edge_id);
                  if (finder == edges_lid.end())
                    {
                      old_changed_edge_lids[count] = changed_edge_data.old_changed_edge_lids[i] ;
                      new_changed_edge_lids[count] = changed_edge_data.new_changed_edge_lids[i] ;
                      count++;
                    }

                }
              old_changed_edge_lids.resize(count);
              new_changed_edge_lids.resize(count);

              if (count > 0)
                {
                  VariableList vars;
                  edge_family->usedVariables(vars);
                  for( VariableList::Enumerator i(vars); ++i; ){
                      IVariable* var = *i;
                      if (!var->isPartial())
                        {
                          debug(Trace::High) << "copyItemsValues full variable '" << var->name() << "'";
                          //var->copyItemsValues(changed_edge_data.old_changed_edge_lids, changed_edge_data.new_changed_edge_lids);
                          var->copyItemsValues(old_changed_edge_lids, new_changed_edge_lids);
                        }
                  }
                }
            }
        }

      // Traitement des nouvelles cellules
      if (global_has_cell_to_add)
        {
          auto new_lids = _addCells(mesh,has_edge,
              new_cell_uids,
              new_cell_infos,
              new_cell_connectivity_infos,
              new_cell_connectivity_owners);
          m_new_cells.setItems(new_lids);

          topology_has_changed = true;
        }

      //* 8- Suppression des cellules d�tach�es
      for(Arcane::Integer i_family = 0; i_family < changed_cell_data_size; ++i_family)
        {
          ChangedCellData & changed_cell_data = changed_cell_datas[i_family];
          const Arcane::Int32Array & old_changed_cell_lids = changed_cell_data.old_changed_cell_lids;
          const Arcane::Int64Array & old_changed_cell_uids = changed_cell_data.old_changed_cell_uids;
          Arcane::mesh::CellFamily * cell_family = changed_cell_data.cell_family;
          Arcane::ItemInternalList internals = cell_family->itemsInternal();

          for(Arcane::Integer i=0;i<old_changed_cell_lids.size(); ++i)
            {
              Arcane::ItemInternal * deleted_cell = internals[old_changed_cell_lids[i]];
              debug() << "Update Cell info : uid=" << old_changed_cell_uids[i]
                                                                            << " old_lid=" << deleted_cell->localId() << " new_lid=" << changed_cell_data.new_changed_cell_lids[i];
              cell_family->removeDetachedCell(deleted_cell);
            }
        }
      topology_has_changed = true;

    }

  // Traitement des nouvelles cellules
  if (global_has_cell_to_add && topology_has_changed == false)
    {
      auto new_lids = _addCells(mesh,has_edge,
                                              new_cell_uids,
                                              new_cell_infos,
                                              new_cell_connectivity_infos,
                                              new_cell_connectivity_owners);
      m_new_cells.setItems(new_lids);

      topology_has_changed = true;
    }

   // Suppression effective
   if (global_has_cell_to_remove)
    {
#ifdef USE_EVOLUTIF
      notifyEvolutiveMeshObservers(IEvolutiveMesh::BeforeDeletion);
#endif
      // La Mise � jour des propri�taires est maintenant faite au 3- avant le d�tachement des cellules (une fois les cellules d�tach�es, on perd l'information de leur connectivit�...)

      // Suppression effective des cellules
      m_old_cells.clear();

      for(Arcane::Integer i_family = 0; i_family < removed_cell_datas_size; ++i_family)
        {
          RemovedCellData & removed_cell_data = removed_cell_datas[i_family];
          const Arcane::Int32Array & old_removed_cell_lids = removed_cell_data.old_removed_cell_lids;
          const Arcane::Int64Array & old_removed_cell_uids = removed_cell_data.old_removed_cell_uids;
          Arcane::mesh::CellFamily * cell_family = removed_cell_data.cell_family;
          Arcane::ItemInternalList internals = cell_family->itemsInternal();

          for(Arcane::Integer i=0;i<old_removed_cell_lids.size(); ++i)
            {
              Arcane::ItemInternal * deleted_cell = internals[old_removed_cell_lids[i]];
              debug() << "Delete Cell info : uid=" << old_removed_cell_uids[i]
                      << " old_lid=" << deleted_cell->localId() << " old_lid=" << removed_cell_data.old_removed_cell_lids[i];
              cell_family->removeDetachedCell(deleted_cell);
            }
        }

      topology_has_changed = true;
    }


  if (topology_has_changed)
    {
      // Affectation du groupe de nouveaux noeuds

      { // Les cellules ...
        Arcane::mesh::CellFamily * cellFamily = dynamic_cast<Arcane::mesh::CellFamily*> (mesh->cellFamily());
        cellFamily->partialEndUpdate();
        // On connait d�j� le groupe, ce n'est que pour la pr�paration au endUpdate
      }


      { // Les faces ...
        Arcane::mesh::FaceFamily * faceFamily = dynamic_cast<Arcane::mesh::FaceFamily*> (mesh->faceFamily());
        const Arcane::mesh::DynamicMeshKindInfos & infos = faceFamily->infos();
        Arcane::Int32ConstArrayView addedFaces = infos.addedItems();
        m_new_faces.setItems(addedFaces);

        Arcane::Int32SharedArray  newfaces_lids(newfacesOfChangedCells.size());
        faceFamily->itemsUniqueIdToLocalId(newfaces_lids, newfacesOfChangedCells, check);

        // suppress twinfaces_lids from newfaces_lids

        Arcane::Int32SharedArray  twinfaces_lids(twinfaces_uids.size());

        std::set<Arcane::Int32> set_twin_faces;

        if (twinfaces_uids.size() > 0)
          {
            faceFamily->itemsUniqueIdToLocalId(twinfaces_lids, twinfaces_uids, check);

            m_twin_faces.setItems(twinfaces_lids);

            Arcane::Int32SharedArray::iterator it1;
            for (it1 = twinfaces_lids.begin(); it1 != twinfaces_lids.end(); ++it1)
              {
                set_twin_faces.insert(*it1);
              }
          }

        if (newfaces_lids.size() > 0)
          {
            if ( twinfaces_uids.size() > 0 )
              {

                Arcane::Int32SharedArray otherAddedFaces;
                otherAddedFaces.resize(newfaces_lids.size());

                int count = 0;

                Arcane::Int32SharedArray::iterator it;
                for (it = newfaces_lids.begin(); it != newfaces_lids.end(); ++it)
                  {
                    std::set<Arcane::Int32>::const_iterator finder = set_twin_faces.find(*it);
                    if (finder == set_twin_faces.end())
                      {
                        otherAddedFaces[count] = *it;
                        count++;
                      }
                  }

                otherAddedFaces.resize(count);

                m_new_faces.addItems(otherAddedFaces);
              }
            else
              m_new_faces.addItems(newfaces_lids);
          }

        faceFamily->partialEndUpdate();
      }



      { // Les ar�tes ...
        Arcane::mesh::EdgeFamily * edgeFamily = dynamic_cast<Arcane::mesh::EdgeFamily*> (mesh->edgeFamily());
        const Arcane::mesh::DynamicMeshKindInfos & infos = edgeFamily->infos();
        Arcane::Int32ConstArrayView addedEdges = infos.addedItems();
        m_new_edges.setItems(addedEdges);

        Arcane::Int32SharedArray  newedges_lids(newedgesOfChangedCells.size());

        edgeFamily->itemsUniqueIdToLocalId(newedges_lids, newedgesOfChangedCells, check);
        m_twin_edges.setItems(newedges_lids);

        //edgeFamily->partialEndUpdate();
      }


      { // Les noeuds ...
        Arcane::mesh::NodeFamily * nodeFamily = dynamic_cast<Arcane::mesh::NodeFamily*> (mesh->nodeFamily());
        const Arcane::mesh::DynamicMeshKindInfos & infos = nodeFamily->infos();
        Arcane::Int32ConstArrayView addedNodes = infos.addedItems();

        m_new_nodes.setItems(addedNodes);

        Arcane::Int32SharedArray  newnodes_lids(newnodesOfChangedCells.size());
        nodeFamily->itemsUniqueIdToLocalId(newnodes_lids, newnodesOfChangedCells, check);

        // suppress twinnodes_lids from newnodes_lids

        Arcane::Int32SharedArray  twinnodes_lids(twinnodes_uids.size());

        std::set<Arcane::Int32> set_twin_nodes;

        if (twinnodes_uids.size() > 0)
          {
            nodeFamily->itemsUniqueIdToLocalId(twinnodes_lids, twinnodes_uids, check);

            m_twin_nodes.setItems(twinnodes_lids);

            Arcane::Int32SharedArray::iterator it1;
            for (it1 = twinnodes_lids.begin(); it1 != twinnodes_lids.end(); ++it1)
              {
                set_twin_nodes.insert(*it1);
              }
          }

        if (newnodes_lids.size() > 0)
          {
            if ( twinnodes_uids.size() > 0 )
              {

                Arcane::Int32SharedArray otherAddedNodes;
                otherAddedNodes.resize(newnodes_lids.size());

                int count = 0;

                Arcane::Int32SharedArray::iterator it;
                for (it = newnodes_lids.begin(); it != newnodes_lids.end(); ++it)
                  {
                    std::set<Arcane::Int32>::const_iterator finder = set_twin_nodes.find(*it);
                    if (finder == set_twin_nodes.end())
                      {
                        otherAddedNodes[count] = *it;
                        count++;
                      }
                  }

                otherAddedNodes.resize(count);

                m_new_nodes.addItems(otherAddedNodes);
              }
            else
              m_new_nodes.addItems(newnodes_lids);
          }


        nodeFamily->partialEndUpdate();
      }



      if (m_parallel_mng->commSize() > 1)
        {
          const Arcane::Integer sid = m_parallel_mng->commRank();

          if (not changed_cell_owners.empty())
            ENUMERATE_CELL(icell,m_updated_cells)
              (*icell).internal()->setOwner(changed_cell_owners[icell.index()],sid);

          if (not new_cell_owners.empty())
            ENUMERATE_CELL(icell,m_new_cells)
              (*icell).internal()->setOwner(new_cell_owners[icell.index()],sid);
        }

      // Mise � jour finale du maillage
      mesh->modifier()->endUpdate(true, true); // recalcul des ghosts avec suppression des anciens
      // Localiser proprement (mixer avec _manageMeshConstraints) un bon recalcul des fantomes avant extra-fantomes


    }

  return topology_has_changed;
}
/*---------------------------------------------------------------------------*/
bool
ArcGeoSim::IXMMeshBuilderBase::
manageUpdatedNodes(IPrimaryMesh * mesh,
                   const ArcGeoSim::IXMTools::IXMNodeData& added_nodes,
                   const ArcGeoSim::IXMTools::IXMClonedNodeData& cloned_nodes,
                   const bool check)
{
  // Working arrays
  const Arcane::Int64ConstArrayView clone_update_node_uids = cloned_nodes.item_ids;
  const Arcane::Int64ConstArrayView clone_update_node_cloned_uids = cloned_nodes.item_infos;
  const Arcane::Int64ConstArrayView coord_update_node_uids = added_nodes.item_ids;
  const Arcane::Real3ConstArrayView coord_update_node_coords = added_nodes.item_infos;

  // fixme: Bizarre qu'il n'y ait pas besoin de traitement sp�cial de forecast_compute ici
  Arcane::Int64SharedArray all_uids;
  all_uids.addRange(coord_update_node_uids);
  all_uids.addRange(clone_update_node_uids);
  all_uids.addRange(clone_update_node_cloned_uids);

  Arcane::Int32SharedArray all_lids(all_uids.size());
  mesh->nodeFamily()->itemsUniqueIdToLocalId(all_lids, all_uids, true);

  const Arcane::Integer coord_update_node_count = coord_update_node_uids.size();
  const Arcane::Integer clone_update_node_count = clone_update_node_uids.size();
  const Arcane::Integer update_node_count = coord_update_node_count + clone_update_node_count;

  if (check)
    {
      /* Les contr�les v�rifient:
       * - les doublons dans les noeuds mis � jour par coordonn�es
       * - les doublons dans les noeuds mis � jour par clone
       * - les doubles mises � jour
       * - les auto-clones (clones d'eux m�mes)
       * - les nouveaux noeuds jamais mis � jour
       * - la connectivit� entre les noeuds mis � jour par clone (ils doivent �tre voisins, ici par face)
       */
      bool has_error = false;
      typedef std::set<Int64> Int64Set;
      typedef std::pair<std::set<Int64>::iterator,bool> Int64Inserter;
      Int64Set new_nodes;
      ENUMERATE_NODE(inode,m_new_nodes) new_nodes.insert(inode->uniqueId());
      Int64Set updated_nodes;
      for(Arcane::Integer i=0;i<coord_update_node_count;++i)
        {
          Int64Inserter ret = updated_nodes.insert(coord_update_node_uids[i]);
          if (ret.second == false) // already exists
            {
              error() << "Duplicated updated node " << coord_update_node_uids[i];
              has_error = true;
            }
        }
      for(Arcane::Integer i=0;i<clone_update_node_count;++i)
        {
          Int64Inserter ret = updated_nodes.insert(clone_update_node_uids[i]);
          if (ret.second == false) // already exists
            {
              error() << "Duplicated updated node " << clone_update_node_uids[i];
              has_error = true;
            }
        }
      for(Arcane::Integer i=0;i<clone_update_node_count;++i)
        {
          Int64Set::iterator finder = updated_nodes.find(clone_update_node_cloned_uids[i]);
          if (finder != updated_nodes.end())
            {
              warning() << "Overwritten clone " << clone_update_node_uids[i] << " while updating nodes";
//#ifndef NO_USER_WARNING
//#ifndef WIN32
//#warning"TODO: Modifier le controle noeud-clones, noeud updates pour eviter les cycles"
//#endif
//#endif
              // has_error = true;
            }
        }
      for(Arcane::Integer i=0;i<clone_update_node_count;++i)
        {
          if (clone_update_node_uids[i] == clone_update_node_cloned_uids[i])
            {
              error() << "Self-cloned node " << clone_update_node_uids[i];
              has_error = true;
            }
        }

      Int64Set not_updated_new_nodes;
      std::set_difference(new_nodes.begin(), new_nodes.end(),
                          updated_nodes.begin(), updated_nodes.end(),
                          std::inserter(not_updated_new_nodes, not_updated_new_nodes.begin()));
      if (not not_updated_new_nodes.empty())
        {
          has_error = true;
          for(Int64Set::iterator i=not_updated_new_nodes.begin(); i != not_updated_new_nodes.end(); ++i)
            {

              Arcane::mesh::NodeFamily * nodefamily = dynamic_cast<Arcane::mesh::NodeFamily*>(mesh->nodeFamily());
              ItemInternal * item = nodefamily->findOneItem(*i);
              info() << "Error = " << FullItemPrinter(item);

              ItemVectorView cells_view = Node(item).cells();

              ENUMERATE_CELL(icell, cells_view)
              {
                info() << "Cell Error = " << FullItemPrinter(*icell);
              }

              error() << "New node " << (*i) << " has not been updated";
            }
        }

      Arcane::NodeVectorView nodes = mesh->nodeFamily()->view(all_lids.subConstView(coord_update_node_count,clone_update_node_count));
      Arcane::NodeVectorView cloned_nodes = mesh->nodeFamily()->view(all_lids.subConstView(coord_update_node_count+clone_update_node_count,clone_update_node_count));
      for(Arcane::Integer i=0;i<clone_update_node_count;++i)
        {
          const Arcane::Node & node = nodes[i];
          const Arcane::Node & cloned_node = cloned_nodes[i];
          bool neighbor_found = false;
          ENUMERATE_FACE(iface,node.faces())
            {
              ENUMERATE_NODE(inode,iface->nodes())
               {
                  neighbor_found |= (*inode == cloned_node);
                  if (neighbor_found) break;
               }
              if (neighbor_found) break;
            }
          if (not neighbor_found)
            {
              error() << "Updated node " << node.uniqueId() << " is not a neighbor of its clone reference node " << cloned_node.uniqueId();
              has_error = true;
            }
        }

      if (has_error)
        fatal() << "Update node error : see error(s) above";
    }

  m_updated_nodes.setItems(all_lids.subConstView(0,update_node_count));

#ifdef USE_EVOLUTIF
  notifyEvolutiveMeshObservers(IEvolutiveMesh::BeforeUpdateNode);
#endif
  Arcane::VariableNodeReal3 varCoordinates = mesh->nodesCoordinates();
  Arcane::ArrayView<Real3> arrayCoordinates = varCoordinates.asArray();

  // Use order in all_uids to treat nodes. Coord update note first.
  for(Arcane::Integer i=0;i<coord_update_node_count;++i)
    {
      arrayCoordinates[all_lids[i]] = coord_update_node_coords[i];
    }

  // Then clone update node.
  for(Arcane::Integer i=coord_update_node_count, i_clone=update_node_count;i<update_node_count;++i, ++i_clone)
    {
      arrayCoordinates[all_lids[i]] = arrayCoordinates[all_lids[i_clone]];
    }

#ifndef NDEBUG
        Arcane::Integer n = varCoordinates.checkIfSync(10);
        if (n != 0) throw Arcane::InternalErrorException(A_FUNCINFO,"Coordinates not synchronized after update-nodes");
#endif /* NDEBUG */

  bool topology_has_changed = m_parallel_utils.collectiveOr(update_node_count > 0);
  // La modification update-nodes est elle une modification topologique.
  return topology_has_changed;
}
/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMMeshBuilderBase::
manageGroup(IMesh* mesh, 
            const ArcGeoSim::IXMTools::IXMGroupData group_data,
            const Arcane::String& group_mode,
            const IXMUidToLidMng& uid2lid_mng,
            const bool check)
{
  // Data
  Arcane::Int64ConstArrayView all_uids = group_data.ids;
  const Arcane::String& group_name = group_data.name;
  Arcane::eItemKind item_kind = group_data.kind;

  // Treat group section
  const Integer all_uid_count= all_uids.size();
  Arcane::IntegerSharedArray lids(all_uid_count);
  Arcane::Int64SharedArray uids;
  bool topology_has_changed = false;

  // Special handling for Groups of particles
  Arcane::IItemFamily * item_family;
#if (ARCANE_VERSION >= 30003)
  switch(item_kind)
  {
    case IK_Particle:
      item_family = mesh->findItemFamily(IK_Particle,"Particle",true);
      break ;
    case ItemConnectionImpl::ik_type :  // ConnectionType
      item_family = m_graph->linkFamily() ;
      break ;
    default :
      item_family = mesh->itemFamily(item_kind);
      break ;
  }
#else
  if (item_kind == IK_Particle)
  {
    item_family = mesh->findItemFamily(IK_Particle,"Particle",true);
  }
  else{
    item_family = mesh->itemFamily(item_kind);
  }
#endif
  // Get local and unique ids of items owned (own + ghost) by the current subdomain
  bool strict_check = (m_parallel_mng->commSize() == 1);
  if(item_kind == IK_Particle){
      item_family->itemsUniqueIdToLocalId(lids,all_uids,strict_check);
      // Faut il vraiment retravailler le tableau des uids : uniquement si strict_check==false
      if (strict_check)
        {
          uids = all_uids;
        }
      else
        {
          Arcane::Integer repos_index = 0;
          for(Arcane::Integer i=0;i<all_uid_count;++i)
            {
              if (lids[i] != NULL_ITEM_LOCAL_ID)
                {
                  lids[repos_index++] = lids[i];
                  uids.add(all_uids[i]);
                }
            }
          lids.resize(repos_index);
        }
  }
  else
      uid2lid_mng.localItemsUniqueIdToLocalId(lids,uids,all_uids,item_kind,strict_check);

  // Find group : create it if it does not exist (temporary)
  Arcane::ItemGroup group = item_family->findGroup(group_name, true);
  info()<<"MANAGE GROUP : "<<group_name<<" "<<group_mode;

  if (group.isAllItems())
    {
      if (check)
        {
          if (group_mode == "add" || group_mode == "delete")
            throw Arcane::FatalErrorException(A_FUNCINFO,String::format("Cannot add or remove items from group {0}",group.name()));
          std::set<Arcane::Int64> group_uids_set(all_uids.begin(),all_uids.end());
          bool is_conform = true;
          ENUMERATE_ITEM(iitem,group)
          {
            is_conform = is_conform && (group_uids_set.find(iitem->uniqueId()) != group_uids_set.end());
          }
          if (!is_conform)
            throw Arcane::FatalErrorException(A_FUNCINFO,String::format("Computed group {0} does not match its declaration in the ixm mesh file",group.name()));
        }
      return topology_has_changed;
    }

  auto* internal = group.internal();
  GroupChangeInfo gci;
  auto inserter = m_changed_groups.insert(std::make_pair(internal,gci));
  if (inserter.second) m_changed_group_collection.add(group);
  GroupChangeInfo & group_change_info = inserter.first->second;
  group_change_info.m_group = group.internal();

  if (group_mode == "add")
    {
      group_change_info.m_info |= EvolutiveMeshProperty::Add;
      group.addItems(lids, check);
      for (Arcane::Integer i = 0; i < uids.size(); ++i)
        group_change_info.m_added_items.add(uids[i]);
      if (!all_uids.empty()) topology_has_changed = true;
    }
  else if (group_mode == "reset")
    {
      // Ecrase toutes autres pr���c���dentes modifs sur le groupe et les placent dans le buffer Add
      group_change_info.m_info = EvolutiveMeshProperty::Reset;
      group_change_info.m_added_items.clear();
      group_change_info.m_deleted_items.clear();
      group.clear();
      group.setItems(lids);
      for (Arcane::Integer i = 0; i < uids.size(); ++i)
        group_change_info.m_added_items.add(uids[i]);
      topology_has_changed = true;
    }
  else if (group_mode == "delete")
    {
      group_change_info.m_info |= EvolutiveMeshProperty::Delete;
      group.removeItems(lids, check);
      for (Arcane::Integer i = 0; i < uids.size(); ++i)
        group_change_info.m_deleted_items.add(uids[i]);
      if (!all_uids.empty()) topology_has_changed = true;
    }
  else
    {
      throw Arcane::FatalErrorException(A_FUNCINFO, "Undefined mode");
    }
  return topology_has_changed;
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
addConnections(Arcane::IPrimaryMesh* mesh, 
               const ArcGeoSim::IXMTools::IXMConnectionData& connection_data,
               IXMUidToLidMng& uid2lid_mng)
{
  // Connections are implemented using Arcane Graph

  ConnectionItems connection_items;
  ConnectionDescriptions connection_descriptions;
  _extractConnectionInfo(mesh,connection_data,uid2lid_mng,connection_items,connection_descriptions);

  Arcane::Integer nb_connections = connection_data.item_ids.size();


  #if (ARCANE_VERSION >= 30003)
  auto total_nb_connections = nb_connections ;
  if(m_parallel_mng)
    total_nb_connections = m_parallel_mng->reduce(Arcane::Parallel::ReduceSum,nb_connections) ;
  if(total_nb_connections>0)
  {
    if(m_graph==nullptr)
      m_graph = ArcGeoSim::Mesh::GraphMng::graph(mesh,true) ;
    uid2lid_mng.setGraph(m_graph) ;

    Arcane::Int64SharedArray dual_node_infos;
    _buildDualNodeInfo(connection_items,dual_node_infos);

    Arcane::Int64SharedArray link_infos;
    // info for connection aid to uid mapping => connection_mapping_info.item_ids = aids, connection_mapping_info.item_infos = uids.
    ArcGeoSim::IXMTools::IXMConnectionData connection_mapping_info;
    connection_mapping_info.item_ids.reserve(nb_connections);
    connection_mapping_info.item_infos.reserve(nb_connections);
    _buildLinkInfo(connection_items,connection_descriptions,link_infos,connection_mapping_info);

    Arcane::Integer nb_items = connection_items.size();
    Arcane::Integer nb_dual_nodes = dual_node_infos.size()/3 ;

    auto graph_modifier = m_graph->modifier();

    // Add dual_nodes and links
    graph_modifier->addDualNodes(nb_dual_nodes,dual_node_infos);
    graph_modifier->addLinks(nb_connections,2,link_infos);

    // End update
    graph_modifier->endUpdate();

    // Add connection mapping info
    const bool do_check = true;
    uid2lid_mng.loadConnectionAidMapping(connection_mapping_info,do_check);

    // Create AllConnections group
    _createAllConnectionGroup(connection_mapping_info.item_infos,mesh);
  }
#else
  Arcane::Int64SharedArray dual_node_infos;
  _buildDualNodeInfo(connection_items,dual_node_infos);

  Arcane::Int64SharedArray link_infos;
  // info for connection aid to uid mapping => connection_mapping_info.item_ids = aids, connection_mapping_info.item_infos = uids.
  ArcGeoSim::IXMTools::IXMConnectionData connection_mapping_info;
  connection_mapping_info.item_ids.reserve(nb_connections);
  connection_mapping_info.item_infos.reserve(nb_connections);
  _buildLinkInfo(connection_items,connection_descriptions,link_infos,connection_mapping_info);

  Arcane::Integer nb_items = connection_items.size();
  Arcane::Integer nb_dual_nodes = dual_node_infos.size()/3 ;
  // Add dual_nodes and links
  mesh->graph()->modifier()->addDualNodes(nb_dual_nodes,dual_node_infos);
  mesh->graph()->modifier()->addLinks(nb_connections,2,link_infos);
  
  // End update
  mesh->graph()->modifier()->endUpdate();
  
  // Add connection mapping info
  const bool do_check = true;
  uid2lid_mng.loadConnectionAidMapping(connection_mapping_info,do_check);

  // Create AllConnections group
  _createAllConnectionGroup(connection_mapping_info.item_infos,mesh);
#endif
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
_buildDualNodeInfo(const ConnectionItems& connection_items, Arcane::Int64SharedArray& dual_node_infos) const
{
  // Handle item kind
  dual_node_infos.reserve(3*connection_items.size());
#if ARCANE_VERSION >= 12100
  _buildDualNodeInfoT<Particle>(connection_items.m_particles,dual_node_infos,Arcane::IT_DualParticle);
#endif
  _buildDualNodeInfoT<Cell>(connection_items.m_cells,dual_node_infos,Arcane::IT_DualCell);
  _buildDualNodeInfoT<Face>(connection_items.m_faces,dual_node_infos,Arcane::IT_DualFace);
  _buildDualNodeInfoT<Edge>(connection_items.m_edges,dual_node_infos,Arcane::IT_DualEdge);
  _buildDualNodeInfoT<Node>(connection_items.m_nodes,dual_node_infos,Arcane::IT_DualNode);
}

/*---------------------------------------------------------------------------*/

template<class DualItemKind>
void
ArcGeoSim::IXMMeshBuilderBase::
_buildDualNodeInfoT(const Arcane::ItemVectorViewT<DualItemKind>& connection_items, Arcane::Int64SharedArray& dual_node_infos, const Arcane::Integer& dual_node_type) const
{
  std::set<Int64> uid_set ; // to eliminate duplicated dual items
  ENUMERATE_GENERIC(DualItemKind,iitem,connection_items)
  {
    auto uid = Arcane::DualUniqueIdMng::uniqueIdOf<DualItemKind>(*iitem) ;
    auto value = uid_set.insert(uid) ;
    if(value.second)
    {
      dual_node_infos.add(dual_node_type);
      dual_node_infos.add(Arcane::DualUniqueIdMng::uniqueIdOf<DualItemKind>(*iitem));
      dual_node_infos.add(iitem->uniqueId().asInt64());
    }
  }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
_buildLinkInfo(const ConnectionItems& connection_items, const ConnectionDescriptions& connection_description,
               Arcane::Int64SharedArray& link_infos, ArcGeoSim::IXMTools::IXMConnectionData& connection_mapping_info) const
{
  // Handle ItemKind
  link_infos.reserve(3*connection_description.size());
  // Connections with cell as first item
#if ARCANE_VERSION >= 12100
  _buildLinkInfoT<Particle>(connection_items.m_particles,connection_items,connection_description,ICT_Particle,link_infos,connection_mapping_info);
#endif
  // Connections with cell as first item
  _buildLinkInfoT<Cell>(connection_items.m_cells,connection_items,connection_description,ICT_Cell,link_infos,connection_mapping_info);
  // Connections with face as first item
  _buildLinkInfoT<Face>(connection_items.m_faces,connection_items,connection_description,ICT_Face,link_infos,connection_mapping_info);
  // Connections with edge as first item
  _buildLinkInfoT<Edge>(connection_items.m_edges,connection_items,connection_description,ICT_Edge,link_infos,connection_mapping_info);
  // Connections with node as first item
  _buildLinkInfoT<Node>(connection_items.m_nodes,connection_items,connection_description,ICT_Node,link_infos,connection_mapping_info);
}

/*---------------------------------------------------------------------------*/

template<class FirstDualItemKind>
void
ArcGeoSim::IXMMeshBuilderBase::
_buildLinkInfoT(const Arcane::ItemVectorViewT<FirstDualItemKind>& connection_first_items,
                const ConnectionItems& connection_second_items,
                const ConnectionDescriptions& connection_description,
                const Arcane::Integer first_item_type,
                Arcane::Int64SharedArray& link_infos,
                ArcGeoSim::IXMTools::IXMConnectionData& connection_mapping_info) const
{
#if ARCANE_VERSION >= 12100
  _buildLinkInfoBaseT<FirstDualItemKind,Particle>(connection_first_items,connection_second_items.m_particles,connection_description,
                                              connectionType(first_item_type,ICT_Particle),link_infos,connection_mapping_info);
#endif
  _buildLinkInfoBaseT<FirstDualItemKind,Cell>(connection_first_items,connection_second_items.m_cells,connection_description,
                                              connectionType(first_item_type,ICT_Cell),link_infos,connection_mapping_info);
  _buildLinkInfoBaseT<FirstDualItemKind,Face>(connection_first_items,connection_second_items.m_faces,connection_description,
                                              connectionType(first_item_type,ICT_Face),link_infos,connection_mapping_info);
  _buildLinkInfoBaseT<FirstDualItemKind,Edge>(connection_first_items,connection_second_items.m_edges,connection_description,
                                              connectionType(first_item_type,ICT_Edge),link_infos,connection_mapping_info);
  _buildLinkInfoBaseT<FirstDualItemKind,Node>(connection_first_items,connection_second_items.m_nodes,connection_description,
                                              connectionType(first_item_type,ICT_Node),link_infos,connection_mapping_info);
}


/*---------------------------------------------------------------------------*/

template<class FirstDualItemKind,class SecondDualItemKind>
void
ArcGeoSim::IXMMeshBuilderBase::
_buildLinkInfoBaseT(const Arcane::ItemVectorViewT<FirstDualItemKind>& connection_first_items,
                    const Arcane::ItemVectorViewT<SecondDualItemKind>& connection_second_items,
                    const ConnectionDescriptions& connection_descriptions,
                    const Arcane::Integer connection_type,
                    Arcane::Int64SharedArray& link_infos,
                    ArcGeoSim::IXMTools::IXMConnectionData& connection_mapping_info) const
{
  ConnectionDescriptions::const_iterator connections_ite = connection_descriptions.find(connection_type);
  if (connection_descriptions.end() == connections_ite) return;
  ConnectionDescriptions::value_type::second_type connections = connections_ite->second; // extract ConnectionArray of current type
  ConnectionDescriptions::value_type::second_type::iterator ite = connections.begin();
  for (;ite != connections.end();++ite)
    {
      const FirstDualItemKind first_item = connection_first_items[ite->first_item_position];
      const SecondDualItemKind second_item = connection_second_items[ite->second_item_position];
      Arcane::Int64 connection_uid = Arcane::DualUniqueIdMng::uniqueIdOf<FirstDualItemKind,SecondDualItemKind>(first_item,second_item);
      link_infos.add(connection_uid);
      link_infos.add(Arcane::DualUniqueIdMng::uniqueIdOf<FirstDualItemKind>(first_item));
      link_infos.add(Arcane::DualUniqueIdMng::uniqueIdOf<SecondDualItemKind>(second_item));
      connection_mapping_info.item_ids.add(ite->connection_aid);
      connection_mapping_info.item_infos.add(connection_uid);
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
_createAllConnectionGroup(Arcane::Int64ConstArrayView connection_uids, Arcane::IMesh* mesh)
{
    Arcane::Int32SharedArray connection_lids(connection_uids.size());
    Arcane::IItemFamily* link_family = nullptr;
#ifndef USE_ARCANE_V3
  link_family = mesh->graph()->linkFamily();
#else
  link_family = m_graph->linkFamily();
#endif
  link_family->itemsUniqueIdToLocalId(connection_lids,connection_uids,true);
  ItemGroupBuilder<ArcGeoSim::ItemConnectionImpl::type> builder(mesh,ArcGeoSim::ItemConnectionMng::allConnectionGroupName(),link_family->name());
  builder.add(link_family->view(connection_lids).enumerator());
  builder.buildGroup();
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
_extractConnectionInfo(Arcane::IPrimaryMesh* mesh,
                       const ArcGeoSim::IXMTools::IXMConnectionData& connection_data,
                       const IXMUidToLidMng& uid2lid_mng,
                       ConnectionItems& connection_items,
                       ConnectionDescriptions& connection_descriptions)
{
  // Store item ids
  Arcane::Int64SharedArray item_uids[ICT_NbItemTypes];//! [0] = empty; [1] = nodes, [2] = edges, [3] = faces, [4] = cells, [5] = Particle
  // Reserve item_ids size
  Arcane::Integer nb_connection = connection_data.item_ids.size();
  Arcane::Integer max_size = 2*nb_connection;
  for (Arcane::Integer i=1; i<ICT_NbItemTypes;++i) item_uids[i].reserve(max_size);
  // Extract item_ids, create connection description
  Arcane::Integer item_counters[ICT_NbItemTypes] = {0,0,0,0,0,0};
  for (Arcane::Integer i =0 ; i<nb_connection;++i)
    {
      // Get connection Type
      ArcGeoSim::ItemConnectionType connection_type(connection_data.item_infos[3*i]);
      // Get item type (1 = Node, 2 = Edge, 3 = Face, 4= Cell, 5=Particle)
      Arcane::Integer first_item_type = connection_type.firstItemType();
      Arcane::Integer second_item_type = connection_type.secondItemType();
      // Store ids by type
      item_uids[first_item_type].add(connection_data.item_infos[3*i+1]);
      item_uids[second_item_type].add(connection_data.item_infos[3*i+2]);
      // Add connection and Increment counters
      Arcane::Integer first_item_position = item_counters[first_item_type];
      ++item_counters[first_item_type];
      Arcane::Integer second_item_position = item_counters[second_item_type];
      ++item_counters[second_item_type];
      ConnectionDescription connection(first_item_position,second_item_position,connection_data.item_ids[i]);
      connection_descriptions[connection_type].add(connection);
      //
    }

  // Get LocalIds
  for (Arcane::Integer i = 1; i<ICT_NbItemTypes; ++i) connection_items.m_lids[i].resize(item_uids[i].size());
  bool check = true; // All connections arriving here must be for items owned by the subdomain. Parallelism handled in reading part.
  if (item_uids[5].size() > 0) uid2lid_mng.itemsUniqueIdToLocalId(connection_items.m_lids[5],item_uids[5],Arcane::IK_Particle,check);
  uid2lid_mng.itemsUniqueIdToLocalId(connection_items.m_lids[4],item_uids[4],Arcane::IK_Cell,check);
  uid2lid_mng.itemsUniqueIdToLocalId(connection_items.m_lids[3],item_uids[3],Arcane::IK_Face,check);
  uid2lid_mng.itemsUniqueIdToLocalId(connection_items.m_lids[2],item_uids[2],Arcane::IK_Edge,check);
  uid2lid_mng.itemsUniqueIdToLocalId(connection_items.m_lids[1],item_uids[1],Arcane::IK_Node,check);

  // Get Items
  if (item_uids[5].size() > 0) connection_items.m_particles =mesh->findItemFamily(Arcane::IK_Particle,"Particle",true)->view(connection_items.m_lids[5]);
  connection_items.m_cells = mesh->cellFamily()->view(connection_items.m_lids[4]);
  connection_items.m_faces = mesh->faceFamily()->view(connection_items.m_lids[3]);
  connection_items.m_edges = mesh->edgeFamily()->view(connection_items.m_lids[2]);
  connection_items.m_nodes = mesh->nodeFamily()->view(connection_items.m_lids[1]);
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
_findAllCellChildFamilies(Arcane::IItemFamily * family, Arcane::SharedArray<RemovedCellData> & child_array, IItemFamilySet & scanned_families)
{
  std::pair<IItemFamilySet::iterator,bool> finder = scanned_families.insert(family);
  if (not finder.second) return; // existait d�j�
  Arcane::mesh::CellFamily * cell_family = dynamic_cast<mesh::CellFamily*>(family);
  if (cell_family == NULL) fatal() << "Cell child family " << family->name() << " on mesh " << family->mesh()->name() << " is not a Cell family";
  child_array.add(RemovedCellData(cell_family));

  Arcane::IItemFamilyCollection child_families = family->childFamilies();
  for(Arcane::IItemFamilyCollection::Enumerator i_family(child_families); ++i_family; )
    {
      _findAllCellChildFamilies(*i_family, child_array, scanned_families);
    }
}


/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
_findAllCellChildFamilies(Arcane::IItemFamily * family, Arcane::SharedArray<ChangedCellData> & child_array, IItemFamilySet & scanned_families)
{
  std::pair<IItemFamilySet::iterator,bool> finder = scanned_families.insert(family);
  if (not finder.second) return; // existait d�j�
  Arcane::mesh::CellFamily * cell_family = dynamic_cast<mesh::CellFamily*>(family);
  if (cell_family == NULL) fatal() << "Cell child family " << family->name() << " on mesh " << family->mesh()->name() << " is not a Cell family";
  child_array.add(ChangedCellData(cell_family));

  Arcane::IItemFamilyCollection child_families = family->childFamilies();
  for(Arcane::IItemFamilyCollection::Enumerator i_family(child_families); ++i_family; )
    {
      _findAllCellChildFamilies(*i_family, child_array, scanned_families);
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
_findAllFaceChildFamilies(Arcane::IItemFamily * family, Arcane::SharedArray<ChangedFaceData> & child_array, IItemFamilySet & scanned_families)
{
  std::pair<IItemFamilySet::iterator,bool> finder = scanned_families.insert(family);
  if (not finder.second) return; // existait d���j���
  Arcane::mesh::FaceFamily * face_family = dynamic_cast<mesh::FaceFamily*>(family);
  if (face_family == NULL) warning() << "Face child family " << family->name() << " on mesh " << family->mesh()->name() << " is not a Face family";
  if (face_family != NULL)
    {
      child_array.add(ChangedFaceData(face_family));

      Arcane::IItemFamilyCollection child_families = family->childFamilies();
      for(Arcane::IItemFamilyCollection::Enumerator i_family(child_families); ++i_family; )
        {
          _findAllFaceChildFamilies(*i_family, child_array, scanned_families);
        }
    }
}


/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
_findAllEdgeChildFamilies(Arcane::IItemFamily * family, Arcane::SharedArray<ChangedEdgeData> & child_array, IItemFamilySet & scanned_families)
{
  std::pair<IItemFamilySet::iterator,bool> finder = scanned_families.insert(family);
  if (not finder.second) return; // existait d�j�
  Arcane::mesh::EdgeFamily * edge_family = dynamic_cast<mesh::EdgeFamily*>(family);
  if (edge_family == NULL) warning() << "edge child family " << family->name() << " on mesh " << family->mesh()->name() << " is not a edge family";
  if (edge_family != NULL)
    {
      child_array.add(ChangedEdgeData(edge_family));

      Arcane::IItemFamilyCollection child_families = family->childFamilies();
      for(Arcane::IItemFamilyCollection::Enumerator i_family(child_families); ++i_family; )
        {
          _findAllEdgeChildFamilies(*i_family, child_array, scanned_families);
        }
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
_findAllNodeChildFamilies(Arcane::IItemFamily * family, Arcane::SharedArray<ChangedNodeData> & child_array, IItemFamilySet & scanned_families)
{
  std::pair<IItemFamilySet::iterator,bool> finder = scanned_families.insert(family);
  if (not finder.second) return; // existait d�j�
  Arcane::mesh::NodeFamily * node_family = dynamic_cast<mesh::NodeFamily*>(family);
  if (node_family == NULL) warning() << "Node child family " << family->name() << " on mesh " << family->mesh()->name() << " is not a Node family";
  if (node_family != NULL)
  {
      child_array.add(ChangedNodeData(node_family));

      Arcane::IItemFamilyCollection child_families = family->childFamilies();
      for(Arcane::IItemFamilyCollection::Enumerator i_family(child_families); ++i_family; )
        {
          _findAllNodeChildFamilies(*i_family, child_array, scanned_families);
        }
  }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMMeshBuilderBase::
_updateNeighborOwners(Arcane::IPrimaryMesh * mesh, Arcane::CellGroup removed_cell_group)
{
  // Inutile en s�quentiel
  if (m_parallel_mng->commSize() == 1) return;

  // On ne s'int�resse qu'aux mailles supprim�es de removed_cell_group car le reste est suppos� d�j� coh�rent.
  IItemFamily* cell_family = mesh->cellFamily();
  BoolSharedArray removed_markers(cell_family->maxLocalId());
  removed_markers.fill(false);
  ENUMERATE_CELL(icell,removed_cell_group)
    {
      removed_markers[icell.localId()] = true;
    }

  // Calcul des groupes d'int�r�t en commen�ant par le groupe de face de bords de removed_cell_group et interne vis-�-vis de allCells
  FaceVector face_group;
  {
    IItemFamily* face_family = mesh->faceFamily();
    Int32SharedArray item_lids;
    BoolSharedArray done(face_family->maxLocalId());
    done.fill(false);
    ENUMERATE_CELL(icell,removed_cell_group) {
        ENUMERATE_FACE(iface, icell->faces()) {
            const Face & face = *iface;
            if (face.nbCell() == 2 and
                (removed_markers[face.backCell().localId()] xor removed_markers[face.frontCell().localId()])) {
                const Int32 lid = face.localId();
                if (not done[lid]) {
                  done[lid] = true;
                  item_lids.add(lid);
                }
            }
            //if (face.nbCell() == 1)
            //    ARCANE_ASSERT((face.owner() == face.boundaryCell().owner()),("Bad face owner"))
            if ( face.nbCell() == 1)
            {
                face.cell(0);
                const Arcane::Integer sid = m_parallel_mng->commRank();
                face.internal()->setOwner(face.boundaryCell().owner(), sid);
            }
        }
    }
#if (ARCANE_VERSION < 12010)
    face_group = ItemVector(face_family, item_lids);
#else /* ARCANE_VERSION */
    face_group = FaceVector(face_family, item_lids);
#endif /* ARCANE_VERSION */
  }

 /* EdgeVector edge_group;
  {
    IItemFamily* edge_family = mesh->edgeFamily();
    Int32SharedArray item_lids;
    BoolSharedArray done(edge_family->maxLocalId());
    done.fill(false);
    ENUMERATE_FACE(iface,face_group) {
      ENUMERATE_EDGE(iedge, iface->edges()) {
        const Int32 lid = iedge.localId();
        if (not done[lid]) {
          done[lid] = true;
          item_lids.add(lid);
        }
      }
    }
#if (ARCANE_VERSION < 12010)
    edge_group = ItemVector(edge_family, item_lids);
#else  ARCANE_VERSION
    edge_group = EdgeVector(edge_family, item_lids);
#endif  ARCANE_VERSION
  }*/

  EdgeVector edge_group;
    {
      IItemFamily* edge_family = mesh->edgeFamily();
      Int32SharedArray item_lids;
      BoolSharedArray done(edge_family->maxLocalId());
      done.fill(false);

      ENUMERATE_CELL(icell,removed_cell_group) {
                ENUMERATE_EDGE(iedge, icell->edges()) {
                    const Edge & edge = *iedge;

                    bool has_removed_cell = false;
                    bool has_not_removed_cell = false;
                    ENUMERATE_CELL(inodecell, edge.cells())
                    {
                        const Cell & node_cell = *inodecell;
                        has_removed_cell |= removed_markers[node_cell.localId()];
                        has_not_removed_cell |= !removed_markers[node_cell.localId()];
                    }

                    if (has_removed_cell && has_not_removed_cell) {
                        const Int32 lid = edge.localId();
                        if (not done[lid]) {
                          done[lid] = true;
                          item_lids.add(lid);
                        }
                    }
                }
            }



  #if (ARCANE_VERSION < 12010)
      edge_group = ItemVector(edge_family, item_lids);
  #else  /* ARCANE_VERSION */
      edge_group = EdgeVector(edge_family, item_lids);
  #endif  /* ARCANE_VERSION */
    }

    NodeVector node_group;
    {
      IItemFamily* node_family = mesh->nodeFamily();
      Int32SharedArray item_lids;
      BoolSharedArray done(node_family->maxLocalId());
      done.fill(false);
      ENUMERATE_CELL(icell,removed_cell_group) {
          ENUMERATE_NODE(inode, icell->nodes()) {
              const Node & node = *inode;

              bool has_removed_cell = false;
              bool has_not_removed_cell = false;
              ENUMERATE_CELL(inodecell, node.cells())
              {
                const Cell & node_cell = *inodecell;
                has_removed_cell |= removed_markers[node_cell.localId()];
                has_not_removed_cell |= !removed_markers[node_cell.localId()];
              }

              if (has_removed_cell && has_not_removed_cell) {
                  const Int32 lid = node.localId();
                  if (not done[lid]) {
                    done[lid] = true;
                    item_lids.add(lid);
                  }
              }
          }
      }

    #if (ARCANE_VERSION < 12010)
    node_group = ItemVector(node_family, item_lids);
#else /* ARCANE_VERSION */
    node_group = NodeVector(node_family, item_lids);
#endif /* ARCANE_VERSION */
  }

  // Reprend globalement l'algorithme de UnstructuredMeshUtilities::changeOwnersFromCells()
  // tout en excluant l'association � des �l�ments de removed_cell_group
  // Les modifications sont synchronis�es par le fait que les items trait�s sont toujours internes et donc de voisinage compl�tement d�fini.
  // (le voisinage compl�tement d�fini vient de la connectivit� par noeud du voisinage)

  const Arcane::Integer sid = m_parallel_mng->commRank();

  // D�termine les nouveaux propri�taires des noeuds
  {
    ENUMERATE_NODE(i_node,node_group){
      const Node& node = *i_node;
      Cell cell;
      for( CellEnumerator icell(node.cells()); icell(); ++icell ){
        const Cell& node_cell = *icell;
        if (not removed_markers[node_cell.localId()])
          if (cell.null() or node_cell.uniqueId() < cell.uniqueId())
            cell = node_cell;
      }
      ARCANE_ASSERT((not cell.null()),("Inconsistent null cell owner reference"));
      node.internal()->setOwner(cell.owner(), sid);

    }
  }

  // D�termine les nouveaux propri�taires des ar�tes
  {
    ENUMERATE_EDGE(i_edge,edge_group){
      const Edge& edge = *i_edge;
      Cell cell;
      for( CellEnumerator icell(edge.cells()); icell(); ++icell ){
        const Cell& edge_cell = *icell;
        if (not removed_markers[edge_cell.localId()])
          if (cell.null() or edge_cell.uniqueId() < cell.uniqueId())
            cell = edge_cell;
      }
      ARCANE_ASSERT((not cell.null()),("Inconsistent null cell owner reference"));
      edge.internal()->setOwner(cell.owner(), sid);
    }
  }

  // D�termine les nouveaux propri�taires des faces
  {
    ENUMERATE_FACE(i_face,face_group){
      const Face& face = *i_face;
      Cell cell;
      for( CellEnumerator icell(face.cells()); icell(); ++icell ){
        const Cell& face_cell = *icell;
        if (not removed_markers[face_cell.localId()])
          if (cell.null() or face_cell.uniqueId() < cell.uniqueId())
            cell = face_cell;
      }
      ARCANE_ASSERT((not cell.null()),("Inconsistent null cell owner reference"));
      face.internal()->setOwner(cell.owner(), sid);
    }
  }

  mesh->nodeFamily()->notifyItemsOwnerChanged();
  mesh->edgeFamily()->notifyItemsOwnerChanged();
  mesh->faceFamily()->notifyItemsOwnerChanged();

}

/*---------------------------------------------------------------------------*/

Arcane::Int32SharedArray
ArcGeoSim::IXMMeshBuilderBase::
_addCells(Arcane::IPrimaryMesh * mesh,
          const bool need_edge,
          const Arcane::Int64ConstArrayView cell_uids,
          const Arcane::Int64ConstArrayView cell_infos,
          const Arcane::Int64ConstArrayView cell_connectivity_infos,
          const Arcane::Int32ConstArrayView cell_connectivity_owners)
{
  const Arcane::Integer nb_cells = cell_uids.size();
  Arcane::IntegerSharedArray lids;

  //auto & m_owner_map = owner_map;

  // Si tableau de connectivit�, on suit ses consignes de num�rotation, sinon libre (ie en s�quentiel ou maillage statique �ventuellement parall�le)
  if (not cell_connectivity_infos.empty())
    {
      ARCANE_ASSERT((not cell_connectivity_owners.empty()),("Incompatible parallel data"));

      // Gestionnaire de types pour mapper les sous-items des cellules � construire
      Arcane::ItemTypeMng* itm = Arcane::ItemTypeMng::singleton();

      // ne g�re pas la non-duplication des items cr��s
      Arcane::Int64SharedArray node_infos;
      Arcane::Int64SharedArray edge_infos;
      Arcane::Int64SharedArray face_infos;
      Arcane::Integer edge_count = 0;
      Arcane::Integer face_count = 0;

      for(Arcane::Integer icell=0, info_index=0, connectivity_index=0;icell<nb_cells;++icell)
        {
          // info_index pointe les infos de construction : ie type et noeuds
          // connectivity_index pointe les infos de connectivit� issue du mode forecast : uids des ar�tes et faces

          Arcane::Integer cell_type_id = (Arcane::Integer)cell_infos[info_index];
          ARCANE_ASSERT((cell_uids[icell] == cell_infos[info_index+1]),("Inconsistent cell uid"));
          Arcane::ItemTypeInfo* cell_type = itm->typeFromId(cell_type_id);
          const Arcane::Integer nb_node = cell_type->nbLocalNode();
          const Arcane::Integer nb_edge = cell_type->nbLocalEdge();
          const Arcane::Integer nb_face = cell_type->nbLocalFace();
          const Arcane::Int64ConstArrayView nodes = cell_infos.subView(info_index+2, nb_node);

          for(Arcane::Integer i_node=0;i_node<nb_node;++i_node)
            node_infos.add(nodes[i_node]);

          if (need_edge)
            {
              const Arcane::Int64ConstArrayView edges = cell_connectivity_infos.subView(connectivity_index, nb_edge);
              for(Arcane::Integer i_edge=0;i_edge<nb_edge;++i_edge)
                {
                  const Arcane::ItemTypeInfo::LocalEdge& le = cell_type->localEdge(i_edge);
                  edge_infos.add(edges[i_edge]); // uid
                  edge_infos.add(nodes[le.beginNode()]); // nodes
                  edge_infos.add(nodes[le.endNode()]);
                  ++edge_count;
                }
              connectivity_index += nb_edge;
            }

          const Arcane::Int64ConstArrayView faces = cell_connectivity_infos.subView(connectivity_index, nb_face);
          for(Arcane::Integer i_face=0;i_face<nb_face;++i_face)
            {
              const Arcane::ItemTypeInfo::LocalFace& lf = cell_type->localFace(i_face);
              face_infos.add(lf.typeId()); // type id
              face_infos.add(faces[i_face]); // uid
              const Arcane::Integer face_nb_node = lf.nbNode();
              for(Arcane::Integer i_node=0;i_node<face_nb_node;++i_node)
                face_infos.add(nodes[lf.node(i_node)]); // nodes
              ++face_count;
            }
          connectivity_index += nb_face;

          info_index += nb_node+2;
        }

      Arcane::Int32SharedArray node_localids(node_infos.size());
      Arcane::Int32SharedArray edge_localids(edge_count);
      Arcane::Int32SharedArray face_localids(face_count);

      mesh->modifier()->addNodes(node_infos, node_localids);

      if (need_edge)
        {
          mesh->modifier()->addEdges(edge_count,edge_infos, edge_localids);
        }
      mesh->modifier()->addFaces(face_count,face_infos, face_localids);

      // Set owners from cell_connectivity_owners
      const Arcane::Integer current_subdomain = m_parallel_mng->commRank();
      for(Arcane::Integer icell=0, info_index=0, connectivity_index=0, owner_index=0, node_index=0, edge_index=0, face_index=0;icell<nb_cells;++icell)
        {
          // info_index pointe les infos de construction : ie type et noeuds
          // connectivity_index pointe les infos de connectivit� issue du mode forecast : uids des ar�tes et faces

          Arcane::Integer cell_type_id = (Arcane::Integer)cell_infos[info_index];
          Arcane::ItemTypeInfo* cell_type = itm->typeFromId(cell_type_id);
          const Arcane::Integer nb_node = cell_type->nbLocalNode();
          const Arcane::Integer nb_edge = cell_type->nbLocalEdge();
          const Arcane::Integer nb_face = cell_type->nbLocalFace();
          info_index += 2; // skip offset (type + uid)
          ARCANE_ASSERT((cell_uids[icell] == cell_connectivity_owners[owner_index]),("Inconsistent cell uid"));
          owner_index += 1; // skip uid

          {
            Arcane::NodeVectorView nodes(mesh->nodeFamily()->itemsInternal(), node_localids.subConstView(node_index, nb_node));
            Arcane::Int32ConstArrayView node_owners = cell_connectivity_owners.subView(owner_index, nb_node);
            ENUMERATE_NODE(i_node, nodes)
              {
                ARCANE_ASSERT((cell_infos[info_index+i_node.index()] == i_node->uniqueId()),("Inconsistent node uid"));
                ARCANE_ASSERT((node_owners[i_node.index()]>=0 and node_owners[i_node.index()]<m_parallel_mng->commSize()),("Bad owner"));
                (*i_node).internal()->setOwner(node_owners[i_node.index()],current_subdomain);
              }
            node_index += nb_node;
            info_index += nb_node;
            owner_index += nb_node;
          }


          if (need_edge)
            {
              Arcane::EdgeVectorView edges(mesh->edgeFamily()->itemsInternal(), edge_localids.subConstView(edge_index, nb_edge));
              Arcane::Int32ConstArrayView edge_owners = cell_connectivity_owners.subView(owner_index, nb_edge);
              ENUMERATE_EDGE(i_edge, edges)
                {
                  ARCANE_ASSERT((cell_connectivity_infos[connectivity_index+i_edge.index()] == i_edge->uniqueId()),("Inconsistent edge uid"));
                  ARCANE_ASSERT((edge_owners[i_edge.index()]>=0 and edge_owners[i_edge.index()]<m_parallel_mng->commSize()),("Bad owner"));
                  (*i_edge).internal()->setOwner(edge_owners[i_edge.index()],current_subdomain);
                }
              edge_index += nb_edge;
              connectivity_index += nb_edge;
              owner_index += nb_edge;
            }

          {
            Arcane::FaceVectorView faces(mesh->faceFamily()->itemsInternal(), face_localids.subConstView(face_index, nb_face));
            Arcane::Int32ConstArrayView face_owners = cell_connectivity_owners.subView(owner_index, nb_face);
            ENUMERATE_FACE(i_face, faces)
              {
                ARCANE_ASSERT((cell_connectivity_infos[connectivity_index+i_face.index()] == i_face->uniqueId()),("Inconsistent face uid"));
                ARCANE_ASSERT((face_owners[i_face.index()]>=0 and face_owners[i_face.index()]<m_parallel_mng->commSize()),("Bad owner"));
                (*i_face).internal()->setOwner(face_owners[i_face.index()],current_subdomain);
              }
            face_index += nb_face;
            connectivity_index += nb_face;
            owner_index += nb_face;
          }
        }
      // Add cells (evolutive mesh context)
      lids.resize(nb_cells);
      mesh->modifier()->addCells(nb_cells, cell_infos, lids);
    }
  else // No connexion info, ie. sequential or initial static mesh
    {
      if (m_parallel_mng->isParallel()) mesh->allocateCells(nb_cells, cell_infos, false); // static parallel mesh
      // addCells not used in static mesh context since in parallel the faces cannot be constructed automatically (while possible with allocateCells)

      else // evolutive sequential mesh
        {
          lids.resize(nb_cells);
          mesh->modifier()->addCells(nb_cells, cell_infos, lids);
        }
    }


  return lids;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
