// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMITEMCONNECTIONS_H
#define ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMITEMCONNECTIONS_H
/* Author : dechaiss at Mon Mar 11 15:08:17 2013
 * Generated by createNew
 */

#include <arcane/IMesh.h>
#include <arcane/ItemGroup.h>
#include <arcane/IItemFamily.h>

#include "ArcGeoSim/Utils/ArcGeoSim.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMItemAidMapper.h"

BEGIN_ARCGEOSIM_NAMESPACE

/*!
 * API des connections d'items pour manipuler les connections decrites dans le maillage au format ixm.
 * Illustration dans IXMReaderTestModule::_connectionDemo()
 * Cas test de validation dans IXMReaderTestModule::_connectionTest()
 */


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

//! Numero des types pour les connections ItemConnectionTypes (ICT_xx)

static const Arcane::Integer ICT_NbItemTypes = 6 ;
static const Arcane::Integer ICT_Particle = 5;
static const Arcane::Integer ICT_Cell = 4;
static const Arcane::Integer ICT_Face = 3;
static const Arcane::Integer ICT_Edge = 2;
static const Arcane::Integer ICT_Node = 1;
static const Arcane::Integer ICT_InvalidItem = -1;
static const Arcane::Integer ICT_CellParticle = 45;
static const Arcane::Integer ICT_CellCell = 44;
static const Arcane::Integer ICT_CellFace = 43;
static const Arcane::Integer ICT_CellEdge = 42;
static const Arcane::Integer ICT_CellNode = 41;
static const Arcane::Integer ICT_FaceParticle = 35;
static const Arcane::Integer ICT_FaceCell = 34;
static const Arcane::Integer ICT_FaceFace = 33;
static const Arcane::Integer ICT_FaceEdge = 32;
static const Arcane::Integer ICT_FaceNode = 31;
static const Arcane::Integer ICT_EdgeParticle = 25;
static const Arcane::Integer ICT_EdgeCell = 24;
static const Arcane::Integer ICT_EdgeFace = 23;
static const Arcane::Integer ICT_EdgeEdge = 22;
static const Arcane::Integer ICT_EdgeNode = 21;
static const Arcane::Integer ICT_NodeParticle = 15;
static const Arcane::Integer ICT_NodeCell = 14;
static const Arcane::Integer ICT_NodeFace = 13;
static const Arcane::Integer ICT_NodeEdge = 12;
static const Arcane::Integer ICT_NodeNode = 11;
static const Arcane::Integer ICT_ParticleParticle = 55;
static const Arcane::Integer ICT_ParticleCell = 54;
static const Arcane::Integer ICT_ParticleFace = 53;
static const Arcane::Integer ICT_ParticleEdge = 52;
static const Arcane::Integer ICT_ParticleNode = 51;
static const Arcane::Integer ICT_InvalidConnection = -1;

enum eItemConnectionKind{
    ICK_Particle = 5,
    ICK_Cell = 4,
    ICK_Face = 3,
    ICK_Edge = 2,
    ICK_Node = 1,
    ICK_CellParticle = 45,
    ICK_CellCell = 44,
    ICK_CellFace = 43,
    ICK_CellEdge = 42,
    ICK_CellNode = 41,
    ICK_FaceParticle = 35,
    ICK_FaceCell = 34,
    ICK_FaceFace = 33,
    ICK_FaceEdge = 32,
    ICK_FaceNode = 31,
    ICK_EdgeParticle = 25,
    ICK_EdgeCell = 24,
    ICK_EdgeFace = 23,
    ICK_EdgeEdge = 22,
    ICK_EdgeNode = 21,
    ICK_NodeParticle = 15,
    ICK_NodeCell = 14,
    ICK_NodeFace = 13,
    ICK_NodeEdge = 12,
    ICK_NodeNode = 11,
    ICK_ParticleParticle = 55,
    ICK_ParticleCell = 54,
    ICK_ParticleFace = 53,
    ICK_ParticleEdge = 52,
    ICK_ParticleNode = 51
};

/*---------------------------------------------------------------------------*/

inline Arcane::Integer connectionType(Arcane::Integer first_item_type, Arcane::Integer second_item_type)
{
  if (ICT_InvalidItem == first_item_type || ICT_InvalidItem == second_item_type) return ICT_InvalidConnection;
  return 10*first_item_type+second_item_type;
}

/*---------------------------------------------------------------------------*/

inline Arcane::Integer itemConnectionTypeFromKind(Arcane::eItemKind kind)
{
  Arcane::Integer item_type;
  switch (kind) {
    case Arcane::IK_Cell:
      item_type = ICT_Cell;
      break;
    case Arcane::IK_Face:
      item_type = ICT_Face;
      break;
    case Arcane::IK_Edge:
      item_type = ICT_Edge;
      break;
    case Arcane::IK_Node:
      item_type = ICT_Node;
      break;
    case Arcane::IK_Particle:
      item_type = ICT_Particle;
      break;
    default:
      item_type = ICT_InvalidItem;
      break;
  }
  return item_type;
}

/*---------------------------------------------------------------------------*/

struct ItemConnectionType
{
  ItemConnectionType(const Arcane::Integer& connection_type) : m_type(connection_type) {}
  operator Arcane::Integer() {return m_type;}
  Arcane::Integer firstItemType() {return m_type/10;}
  Arcane::Integer secondItemType() {return m_type%10;}
private:
  Arcane::Integer m_type;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class ItemConnectionImpl
{
public:
#if (ARCANE_VERSION >= 30003)
  typedef Arcane::DoF type;
  static const Arcane::eItemKind ik_type = Arcane::IK_DoF ;
#else
  typedef Arcane::Link type;
  static const Arcane::eItemKind ik_type = Arcane::IK_Link;
#endif
public:
  ItemConnectionImpl(const type& item_connection_impl) : m_impl(item_connection_impl){}
  operator type() const {return m_impl;}
#if (ARCANE_VERSION >= 30003)
  static Arcane::eItemKind kind() {return Arcane::IK_DoF;};
  Arcane::ItemUniqueId uniqueId() const {return IXMItemUidToAidLinkVariable::get()->uid(m_impl);}
#else
  static Arcane::eItemKind kind() {return Arcane::IK_Link;};
  Arcane::ItemUniqueId uniqueId() const {return IXMItemUidToAidVariable::get()->uid(m_impl);}
#endif
private:
  type m_impl;
};

/*---------------------------------------------------------------------------*/

template <class DataType> class ItemConnectionVariableScalarRefT;

class ItemConnection
{
public:
  ItemConnection(const ItemConnectionImpl::type& connection_impl) : m_impl(connection_impl){}
  virtual ~ItemConnection(){}
  Arcane::ItemUniqueId uniqueId() const {return internal().uniqueId();}
#if (ARCANE_VERSION >= 30003)
  Arcane::Item first(Arcane::IGraph2* graph) {
    return graph->connectivity()->dualItem(graph->connectivity()->dualNodes(m_impl)[0]) ;
  }
  Arcane::Item second(Arcane::IGraph2* graph) {
    return graph->connectivity()->dualItem(graph->connectivity()->dualNodes(m_impl)[1]) ;
  }
  Arcane::Item first(Arcane::IGraph2* graph) const {
    return graph->connectivity()->dualItem(graph->connectivity()->dualNodes(m_impl)[0]) ;
  }
  Arcane::Item second(Arcane::IGraph2* graph) const {
    return graph->connectivity()->dualItem(graph->connectivity()->dualNodes(m_impl)[1]) ;
  }
  Arcane::Integer type(Arcane::IGraph2* graph) const {
    return connectionType(itemConnectionTypeFromKind(first(graph).kind()),
                          itemConnectionTypeFromKind(second(graph).kind()));
  }
#else
  Arcane::Item first()  {return m_impl.dualNode(0).dualItem();}
  Arcane::Item second() {return m_impl.dualNode(1).dualItem();}
  Arcane::Item first()  const {return m_impl.dualNode(0).dualItem();}
  Arcane::Item second() const {return m_impl.dualNode(1).dualItem();}
  Arcane::Integer type() {return connectionType(itemConnectionTypeFromKind(first().kind()),itemConnectionTypeFromKind(second().kind()));}
#endif
  ItemConnection* operator->() {return this;}
  const ItemConnection* operator->() const {return this;}
  const ItemConnectionImpl internal() const {return ItemConnectionImpl(m_impl);}
private:
  ItemConnectionImpl::type m_impl;
};

/*---------------------------------------------------------------------------*/

template <class FirstItemKind,class SecondItemKind>
class ItemConnectionT : public ItemConnection
{
public:
  ItemConnectionT() {}
  virtual ~ItemConnectionT(){}
  ItemConnectionT(const ItemConnection& item_connection) : ItemConnection(item_connection){}
#if (ARCANE_VERSION >= 30003)
  FirstItemKind first(Arcane::IGraph2* graph) {return ItemConnection::first(graph).internal();}
  SecondItemKind second(Arcane::IGraph2* graph) {return ItemConnection::second(graph).internal();}
  FirstItemKind first(Arcane::IGraph2* graph) const {return ItemConnection::first(graph).internal();}
  SecondItemKind second(Arcane::IGraph2* graph) const {return ItemConnection::second(graph).internal();}
#else
  FirstItemKind first() {return ItemConnection::first().internal();}
  SecondItemKind second() {return ItemConnection::second().internal();}
  FirstItemKind first() const {return ItemConnection::first().internal();}
  SecondItemKind second() const {return ItemConnection::second().internal();}
#endif
  ItemConnectionT* operator->() {return this;}
  const ItemConnectionT* operator->() const {return this;}
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class ItemConnectionEnumerator : public Arcane::ItemEnumeratorT<ItemConnectionImpl::type>
{
public:
  typedef Arcane::ItemEnumeratorT<ItemConnectionImpl::type> ItemConnectionEnumeratorImpl;
public:
  ItemConnectionEnumerator(const ItemConnectionEnumeratorImpl& enumerator) : ItemConnectionEnumeratorImpl(enumerator){}
  virtual ~ItemConnectionEnumerator(){}
  ItemConnection operator->() const {return ItemConnectionEnumeratorImpl::operator *();}
  ItemConnection operator*() const {return ItemConnectionEnumeratorImpl::operator *();}
};

/*---------------------------------------------------------------------------*/

template <class FirstItemKind,class SecondItemKind>
class ItemConnectionEnumeratorT : public ItemConnectionEnumerator
{
public:
  ItemConnectionEnumeratorT(const ItemConnectionEnumerator& enumerator) : ItemConnectionEnumerator(enumerator){}
  ItemConnectionT<FirstItemKind,SecondItemKind> operator->() {return ItemConnectionEnumerator::operator*();}
  ItemConnectionT<FirstItemKind,SecondItemKind> operator*() {return ItemConnectionEnumerator::operator *();}
};

/*---------------------------------------------------------------------------*/

class ItemConnectionGroup
{
public:
  typedef Arcane::ItemGroupT<ItemConnectionImpl::type> ItemConnectionGroupImpl;
public:
  ItemConnectionGroup() {}
  ItemConnectionGroup(const Arcane::ItemGroup& group) : m_impl(group){}
  virtual ~ItemConnectionGroup() {}
  ItemConnectionEnumerator enumerator() const {return m_impl.enumerator();}
  const ItemConnectionGroup& operator=(const ItemConnectionGroup& from) {m_impl = from.m_impl; return (*this);}
  inline bool null() const { return m_impl.null();}
  inline bool empty() const { return m_impl.empty();}
  inline const Arcane::String& name() const { return m_impl.name();}
  inline const Arcane::String& fullName() const { return m_impl.fullName();}
  inline Arcane::Integer size() const { return m_impl.size();}
  ItemConnectionGroup own() const {return m_impl.own();}
  bool isOwn() const {return m_impl.isOwn();}
  Arcane::String itemFamilyName() {return m_impl.itemFamily()->name();}
  Arcane::ItemVectorView view() const { return m_impl.view() ; }
private:
  ItemConnectionGroupImpl m_impl;
};

/*---------------------------------------------------------------------------*/

class ItemConnectionMng
{
public:
#if (ARCANE_VERSION >= 30003)
  ItemConnectionMng(Arcane::IMesh* mesh, Arcane::IGraph2* graph)
  : m_mesh(mesh)
  , m_graph(graph)
  , m_graph_connectivity(m_graph->connectivity())
  {}
#else
  ItemConnectionMng(Arcane::IMesh* mesh, Arcane::IGraph* graph = nullptr)
  : m_mesh(mesh) {}
#endif

#if (ARCANE_VERSION >= 30003)
  Arcane::IGraph2* graph() {
    return m_graph ;
  }
#endif
  ItemConnectionGroup findConnectionGroup(const Arcane::String& name) {return m_mesh->findGroup(name);}
#if (ARCANE_VERSION >= 30003)
  const Arcane::String itemConnectionFamilyName() const {return m_graph->linkFamily()->name();}
  ItemConnectionGroup allConnections() {return m_graph->linkFamily()->findGroup(allConnectionGroupName());}
#else
  const Arcane::String itemConnectionFamilyName() const {return m_mesh->itemFamily(ItemConnectionImpl::kind())->name();}
  ItemConnectionGroup allConnections() {return m_mesh->findGroup(allConnectionGroupName());}
#endif
  ItemConnectionGroup ownConnections() {return allConnections().own();}
  bool hasConnection() {return (! allConnections().null());}
  static Arcane::String allConnectionGroupName() {return "AllConnections";}

#if (ARCANE_VERSION >= 30003)
  Arcane::Item first(ItemConnection const& connection)  const {
    return m_graph_connectivity->dualItem(m_graph_connectivity->dualNodes(connection.internal())[0]) ;
  }

  template <class FirstItemKind,class SecondItemKind>
  FirstItemKind first(ItemConnectionT<FirstItemKind,SecondItemKind> const& connection)  const {
    return FirstItemKind(m_graph_connectivity->dualItem(m_graph_connectivity->dualNodes(connection.internal())[0]).internal()) ;
  }

  Arcane::Item first(ItemConnectionEnumerator& iconnection)  const {
    return m_graph_connectivity->dualItem(m_graph_connectivity->dualNodes(iconnection->internal())[0]) ;
  }

  template <class FirstItemKind,class SecondItemKind>
  FirstItemKind first(ItemConnectionEnumeratorT<FirstItemKind,SecondItemKind>& iconnection) const {
    return FirstItemKind(m_graph_connectivity->dualItem(m_graph_connectivity->dualNodes(iconnection->internal())[0]).internal()) ;
  }

  Arcane::Item second(ItemConnection const& connection)  const {
    return m_graph_connectivity->dualItem(m_graph_connectivity->dualNodes(connection.internal())[1]) ;
  }

  template <class FirstItemKind,class SecondItemKind>
  SecondItemKind second(ItemConnectionT<FirstItemKind,SecondItemKind> const& connection)  const {
    return SecondItemKind(m_graph_connectivity->dualItem(m_graph_connectivity->dualNodes(connection.internal())[1]).internal()) ;
  }

  Arcane::Item second(ItemConnectionEnumerator& iconnection)  const {
    return m_graph_connectivity->dualItem(m_graph_connectivity->dualNodes(iconnection->internal())[1]) ;
  }

  template <class FirstItemKind,class SecondItemKind>
  SecondItemKind second(ItemConnectionEnumeratorT<FirstItemKind,SecondItemKind>& iconnection)  const {
    return SecondItemKind(m_graph_connectivity->dualItem(m_graph_connectivity->dualNodes(iconnection->internal())[1]).internal()) ;
  }

  Arcane::Integer type(ItemConnection const& connection)  const {
    return connectionType(itemConnectionTypeFromKind(first(connection).kind()),
                          itemConnectionTypeFromKind(second(connection).kind()));
  }

  Arcane::Integer type(ItemConnectionEnumerator& iconnection)  const {
    return connectionType(itemConnectionTypeFromKind(first(iconnection).kind()),
                          itemConnectionTypeFromKind(second(iconnection).kind()));
  }
#else // Arcane 2
    Arcane::Item first(ItemConnection const& connection)  const {
    return connection.first();
  }

  template <class FirstItemKind,class SecondItemKind>
  FirstItemKind first(ItemConnectionT<FirstItemKind,SecondItemKind> const& connection)  const {
    return connection.first().internal() ;
  }

  Arcane::Item first(ItemConnectionEnumerator& iconnection)  const {
    return iconnection->first() ;
  }

  template <class FirstItemKind,class SecondItemKind>
  FirstItemKind first(ItemConnectionEnumeratorT<FirstItemKind,SecondItemKind>& iconnection) const {
    return iconnection->first().internal() ;
  }

  Arcane::Item second(ItemConnection const& connection)  const {
    return connection.second() ;
  }

  template <class FirstItemKind,class SecondItemKind>
  SecondItemKind second(ItemConnectionT<FirstItemKind,SecondItemKind> const& connection)  const {
    return connection.second().internal() ;
  }

  Arcane::Item second(ItemConnectionEnumerator& iconnection)  const {
    return iconnection->first() ;
  }

  template <class FirstItemKind,class SecondItemKind>
  SecondItemKind second(ItemConnectionEnumeratorT<FirstItemKind,SecondItemKind>& iconnection)  const {
    return iconnection->second().internal() ;
  }

  Arcane::Integer type(ItemConnection const& connection)  const {
    return connectionType(itemConnectionTypeFromKind(first(connection).kind()),
                          itemConnectionTypeFromKind(second(connection).kind()));
  }

  Arcane::Integer type(ItemConnectionEnumerator& iconnection)  const {
    return connectionType(itemConnectionTypeFromKind(first(iconnection).kind()),
                          itemConnectionTypeFromKind(second(iconnection).kind()));
  }
#endif
private:
  Arcane::IMesh* m_mesh = nullptr;
#if (ARCANE_VERSION >= 30003)
  Arcane::IGraph2* m_graph = nullptr ;
  Arcane::IGraphConnectivity const* m_graph_connectivity = nullptr;
#endif
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

typedef ItemConnectionT<Cell,Particle> CellParticleConnection;
typedef ItemConnectionT<Cell,Cell> CellCellConnection;
typedef ItemConnectionT<Cell,Face> CellFaceConnection;
typedef ItemConnectionT<Cell,Node> CellNodeConnection;
typedef ItemConnectionT<Face,Particle> FaceParticleConnection;
typedef ItemConnectionT<Face,Cell> FaceCellConnection;
typedef ItemConnectionT<Face,Face> FaceFaceConnection;
typedef ItemConnectionT<Face,Node> FaceNodeConnection;
typedef ItemConnectionT<Node,Particle> NodeParticleConnection;
typedef ItemConnectionT<Node,Cell> NodeCellConnection;
typedef ItemConnectionT<Node,Face> NodeFaceConnection;
typedef ItemConnectionT<Node,Node> NodeNodeConnection;
typedef ItemConnectionEnumeratorT<Cell,Particle> CellParticleConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Cell,Cell> CellCellConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Cell,Face> CellFaceConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Cell,Node> CellNodeConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Face,Particle> FaceParticleConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Face,Cell> FaceCellConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Face,Face> FaceFaceConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Face,Node> FaceNodeConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Node,Particle> NodeParticleConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Node,Cell> NodeCellConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Node,Face> NodeFaceConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Node,Node> NodeNodeConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Particle,Particle> ParticleParticleConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Particle,Cell> ParticleCellConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Particle,Face> ParticleFaceConnectionEnumerator;
typedef ItemConnectionEnumeratorT<Particle,Node> ParticleNodeConnectionEnumerator;

#define ENUMERATE_CONNECTION(name,group) for (ArcGeoSim::ItemConnectionEnumerator name  = group.enumerator(); name.hasNext(); ++name)
#define ENUMERATE_CELLPARTICLE_CONNECTION(name,group) for (ArcGeoSim::CellParticleConnectionEnumerator name = group.enumerator(); name.hasNext(); ++name)
#define ENUMERATE_CELLCELL_CONNECTION(name,group) for (ArcGeoSim::CellCellConnectionEnumerator name = group.enumerator(); name.hasNext(); ++name)
#define ENUMERATE_CELLFACE_CONNECTION(name,group) for (ArcGeoSim::CellFaceConnectionEnumerator name = group.enumerator(); name.hasNext(); ++name)
#define ENUMERATE_CELLNODE_CONNECTION(name,group) for (ArcGeoSim::CellNodeConnectionEnumerator name = group.enumerator(); name.hasNext(); ++name)
#define ENUMERATE_FACEPARTICLE_CONNECTION(name,group) for (ArcGeoSim::FaceParticleConnectionEnumerator name = group.enumerator(); name.hasNext(); ++name)
#define ENUMERATE_FACECELL_CONNECTION(name,group) for (ArcGeoSim::FaceCellConnectionEnumerator name = group.enumerator(); name.hasNext(); ++name)
#define ENUMERATE_FACEFACE_CONNECTION(name,group) for (ArcGeoSim::FaceFaceConnectionEnumerator name = group.enumerator(); name.hasNext(); ++name)
#define ENUMERATE_FACENODE_CONNECTION(name,group) for (ArcGeoSim::FaceNodeConnectionEnumerator name = group.enumerator(); name.hasNext(); ++name)
#define ENUMERATE_NODEPARTICLE_CONNECTION(name,group) for (ArcGeoSim::NodeParticleConnectionEnumerator name = group.enumerator(); name.hasNext(); ++name)
#define ENUMERATE_NODECELL_CONNECTION(name,group) for (ArcGeoSim::NodeCellConnectionEnumerator name = group.enumerator(); name.hasNext(); ++name)
#define ENUMERATE_NODEFACE_CONNECTION(name,group) for (ArcGeoSim::NodeFaceConnectionEnumerator name = group.enumerator(); name.hasNext(); ++name)
#define ENUMERATE_NODENODE_CONNECTION(name,group) for (ArcGeoSim::NodeNodeConnectionEnumerator name = group.enumerator(); name.hasNext(); ++name)

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

// All ItemConnectionVariable are partial variables since AllConnections not necessarily = AllLinks
// => all [] operator are direct access and not enumerated access, to mimic a AllItems variable (ie no problem in enumerating a sub-group).
template <class DataType>
class ItemConnectionVariableScalarRefT : public Arcane::MeshPartialVariableScalarRefT<ItemConnectionImpl::type,DataType>
{
public :
  typedef Arcane::MeshPartialVariableScalarRefT<ItemConnectionImpl::type,DataType> VariableImpl;
  typedef typename VariableImpl::ReturnReferenceType ReturnType;
  typedef typename VariableImpl::ConstReturnReferenceType ConstReturnType;
public:
    ItemConnectionVariableScalarRefT(const Arcane::VariableBuildInfo& vbi)
    : VariableImpl(Arcane::VariableBuildInfo(vbi.mesh(),
                                             vbi.name(),
#if (ARCANE_VERSION >= 30003)
                                             vbi.mesh()->findItemFamily(ItemConnectionImpl::kind(),"Links",true)->name(),
#else
                                             vbi.mesh()->itemFamily(ItemConnectionImpl::kind())->name(),
#endif
                                             ItemConnectionMng::allConnectionGroupName(),
                                             vbi.property())){}
  ConstReturnType operator[] (const ItemConnection& item_connection) const {return VariableImpl::operator [](item_connection.internal());}
  ConstReturnType operator[] (const ItemConnectionEnumerator& item_connection_enumerator) const {return VariableImpl::operator [](item_connection_enumerator->internal());}
  ReturnType operator[] (const ItemConnection& item_connection) {return VariableImpl::operator [](item_connection.internal());}
  ReturnType operator[] (const ItemConnectionEnumerator& item_connection_enumerator) {return VariableImpl::operator [](item_connection_enumerator->internal());}
};

/*---------------------------------------------------------------------------*/

template <class DataType>
class ItemConnectionPartialVariableScalarRefT : public Arcane::MeshPartialVariableScalarRefT<ItemConnectionImpl::type,DataType>
{
public :
  typedef Arcane::MeshPartialVariableScalarRefT<ItemConnectionImpl::type,DataType> VariableImpl;
  typedef typename VariableImpl::ReturnReferenceType ReturnType;
  typedef typename VariableImpl::ConstReturnReferenceType ConstReturnType;
public:
  ItemConnectionPartialVariableScalarRefT(const Arcane::VariableBuildInfo& vbi) : VariableImpl(vbi){}
  ConstReturnType operator[] (const ItemConnection& item_connection) const {return VariableImpl::operator [](item_connection.internal());}
  ConstReturnType operator[] (const ItemConnectionEnumerator& item_connection_enumerator) const {return VariableImpl::operator [](item_connection_enumerator);}
  ReturnType operator[] (const ItemConnection& item_connection) {return VariableImpl::operator [](item_connection.internal());}
  ReturnType operator[] (const ItemConnectionEnumerator& item_connection_enumerator) {return VariableImpl::operator [](item_connection_enumerator);}
};

/*---------------------------------------------------------------------------*/

// All ItemConnectionVariable are partial variables since AllConnections not necessarily = AllLinks
// => all [] operator are direct access and not enumerated access, to mimic a AllItems variable (ie no problem in enumerating a sub-group).
template <class DataType>
class ItemConnectionVariableArrayRefT : public Arcane::MeshPartialVariableArrayRefT<ItemConnectionImpl::type,DataType>
{
public:
  typedef Arcane::MeshPartialVariableArrayRefT<ItemConnectionImpl::type,DataType> VariableImpl;
  typedef typename VariableImpl::ReturnReferenceType ReturnType;
  typedef typename VariableImpl::ConstReturnReferenceType ConstReturnType;
public:
  ItemConnectionVariableArrayRefT(const Arcane::VariableBuildInfo& vbi)
    : VariableImpl(Arcane::VariableBuildInfo(vbi.mesh(),
                                             vbi.name(),
#if (ARCANE_VERSION >= 30003)
                                             vbi.mesh()->findItemFamily(ItemConnectionImpl::kind(),"Links",true)->name(),
#else
                                             vbi.mesh()->itemFamily(ItemConnectionImpl::kind())->name(),
#endif
                                             ItemConnectionMng::allConnectionGroupName(),
                                             vbi.property())){}
  ConstReturnType operator[] (const ItemConnectionEnumerator& item_connection_enumerator) const {return VariableImpl::operator [](item_connection_enumerator->internal());}
  ConstReturnType operator[] (const ItemConnection& item_connection) const {return VariableImpl::operator [](item_connection.internal());}
  ReturnType operator[] (const ItemConnectionEnumerator& item_connection_enumerator) {return VariableImpl::operator [](item_connection_enumerator->internal());}
  ReturnType operator[] (const ItemConnection& item_connection) {return VariableImpl::operator [](item_connection.internal());}
};

/*---------------------------------------------------------------------------*/

template <class DataType>
class ItemConnectionPartialVariableArrayRefT : public Arcane::MeshPartialVariableArrayRefT<ItemConnectionImpl::type,DataType>
{
public:
  typedef Arcane::MeshPartialVariableArrayRefT<ItemConnectionImpl::type,DataType> VariableImpl;
  typedef typename VariableImpl::ReturnReferenceType ReturnType;
  typedef typename VariableImpl::ConstReturnReferenceType ConstReturnType;
public:
  ItemConnectionPartialVariableArrayRefT(const Arcane::VariableBuildInfo& vbi) : VariableImpl(vbi){}
  ConstReturnType operator[] (const ItemConnectionEnumerator& item_connection_enumerator) const {return VariableImpl::operator [](item_connection_enumerator);}
  ConstReturnType operator[] (const ItemConnection& item_connection) const {return VariableImpl::operator [](item_connection.internal());}
  ReturnType operator[] (const ItemConnectionEnumerator& item_connection_enumerator) {return VariableImpl::operator [](item_connection_enumerator);}
  ReturnType operator[] (const ItemConnection& item_connection) {return VariableImpl::operator [](item_connection.internal());}
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

typedef ItemConnectionVariableScalarRefT<Arcane::Real> VariableItemConnectionReal;
typedef ItemConnectionVariableScalarRefT<Arcane::Real2> VariableItemConnectionReal2;
typedef ItemConnectionVariableScalarRefT<Arcane::Real3> VariableItemConnectionReal3;
typedef ItemConnectionVariableScalarRefT<Arcane::Real2x2> VariableItemConnectionReal2x2;
typedef ItemConnectionVariableScalarRefT<Arcane::Real3x3> VariableItemConnectionReal3x3;
typedef ItemConnectionVariableScalarRefT<Arcane::Integer> VariableItemConnectionInteger;
typedef ItemConnectionVariableScalarRefT<Arcane::Int32> VariableItemConnectionInt32;
typedef ItemConnectionVariableScalarRefT<Arcane::Int64> VariableItemConnectionInt64;
typedef ItemConnectionVariableScalarRefT<Arcane::String> VariableItemConnectionString;
typedef ItemConnectionVariableScalarRefT<Arcane::Byte> VariableItemConnectionByte;

typedef ItemConnectionPartialVariableScalarRefT<Arcane::Real> PartialVariableItemConnectionReal;
typedef ItemConnectionPartialVariableScalarRefT<Arcane::Real2> PartialVariableItemConnectionReal2;
typedef ItemConnectionPartialVariableScalarRefT<Arcane::Real3> PartialVariableItemConnectionReal3;
typedef ItemConnectionPartialVariableScalarRefT<Arcane::Real2x2> PartialVariableItemConnectionReal2x2;
typedef ItemConnectionPartialVariableScalarRefT<Arcane::Real3x3> PartialVariableItemConnectionReal3x3;
typedef ItemConnectionPartialVariableScalarRefT<Arcane::Integer> PartialVariableItemConnectionInteger;
typedef ItemConnectionPartialVariableScalarRefT<Arcane::Int32> PartialVariableItemConnectionInt32;
typedef ItemConnectionPartialVariableScalarRefT<Arcane::Int64> PartialVariableItemConnectionInt64;
typedef ItemConnectionPartialVariableScalarRefT<Arcane::String> PartialVariableItemConnectionString;
typedef ItemConnectionPartialVariableScalarRefT<Arcane::Byte> PartialVariableItemConnectionByte;

typedef ItemConnectionVariableArrayRefT<Arcane::Real> VariableItemConnectionArrayReal;
typedef ItemConnectionVariableArrayRefT<Arcane::Real2> VariableItemConnectionArrayReal2;
typedef ItemConnectionVariableArrayRefT<Arcane::Real3> VariableItemConnectionArrayReal3;
typedef ItemConnectionVariableArrayRefT<Arcane::Real2x2> VariableItemConnectionArrayReal2x2;
typedef ItemConnectionVariableArrayRefT<Arcane::Real3x3> VariableItemConnectionArrayReal3x3;
typedef ItemConnectionVariableArrayRefT<Arcane::Integer> VariableItemConnectionArrayInteger;
typedef ItemConnectionVariableArrayRefT<Arcane::Int32> VariableItemConnectionArrayInt32;
typedef ItemConnectionVariableArrayRefT<Arcane::Int64> VariableItemConnectionArrayInt64;
typedef ItemConnectionVariableArrayRefT<Arcane::String> VariableItemConnectionArrayString;
typedef ItemConnectionVariableArrayRefT<Arcane::Byte> VariableItemConnectionArrayByte;

typedef ItemConnectionPartialVariableArrayRefT<Arcane::Real> PartialVariableItemConnectionArrayReal;
typedef ItemConnectionPartialVariableArrayRefT<Arcane::Real2> PartialVariableItemConnectionArrayReal2;
typedef ItemConnectionPartialVariableArrayRefT<Arcane::Real3> PartialVariableItemConnectionArrayReal3;
typedef ItemConnectionPartialVariableArrayRefT<Arcane::Real2x2> PartialVariableItemConnectionArrayReal2x2;
typedef ItemConnectionPartialVariableArrayRefT<Arcane::Real3x3> PartialVariableItemConnectionArrayReal3x3;
typedef ItemConnectionPartialVariableArrayRefT<Arcane::Integer> PartialVariableItemConnectionArrayInteger;
typedef ItemConnectionPartialVariableArrayRefT<Arcane::Int32> PartialVariableItemConnectionArrayInt32;
typedef ItemConnectionPartialVariableArrayRefT<Arcane::Int64> PartialVariableItemConnectionArrayInt64;
typedef ItemConnectionPartialVariableArrayRefT<Arcane::String> PartialVariableItemConnectionArrayString;
typedef ItemConnectionPartialVariableArrayRefT<Arcane::Byte> PartialVariableItemConnectionArrayByte;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_ARCGEOSIM_NAMESPACE


#endif /* ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMITEMCONNECTIONS_H */
