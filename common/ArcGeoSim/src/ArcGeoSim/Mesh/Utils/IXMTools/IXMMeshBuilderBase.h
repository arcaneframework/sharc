// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMMESHBUILDERBASE_H
#define ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMMESHBUILDERBASE_H
/* Author : dechaiss at Fri Jul 13 14:08:12 2012
 * Generated by createNew
 */

#include <set>
#include <map>
#include <arcane/ArcaneVersion.h>
#include <arcane/BasicService.h>
#include <arcane/ServiceBuildInfo.h>
#include <arcane/IPrimaryMesh.h>
#include <arcane/IParallelMng.h>
#include <arcane/mesh/CellFamily.h>

#if (ARCANE_VERSION >= 30003)
#include <arcane/mesh/GraphDoFs.h>
#include <arcane/mesh/GraphBuilder.h>
#else
#include <arcane/IGraph.h>
#include <arcane/IGraphModifier.h>
#endif

#include "ArcGeoSim/Utils/ArcGeoSim.h"
#include "ArcGeoSim/Utils/ParallelUtils.h"
#include "ArcGeoSim/Utils/Utils.h"
#include <arcane/ArcaneVersion.h>
#include <arcane/IVariable.h>
//#include "ArcGeoSim/Mesh/EvolutiveMesh/IEvolutiveMesh.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/EvolutiveMeshProperty.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMTools.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMMeshBuilderBase.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMUidToLidMng.h"

BEGIN_ARCGEOSIM_NAMESPACE

using namespace IXMTools;

//! Association uid -> proc proprietaire
typedef std::map<Int64,Integer> OwnerMap;

//class IXMEvolutiveMeshBuilderObserverMng;

class IXMMeshBuilderBase : public Arcane::TraceAccessor
{
  /*!
   * Classe d'implementation a usage interne uniquement. L'API doit manipuler les classes IXMEvolutiveMeshBuilder ou IXMMeshBuilder.
   */
public:
  
  /** Constructeur de la classe */
  IXMMeshBuilderBase(Arcane::IMesh * mesh, Arcane::ITraceMng * traceMng, Arcane::IParallelMng * parallelMng);
  
  /** Destructeur de la classe */
  virtual ~IXMMeshBuilderBase() {}
  
public:

  void staticInit(Arcane::IPrimaryMesh * mesh);

  void evolutiveInit(Arcane::IPrimaryMesh * mesh);

  //! Gestion des operations de base sur les cellules. Peut decrire un increment de maillage evolutif ou une creation de maillage statique.
  //! Dans ce dernier cas les tableaux removed_cells et changed sont vides et on ne donne pas le cell_partition_info
  //! Le booleen retourne indique si la topologie a change.
  bool manageCellOperations(Arcane::IPrimaryMesh * mesh,
                            const IXMCellData& new_cells,
                            const IXMCellData& removed_cells,
                            const IXMCellData& changed_cells,
                            const IXMCellIncrementPartitionInfo& cell_partition_info = IXMCellIncrementPartitionInfo(),
                            const bool check = false);

  //! Gestion des operations de noeuds. Utilisable pour maillage evolutif ou statique. Dans le cas statique, la structure cloned_nodes sera vide.
  //! Le booleen retourne indique si la topologie a change.
  bool manageUpdatedNodes(Arcane::IPrimaryMesh * mesh, const IXMNodeData& added_nodes, const IXMClonedNodeData& cloned_nodes, const bool check = false);

  //! Gestion des operations de noeuds. Utilisable pour maillage evolutif ou statique. Dans le cas statique, la chaine group_operation sera vide.
  //! Le booleen retourne indique si la topologie a change.
  bool manageGroup(Arcane::IMesh* mesh, const IXMGroupData group_data, const Arcane::String& group_operation, const IXMUidToLidMng& uid2lid_mng, const bool check = false);

  //! Ajout des connections
  void addConnections(Arcane::IPrimaryMesh* mesh, const IXMConnectionData& connection_data, IXMUidToLidMng& uid2lid_mng);

  //! Groupe des cellules en cours de suppression
  Arcane::CellGroup toRemoveCells();

  //! Groupe des nouvelles cellules
  Arcane::CellGroup newCells();

  //! Groupe des nouveaux noeuds
  Arcane::NodeGroup newNodes();

  //! Groupe des noeuds jumeaux
  Arcane::NodeGroup twinNodes();

  //! Groupe des nouvelles faces
  Arcane::FaceGroup newFaces();

  //! Groupe des faces jumelles
  Arcane::FaceGroup twinFaces();

  //! Groupe des cellules topologiquement modifi�es
  Arcane::CellGroup updatedCells();

  //! Groupe des noeuds topologiquement modifi�s
  Arcane::NodeGroup updatedNodes();

  //! Ensemble des groupes ayant �t� modifi�s
  Arcane::ItemGroupCollection changedGroups();

  //! Indique si un groupe a chang� (hors groupe globaux)
  bool hasChangedGroup(const ItemGroup group);

  //! Indique les types de changement sur un groupe donn� (hors groupes globaux)
  /*! Les modifications sont donn�es comme ou logique (|) de eGroupEvent */
  Arcane::Integer groupChangeTypes(const ItemGroup group);

  //! Liste des items constituants la modification li� � l'�v�nement "event"
  Arcane::ItemVector groupChanges(const ItemGroup group, EvolutiveMeshProperty::eGroupEvent event, const bool check);

#ifdef USE_EVOLUTIF
  //! Libere les structures de donnees de l'increment effectue
  void resetIncrement();

  //! Information de l'observeur de EvolutiveMesh
  void setEvolutiveMeshObserverMng(IXMEvolutiveMeshBuilderObserverMng* const observer_mng){m_evolutive_mesh_observer_mng = observer_mng;}
  void notifyEvolutiveMeshObservers(IEvolutiveMesh::eStatus status);
#endif


#if (ARCANE_VERSION >= 30003)
  Arcane::IGraph2* graph() {
    return m_graph ;
  }
#endif
protected:
  Arcane::IMesh* m_mesh;
  Arcane::IParallelMng* m_parallel_mng;

#if (ARCANE_VERSION >= 30003)
  Arcane::IGraph2* m_graph = nullptr;
#endif

  Arcane::CellGroup m_old_cells; //!< Cellules en passe d'�tre supprim�es
  Arcane::CellGroup m_new_cells; //!< Nouvelles cellules
  Arcane::NodeGroup m_new_nodes; //!< Nouveaux noeuds
  Arcane::NodeGroup m_twin_nodes; //!< Noeuds jumeaux
  Arcane::EdgeGroup m_new_edges; //!< Nouvelles ar�tes
  Arcane::EdgeGroup m_twin_edges; //!< Ar�tes jumelles
  Arcane::FaceGroup m_new_faces; //!< Nouvelles faces
  Arcane::FaceGroup m_twin_faces; //!< Faces jumelles

  Arcane::CellGroup m_updated_cells; //!< Cellules modifi�es
  Arcane::NodeGroup m_updated_nodes; //!< Noeuds modifi�s (topologie)

  bool m_is_initialized;

  ArcGeoSim::ParallelUtils m_parallel_utils;

#ifdef USE_EVOLUTIF
  IXMEvolutiveMeshBuilderObserverMng* m_evolutive_mesh_observer_mng;
#endif

  struct RemovedCellData {
	  RemovedCellData(Arcane::mesh::CellFamily * f) : cell_family(f) { }
      Arcane::mesh::CellFamily * cell_family;
      Arcane::Int32SharedArray old_removed_cell_lids;
      Arcane::Int64SharedArray old_removed_cell_uids;
    };


  struct ChangedCellData {
    ChangedCellData(Arcane::mesh::CellFamily * f) : cell_family(f) { }
    Arcane::mesh::CellFamily * cell_family;
    Arcane::Int32SharedArray old_changed_cell_lids;
    Arcane::Int64SharedArray old_changed_cell_uids;
    Arcane::Int32SharedArray new_changed_cell_lids;
  };

  struct ChangedFaceData {
	  ChangedFaceData(Arcane::mesh::FaceFamily * f) : face_family(f) { }
	  Arcane::mesh::FaceFamily * face_family;
      Arcane::Int32SharedArray old_changed_face_lids;
      Arcane::Int32SharedArray new_changed_face_lids;
    };

  struct ChangedNodeData {
  	  ChangedNodeData(Arcane::mesh::NodeFamily * f) : node_family(f) { }
  	    Arcane::mesh::NodeFamily * node_family;
        Arcane::Int32SharedArray old_changed_node_lids;
        Arcane::Int32SharedArray new_changed_node_lids;
      };

  struct ChangedEdgeData {
    	  ChangedEdgeData(Arcane::mesh::EdgeFamily * f) : edge_family(f) { }
    	  Arcane::mesh::EdgeFamily * edge_family;
          Arcane::Int32SharedArray old_changed_edge_lids;
          Arcane::Int32SharedArray new_changed_edge_lids;
        };

  //! Structure interne de gestion des groupes
  struct GroupChangeInfo
  {
    GroupChangeInfo()
    {}
    Arcane::Integer m_info = EvolutiveMeshProperty::None ;
    Arcane::ItemGroupImpl * m_group = nullptr;
    Arcane::Int64SharedArray m_added_items;
    Arcane::Int64SharedArray m_deleted_items;
  };

  Arcane::ItemGroupCollection m_changed_group_collection;
  typedef std::map<Arcane::ItemGroupImpl *, GroupChangeInfo> GroupChangeMap; //!< Type interne des modifications de groupe
  GroupChangeMap m_changed_groups; //!< Groupe modifi�

  typedef std::set<Arcane::IItemFamily*> IItemFamilySet;
  void _findAllCellChildFamilies(Arcane::IItemFamily * family, Arcane::SharedArray<ChangedCellData> & child_array, IItemFamilySet & scanned_families);

  void _findAllFaceChildFamilies(Arcane::IItemFamily * family, Arcane::SharedArray<ChangedFaceData> & child_array, IItemFamilySet & scanned_families);

  void _findAllNodeChildFamilies(Arcane::IItemFamily * family, Arcane::SharedArray<ChangedNodeData> & child_array, IItemFamilySet & scanned_families);

  void _findAllEdgeChildFamilies(Arcane::IItemFamily * family, Arcane::SharedArray<ChangedEdgeData> & child_array, IItemFamilySet & scanned_families);

  void _findAllCellChildFamilies(Arcane::IItemFamily * family, Arcane::SharedArray<RemovedCellData> & child_array, IItemFamilySet & scanned_families);


  Arcane::Int32SharedArray _addCells(Arcane::IPrimaryMesh * mesh,
                               const bool need_edge,
                               const Arcane::Int64ConstArrayView cell_uids,
                               const Arcane::Int64ConstArrayView cell_infos,
                               const Arcane::Int64ConstArrayView cell_connectivity_infos,
                               const Arcane::Int32ConstArrayView cell_connectivity_owners);


  void _updateNeighborOwners(Arcane::IPrimaryMesh * mesh, Arcane::CellGroup cellGroup);

  // Connections
  struct ConnectionItems
  {
    Arcane::ParticleVectorView m_particles;
    Arcane::CellVectorView m_cells;
    Arcane::FaceVectorView m_faces;
    Arcane::EdgeVectorView m_edges;
    Arcane::NodeVectorView m_nodes;
    Arcane::Int32SharedArray m_lids[ICT_NbItemTypes];
    Arcane::Integer size() const {return m_particles.size() + m_cells.size()+m_faces.size()+m_edges.size()+m_nodes.size();}
  };

  struct ConnectionDescription
  {
    ConnectionDescription(const Arcane::Integer first_item_position, const Arcane::Integer second_item_position, const Arcane::Int64 connection_aid)
      : first_item_position(first_item_position)
      , second_item_position(second_item_position)
      , connection_aid(connection_aid) {}
    const Arcane::Integer first_item_position;//! index de l'item dans le tableau des items de meme famille
    const Arcane::Integer second_item_position;//! index de l'item dans le tableau des items de meme famille
    const Arcane::Int64 connection_aid;
  };

  typedef Arcane::SharedArray<ConnectionDescription> ConnectionDescriptionArray; // connections of same type (cell-cell, face-cell, ...)
  typedef Arcane::Integer ConnectionType;
  typedef std::map<ConnectionType,ConnectionDescriptionArray> ConnectionDescriptions; // all connections.
  ConnectionDescriptions m_connection_description;



  void _extractConnectionInfo (Arcane::IPrimaryMesh* mesh,
                               const IXMConnectionData& connection_data,
                               const IXMUidToLidMng& uid2lid_mng,
                               ConnectionItems& connection_items,
                               ConnectionDescriptions& connection_descriptions);
  void _buildDualNodeInfo(const ConnectionItems& connection_items, Arcane::Int64SharedArray& dual_node_infos) const;
  void _buildLinkInfo(const ConnectionItems& connection_items,
                      const ConnectionDescriptions& connection_description,
                      Arcane::Int64SharedArray& link_infos,
                      IXMConnectionData& connection_mapping_info) const;

  template<class DualItemKind>
  void _buildDualNodeInfoT(const Arcane::ItemVectorViewT<DualItemKind>& connection_items, Arcane::Int64SharedArray& dual_node_infos, const Arcane::Integer& dual_node_type) const;

  template<class FirstDualItemKind>
  void _buildLinkInfoT(const Arcane::ItemVectorViewT<FirstDualItemKind>& connection_first_items,
                       const ConnectionItems& connection_second_items,
                       const ConnectionDescriptions& connection_description,
                       const Arcane::Integer first_item_type,
                       Arcane::Int64SharedArray& link_infos,
                       IXMConnectionData& connection_mapping_info) const;

  template<class FirstDualItemKind,class SecondDualItemKind>
  void _buildLinkInfoBaseT(const Arcane::ItemVectorViewT<FirstDualItemKind>& connection_first_items,
                           const Arcane::ItemVectorViewT<SecondDualItemKind>& connection_second_items,
                           const ConnectionDescriptions& connection_description,
                           const Arcane::Integer connection_type,
                           Arcane::Int64SharedArray& link_infos,
                           IXMConnectionData& connection_mapping_info) const;

  void _createAllConnectionGroup(Arcane::Int64ConstArrayView connection_uids, Arcane::IMesh* mesh);

};

END_ARCGEOSIM_NAMESPACE

#endif /* ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMMESHBUILDERBASE_H */
