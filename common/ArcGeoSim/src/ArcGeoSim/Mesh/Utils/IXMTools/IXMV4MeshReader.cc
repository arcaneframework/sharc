#include "IXMV4MeshReader.h"
/* Author : dechaiss at Wed Jul 18 14:32:13 2012
 * Generated by createNew
 */

#ifdef WIN32
#include <ciso646>
#endif

#include <boost/tuple/tuple.hpp> // Use std::tuple instead in C++11

#include <arcane/utils/OStringStream.h>
#include <arcane/DomUtils.h>
ARCANE_BEGIN_NAMESPACE
ARCANE_BEGIN_NAMESPACE_DOMUTILS

extern "C++" ARCANE_CORE_EXPORT void
removeAllChildren(const dom::Node& parent);

extern "C++" ARCANE_CORE_EXPORT bool
writeNode(std::ostream& ostr,const dom::Node&);

extern "C++" ARCANE_CORE_EXPORT bool
writeNodeChildren(std::ostream& ostr,const dom::Node&);

ARCANE_END_NAMESPACE_DOMUTILS
ARCANE_END_NAMESPACE


#include "ArcGeoSim/Mesh/Utils/IXMTools/ixm_v4_xsd.h"
#include "ArcGeoSim/Mesh/Utils/StringToItemUtils.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/ParticleReader.h"
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace ArcGeoSim::IXMTools::IXMPropertyExceptions;

/*---------------------------------------------------------------------------*/

// Set static member of some IXM struct used
#ifdef USE_EVOLUTIF
Arcane::String ArcGeoSim::IXMTools::IXMPropertyIncrementDataList::mesh_type = "evolutive";
#endif
Arcane::String ArcGeoSim::IXMTools::IXMPropertyDataList::mesh_type = "static";

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMV4MeshReader::
IXMV4MeshReader(Arcane::IIOMng* io_mng,
                Arcane::IParallelMng* parallel_mng,
                Arcane::ITraceMng* trace_mng)
  : m_io_mng(io_mng)
  , m_parallel_mng(parallel_mng)
  , m_trace_mng(trace_mng)
  , m_grid_type("NoGrid")
  , m_grid_dimension("NoGrid")
  , m_supported_version("V4")
{
}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMV4MeshReader::
~IXMV4MeshReader()
{
  if (m_xmldoc) delete m_xmldoc;
}

/*---------------------------------------------------------------------------*/

Arcane::String
ArcGeoSim::IXMV4MeshReader::
loadMeshFile(IXMMeshFile mesh_file)
{

  if(m_parallel_mng->commRank()==0)
  {
    // Get xml document from mesh file
    m_xmldoc << mesh_file(m_io_mng,"ixm_v4.xsd",Arcane::ByteConstArrayView(strlen((const char*) ixm_v4_xsd), ixm_v4_xsd));

    // Go to event definition
    Arcane::XmlNode rootNode = m_xmldoc->documentNode().child("ixm");


    // Up to now only unstructured grid authorized by xsd
    m_grid_type = "unstructured-grid";
    Arcane::XmlNode gridRoot = rootNode.child(m_grid_type);

    // Check grid attributes

    String dimension = gridRoot.attrValue("dimension");
    m_grid_dimension = dimension ;
    m_parallel_mng->broadcastString(dimension,0) ;

    // Check version number
    /*
    ArcGeoSim::IXMMeshVersion mesh_version = mesh_file.version(m_io_mng,m_parallel_mng);
    if (mesh_version != m_supported_version)
      m_trace_mng->fatal() << Arcane::String::format("Cannot read {0} mesh file version. Supported mesh version is {1}.",
                                                     mesh_version.str(),m_supported_version.str());
    */
//#ifdef USE_EVOLUTIF
    m_events_data = gridRoot.children("event");

    // Check unicity of event names
    std::set<String> event_names;
    for(Integer iEvent=0;iEvent<m_events_data.size();++iEvent)
      {
        const String current_name = m_events_data[iEvent].attr("name").value();
        const bool is_new_name = event_names.insert(current_name).second;
        if (not is_new_name) m_trace_mng->error() << "Event name '" << current_name << "' is duplicated";
      }
    if ((Integer)event_names.size() != m_events_data.size())
      m_trace_mng->fatal() << "Incorrect event definition: see errors above";
    m_nb_events_data_size = m_events_data.size() ;
//#endif
    m_mesh_data = gridRoot.child("mesh");
    m_has_mesh_data = ! m_mesh_data.null() ;
    SharedArray<Integer> buffer(2) ;
    buffer[0] = m_has_mesh_data?1:0 ;
    buffer[1] = m_nb_events_data_size ;
    m_parallel_mng->broadcast(buffer,0) ;
  }
  else
  {
    String dimension ;
    m_parallel_mng->broadcastString(dimension,0) ;
    m_grid_dimension = dimension ;
    SharedArray<Integer> buffer(2) ;
    m_parallel_mng->broadcast(buffer,0) ;
    m_has_mesh_data = buffer[0]!=0 ;
    m_nb_events_data_size = buffer[1] ;
  }

  m_mesh_file_directory_name = mesh_file.path();

  return m_mesh_file_directory_name;
}

/*---------------------------------------------------------------------------*/

Arcane::String
ArcGeoSim::IXMV4MeshReader::
meshType()
{
  return m_grid_type;
}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IXMMeshDimension
ArcGeoSim::IXMV4MeshReader::
meshDimension()
{
  return m_grid_dimension;
}

/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
Arcane::Integer
ArcGeoSim::IXMV4MeshReader::meshIncrementNumber()
{
  return m_nb_events_data_size ;
}

/*---------------------------------------------------------------------------*/

ArcGeoSim::IIXMEvolutiveMeshReader::IXMMeshIncrementInfo
ArcGeoSim::IXMV4MeshReader::
meshIncrementInfo(const Arcane::Integer& mesh_increment_number,bool synch)
{

  SharedArray<Real> buffer(2) ;
  Arcane::String name ;
  if(m_parallel_mng->commRank()==0)
  {
    ARCANE_ASSERT((!m_events_data.empty()),("No mesh file loaded in IXM V4 reader."))
    ARCANE_ASSERT((mesh_increment_number < m_events_data.size()),("Number of mesh increment is exceeded, in IXM V4 reader"))
    // Get mesh increment info
    Arcane::XmlNode& current_mesh_increment = m_events_data[mesh_increment_number];
    Arcane::XmlNode beginTimeNode = current_mesh_increment.attr("begin-time");
    Arcane::XmlNode endTimeNode = current_mesh_increment.attr("end-time");
    Arcane::Real begin_time = beginTimeNode.valueAsReal();
    Arcane::Real end_time = endTimeNode.valueAsReal();
    name = current_mesh_increment.attr("name").value();
    buffer[0] = begin_time ;
    buffer[1] = end_time ;
  }
  if(synch)
  {
     m_parallel_mng->broadcast(buffer,0) ;
     m_parallel_mng->broadcastString(name,0) ;
  }
  return IIXMEvolutiveMeshReader::IXMMeshIncrementInfo(buffer[0],buffer[1],name,mesh_increment_number);
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
loadMeshIncrement(const IIXMEvolutiveMeshReader::IXMMeshIncrementInfo& mesh_increment_info, const IXMLoadInfo& load_info)
{
  ARCANE_ASSERT((!m_events_data.empty()),("No mesh file loaded in IXM V4 reader."))
  ARCANE_ASSERT((mesh_increment_info.id < m_events_data.size()),("Number of mesh increment is exceeded, cannot load increment. In IXM V4 reader"))

  // Create mesh increment xml node
  if (m_mesh_increment_xml_node) delete m_mesh_increment_xml_node;
  m_mesh_increment_xml_node = new ArcGeoSim::IXMMeshIncrementXmlNode(mesh_increment_info);

  Arcane::XmlNode current_event;
  Arcane::XmlNode topology;
  Arcane::XmlNode geometry;
  Arcane::XmlNode properties;

  current_event = m_events_data[mesh_increment_info.id];

  // MeshIncrement
  Arcane::XmlNode mesh_increment = current_event.child("mesh-increment");

  //if(mesh_increment.null())
  //	  mesh_increment = current_event.child("mesh");


  if (!mesh_increment.null())
    {
      // Topology
      topology = mesh_increment.child("topology");
      if (!topology.null()) m_has_topology_increment = true;
      if ( (load_info & LoadTopology) == LoadTopology) m_mesh_increment_xml_node->topology_node.reset(new Arcane::XmlNode(topology));
      // Geometry
      geometry = mesh_increment.child("geometry");
      if (!geometry.null()) m_has_geometry_increment = true;
      if ( (load_info & LoadGeometry) == LoadGeometry) m_mesh_increment_xml_node->geometry_node.reset(new Arcane::XmlNode(geometry));
    }

  if( mesh_increment.null() )
  {
	  // Topology
	  topology = current_event.child("mesh");
	  if (!topology.null()) m_has_topology_increment = true;
	  if ( (load_info & LoadTopology) == LoadTopology) m_mesh_increment_xml_node->topology_node.reset(new Arcane::XmlNode(topology));
  }

  // Properties
  properties = current_event.child("properties");
  if (!properties.null()) m_has_property_increment = true;
  if ( (load_info & LoadProperties) == LoadProperties) m_mesh_increment_xml_node->property_node.reset(new Arcane::XmlNode(properties));

}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
unloadMeshIncrement()
{
  m_has_topology_increment = false;
  m_has_geometry_increment = false;
  m_has_property_increment = false;
  if (m_mesh_increment_xml_node)
    {
      delete m_mesh_increment_xml_node;
      m_mesh_increment_xml_node = NULL;
    }
  else 
    {
      m_trace_mng->warning() << "Cannot unload mesh increment : was not loaded. Ignoring";
    }
}

/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMV4MeshReader::
_isTopologyIncrementLoaded()
{
  if (m_mesh_increment_xml_node) return static_cast<bool>(m_mesh_increment_xml_node->topology_node);
  return false;
}

/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMV4MeshReader::
_isGeometryIncrementLoaded()
{
  if (m_mesh_increment_xml_node) return static_cast<bool>(m_mesh_increment_xml_node->geometry_node);
  return false;
}

/*---------------------------------------------------------------------------*/

bool
ArcGeoSim::IXMV4MeshReader::
_isPropertyIncrementLoaded()
{
  if (m_mesh_increment_xml_node) return static_cast<bool>(m_mesh_increment_xml_node->property_node);
  return false;
}
#endif
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
readCellData(ArcGeoSim::IXMTools::IXMCellData& cell_data, const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  ARCANE_ASSERT((!m_mesh_data.null()),("No mesh file loaded in IXM V4 reader."))
  Arcane::XmlNode rootNode = m_mesh_data.child("topology");

  // Get managers
  ItemTypeMng * typeMng = ItemTypeMng::singleton();
  { // Handle created cells
    _readCellInfos(rootNode.children("cells"),
        "cells",
        typeMng,
        cell_data.item_ids,
        cell_data.item_infos,
        check_mesh_info);
  }
}

/*---------------------------------------------------------------------------*/
void
ArcGeoSim::IXMV4MeshReader::
readEdgeData(ArcGeoSim::IXMTools::IXMEdgeData& edge_data, const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  //ARCANE_ASSERT((!m_mesh_data.null()),("No mesh file loaded in IXM V4 reader."))
  //Arcane::XmlNode rootNode = m_mesh_data.child("topology");

  // Choose between static and evolutive mesh
  Arcane::XmlNode rootNode;
  _getTopologyNode(rootNode);

  // Get managers
  ItemTypeMng * typeMng = ItemTypeMng::singleton();
  { // Handle created cells
    _readEdgeInfos(rootNode.children("edges"),
        "edges",
        typeMng,
        edge_data.item_ids,
        edge_data.item_infos,
        check_mesh_info);
  }
}


/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMV4MeshReader::
readCellIncrementData(ArcGeoSim::IXMTools::IXMCellIncrementData& cell_increment_data,const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV4MeshReader"))
  ARCANE_ASSERT((_isTopologyIncrementLoaded()),("Topology Increment not loaded in the IXMV4MeshReader"))

  Arcane::XmlNode rootNode = *(m_mesh_increment_xml_node->topology_node.get());

  // Get managers
  ItemTypeMng * typeMng = ItemTypeMng::singleton();

  { // Handle deleted cells
    Arcane::XmlNodeList delete_cell_list = rootNode.children("delete-cells");
    for (Arcane::XmlNodeList::const_iterator iCellList = delete_cell_list.begin();
         iCellList != delete_cell_list.end(); ++iCellList)
      { // Read delete-cells node
        Arcane::Int64SharedArray cell_ids = IXMInt64DataNodeReader(iCellList->child("cell-ids"),
                                                             "Error while reading delete-cells uids",
                                                             m_mesh_file_directory_name).read();
        cell_increment_data.removed_cell_data.item_ids.addRange(cell_ids);
      }
  }

  { // Handle created cells
      _readCellInfos(rootNode.children("create-cells"),
                       "create-cells",
                       typeMng,
                       cell_increment_data.new_cell_data.item_ids,
                       cell_increment_data.new_cell_data.item_infos,
                       check_mesh_info);
    }

    {// Handle modified cells
      _readCellInfos(rootNode.children("change-cells"),
                       "change-cells",
                       typeMng,
                       cell_increment_data.changed_cell_data.item_ids,
                       cell_increment_data.changed_cell_data.item_infos,
                       check_mesh_info);
    }
}
#endif
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
readFaceData(ArcGeoSim::IXMTools::IXMFaceData& face_data,const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  // Choose between static and evolutive mesh
  Arcane::XmlNode rootNode;
  _getTopologyNode(rootNode);

  Arcane::XmlNodeList facesList = rootNode.children("faces");

  // Iterate on "faces" xml node (minOccurs=0, maxOccurs=1)
  for (Arcane::XmlNodeList::const_iterator iFacesList = facesList.begin();
       iFacesList != facesList.end(); ++iFacesList)
    { // Read faces infos
      Arcane::IntegerSharedArray node_number = IXMIntegerDataNodeReader(iFacesList->child("face-types"),
                                                                  "Error while reading faces/face-types",
                                                                  m_mesh_file_directory_name).read();
      Arcane::Int64SharedArray face_ids = IXMInt64DataNodeReader(iFacesList->child("face-ids"),
                                                           "Error while reading faces/face-ids",
                                                           m_mesh_file_directory_name).read();
      Arcane::Int64SharedArray node_ids = IXMInt64DataNodeReader(iFacesList->child("node-ids"),
                                                           "Error while reading faces/node-ids",
                                                           m_mesh_file_directory_name).read();

      // Check sizes for node number and faces
      Arcane::Integer nb_faces = face_ids.size();
      if (node_number.size() != nb_faces) {
          m_trace_mng->info() << " node_number.size() =  " << node_number.size() << " face_ids.size() = " << face_ids.size() ;
        m_trace_mng->fatal() << "Different number of face types and face ids";
      }

      // Check (only in strict check mode) if node number does not contain values lower to 3
      if (check_mesh_info.isCheckEnabled() && check_mesh_info.dimension()>2)
        {
          for (Arcane::IntegerSharedArray::iterator ite = node_number.begin(); ite != node_number.end(); ++ite)
            {
              if (*ite < 3)
                m_trace_mng->fatal() << "Face described with less than 3 nodes in <faces>/<nodes-number>";
            }
        }

      // Check node number
      Integer total_nb_node = 0;
      for (Arcane::IntegerSharedArray::const_iterator ite = node_number.begin(); ite != node_number.end(); ++ite)
        total_nb_node += *ite;

      if (total_nb_node != node_ids.size())
        m_trace_mng->fatal() << "Inconsistent total node number not equal to face number times face node number. Total node number expected ="
                << total_nb_node << " Total node number received = " << node_ids.size();

      // Save infos into main containers
      face_data.faces.item_ids.addRange(face_ids);
      face_data.faces.item_infos.addRange(node_number);
      face_data.node_ids.addRange(node_ids);
    }
}

void
ArcGeoSim::IXMV4MeshReader::
_readEdgeInfos(const Arcane::XmlNodeList& edge_list_node,
               const String& block_name,
               ItemTypeMng * typeMng,
               Arcane::Int64Array & edge_uids,
               Arcane::Int64Array & edge_infos,
               const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  Arcane::String error_ids = Arcane::String::format("Error while reading {0} edge-ids",block_name);
  Arcane::String error_node_ids = Arcane::String::format("Error while reading {0} node-ids",block_name);

  for (Arcane::XmlNodeList::const_iterator iEdgeList = edge_list_node.begin();
      iEdgeList != edge_list_node.end(); ++iEdgeList)
    {
      // Read each block of data (edge ids, edge node ids)

      Arcane::Int64SharedArray edge_ids = IXMInt64DataNodeReader(iEdgeList->child("edge-ids"),error_ids,m_mesh_file_directory_name).read();
      Arcane::Int64SharedArray node_ids = IXMInt64DataNodeReader(iEdgeList->child("node-ids"),error_node_ids,m_mesh_file_directory_name).read();

      // Check sizes for edge ids and node ids
      if ( 2* edge_ids.size() != node_ids.size())
        m_trace_mng->fatal() << "Inconsistent number of edge_ids (" << edge_ids.size() << ") and node ids (" << node_ids.size() << ") in " << block_name << " block";

      // Save infos into main containers
      edge_uids.addRange(edge_ids);
      edge_infos.addRange(node_ids);

    }

}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
readConnectionData(ArcGeoSim::IXMTools::IXMConnectionData& connection_data)
{
  // Get connection xml node
  Arcane::XmlNode rootNode;
  // Choose between static and evolutive mesh
  _getTopologyNode(rootNode);
  Arcane::XmlNode connections_node = rootNode.child("connections");
  if (connections_node.null()) return;

  // Read item ids
  Arcane::String error_ids = Arcane::String::format("Error while reading {0} in connections","connection-ids");
  connection_data.item_ids = IXMInt64DataNodeReader(connections_node.child("connection-ids"),error_ids,m_mesh_file_directory_name).read();

  // Read item infos
  Arcane::String error_item_ids = Arcane::String::format("Error while reading {0} in connections","item-ids");
  Arcane::Int64SharedArray item_ids = IXMInt64DataNodeReader(connections_node.child("item-ids"),error_item_ids,m_mesh_file_directory_name).read();
  Arcane::String error_types = Arcane::String::format("Error while reading {0} in connections","types");
  Arcane::Int32SharedArray connection_types = IXMInt32DataNodeReader(connections_node.child("connection-types"),error_types,m_mesh_file_directory_name).read();

  // Check data integrity and gather infos in one array (...,connection-type, item1,item2,....)
  Arcane::Integer nb_connection = connection_data.item_ids.size();
  Arcane::Integer nb_item = item_ids.size();
  Arcane::Integer nb_types = connection_types.size();
  if (nb_item != 2* nb_connection) m_trace_mng->fatal() << Arcane::String::format("Incoherent connection description. {0} connection and {1} items. A connection contains exactly tow items",
                                                                                  nb_connection, nb_item);
  if (nb_types != nb_connection) m_trace_mng->fatal() << Arcane::String::format("Incoherent connection description. {0} connection and {1} connection types",
                                                                                nb_connection, nb_types);
  Arcane::Integer infos_size = 3*nb_connection;
  connection_data.item_infos.resize(infos_size);
  for (Arcane::Integer i = 0; i < nb_connection; ++i)
    {
      connection_data.item_infos[3*i] = connection_types[i];
      connection_data.item_infos[3*i+1] = item_ids[2*i];
      connection_data.item_infos[3*i+2] = item_ids[2*i+1];
    }
}

/*---------------------------------------------------------------------------*/
void ArcGeoSim::IXMV4MeshReader::readParticleData(IMesh* mesh)
{
  ParticleReader myParticleReader(mesh,m_mesh_data,m_parallel_mng,m_trace_mng, m_mesh_file_directory_name);
  myParticleReader.collectiveRead();
}

/*---------------------------------------------------------------------------*/
void ArcGeoSim::IXMV4MeshReader::readParticleData(ArcGeoSim::IXMTools::IXMParticleData& particle_data)
{

	Arcane::XmlNode rootNode = m_mesh_data.child("topology");
	Arcane::XmlNode particles_node = rootNode.child("particles");
	Integer use_particles = particles_node.null()?0:1 ;

	if(use_particles==0) return ;

	// Error messages
	String error_particule_ids = Arcane::String::format("Error while reading {0} particle-ids", "particles");
	String error_types = Arcane::String::format("Error while reading {0} particle-types", "particles");
	String error_cell_ids = Arcane::String::format("Error while reading {0} cell-ids", "particles");
	String error_coords = Arcane::String::format("Error while reading {0} particle-coords", "particles");

	// Temporary variable
	Cell myCell;

	Arcane::XmlNodeList particle_list_node = rootNode.children("particles");

	// Read each block of data
	for (XmlNodeList::const_iterator iPartList = particle_list_node.begin(); iPartList != particle_list_node.end();
			++iPartList)
	{
		// Reading particles variables
		Int64SharedArray part_ids = IXMInt64DataNodeReader(iPartList->child("particle-ids"), error_particule_ids, m_mesh_file_directory_name).read();
		IntegerSharedArray part_type_ids = IXMIntegerDataNodeReader(iPartList->child("particle-types"), error_types, m_mesh_file_directory_name).read();
		Int64SharedArray cell_ids = IXMInt64DataNodeReader(iPartList->child("cell-ids"), error_cell_ids, m_mesh_file_directory_name).read();

		Real3SharedArray xyz = IXMReal3DataNodeReader(iPartList->child("particle-coords"), error_coords, m_mesh_file_directory_name).read();

		particle_data.particles.item_ids.addRange(part_ids);
		particle_data.particles.item_infos.addRange(part_type_ids);

		particle_data.xyz.item_ids.addRange(cell_ids);
		particle_data.xyz.item_infos.addRange(xyz);

	}

}

/*---------------------------------------------------------------------------*/
void
ArcGeoSim::IXMV4MeshReader::
_getTopologyNode(Arcane::XmlNode& root_node)
{
  // Method used for static and evolutive mesh. Behavior : if an increment is loaded use this increment to get
  // root node, otherwise use mesh
#ifdef USE_EVOLUTIF
  if (m_mesh_increment_xml_node)
    {
      ARCANE_ASSERT((_isTopologyIncrementLoaded()),("Topology Increment not loaded in the IXMV4MeshReader"))
      root_node = *(m_mesh_increment_xml_node->topology_node.get());
    }
  else
#endif
    {
      ARCANE_ASSERT((!m_mesh_data.null()),("No mesh file loaded in IXM V4 reader."))
      root_node = m_mesh_data.child("topology");
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
readNodeData(ArcGeoSim::IXMTools::IXMNodeData& node_data, const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  ARCANE_ASSERT((!m_mesh_data.null()),("No mesh file loaded in IXM V4 reader."))
  Arcane::XmlNode rootNode = m_mesh_data.child("topology");
  Arcane::XmlNodeList NodeList = rootNode.children("nodes");

  for (Arcane::XmlNodeList::const_iterator iNodeList = NodeList.begin();
        iNodeList != NodeList.end(); ++iNodeList)
    {
      _readNodeCoordUpdate(*iNodeList,node_data,"nodes",check_mesh_info);
    }
}

/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMV4MeshReader::
readUpdateNodeData(ArcGeoSim::IXMTools::IXMUpdateNodeData& update_node_data, const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)

{
  ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV4MeshReader"))
  ARCANE_ASSERT((_isTopologyIncrementLoaded()),("Topology Increment not loaded in the IXMV4MeshReader"))

  Arcane::XmlNode rootNode = *(m_mesh_increment_xml_node->topology_node.get());

  Arcane::XmlNodeList updateNodesList = rootNode.children("update-nodes");
  for (Arcane::XmlNodeList::const_iterator iNodeList = updateNodesList.begin();
      iNodeList != updateNodesList.end(); ++iNodeList)
    { // Read nodes id and coord
      // Update node by cloning existing node
      Arcane::String error_msg;
      Arcane::XmlNode clone_listNode = iNodeList->child("clone-update");
      if (!clone_listNode.null())
        {
          error_msg = "Error while reading update-nodes/clone-update/node-ids";
          Arcane::Int64SharedArray clone_update_node_uids_tmp = IXMInt64DataNodeReader(clone_listNode.child("node-ids"),
                                                                                 error_msg,m_mesh_file_directory_name).read();
          error_msg = "Error while reading update-nodes/clone-update/cloned-node-ids";
          Arcane::Int64SharedArray clone_update_node_cloned_uids_tmp =  IXMInt64DataNodeReader(clone_listNode.child("cloned-node-ids"),
                                                                                         error_msg,
                                                                                         m_mesh_file_directory_name).read();

          // Check size
          if (clone_update_node_uids_tmp.size() != clone_update_node_cloned_uids_tmp.size())
            m_trace_mng->fatal() << Arcane::String::format("Inconsistent size between clone-update/node-ids ({0}) and  clone-update/cloned-node-ids ({1}) clone-list",
                                      clone_update_node_uids_tmp.size(),
                                      clone_update_node_cloned_uids_tmp.size());
          update_node_data.cloned_nodes.item_ids.addRange(clone_update_node_uids_tmp);
          update_node_data.cloned_nodes.item_infos.addRange(clone_update_node_cloned_uids_tmp);
        }

      // Update node by setting coordinates
      const Arcane::XmlNode coordNode = iNodeList->child("coord-update");
      if (!coordNode.null())
        {
          _readNodeCoordUpdate(coordNode,update_node_data.added_nodes,"update-nodes/coord-update",check_mesh_info);
        }
    }
}
#endif
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
_readNodeCoordUpdate(const Arcane::XmlNode& coordNode, ArcGeoSim::IXMTools::IXMNodeData& node_data,const Arcane::String& message,const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  Arcane::String error_msg = Arcane::String::format("Error while reading {0}/node-ids",message);
  node_data.item_ids = IXMInt64DataNodeReader(coordNode.child("node-ids"),error_msg,m_mesh_file_directory_name).read() ;
  error_msg = Arcane::String::format("Error while reading {0}/coords. NB: coordinates are always (x,y,z) even for 2D topologic mesh",message);
  node_data.item_infos = IXMReal3DataNodeReader(coordNode.child("coords"),error_msg, m_mesh_file_directory_name).read();

  if (node_data.item_ids.size() != node_data.item_infos.size())
    {
      m_trace_mng->fatal() << "Inconsistent number of node coordinates :"
                           << " Uids given for " << node_data.item_ids.size() << " nodes."
                           << " Coordinates (real3 type) given for " << node_data.item_infos.size()<< " nodes ";
    }
}
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
collectiveReadGroupData(ArcGeoSim::IXMTools::IXMGroupDataList& group_data_list, ParallelUtils parallel_utils)
{
  // Broadcast group xml node to all processes
  Arcane::IXmlDocumentHolder * group_holder = NULL;
  Arcane::XmlNode rootNode;

  _broadcastGroupData(rootNode,group_holder,parallel_utils,"static");

  Arcane::XmlNodeList group_nodes = rootNode.children("group");

  for (Arcane::XmlNodeList::const_iterator iGroupList = group_nodes.begin(); iGroupList != group_nodes.end(); ++iGroupList)
    {
      IXMGroupData group_data;
      _readGroupData(group_data,*iGroupList,parallel_utils);
      group_data_list.push_back(group_data);
    }

  delete group_holder;
}

/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMV4MeshReader::
collectiveReadGroupIncrementData(ArcGeoSim::IXMTools::IXMGroupIncrementDataList& group_increment_data_list, ParallelUtils parallel_utils)
{

  // Broadcast group xml node to all processes
  Arcane::IXmlDocumentHolder * group_holder = NULL;
  Arcane::XmlNode rootNode;

  _broadcastGroupData(rootNode,group_holder,parallel_utils,"evolutive");

  Arcane::XmlNodeList group_nodes = rootNode.children("group");

  for (Arcane::XmlNodeList::const_iterator iGroupList = group_nodes.begin(); iGroupList != group_nodes.end(); ++iGroupList)
    {
      IXMGroupIncrementData group_increment_data;
      _readGroupData(group_increment_data.group_data,*iGroupList,parallel_utils);
      group_increment_data.mode = (*iGroupList).attr("mode").value();
      group_increment_data_list.push_back(group_increment_data);
    }

  delete group_holder;
}
#endif
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
collectiveReadPropertyData(ArcGeoSim::IXMTools::IXMPropertyDataList& property_data_list, ParallelUtils parallel_utils)
{
  _readPropertyData<IXMPropertyDataList>(property_data_list,parallel_utils);
}

/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMV4MeshReader::
collectiveReadPropertyIncrementData(ArcGeoSim::IXMTools::IXMPropertyIncrementDataList& property_increment_data_list, ParallelUtils parallel_utils)
{
  m_trace_mng->info()<<"collectiveReadPropertyIncrementData";
  _readPropertyData<IXMPropertyIncrementDataList>(property_increment_data_list,parallel_utils);
}
#endif
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

#ifdef USE_EVOLUTIF
void
ArcGeoSim::IXMV4MeshReader::
readGeometryIncrementData(ArcGeoSim::IXMTools::IXMGeometryIncrementData& geometry_data, const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV4MeshReader"))
  ARCANE_ASSERT((_isGeometryIncrementLoaded()),("Geometry Increment not loaded in the IXMV4MeshReader"))

  Arcane::XmlNode geometry_node = *(m_mesh_increment_xml_node->geometry_node.get());

  Arcane::Integer node_count;
   Arcane::XmlNode moveNodeRoot = geometry_node.child("move-node-to");
   if (not moveNodeRoot.null())
     {
       // Node ids
       geometry_data.item_ids = IXMInt64DataNodeReader(moveNodeRoot.child("node-ids"),
                                                       "Error while reading move-node-to node ids",
                                                       m_mesh_file_directory_name).read();
       node_count = geometry_data.item_ids.size();

       // Node coordinates : on charge d'abord dans un tableau de Real3 pour avoir une erreur plus explicite si le nombre de coord est faux.

       Arcane::Real3SharedArray xyz = IXMReal3DataNodeReader(moveNodeRoot.child("coords"),
                                                            "Error while reading move-node-to node coords",
                                                            m_mesh_file_directory_name).read();

       // Check compatibility between read uids and coords

      if (node_count * check_mesh_info.coordDimension() != 3 * xyz.size())
         m_trace_mng->fatal() << "Inconsistent number of nodes coordinates :"
         << " Node number = " << node_count << " in dimension " << check_mesh_info.coordDimension() << ".\n"
         << " Expected  " << node_count * check_mesh_info.coordDimension() << " values for node coordinates,"
         << " Received " << 3 * xyz.size() << " values."
         << " NB: coordinates are always (x,y,z) even for 2D topologic mesh";

       // Fill moved nodes coords
       geometry_data.item_infos.resize(node_count);
       for (Arcane::Integer i = 0; i < node_count; ++i)
         {
           geometry_data.item_infos[i].x = xyz[i].x;
           geometry_data.item_infos[i].y = xyz[i].y;
           geometry_data.item_infos[i].z = xyz[i].z;
         }
     }
}
#endif
/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
_readCellInfos(const Arcane::XmlNodeList& cell_list_node,
               const String& block_name,
               ItemTypeMng * typeMng,
               Arcane::Int64Array & cell_uids,
               Arcane::Int64Array & cell_infos,
               const ArcGeoSim::IXMTools::IXMMeshInfo& check_mesh_info)
{
  Arcane::String error_types = Arcane::String::format("Error while reading {0} cell-types",block_name);
  Arcane::String error_ids = Arcane::String::format("Error while reading {0} cell-ids",block_name);
  Arcane::String error_node_ids = Arcane::String::format("Error while reading {0} node-ids",block_name);
  for (Arcane::XmlNodeList::const_iterator iCellList = cell_list_node.begin();
      iCellList != cell_list_node.end(); ++iCellList)
    {
      // Read each block of data (types, cell ids, cell node ids)

      Arcane::IntegerSharedArray cell_type_ids = IXMIntegerDataNodeReader(iCellList->child("cell-types"),error_types, m_mesh_file_directory_name).read();
      Arcane::Int64SharedArray cell_ids = IXMInt64DataNodeReader(iCellList->child("cell-ids"),error_ids,m_mesh_file_directory_name).read();
      Arcane::Int64SharedArray node_ids = IXMInt64DataNodeReader(iCellList->child("node-ids"),error_node_ids, m_mesh_file_directory_name).read();

      // Check sizes for cells types and id
      if (cell_type_ids.size() != cell_ids.size())
        m_trace_mng->fatal() << "Inconsistent number of cell types (" << cell_ids.size() << ") and cell ids (" << cell_type_ids.size() << ") in " << block_name << " block";

      const Arcane::Integer event_nb_new_cells = cell_type_ids.size();
      Arcane::Integer event_nb_new_nodes = 0;
      // Parse types
      Arcane::IntegerSharedArray cell_nb_nodes(event_nb_new_cells); // number of nodes for each cell
      const Arcane::Integer mesh_dimension = check_mesh_info.dimension(); // dimension of current mesh
      for (Arcane::Integer i = 0; i < event_nb_new_cells; ++i)
        {
          if (cell_type_ids[i] >= typeMng->nbBasicItemType())
            m_trace_mng->fatal() << String::format("Type id {0} does not exist for arcane items.",cell_type_ids[i]);
          if (check_mesh_info.typeDimension()[cell_type_ids[i]] != mesh_dimension)
            m_trace_mng->fatal() << "Type id " << cell_type_ids[i] << " for cell is not allowed in " << mesh_dimension << "d mesh in <" << iCellList->xpathFullName() << ">";
          // increment new node number
          auto current_cell_type = typeMng->typeFromId(cell_type_ids[i]);
          cell_nb_nodes[i] = current_cell_type->nbLocalNode();
          event_nb_new_nodes += cell_nb_nodes[i];
        }
      // Check size for node id
      if (node_ids.size() != event_nb_new_nodes)
          m_trace_mng->fatal()
              << "Inconsistent total node number not equal to cell number times cell node number. Total node number expected ="
              << event_nb_new_nodes << " Total node number received = " << node_ids.size();
      // Add cells info
      cell_uids.addRange(cell_ids);
      cell_infos.reserve(cell_infos.size() + 2*event_nb_new_cells + event_nb_new_nodes); // optimisation d'allocation
      for (Arcane::Integer i = 0, current_node_position = 0; i < event_nb_new_cells; ++i)
        {
          cell_infos.add(cell_type_ids[i]);
          cell_infos.add(cell_ids[i]);
          cell_infos.addRange(node_ids.subConstView(current_node_position,cell_nb_nodes[i]));
          current_node_position += cell_nb_nodes[i];
        }
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
_broadcastGroupData(Arcane::XmlNode& root_node, Arcane::IXmlDocumentHolder * group_holder, ParallelUtils parallel_utils,const Arcane::String& mesh_type)
{
  bool is_master = (parallel_utils.parallelMng()->commRank() == parallel_utils.parallelMng()->masterIORank());
  if (parallel_utils.parallelMng()->commSize() == 1)
    {
      _readTopologyNode(root_node,mesh_type);
    }
  else
    { // Diffusion des infos de groupes
      Arcane::ByteSharedArray bytes;
      if (is_master)
        {
          Arcane::XmlNode localRootNode;
          _readTopologyNode(localRootNode,mesh_type);
          Arcane::OStringStream oss;
          oss() << "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?><groups>"; // prefix
          Arcane::XmlNodeList groups = localRootNode.children("group");
          for (Arcane::XmlNodeList::const_iterator i_group = groups.begin(); i_group != groups.end(); ++i_group)
            {
              Arcane::domutils::writeNode(oss(),(*i_group).domNode());
            }
          oss() << "</groups>"; // suffix
          bytes = oss.str().utf8();
        }
      parallel_utils.multiBroadcast(bytes,parallel_utils.parallelMng()->masterIORank());

      group_holder = m_io_mng->parseXmlBuffer(bytes,"dumped-groups");
      root_node = group_holder->documentNode().child("groups"); // c'est la nuance avec l'algo s���quentiel
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
_readGroupData(ArcGeoSim::IXMTools::IXMGroupData& group_data, const Arcane::XmlNode& group_node, ParallelUtils& parallel_utils)
{
  group_data.name = (group_node).attr("name").value();

  const String group_kind = (group_node).attr("kind").value();
  const Arcane::eItemKind item_kind = ArcGeoSim::IXMTools::itemKindFromIXMName(group_kind);
  group_data.kind = item_kind;

  Int64SharedArray group_id;
  _broadcastGroupIds(group_id,group_node,parallel_utils);
  group_data.ids = group_id;
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
_readTopologyNode(Arcane::XmlNode& topology_node, const Arcane::String mesh_type)
{
#ifdef USE_EVOLUTIF
  if ("evolutive" == mesh_type)
    {
      ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV4MeshReader"))
      ARCANE_ASSERT((_isTopologyIncrementLoaded()),("Topology Increment not loaded in the IXMV4MeshReader"))
      topology_node = *(m_mesh_increment_xml_node->topology_node.get());
    }
  else
#endif
    if ("static" == mesh_type)
    {
      ARCANE_ASSERT((!m_mesh_data.null()),("No mesh file loaded in IXM V4 reader."))
      topology_node = m_mesh_data.child("topology");
    }
  else throw Arcane::FatalErrorException(String::format("Unknown ixm mesh type {0} in load topology node",mesh_type));
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
_broadcastGroupIds(Arcane::Int64SharedArray& group_ids, const Arcane::XmlNode& group_node, ParallelUtils parallel_utils)
{
  Arcane::String group_name = group_node.attrValue("name");
  bool is_parallel = (parallel_utils.parallelMng()->commSize() > 1);
  // Check if group node contains group ids (not mandatory)
  Arcane::XmlNode group_ids_node = group_node.child("group-ids");
  if (group_ids_node.null()) return;
  const Arcane::String data_format = group_ids_node.child("data").attrValue("format");
  if (data_format == "xml" || (!is_parallel)) // All processes can read
    {
      _readGroupIds(group_ids,group_node.child("group-ids"),group_name);
    }
  else if (data_format == "hdf" && is_parallel) // Master read and dispatch
    {
      Arcane::Integer master_id = parallel_utils.parallelMng()->masterIORank();
      bool is_master = (parallel_utils.parallelMng()->commRank() == master_id);
      if (is_master)
        {
          _readGroupIds(group_ids,group_node.child("group-ids"),group_name);
          parallel_utils.multiBroadcast(group_ids,master_id);
        }
      else parallel_utils.multiBroadcast(group_ids,master_id);
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
_readGroupIds(Arcane::Int64SharedArray& group_ids, const Arcane::XmlNode& group_ids_node, const Arcane::String& group_name)
{
  // Il est ici autoris��� d'avoir une liste vide (blanche) sur group-id
  // Toutes les autres balises l'excluent.
  // Ce comportement est indique par le booleen data_node_can_be_empty.
  bool data_node_can_be_empty = true;
  Arcane::String error_msg = String::format("Error while reading group '{0}' ids",group_name);
  group_ids = IXMInt64DataNodeReader(group_ids_node,error_msg,m_mesh_file_directory_name,data_node_can_be_empty).read();
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
_broadcastPropertyData(Arcane::XmlNode& property_node, Arcane::IXmlDocumentHolder * property_holder, ParallelUtils parallel_utils, const Arcane::String& mesh_type)
{
  // Broadcast Property data to all
  if (parallel_utils.parallelMng()->commSize() == 1) // sequential bypass
    {
      _readPropertyNode(property_node,mesh_type);
    }
  else
    {
      // Broadcast to every process property node (including extern nodes if exist)
      Arcane::ByteSharedArray bytes;
      if (parallel_utils.parallelMng()->commRank() == parallel_utils.parallelMng()->masterIORank())
        {
          Arcane::XmlNode localRootNode;
          _readPropertyNode(localRootNode,mesh_type);
          Arcane::OStringStream oss;
          oss() << "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>"; // prefix
          if (!localRootNode.null())
            Arcane::domutils::writeNode(oss(),localRootNode.domNode());
          else
            oss() << "<properties></properties>"; // corps de remplacement
          bytes = oss.str().utf8();
        }
      parallel_utils.multiBroadcast(bytes,parallel_utils.parallelMng()->masterIORank());
      // Get Property Node in every parallel process
      property_holder = m_io_mng->parseXmlBuffer(bytes,"property-node");
      property_node = property_holder->documentNode().child("properties");
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
_readPropertyNode(Arcane::XmlNode& property_node, const Arcane::String mesh_type)
{
#ifdef USE_EVOLUTIF
  if ("evolutive" == mesh_type)
    {
      ARCANE_ASSERT((m_mesh_increment_xml_node),("No Mesh Increment loaded in the IXMV4MeshReader"))
      ARCANE_ASSERT((_isPropertyIncrementLoaded()),("Property Increment not loaded in the IXMV4MeshReader"))
      property_node = *(m_mesh_increment_xml_node->property_node.get());
    }
  else
#endif
    if ("static" == mesh_type)
    {
      ARCANE_ASSERT((!m_mesh_data.null()),("No mesh file loaded in IXM V4 reader."))
      property_node = m_mesh_data.child("properties");
    }
  else throw Arcane::FatalErrorException(String::format("Unknown ixm mesh type {0} in load topology node",mesh_type));
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
_broadcastPropertySupport(Arcane::Int64SharedArray& property_support, const Arcane::XmlNode& property_node, ParallelUtils parallel_utils)
{
  Arcane::String property_name = property_node.attrValue("name");
  bool is_parallel = (parallel_utils.parallelMng()->commSize() > 1);
  const Arcane::String data_format = property_node.child("support").child("data").attrValue("format");
  if (data_format == "xml" || (!is_parallel)) // All processes can read
    {
      _readPropertySupport(property_support,property_node.child("support"),property_name);
    }
  else if (data_format == "hdf" && is_parallel) // Master read and dispatch
    {
      Arcane::Integer master_id = parallel_utils.parallelMng()->masterIORank();
      bool is_master = (parallel_utils.parallelMng()->commRank() == master_id);
      if (is_master)
        {
          _readPropertySupport(property_support,property_node.child("support"),property_name);
          parallel_utils.multiBroadcast(property_support,master_id);
        }
      else parallel_utils.multiBroadcast(property_support,master_id);
    }
}

/*---------------------------------------------------------------------------*/

void
ArcGeoSim::IXMV4MeshReader::
_readPropertySupport(Arcane::Int64SharedArray& property_support, const Arcane::XmlNode& support_node, const Arcane::String& property_name)
{
  Arcane::String error_msg = Arcane::String::format("Cannot read property {0} support data node",property_name);
  property_support = IXMInt64DataNodeReader(support_node,error_msg,m_mesh_file_directory_name).read();
}

/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
