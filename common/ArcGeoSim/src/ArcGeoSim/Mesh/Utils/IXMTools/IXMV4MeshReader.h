// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMV4MESHREADER_H
#define ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMV4MESHREADER_H
/* Author : dechaiss at Wed Jul 18 14:32:13 2012
 * Generated by createNew
 */

#include <arcane/IIOMng.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/XmlNodeList.h>
#include <arcane/IXmlDocumentHolder.h>


#include "ArcGeoSim/Utils/ArcGeoSim.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IIXMMeshReader.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMTools.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMMeshReaderTools.h"
#include "ArcGeoSim/Utils/ParallelUtils.h"

BEGIN_ARCGEOSIM_NAMESPACE

class IXMV4MeshReader : public IIXMMeshReader
{
public:
  
  /** Constructeur de la classe */
  IXMV4MeshReader(Arcane::IIOMng* io_mng,
                  Arcane::IParallelMng* parallel_mng,
                  Arcane::ITraceMng* trace_mng);
  
  /** Destructeur de la classe */
  virtual ~IXMV4MeshReader();
  
public:

  //! === Interface IIXMMeshReaderBase ===

  //! Chargement du fichier de maillage. Retourne le rï¿½pertoire du fichier de maillage
  Arcane::String loadMeshFile(const IXMMeshFile mesh_file);

  //! Type de grille
  Arcane::String meshType();

  //! Dimension de la grille
  IXMMeshDimension meshDimension();

  //! === Interface IIXMEvolutiveMeshReader ===

  bool hasMeshData() { return m_has_mesh_data;}

#ifdef USE_EVOLUTIF
  //! Nombre d'evenement d'increment de maillage
  Arcane::Integer meshIncrementNumber();

  //! Information sur l'evenement d'increment de maillage \a mesh_increment_number
  IXMMeshIncrementInfo meshIncrementInfo(const Arcane::Integer& mesh_increment_number,bool synch);

  //! Chargement en interne de l'increment de maillage decrit par \a mesh_increment_info pendant l'evenement decrit par \a event_info
  void loadMeshIncrement(const IXMMeshIncrementInfo& mesh_increment_info, const IXMLoadInfo& load_info);

  //! Desalloue l'increment de maillage charge.
  void unloadMeshIncrement();

  //! Informations sur l'increment de maillage
  bool hasTopologyIncrement() {return m_has_topology_increment;}
  bool hasGeometryIncrement() {return m_has_geometry_increment;}
  bool hasPropertyIncrement() {return m_has_property_increment;}

  //! Lecture des donnees de l'increment de maillage
  void readCellIncrementData(IXMCellIncrementData& cell_increment_data,const IXMMeshInfo& check_mesh_info);
  void readUpdateNodeData(IXMUpdateNodeData& update_node_data, const IXMMeshInfo& check_mesh_info);
  void readGeometryIncrementData(IXMGeometryIncrementData& geometry_data, const IXMMeshInfo& check_mesh_info);
  //! Lecture collective des informations de groupes et des proprietes : tous les processus doivent lire ces informations.
  void collectiveReadGroupIncrementData(IXMGroupIncrementDataList& group_increment_data_list, ParallelUtils parallel_utils);
  void collectiveReadPropertyIncrementData(IXMPropertyIncrementDataList& property_increment_data_list, ParallelUtils parallel_utils);
#endif
  //! === Interface IIXMStaticMeshReader ===

  //! Lecture des donnees du maillage
  void readCellData(IXMCellData& cell_data, const IXMMeshInfo& check_mesh_info);
  void readNodeData(IXMNodeData& node_data, const IXMMeshInfo& check_mesh_info);

  //! Lecture collective des informations de groupes et de proprietes : tous les processus doivent lire ces informations.
  void collectiveReadGroupData(IXMGroupDataList& group_data_list, ParallelUtils parallel_utils);
  void collectiveReadPropertyData(IXMPropertyDataList& property_data_list, ParallelUtils parallel_utils);

  //! === Interface IIXMMeshReaderBase ===
  // Methods shared in static and evolutive mesh
  void readFaceData(IXMFaceData& face_data,const IXMMeshInfo& check_mesh_info);
  void readEdgeData(IXMEdgeData& edge_data,const IXMMeshInfo& check_mesh_info);
  void readConnectionData(IXMConnectionData& connection_data);

  void readParticleData(IMesh* mesh);

  void readParticleData(ArcGeoSim::IXMTools::IXMParticleData& particle_data);
protected:

#ifdef USE_EVOLUTIF
  bool _isTopologyIncrementLoaded();
  bool _isGeometryIncrementLoaded();
  bool _isPropertyIncrementLoaded();
#endif
  void _readCellInfos(const Arcane::XmlNodeList& cell_list_node, const String& block_name, ItemTypeMng * typeMng,
                      Arcane::Int64Array & cell_uids, Arcane::Int64Array & cell_infos,const IXMMeshInfo& check_mesh_info);
  void _readEdgeInfos(const Arcane::XmlNodeList& edge_list_node, const String& block_name, ItemTypeMng * typeMng,
                 	  Arcane::Int64Array & edge_uids,Arcane::Int64Array & edge_infos,const IXMMeshInfo& check_mesh_info);
  void _broadcastGroupData(Arcane::XmlNode& root_node, Arcane::IXmlDocumentHolder * group_holder, ParallelUtils parallel_utils, const Arcane::String& mesh_type);
  void _broadcastGroupIds(Arcane::Int64SharedArray& group_ids, const Arcane::XmlNode& group_node, ParallelUtils parallel_utils);
  void _readGroupIds(Arcane::Int64SharedArray& group_ids, const Arcane::XmlNode& group_ids_node, const Arcane::String& group_name);
  void _broadcastPropertyData(Arcane::XmlNode& property_node, Arcane::IXmlDocumentHolder * property_holder, ParallelUtils parallel_utils,const Arcane::String& mesh_type);
  void _broadcastPropertySupport(Arcane::Int64SharedArray& property_support, const Arcane::XmlNode& property_node, ParallelUtils parallel_utils);
  void _readPropertySupport(Arcane::Int64SharedArray& property_support, const Arcane::XmlNode& support_node, const Arcane::String& property_name);
  void _readNodeCoordUpdate(const Arcane::XmlNode& coordNode, IXMNodeData& node_data, const Arcane::String& message,const IXMMeshInfo& check_mesh_info);
  void _readGroupData(IXMGroupData& group_data, const Arcane::XmlNode& group_node, ParallelUtils& parallel_utils);

  virtual void _readTopologyNode(Arcane::XmlNode& topology_node, const Arcane::String mesh_type);
  virtual void _readPropertyNode(Arcane::XmlNode& property_node, const Arcane::String mesh_type);
  virtual void _getTopologyNode(Arcane::XmlNode& root_node);
  template<typename PropertyDataList> void _readPropertyData(PropertyDataList& property,ParallelUtils& parallel_utils);

protected:

  // Arcane Tools
  Arcane::IIOMng* m_io_mng = nullptr;
  Arcane::IParallelMng* m_parallel_mng = nullptr;
  Arcane::ITraceMng* m_trace_mng = nullptr;

  // Mesh file tools
  Arcane::IXmlDocumentHolder * m_xmldoc = nullptr;

#ifdef USE_EVOLUTIF
  // Xml Data
  IXMMeshIncrementXmlNode* m_mesh_increment_xml_node;
#endif
  // Grid info
  Arcane::String m_grid_type;
  IXMMeshDimension m_grid_dimension;
  IXMMeshVersion m_supported_version;

  // Increment info
#ifdef USE_EVOLUTIF
  bool m_has_topology_increment = false;
  bool m_has_geometry_increment = false;
  bool m_has_property_increment = false;
#endif
  bool m_has_mesh_data = false;

  // Event data
  Arcane::XmlNode m_grid_root;
  Arcane::XmlNode m_mesh_data;
  Arcane::XmlNodeList m_events_data;
  Integer m_nb_events_data_size = 0;


  Arcane::String m_mesh_file_directory_name;

};

template<typename PropertyDataList>
void
ArcGeoSim::IXMV4MeshReader::
_readPropertyData(PropertyDataList& property_data_list,ParallelUtils& parallel_utils)
{
  // Get Property node
  Arcane::XmlNode property_node;
  Arcane::IXmlDocumentHolder* property_holder = NULL;

  _broadcastPropertyData(property_node,property_holder,parallel_utils,PropertyDataList::mesh_type);
  m_trace_mng->info()<<"after brodcast"<<property_holder<<" "<<PropertyDataList::mesh_type;

  // Fill property data list
  Arcane::XmlNodeList propertyNodeList = property_node.children("property");
  for (XmlNodeList::const_iterator iProperty = propertyNodeList.begin(); iProperty!= propertyNodeList.end(); ++iProperty)
    {
      typename PropertyDataList::PropertyDataType property_data;
      property_data.name = iProperty->attrValue("name");
      property_data.kind = iProperty->attrValue("kind");
      // Read Support
      Arcane::XmlNode support_node = iProperty->child("support");
      if (!support_node.null())
        {
          property_data.group_name = support_node.attrValue("group-name");
          Arcane::Int64SharedArray property_support;
          _broadcastPropertySupport(property_support,*iProperty,parallel_utils);
          property_data.support_and_values.item_ids = property_support;
        }

      // Read Values
      Arcane::XmlNodeList values_nodes = iProperty->children("values");
      Arcane::String values_string;
      Arcane::String format;
      Arcane::XmlNode values_time;
      Arcane::String type;
      Arcane::Integer array_size;
      property_data.data_array_size = -1;
      for (XmlNodeList::const_iterator iValues = values_nodes.begin(); iValues != values_nodes.end(); ++iValues)
        {
          // Get values data string
          values_time = iValues->attr("time");
          XmlNode values_data = iValues->child("data");
          format = values_data.attrValue("format");
          // Handle data array size. Data array size is defined for each values tag. It must be the same size.
          array_size = values_data.attr("array-size").valueAsInteger();
          if (property_data.data_array_size == -1) property_data.data_array_size = array_size;
          else if (array_size != property_data.data_array_size) throw IXMPropertyExceptions::InconsistentPropertyDescriptionException (
              property_data.name,
              "property array-size  is not the same in the different values tag of the property.");
          // Handle data type. Type is defined for each values tag. It must be the same type.
          type = values_data.attrValue("type");
          if (property_data.data_type.empty()) property_data.data_type = type;
          else if (type != property_data.data_type) throw IXMPropertyExceptions::InconsistentPropertyDescriptionException (
              property_data.name,
              "property type is not the same in the different values tag of the property.");
          values_string = values_data.value();
          // Indicate values data string content : ie data array or string with data file address
          IXMPropertyValuesData::eDataStringContent data_string_content = IXMPropertyValuesData::DataUndefined;
          if (format == ("xml")) data_string_content = IXMTools::IXMPropertyValuesData::DataArray;
          else if (format == ("hdf")) data_string_content = IXMTools::IXMPropertyValuesData::DataFileAddress;
          // Create property_values_data
          if (values_time.null()) // static mesh case
            property_data.support_and_values.item_infos.push_back(PropertyDataList::build(values_string,data_string_content));
          else // evolutive mesh case
            property_data.support_and_values.item_infos.push_back(PropertyDataList::build(values_time.valueAsReal(),values_string,data_string_content));
        }
      property_data_list.push_back(property_data);
    }

  delete property_holder;
}

END_ARCGEOSIM_NAMESPACE

#endif /* ARCGEOSIM_ARCGEOSIM_MESH_UTILS_IXMTOOLS_IXMV4MESHREADER_H */
