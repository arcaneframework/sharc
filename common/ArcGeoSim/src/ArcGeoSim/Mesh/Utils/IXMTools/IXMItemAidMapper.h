// -*- C++ -*-
#ifndef ARCGEOSIM_MESH_EVOLUTIVEMESH_FACEAIDMAPPER_H
#define ARCGEOSIM_MESH_EVOLUTIVEMESH_FACEAIDMAPPER_H
/* Author : havep at Mon Aug 22 15:03:51 2011
 * Generated by createNew
 */

#include <map>
#include <set>
#include <arcane/ArcaneVersion.h>
#include <arcane/utils/TraceAccessor.h>
#include <arcane/ArcaneTypes.h>
#include <arcane/utils/Array.h>
#include <arcane/VariableTypedef.h>
#include <arcane/IMesh.h>
#include <arcane/IVariableMng.h>
#if (ARCANE_VERSION >= 30003)
#include <arcane/IGraph2.h>
#endif
#include "ArcGeoSim/Utils/ArcGeoSim.h"

BEGIN_ARCGEOSIM_NAMESPACE

/*! Classe de gestion des identifiants de face d�crits par leurs abstract id (aid).
 *  Cette classe n'a pas vocation � �tre un �l�ment de stockage qui est d�l�gu� � des
 *  variables Arcane en vue de conserver une persistence des donn�es.
 *  Cette classe permet de g�rer la correspondance identifiant abstrait (aid) vers identifiant locaux (lid)
 *  Cette classe est � usage interne. Ne doit �tre utilis�e que dans l'import ixm en maitrisant bien
 *  sa port�e : la classe IXMItemAidToUidMapper ne peut donner le mapping aid2lid qu'une fois que la m�thode buildAidToLidMapping()
 *  a �t� appel�e et dans une zone de validit� des local_ids. D�s que les local_ids sont susceptibles de changer nettoyer la correspondance,
 *  clearAidMapping() et la recharger quand n�cessaire.
 *  Cette classe est pilotee par IXMUidToLidMng pour traiter de fa�on g�n�rique des items d�crits dans le maillage par des identifiants uniques ou abstraits.
 */
class IXMItemAidToUidMapper
  : public Arcane::TraceAccessor
{
public:

  // class LocalItemIds{

  // public:
  //   LocalItemIds(const Arcane::Int64Array& local_face_aids, Arcane::Int32Array& local_face_lids)
  //   : m_local_face_aids(local_face_aids)
  //   , m_local_face_lids(local_face_lids)
  //   {}
  //   const Arcane::Int64ConstArrayView localFaceAids() const {return m_local_face_aids.constView();}
  //   const Arcane::Int32ConstArrayView localFaceLids() const {return m_local_face_lids.constView();}

  // private:
  //   const Arcane::Int64UniqueArray m_local_face_aids;
  //   const Arcane::Int32UniqueArray m_local_face_lids;

  // };

public:

  /** Constructeur de la classe */
  //! La classe ne contient aucune donnee tant qu'une des methodes load n'est pas appelee
  IXMItemAidToUidMapper(Arcane::ITraceMng * traceMng, 
                        Arcane::IMesh * mesh,
                        Arcane::IParallelMng * parallelMng,
                        Arcane::Integer masterId,
                        bool useMemory,
                        Arcane::VariableArrayInt64* item_aid_memory,
                        Arcane::eItemKind item_kind);

#if (ARCANE_VERSION >= 30003)
  void setGraph(Arcane::IGraph2 * graph)
  {
    m_graph = graph ;
  }
#endif
  /** Destructeur de la classe */
  virtual ~IXMItemAidToUidMapper() {}
  
public:

  //! Donne acces au nom de la variable de mapping pour les utilitaires mettant cette variable a disposition de l'utilisateur
  // (On ne veut pas exposer le face_aid_mapper en dehors de EvolutiveMesh)
  static const Arcane::String itemAidMemoryVariableName(Arcane::IMesh* mesh, Arcane::eItemKind item_kind) { return Arcane::String::format("{1}{0}AidMemory",item_kind,mesh->name());}

  /* Convertit les abstract id en local id. Si la face n'est pas trouvee sur le processus courant, le local id vaut NULL_ITEM_ID si \param do_fatal vaut faux
   * sinon une exception est levee.
   */
  void itemAbstractIdToLocalId(Arcane::Int32ArrayView face_local_ids, const Arcane::Int64ConstArrayView face_abstract_ids, const bool do_fatal=true) const;

  //! Nettoie le mapping
  void clearAidMapping() {if (!m_aid_to_lids.empty()) m_aid_to_lids.clear();}

  //! Construit la correspondance
  void buildAidToLidMapping(Arcane::Int64ConstArrayView abstract_ids, Arcane::ConstArrayView<Arcane::LocalIdType> local_ids, const bool do_check, const bool is_parallel=true);


  Int64 getItemAidMax() const  ;

private:
  Arcane::IMesh * m_mesh = nullptr;
#if (ARCANE_VERSION >= 30003)
  Arcane::IGraph2 * m_graph = nullptr;
#endif
  Arcane::IParallelMng * m_parallel_mng = nullptr;
  Arcane::Integer m_master_id = 0;
  bool m_is_master = true;
  bool m_use_memory = true;
  Arcane::VariableArrayInt64 * m_item_aid_memory = nullptr;
  typedef std::map<Arcane::Int64, Arcane::Integer> Aid2LidMap;
  Aid2LidMap m_aid_to_lids;
  Arcane::eItemKind m_item_kind;


  void _buildAidToLidMapping(Arcane::Int64ConstArrayView abstract_ids, Arcane::ConstArrayView<Arcane::LocalIdType> local_ids, const bool do_check);
  void _buildAidToLidMappingWithMemory(Arcane::Int64ConstArrayView abstract_ids, Arcane::ConstArrayView<Arcane::LocalIdType> local_ids, const bool do_check, const bool is_parallel=true);
  Arcane::Integer _findLocalIdOrExit(Arcane::Int64 aid) const;
  Arcane::Integer _findLocalId(Arcane::Int64 aid) const;
};

/*---------------------------------------------------------------------------*/

/*!
 * Classe � usage externe permettant d'obtenir des identifiants
 * abstraits � partir d'identifiants uniques, pour des items pour lesquels il existe ces identifiants abstraits.
 *
 */
class IXMItemUidToAidMapper
{
public:

  /** Constructeur de la classe */
  IXMItemUidToAidMapper(Arcane::IMesh* mesh, Arcane::IParallelMng * parallelMng, Arcane::IVariableMng* variableMng, const Arcane::eItemKind& item_kind);
#if (ARCANE_VERSION >= 30003)
  IXMItemUidToAidMapper(Arcane::IMesh* mesh, Arcane::IGraph2* graph, Arcane::IParallelMng * parallelMng, Arcane::IVariableMng* variableMng, const Arcane::eItemKind& item_kind);
#endif

  /** Destructeur de la classe */
  virtual ~IXMItemUidToAidMapper(){}

  /*! Convertit les unique id en abstract id. Si l'item n'est pas trouvee sur le processus courant, le local id vaut NULL_ITEM_ID
   *  La correspondance est r�alis�e gr�ce � la variable arcane utilisee dans IXMItemAidToUidMapper. Si cette variable n'est pas trouv�e,
   *  la correspondance ne peut �tre faite ; le tableau d'abstract ids (qui doit �tre donn� vide) n'est alors pas rempli.
   */
  void itemUniqueIdToAbstractId(Arcane::Int64Array& item_abstract_ids, const Arcane::Int64ConstArrayView item_unique_ids) const;

  Arcane::Int64 itemUniqueIdToAbstractId( Arcane::Int64 uid) const ;

private:
  Arcane::IParallelMng * m_parallel_mng;
  Arcane::IVariableMng * m_variable_mng;
  Arcane::eItemKind m_item_kind;
  typedef std::map<Arcane::Int64,Arcane::Int64> UidToAidMap;
  UidToAidMap m_uid2aid;
  Int64 m_itemAidMax;
};

/*---------------------------------------------------------------------------*/
/*!
 * Classe avec la meme fonctionalite que IXMItemUidToAidMapper pour un usage intensif et dans la duree (singleton et stockage dans une variable arcane,
 * avec separation des phases de creation et d'acces).
 * Utilise pour les IXMItemConnections ou le mapping uid -> aid est accessible dans l'ItemConnection lui meme
 * Usage interne
 */

class IXMItemUidToAidVariable
{
  public:
    static void set(Arcane::IMesh* mesh,const Arcane::eItemKind& kind);
    static IXMItemUidToAidVariable* get();
    Arcane::ItemUniqueId uid(const Arcane::Item& item) {return Arcane::ItemUniqueId(m_aids[item]);}
  private:
    IXMItemUidToAidVariable(Arcane::IMesh* mesh, const ArcGeoSim::IXMItemUidToAidMapper& uids,const Arcane::eItemKind& kind);
#if (ARCANE_VERSION >= 30003)
    IXMItemUidToAidVariable(Arcane::IMesh* mesh, Arcane::IGraph2* graph, const ArcGeoSim::IXMItemUidToAidMapper& uids,const Arcane::eItemKind& kind);
#endif
    static IXMItemUidToAidVariable* m_instance;
    Arcane::VariableItemInt64 m_aids;
    static Arcane::String _variableName(const Arcane::eItemKind& kind) {return Arcane::String::format("UidToAidArcaneVariableForItem{0}",kind);}
};

#if (ARCANE_VERSION >= 30003)
class IXMItemUidToAidLinkVariable
{
  public:
    static void set(Arcane::IMesh* mesh,Arcane::IGraph2* graph);
    static IXMItemUidToAidLinkVariable* get();
    Arcane::ItemUniqueId uid(const Arcane::Item& item) {return Arcane::ItemUniqueId(m_aids[item]);}
  private:
    IXMItemUidToAidLinkVariable(Arcane::IMesh* mesh, Arcane::IGraph2* graph, const ArcGeoSim::IXMItemUidToAidMapper& uids);
    static IXMItemUidToAidLinkVariable* m_instance;
    Arcane::VariableItemInt64 m_aids;
    static Arcane::String _variableName(const Arcane::eItemKind& kind) {return Arcane::String::format("UidToAidArcaneVariableForItem{0}",kind);}
};
#endif
END_ARCGEOSIM_NAMESPACE

#endif /* ARCGEOSIM_MESH_EVOLUTIVEMESH_FACEAIDMAPPER_H */
