// -*- C++ -*-
/* Author : dechaiss at Thu Feb 23 10:31:00 2012
 * Generated by createNew
 */

/* INFO: Les services et modules se conforment maintenant � la politique Arcane core.
 *       L'emploi des .h �tait fictif. 
 *       D�sormais les d�clarations de classe pour les modules et services seront
 *       localis�es dans le fichier .cc correspondant.
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

// Interface du service
#include <iostream>
#include <arcane/ArcaneVersion.h>
#include <arcane/IInitialPartitioner.h>
#include <ArcGeoSim/Mesh/MeshPartitioner/ColumnMeshPartitioner/IInitialPartitionerCreator.h>
#include <ArcGeoSim/Mesh/MeshPartitioner/ColumnMeshPartitioner/ColumnPartitionConstraint.h>

#include <arcane/IMesh.h>
#include <arcane/IMeshPartitioner.h>
#include <arcane/IParallelMng.h>
#include <arcane/utils/ScopedPtr.h>
#include <arcane/utils/TraceInfo.h> // necessaire pour compiler Factory
//#include <arcane/utils/TraceAccessor.h>
#include <arcane/Factory.h>
#include <arcane/ServiceFinder.h>
#include <arcane/IMeshModifier.h>
#include <arcane/IMeshSubMeshTransition.h>
#include <arcane/IMeshPartitionConstraintMng.h>
#include <arcane/IMeshPartitionConstraint.h>

#if (ARCANE_VERSION >= 30003)
#include "arcane/mesh/GraphDoFs.h"
#include "arcane/mesh/GraphBuilder.h"
#endif

#include "ArcGeoSim/Utils/ArcGeoSim.h"
#include "ArcGeoSim/Appli/IAppServiceMng.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMTools.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMItemAidMapper.h"


#include <arcane/utils/ITraceMng.h>


#include "ColumnMeshPartitioner_axl.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class ColumnMeshPartitioner
: public  Arcane::IInitialPartitioner
{

 public:

  ColumnMeshPartitioner(IInitialPartitionerCreator* mt,ISubDomain* sd, CaseOptionsColumnMeshPartitioner* options)
  : m_initial_partitionner(mt)
  , m_sub_domain(sd)
  , m_options(options)
  , m_partitioner_name("")
  {
  }

   virtual ~ColumnMeshPartitioner() {}

   virtual void build() {}

   void partitionAndDistributeMeshes(Arcane::ConstArrayView<Arcane::IMesh*> meshes);

 private:
   void _arcaneDefaultPartitionForTry();
   void _doInitialPartition(const Arcane::String& service_name);
#if (ARCANE_VERSION >= 30003)
   void _readConnection(Arcane::IMesh* meshixm, IGraph2* graph) ;
#else
   void _readConnection(Arcane::IMesh* meshixm);
#endif

   // split fields
   IInitialPartitionerCreator* m_initial_partitionner;
   ISubDomain* m_sub_domain;
   // from option
   CaseOptionsColumnMeshPartitioner* m_options;
   //
   Arcane::ConstArrayView<Arcane::IMesh*> m_meshes;
#if (ARCANE_VERSION >= 30003)
   std::vector<std::unique_ptr<Arcane::IGraph2>> m_graphs ;
#endif
   Arcane::String m_partitioner_name;
   IParallelMng * m_parallel_mng;
   Arcane::UniqueArray<Arcane::IMeshPartitionConstraint*> m_constraint;
   //ITraceMng * traceMng;
};


class ColumnMeshPartitionerService
  : public ArcaneColumnMeshPartitionerObject
{
public:

  /** Constructeur de la classe */
  ColumnMeshPartitionerService(const Arcane::ServiceBuildInfo & sbi)
    : ArcaneColumnMeshPartitionerObject(sbi)
	, m_init_part(nullptr)

  {
	  m_init_part = new ColumnMeshPartitioner(this, subDomain(), options());
	  subDomain()->setInitialPartitioner(m_init_part);
  }


  /** Destructeur de la classe */
  virtual ~ColumnMeshPartitionerService() {};

public:


  //! Initialisation
  virtual void init() {
	  //m_init_part->partitionAndDistributeMeshes(subDomain()->meshes());
  }

  virtual void build(){
  }

  /*!
   * \brief Partitionne les maillages.
   *
   * Cette op�ration doit partitionner tous les mailles \a meshes et
   * les distribuer sur l'ensemble des processeurs.
   */
  //void partitionAndDistributeMeshes(Arcane::ConstArrayView<Arcane::IMesh*> meshes);

private:
  ColumnMeshPartitioner* m_init_part;

};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

//void
//CATSInitialMeshPartitionerService::
//init()
//{
//  //m_init_part->init();
//  info()<<"Nono init";
//}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/


void 
ColumnMeshPartitioner::
partitionAndDistributeMeshes(Arcane::ConstArrayView<Arcane::IMesh*> meshes)
{
  // Try arcane partitioning
  m_meshes = meshes;
#if (ARCANE_VERSION >= 30003)
  m_graphs.resize(meshes.size()) ;
#endif
  //_arcaneDefaultPartitionForTry();
  _doInitialPartition(m_partitioner_name);


}

/*---------------------------------------------------------------------------*/

void
ColumnMeshPartitioner::
_arcaneDefaultPartitionForTry()
{

  // Comme 'parmetis' n'aime pas repartitionner un maillage si un des sous-domaines
  // est vide, ce qui est le cas si un seul processeur cr�� les mailles, il
  // faut d'abord utiliser le partitionneur basique qui r�partit les mailles
  // entre les sous-domaines, puis 'parmetis' s'il est pr�sent

  // Check all meshes have cell
  bool all_meshes_have_cell = true;
  for( Arcane::Integer z=0, zs=m_meshes.size(); z<zs; ++z )
    {
      Arcane::IMesh* mesh = m_meshes[z];
      Arcane::Int64 nb_cell = mesh->nbCell();
      Arcane::Int64 min_nb_cell = m_sub_domain->parallelMng()->reduce(Arcane::Parallel::ReduceMin,nb_cell);
      std::cout<< "Min nb cell=" << min_nb_cell;
      if (min_nb_cell==0)
        all_meshes_have_cell = false;
    }
  if (!all_meshes_have_cell)
    _doInitialPartition("MeshPartitionerTester");
  else
    std::cout<< "All meshes have cells. Do not use MeshPartitionerTester";

  // Do initial partition
  std::cout<< "Partitionnement interne avec partitionneur ArcGeoSim" << m_partitioner_name << "'";
  _doInitialPartition(m_partitioner_name);
}

/*---------------------------------------------------------------------------*/

void
ColumnMeshPartitioner::
_doInitialPartition(const Arcane::String& service_name)
{
  //Arcane::ScopedPtrT<Arcane::IMeshPartitioner> mesh_partitioner;
  //Arcane::FactoryT<Arcane::IMeshPartitioner> mesh_partitioner_factory(m_sub_domain->serviceMng());
  //Arcane::ScopedPtrT<Arcane::IMeshPartitioner> mesh_partitioner = mesh_partitioner_factory.createInstance(service_name,true);
  // autre technique avec le service finder
  //mesh_partitioner = Arcane::ServiceFinderT<Arcane::IMeshPartitioner>(m_sub_domain->serviceMng()).find(service_name);

  Arcane::ScopedPtrT<Arcane::IMeshPartitioner> mesh_partitioner(m_options->partitioner());

  if (!mesh_partitioner.get())
    {
      std::cerr << "ArgeoSim try : Le service specifie pour le partitionnement initial du maillage "
              << "(" << service_name << ") n'est pas disponible";
    }
  // Effectue le partitionnement initial si n�cessaire.
  for( Arcane::Integer z = 0, zs = m_meshes.size(); z<zs; ++z )
  {
    Arcane::IPrimaryMesh* mesh = PRIMARYMESH_CAST(m_meshes[z]);

#if (ARCANE_VERSION >= 30003)
    m_graphs[z].reset(Arcane::mesh::GraphBuilder::createGraph(mesh,"ArcaneParticles")) ;
    _readConnection(m_meshes[z],m_graphs[z].get());
#else
    _readConnection(m_meshes[z]);
#endif
    mesh_partitioner->partitionMesh(true);
    bool is_dynamic = mesh->isDynamic();
    mesh->modifier()->setDynamic(true);
    mesh->exchangeItems();
    //mesh->utilities()->partitionAndExchangeMeshWithReplication(mesh_partitioner.get(),true);
    mesh->modifier()->setDynamic(is_dynamic);
  }
}

void ColumnMeshPartitioner::
#if (ARCANE_VERSION >= 30003)
_readConnection(Arcane::IMesh* meshixm, IGraph2* graph)
#else
_readConnection(Arcane::IMesh* meshixm)
#endif
{
#if (ARCANE_VERSION >= 30003)
  ArcGeoSim::ItemConnectionMng item_connection_mng(meshixm,graph);
  m_constraint.add(new ColumnPartitionConstraint(meshixm,graph,item_connection_mng.allConnections()));
#else
  ArcGeoSim::ItemConnectionMng item_connection_mng(meshixm);
  m_constraint.add(new ColumnPartitionConstraint(meshixm,item_connection_mng.allConnections()));
#endif

  Arcane::IMeshPartitionConstraintMng * partition_constraint_mng = meshixm->partitionConstraintMng();
  partition_constraint_mng->addConstraint(m_constraint[0]);
}

/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_COLUMNMESHPARTITIONER(ColumnMeshPartitioner,ColumnMeshPartitionerService);
