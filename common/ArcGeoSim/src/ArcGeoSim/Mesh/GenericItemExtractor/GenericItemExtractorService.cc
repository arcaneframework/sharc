// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "GenericItemExtractorService.h"
/* Author : mesriy at Tue Sep 29 10:25:39 2009
 * Generated by createNew
 */
#include <iostream>
#include <fstream>

using namespace std;
using namespace Arcane;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void GenericItemExtractorService::init()
{
  //m_input_file = options()->inputFile();
  //m_output_file = options()->outputFile();
  //m_item_file = options()->itemFile();
}

/*---------------------------------------------------------------------------*/

int GenericItemExtractorService::extract()
{
  String input_file= options()->inputFile();
  String output_file= m_output_path + "/" + options()->outputFile();
  String item_file= m_output_path + "/" +options()->itemFile();

  ifstream i_mesh_file(input_file.localstr());
  if (!i_mesh_file.is_open())
    {
      cerr << "Error while opening " << input_file << endl;
      exit(1);
    }
  else
    {
      ofstream o_item_file(item_file.localstr());
      ofstream o_mesh_file(output_file.localstr());

      info() << "Output mesh in file : " << output_file;
      int n, id, i;
      int nb_nodes, nb_faces, nb_cells;
      int cells_nb_nodes=0;
      int faces_nb_nodes=0;
      int id_type= 0;
      double x, y, z;
      String skip;

      i_mesh_file >> nb_nodes;
      o_mesh_file << nb_nodes << endl;
      for (int i=0; i<nb_nodes; i++)
        {
          i_mesh_file >> x >> y >> z;
          o_mesh_file << x << " " << y << " " << z << endl;
        }
      info() << "Read coordinates done...\n";
      // Load faces
//      int pos_faces=o_mesh_file.tellp();
      i_mesh_file >> nb_faces;
      // SDC on �crit pas les infos de faces dans le .vor cf. format
//      o_mesh_file << nb_faces << "                                   " <<endl;
      list<unsigned long> ** list_face_nodes = 0;
      list_face_nodes = new list<unsigned long> * [nb_faces];
      for (i=0; i<nb_faces; ++i)
        {
          list_face_nodes[i] = new list<unsigned long>;
          i_mesh_file >> n;
          faces_nb_nodes += n;
          // SDC on �crit pas les infos de faces dans le .vor
//          o_mesh_file << n << " ";
          for (int j=0; j<n; ++j)
            {
              i_mesh_file >> id;
              // SDC on �crit pas les infos de faces dans le .vor
//              o_mesh_file << id << " ";
              list_face_nodes[i]->push_back(id);
            }
          // SDC on �crit pas les infos de faces dans le .vor
//          o_mesh_file << endl;
          // skip the last value in face numbering line
          i_mesh_file >> skip;
        }
      // Skip Face properties
      // number of properties
      int nb_properties;
      i_mesh_file >> nb_properties;
      if (nb_properties) {
          // We can use stream position pointer to skip this part
          //int in_pos_cells=i_mesh_file.tellg();
          //in_pos_cells= in_pos_cells + nb_properties*(1*sizeof(String)+nb_faces*sizeof(double));
          //i_mesh_file.seekg(in_pos_cells,ios::beg);
          for (i=0;i<nb_properties;i++){
              // name of ith property
              i_mesh_file >> skip;
              for (int j=0;j<nb_faces;j++){
                  i_mesh_file >> skip;
              }
          }
      }
      info() << "Read faces done...";
      // Load cells
      int pos_cells=o_mesh_file.tellp();
      i_mesh_file >> nb_cells;
      o_mesh_file << nb_cells << "                                    " <<endl;
      o_item_file << nb_cells << endl;
      list<unsigned long> * list_cell_nodes = 0;
      list<unsigned long> * list_cell_faces = 0;

      list<unsigned long>::iterator it, itF, itN;

      for (i=0; i<nb_cells; ++i)
        {
          list_cell_nodes = new list<unsigned long>;
          list_cell_faces = new list<unsigned long>;
          // read nb faces of cell
          i_mesh_file >> n;
          //cout << "nb_faces_cell: " << n << endl;
          for (int j=0; j<n; ++j)
            {
              i_mesh_file >> id;
              list_cell_faces->push_back(id);
              itF = list_face_nodes[id]->begin();
              //cout << "nb_face_nodes:" << list_face_nodes[id]->size() << endl;;
              while (itF != list_face_nodes[id]->end())
                {
                  //cout << "itf " << *itF << endl;
                  list_cell_nodes->push_back(*itF);
                  itF++;
                }
            }
          // remove duplicate values
          list_cell_nodes->sort();
          list_cell_nodes->unique();
          o_mesh_file << id_type << " ";
          o_mesh_file << list_cell_nodes->size() << " ";
          cells_nb_nodes += list_cell_nodes->size();
          it = list_cell_nodes->begin();
          while (it != list_cell_nodes->end())
            {
              o_mesh_file << *it << " ";
              it++;
            }
          o_mesh_file << endl;
          //
          debug() << "Extracting edges and adjacent faces...";
          int nb_cell_faces= list_cell_faces->size();
          int nb_cell_nodes= list_cell_nodes->size();
          int nb_cell_edges = nb_cell_nodes + nb_cell_faces - 2;
          debug() << "Edges number: " << nb_cell_edges;

          {
            o_item_file << id_type++ << " " << nb_cell_faces << " " << nb_cell_edges
                << endl;
            EdgeList el;
            el.init(nb_cell_edges);
            itF = list_cell_faces->begin();
            int p = 0,q = 0, id;
            int iedge=0;
            for( int j=0; j<nb_cell_faces; ++j ){
                list<unsigned long>::iterator itFN = list_face_nodes[*itF]->begin();
                int nb_node_face = list_face_nodes[*itF]->size();
                o_item_file << nb_node_face << " ";
                debug() << "nb_node_face: " << nb_node_face;
                list<unsigned long>::iterator it;
                for( int k=0; k<nb_node_face-1; ++k ){
                    it=itFN;it++;
                    p= *itFN;
                    q= *it;
                    //cout << "(p,q)= " << p << " " << q << endl;
                    id=el.find(p,q);
                    if(id==-1){
                        //cout << "(p,q)= " << p << " " << q << endl;
                        el.add_edge(p,q);
                        el.add_face_edge(iedge,j);
                        iedge++;
                    }
                    else
                      el.add_face_edge(id,j);

                    // write local face numbering
                    itN = list_cell_nodes->begin();
                    for( int l=0; l<nb_cell_nodes; ++l ){
                        // find local ids of each edge
                        if (*itFN == *itN)
                          o_item_file << l << " ";
                        itN++;
                    }

                    itFN++;
                }
                // write local face numbering for itFN=end()
                itN = list_cell_nodes->begin();
                for( int l=0; l<nb_cell_nodes; ++l ){
                    // find local ids of each edge
                    if (*itFN == *itN)
                      o_item_file << l << " ";
                    itN++;
                }
                o_item_file << endl;
                // add n-0 edges to close manifold
                list<unsigned long>::reverse_iterator itFNLast = list_face_nodes[*itF]->rbegin();
                list<unsigned long>::iterator itFNBegin= list_face_nodes[*itF]->begin();
                p= *itFNBegin;
                q= *itFNLast;
                id=el.find(p,q);
                if(id == -1) {
                    el.add_edge(p,q);
                    el.add_face_edge(iedge,j);
                    iedge++;
                }
                else
                  el.add_face_edge(id,j);

                itF++;
            }

            // assert(el.size()==nb_edges)
            // correspondance local/global edge numbering
            //cout << "################\n";
            //el.print();
            //cout << "################\n";
            EdgeList::edge_list::iterator itE=el.get_edge_iterator();
            for (int j=0;j<nb_cell_edges;j++) {
                itN = list_cell_nodes->begin();
                for( int l=0; l<nb_cell_nodes; ++l ){
                    // find local ids of each edge
                    if ((*itE).first == (int) *itN) {
                        p=l;
                    }
                    if ((*itE).second == (int) *itN)
                      q=l;
                    itN++;
                }
                // edges, faces left and right
                o_item_file << p << " " << q << " ";
                o_item_file << el.left_face_edge(j) << " " << el.right_face_edge(j) << endl;;
                itE++;
            }

          }
          list_cell_nodes->clear();
          list_cell_faces->clear();
        }
      info() << "Read cells done...";
      info() << "Build data structure done...";
      info() << "Summary.";
      info() << "Number of nodes read: " << nb_nodes;
      info() << "Number of cells read: " << nb_cells;
      info() << "Number of faces read: " << nb_faces;


      if(!i_mesh_file.eof()){
          // read cell's center
          debug() << "cell's center...";
          for ( i=0; i<nb_cells; i++)
            {
              i_mesh_file >> x >> y >> z;
              o_mesh_file << x << " " << y << " " << z << endl;
            }
      }

      // SDC on �crit pas les infos de faces dans le .vor
//      o_mesh_file.seekp(pos_faces,ios::beg);
//      o_mesh_file << nb_faces << " " << faces_nb_nodes << " ";
      o_mesh_file.seekp(pos_cells,ios::beg);
      o_mesh_file << nb_cells << " " << cells_nb_nodes << " ";



      i_mesh_file.close();
      o_item_file.close() ;
      o_mesh_file.close();

      for ( i=0; i<nb_faces; i++)
        {
          list_face_nodes[i]->clear();
        }
      delete [] list_face_nodes;
    }

  return 0 ;


}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_GENERICITEMEXTRACTOR(GenericItemExtractor,GenericItemExtractorService);
