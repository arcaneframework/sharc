// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#ifndef ARCGEOSIM_MESH_GENERICITEMEXTRACTOR_GENERICITEMEXTRACTORSERVICE_H
#define ARCGEOSIM_MESH_GENERICITEMEXTRACTOR_GENERICITEMEXTRACTORSERVICE_H
/* Author : mesriy at Tue Sep 29 10:25:39 2009
 * Generated by createNew
 */
#include <list>
#include <utility>

//using namespace std;
// Interface du service
#include "ArcGeoSim/Mesh/GenericItemExtractor/IGenericItemExtractor.h"


namespace Arcane { }
using namespace Arcane;

#include "GenericItemExtractor_axl.h"

class GenericItemExtractorService :
  public ArcaneGenericItemExtractorObject
{
public:
  /** Constructeur de la classe */
  GenericItemExtractorService(const Arcane::ServiceBuildInfo & sbi) :
    ArcaneGenericItemExtractorObject(sbi),
	m_output_path(".")
    {
      ;
    }

  /** Destructeur de la classe */
  virtual ~GenericItemExtractorService() {}

public:
	class EdgeList {
	    public:
	    	typedef std::list< std::pair <int,int> > edge_list;
    EdgeList() : m_el(NULL), m_elf(NULL), m_nb_edges(0) {;}
	    	~EdgeList() {
	    		m_el->clear();
	    		delete m_el;
	    		for (int i=0;i<m_nb_edges;i++){
	    			m_elf[i]->clear();
	    		}
	    		delete [] m_elf;
	    	};
	    	void init(int & nb_edges) {
	    		m_el = new edge_list;
	    		m_elf = new std::list<int> * [nb_edges];
	    		for(int i=0;i<nb_edges;i++)
	    			m_elf[i]= new std::list<int>;
	    			m_nb_edges= nb_edges;
	    	};
	    	void add_edge(int &a, int &b) {
	    		if (a>b) {int aux=a; a=b; b=aux;}
	    		m_el->push_back(std::make_pair(a,b));
	    	};
	    	int find(int &a, int &b) {
	    		int not_found=-1;
	    		int k=0;
	    		if (a>b) {int aux=a; a=b; b=aux;}
	    		std::pair <int,int> test= std::make_pair(a,b);
	    		edge_list::iterator it= m_el->begin();
	    		for(;it!=m_el->end();it++){
	    			if(*it == test)
	    				return k;
	    			k++;
	    		}
	    		return not_found;
	    	};
	    	void unique() {
	    		m_el->sort();
	    		m_el->unique();
	    	};
	    	void add_face_edge(int& id_edge,int &id_face) {
	    		m_elf[id_edge]->push_back(id_face);
	    	};
	    	int left_face_edge(int & id_edge){
	    		m_elf[id_edge]->sort();
	    		m_elf[id_edge]->unique();
	    		std::list<int>::iterator it= m_elf[id_edge]->begin();
	    		return *it;
	    	};
	    	int right_face_edge(int & id_edge){
	    		m_elf[id_edge]->sort();
	    		m_elf[id_edge]->unique();
	    		std::list<int>::iterator it= m_elf[id_edge]->begin();
	    		it++;
	    		return *it;
	    	};
	    	edge_list::iterator get_edge_iterator() {
	    		return m_el->begin();
	    	};
	    	void print() {
	    		edge_list::iterator itE = m_el->begin();
	    		int id_edge=0;
	    		for(;itE != m_el->end();itE++)
	    		{
	    			std::cout << (*itE).first << " " << (*itE).second << " ";
	    			std::list<int>::iterator it= m_elf[id_edge]->begin();
	    			for(;it != m_elf[id_edge]->end();it++)
	    			{
	    				std::cout << *it << " " << *(it++) << std::endl;
	    			}
	    			id_edge++;
	    		}
	    	};
	    private:
	    	edge_list * m_el;
	    	std::list <int> ** m_elf;
	    	int m_nb_edges;
	};

public:

  //! Initialisation
  void init();

  //! Set output directory path
  void setOutputPath(const Arcane::String ouput_path)
  {
	  m_output_path = ouput_path;
  };

  //! Apply service function
  //void apply();
  //! Extract item types and get new ouput mesh file
  int extract();

private:
  String m_output_path;
	//! noms du maillage d'entree et du maillage et items de sorties
	//String m_input_file;
	//String m_output_file;
	//String m_item_file;
};

#endif /* ARCGEOSIM_MESH_GENERICITEMEXTRACTOR_GENERICITEMEXTRACTORSERVICE_H */
