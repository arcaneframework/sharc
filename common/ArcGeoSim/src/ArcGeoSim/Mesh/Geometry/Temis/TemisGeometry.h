#ifndef ARCGEOSIM_GEOMETRY_TEMISGEOMETRY_H
#define ARCGEOSIM_GEOMETRY_TEMISGEOMETRY_H
/* Author : willien at Wed Mar 19 09:57:00 2008
 * Generated by createNew
 */
#include <map>
#include "ArcGeoSim/Mesh/Geometry/IGeometry.h"
#include "ArcGeoSim/Mesh/Geometry/Euclidian/EuclidianGeometry.h"
#include <arcane/ArcaneTypes.h>
#include <arcane/MeshVariable.h>
#include <arcane/VariableTypedef.h>
#include <arcane/MathUtils.h>
#include <arcane/IMeshSubMeshTransition.h>
#include <arcane/ArcaneVersion.h>
#include <arcane/SharedVariable.h>

using namespace Arcane;
using namespace EuclidianGeometry;

template<typename CoordinatesVariable>
class TemisGeometryT : public EuclidianGeometryT<3,CoordinatesVariable>
{
private:
  typedef EuclidianGeometryT<3,CoordinatesVariable> E3Geometry;

public:
  /** Constructeur de la classe */
  TemisGeometryT(const CoordinatesVariable & coords);
  
  /** Destructeur de la classe */
  virtual ~TemisGeometryT() { }

  //@{ @name Inherited methods from IGeometry

  //! Calcul de l'isobarycentre
  Real3 computeCenter(const ItemWithNodes & item);
  Real3 computeCenter(const ItemWithNodes & item, Array<Real> & coords);

  //! Calcul de la mesure orientée
  /*! Dans le cas d'un élément plan, ceci correspond à
   *  la normale moyenne unitaire * mesure de l'élément
   *  et dans le cas d'un simple élément volumique nous obtenons
   *  volume * z (ou z=(0,0,1))
   */
  Real3 computeOrientedMeasure(const ItemWithNodes & item);

  //! Calcul de la mesure (sans orientation)
  Real  computeMeasure(const ItemWithNodes & item);

  //! Calcul de l'aire 
  /*! Uniquement pour les Items surfaciques */
  Real  computeArea(const ItemWithNodes & item);

  //! Calcul du volume
  /*! Uniquement pour les Items volumiques */
  Real  computeVolume(const ItemWithNodes & item);

  //@}
  
public:
  //@{ @name specific computations on basic types (interface depends to the dimension)
  typedef typename E3Geometry::ComputeLine2 ComputeLine2;

  struct IComputeSurface {
    IComputeSurface(TemisGeometryT * geom) : m_geom(geom), m_coords(geom->m_coords) { }
    virtual ~IComputeSurface() { }
    virtual void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords) = 0;
    TemisGeometryT * m_geom;
    const CoordinatesVariable & m_coords;
  };

  // Utilise une méthode alternative pour les calculs de centre
  struct ComputeTriangle3 : public IComputeSurface { 
    ComputeTriangle3(TemisGeometryT * geom) : IComputeSurface(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords);
  };

  struct ComputeQuad4 : public IComputeSurface {
    ComputeQuad4(TemisGeometryT * geom) : IComputeSurface(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords);
  };

  struct ComputeInvalidSurface : public IComputeSurface { 
    ComputeInvalidSurface(TemisGeometryT * geom) : IComputeSurface(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords);
  };

  typedef ComputeInvalidSurface ComputePentagon5;
  typedef ComputeInvalidSurface ComputeHexagon6;
  
  struct IComputeVolume {
    IComputeVolume(TemisGeometryT * geom) : m_geom(geom), m_coords(geom->m_coords) { }
    virtual ~IComputeVolume() { }
    virtual void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real & measure, Real3 & center, Array<Real> & coords) = 0;
    virtual void computeVolumeArea(const ItemWithNodes & item, Real & area) = 0;
    TemisGeometryT * m_geom;
    const CoordinatesVariable & m_coords;
  };

  struct ComputeGenericVolume : public IComputeVolume { 
    ComputeGenericVolume(TemisGeometryT * geom) : IComputeVolume(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real & measure, Real3 & center, Array<Real> & coords);
    void computeVolumeArea(const ItemWithNodes & item, Real & area);
  };

  struct ComputeInvalidVolume : public IComputeVolume { 
    ComputeInvalidVolume(TemisGeometryT * geom) : IComputeVolume(geom) { }    
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real & measure, Real3 & center, Array<Real> & coords);
    void computeVolumeArea(const ItemWithNodes & item, Real & area);
  };

  typedef ComputeInvalidVolume ComputeTetraedron4;
  typedef ComputeInvalidVolume ComputePyramid5;
  typedef ComputeGenericVolume ComputePentaedron6;
  typedef ComputeGenericVolume ComputeHexaedron8;
  typedef ComputeGenericVolume ComputeHemiHexa7;
  typedef ComputeGenericVolume ComputeHemiHexa6;
  typedef ComputeGenericVolume ComputeHemiHexa5;
  typedef ComputeInvalidVolume ComputeAntiWedgeLeft6;
  typedef ComputeInvalidVolume ComputeAntiWedgeRight6;
  typedef ComputeInvalidVolume ComputeDiTetra5;
  typedef ComputeInvalidVolume ComputeHeptaedron10;
  typedef ComputeInvalidVolume ComputeOctaedron12;

  //@}

  //@{ @name primitive used for volume decomposition
  static inline Real3 computeQuadrilateralCenter(const Real3 & n0, const Real3 & n1, const Real3 & n2, const Real3 & n3)
  {
    return 0.25 * (n0 + n1 + n2 + n3);
  }
  //@}

private:
  typedef SharedArray< SharedArray<Real> > MapType;
  MapType m_node_weight;
};

typedef TemisGeometryT<VariableNodeReal3> TemisGeometry;

#include <arcane/SharedVariable.h>
typedef TemisGeometryT<SharedMeshVariableScalarRefT<Node,Real3> > SharedTemisGeometry;

#endif /* ARCGEOSIM_GEOMETRY_TEMISGEOMETRY_H */
