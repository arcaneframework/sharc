
#include "ArcGeoSim/Mesh/Geometry/Temis/TemisGeometry.h"
/* Author : havep at Wed Nov 14 14:23:21 2007
 * Generated by createNew
 */

#include <arcane/utils/FatalErrorException.h>
#include <arcane/utils/NotImplementedException.h>

#include <arcane/mesh/NodeFamily.h>


/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
TemisGeometryT<CoordinatesVariable>::
TemisGeometryT(const CoordinatesVariable & coords)
  : E3Geometry(coords) {
  m_node_weight.resize(ItemTypeMng::nbBasicItemType()); // use Arcane global variable
  // 1D
  m_node_weight[IT_Line2] = SharedArray<Real>(2);
  m_node_weight[IT_Line2][0] = 1./2.;
  m_node_weight[IT_Line2][1] = 1./2.;
  // 2D
  m_node_weight[IT_Triangle3] = SharedArray<Real>(3);
  m_node_weight[IT_Triangle3][0] = 1./3.; 
  m_node_weight[IT_Triangle3][1] = 1./3.; 
  m_node_weight[IT_Triangle3][2] = 1./3.; 
  //
  m_node_weight[IT_Quad4] =  SharedArray<Real>(4);
  m_node_weight[IT_Quad4][0] = 1./4.;
  m_node_weight[IT_Quad4][1] = 1./4.;
  m_node_weight[IT_Quad4][2] = 1./4.;
  m_node_weight[IT_Quad4][3] = 1./4.;
  //
  m_node_weight[IT_HemiHexa5] = SharedArray<Real>(5);
  m_node_weight[IT_HemiHexa5][0] = 2./8.;
  m_node_weight[IT_HemiHexa5][1] = 1./8.;
  m_node_weight[IT_HemiHexa5][2] = 1./8.;
  m_node_weight[IT_HemiHexa5][3] = 2./8.;
  m_node_weight[IT_HemiHexa5][4] = 2./8.;
  //
  m_node_weight[IT_HemiHexa6] = SharedArray<Real>(6);
  m_node_weight[IT_HemiHexa6][0] = 2./8.;
  m_node_weight[IT_HemiHexa6][1] = 1./8.;
  m_node_weight[IT_HemiHexa6][2] = 1./8.;
  m_node_weight[IT_HemiHexa6][3] = 2./8.;
  m_node_weight[IT_HemiHexa6][4] = 1./8.;
  m_node_weight[IT_HemiHexa6][5] = 1./8.;
  //
  m_node_weight[IT_Pentaedron6] = SharedArray<Real>(6);
  m_node_weight[IT_Pentaedron6][0] = 2./8.;
  m_node_weight[IT_Pentaedron6][1] = 1./8.;	
  m_node_weight[IT_Pentaedron6][2] = 1./8.;	
  m_node_weight[IT_Pentaedron6][3] = 2./8.;	
  m_node_weight[IT_Pentaedron6][4] = 1./8.;	
  m_node_weight[IT_Pentaedron6][5] = 1./8.;	
  //
  m_node_weight[IT_Hexaedron8] = SharedArray<Real>(8);
  m_node_weight[IT_Hexaedron8][0] = 1./8.;
  m_node_weight[IT_Hexaedron8][1] = 1./8.;
  m_node_weight[IT_Hexaedron8][2] = 1./8.;
  m_node_weight[IT_Hexaedron8][3] = 1./8.;
  m_node_weight[IT_Hexaedron8][4] = 1./8.;
  m_node_weight[IT_Hexaedron8][5] = 1./8.;
  m_node_weight[IT_Hexaedron8][6] = 1./8.;
  m_node_weight[IT_Hexaedron8][7] = 1./8.;
  //
  m_node_weight[IT_HemiHexa7] = SharedArray<Real>(7);
  m_node_weight[IT_HemiHexa7][0] = 2./8.;
  m_node_weight[IT_HemiHexa7][1] = 1./8.;
  m_node_weight[IT_HemiHexa7][2] = 1./8.;
  m_node_weight[IT_HemiHexa7][3] = 1./8.;
  m_node_weight[IT_HemiHexa7][4] = 1./8.;
  m_node_weight[IT_HemiHexa7][5] = 1./8.;
  m_node_weight[IT_HemiHexa7][6] = 1./8.;
}

/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
Real3
TemisGeometryT<CoordinatesVariable>::
computeCenter(const ItemWithNodes & item)
{
  Real3 orientation, center, mass_center;
  Real measure;
  SharedArray<Real> coords;

  switch (item.type()) {
  case IT_Line2:
    ComputeLine2(this).computeOrientedMeasureAndCenter(item,orientation,center);
    return center;
  case IT_Triangle3:
    ComputeTriangle3(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return center;
  case IT_Quad4:
    ComputeQuad4(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return center;
  case IT_Pentagon5:
    ComputePentagon5(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return center;
  case IT_Hexagon6:
    ComputeHexagon6(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return center;
  case IT_Tetraedron4:
    ComputeTetraedron4(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_Pyramid5:
    ComputePyramid5(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_Pentaedron6:
    ComputePentaedron6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_Hexaedron8:
    ComputeHexaedron8(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_Heptaedron10:
    ComputeHeptaedron10(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_Octaedron12:
    ComputeOctaedron12(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_HemiHexa7:
    ComputeHemiHexa7(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_HemiHexa6:
    ComputeHemiHexa6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_HemiHexa5:
    ComputeHemiHexa5(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_AntiWedgeLeft6:
    ComputeAntiWedgeLeft6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_AntiWedgeRight6:
    ComputeAntiWedgeRight6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_DiTetra5:
    ComputeDiTetra5(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  default:
    throw FatalErrorException(A_FUNCINFO,"Not supported Item Type");
  }
}


/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
Real3
TemisGeometryT<CoordinatesVariable>::
computeCenter(const ItemWithNodes & item, Array<Real> & coords)
{
  Real3 orientation, center, mass_center;
  Real measure;

  switch (item.type()) {
  case IT_Line2:
    ComputeLine2(this).computeOrientedMeasureAndCenter(item,orientation,center);
    return center;
  case IT_Triangle3:
    ComputeTriangle3(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return center;
  case IT_Quad4:
    ComputeQuad4(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return center;
  case IT_Pentagon5:
    ComputePentagon5(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return center;
  case IT_Hexagon6:
    ComputeHexagon6(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return center;
  case IT_Tetraedron4:
    ComputeTetraedron4(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_Pyramid5:
    ComputePyramid5(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_Pentaedron6:
    ComputePentaedron6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_Hexaedron8:
    ComputeHexaedron8(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_Heptaedron10:
    ComputeHeptaedron10(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_Octaedron12:
    ComputeOctaedron12(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_HemiHexa7:
    ComputeHemiHexa7(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_HemiHexa6:
    ComputeHemiHexa6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_HemiHexa5:
    ComputeHemiHexa5(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_AntiWedgeLeft6:
    ComputeAntiWedgeLeft6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_AntiWedgeRight6:
    ComputeAntiWedgeRight6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  case IT_DiTetra5:
    ComputeDiTetra5(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return center;
  default:
    throw FatalErrorException(A_FUNCINFO,"Not supported Item Type");
  }
}

/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
Real3
TemisGeometryT<CoordinatesVariable>::
computeOrientedMeasure(const ItemWithNodes & item)
{
  Real3 orientation, center, mass_center;
  Real measure;
  SharedArray<Real> coords;

  switch (item.type()) {
  case IT_Line2:
    ComputeLine2(this).computeOrientedMeasureAndCenter(item,orientation,center);
    return orientation;
  case IT_Triangle3:
    ComputeTriangle3(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return orientation;
  case IT_Quad4:
    ComputeQuad4(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return orientation;
  case IT_Pentagon5:
    ComputePentagon5(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return orientation;
  case IT_Hexagon6:
    ComputeHexagon6(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return orientation;
  case IT_Tetraedron4:
    ComputeTetraedron4(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return Real3(0,0,measure);
  case IT_Pyramid5:
    ComputePyramid5(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return Real3(0,0,measure);
  case IT_Pentaedron6:
    ComputePentaedron6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return Real3(0,0,measure);
  case IT_Hexaedron8:
    ComputeHexaedron8(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return Real3(0,0,measure);
  case IT_Heptaedron10:
    ComputeHeptaedron10(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return Real3(0,0,measure);
  case IT_Octaedron12:
    ComputeOctaedron12(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return Real3(0,0,measure);
  default:
    throw FatalErrorException(A_FUNCINFO,"Not supported Item Type");
  }
}

/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
Real
TemisGeometryT<CoordinatesVariable>::
computeMeasure(const ItemWithNodes & item)
{
  Real3 orientation, center, mass_center;
  Real measure;
  SharedArray<Real> coords;

  switch (item.type()) {
  case IT_Line2:
    ComputeLine2(this).computeOrientedMeasureAndCenter(item,orientation,center);
    return math::normeR3(orientation);
  case IT_Triangle3:
    ComputeTriangle3(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return math::normeR3(orientation);
  case IT_Quad4:
    ComputeQuad4(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return math::normeR3(orientation);
  case IT_Pentagon5:
    ComputePentagon5(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return math::normeR3(orientation);
  case IT_Hexagon6:
    ComputeHexagon6(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return math::normeR3(orientation);
  case IT_Tetraedron4:
    ComputeTetraedron4(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_Pyramid5:
    ComputePyramid5(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_Pentaedron6:
    ComputePentaedron6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_Hexaedron8:
    ComputeHexaedron8(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_Heptaedron10:
    ComputeHeptaedron10(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_Octaedron12:
    ComputeOctaedron12(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_HemiHexa7:
    ComputeHemiHexa7(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_HemiHexa6:
    ComputeHemiHexa6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_HemiHexa5:
    ComputeHemiHexa5(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_AntiWedgeLeft6:
    ComputeAntiWedgeLeft6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_AntiWedgeRight6:
    ComputeAntiWedgeRight6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_DiTetra5:
    ComputeDiTetra5(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  default:
    throw FatalErrorException(A_FUNCINFO,"Not supported Item Type");
  }
}

/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
Real
TemisGeometryT<CoordinatesVariable>::
computeArea(const ItemWithNodes & item)
{
  Real3 orientation, center, mass_center;
  SharedArray<Real> coords;

  switch (item.type()) {
  case IT_Line2:
    return 0.;
  case IT_Triangle3:
    ComputeTriangle3(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return math::normeR3(orientation);
  case IT_Quad4:
    ComputeQuad4(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return math::normeR3(orientation);
  case IT_Pentagon5:
    ComputePentagon5(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return math::normeR3(orientation);
  case IT_Hexagon6:
    ComputeHexagon6(this).computeOrientedMeasureAndCenter(item,orientation,center, mass_center,coords);
    return math::normeR3(orientation);
  case IT_Tetraedron4:
  case IT_Pyramid5:
  case IT_Pentaedron6:
  case IT_Hexaedron8:
  case IT_Heptaedron10:
  case IT_Octaedron12:
  case IT_HemiHexa7:
  case IT_HemiHexa6:
  case IT_HemiHexa5:
  case IT_AntiWedgeLeft6:
  case IT_AntiWedgeRight6:
  case IT_DiTetra5:
    return 0.;
  default:
    throw FatalErrorException(A_FUNCINFO,"Not supported Item Type");
  }
}

/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
Real
TemisGeometryT<CoordinatesVariable>::
computeVolume(const ItemWithNodes & item)
{
  Real3 center;
  Real measure;
  SharedArray<Real> coords;

  switch (item.type()) {
  case IT_Line2:
  case IT_Triangle3:
  case IT_Quad4:
  case IT_Pentagon5:
  case IT_Hexagon6:
    return 0.;
  case IT_Tetraedron4:
    ComputeTetraedron4(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_Pyramid5:
    ComputePyramid5(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_Pentaedron6:
    ComputePentaedron6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_Hexaedron8:
    ComputeHexaedron8(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_Heptaedron10:
    ComputeHeptaedron10(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_Octaedron12:
    ComputeOctaedron12(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_HemiHexa7:
    ComputeHemiHexa7(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_HemiHexa6:
    ComputeHemiHexa6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_HemiHexa5:
    ComputeHemiHexa5(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_AntiWedgeLeft6:
    ComputeAntiWedgeLeft6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_AntiWedgeRight6:
    ComputeAntiWedgeRight6(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  case IT_DiTetra5:
    ComputeDiTetra5(this).computeOrientedMeasureAndCenter(item,measure,center,coords);
    return measure;
  default:
    throw FatalErrorException(A_FUNCINFO,"Not supported Item Type");
  }
}

/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
void
TemisGeometryT<CoordinatesVariable>::ComputeTriangle3::
computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords)
{
  // Héritage du cas général (pour orientation et mass_center), on écrase ensuite center avec un nouveau calcul
  typename EuclidianGeometryT<3,CoordinatesVariable>::ComputeTriangle3(this->m_geom).computeOrientedMeasureAndCenter(item, orientation, center, mass_center,coords);

  if (!item.isCell()) { // Face en 3D
    ARCANE_ASSERT((item.isFace()),("Unexpected non-face"));
    ARCANE_ASSERT((item.nbNode()==3),("Unexpected not 3 nodes triangles"));
    const Face face = item.toFace();
    const Cell cell = face.cell(0);
    const Array<Real> & tab = this->m_geom->m_node_weight[cell.type()];
    ARCANE_ASSERT((tab.size() == cell.nbNode()),("Unexpected not vertical degenerated hexa"));

    struct NodeFinder {
      NodeFinder(const Int32ConstArrayView & lids) 
        : m_lids(lids) { }
      inline Integer operator()(Integer lid) const {
        for(Integer i=0;i<m_lids.size();++i)
          if (lid == m_lids[i]) return i;
        ARCANE_ASSERT((false),("Unexpected not found node"));
        return -1;
      }
    private:
      const Int32ConstArrayView m_lids;
    } node_finder(cell.nodes().localIds());

    coords.resize(3);

    for(Integer i=0;i<3;++i) {
        coords[i] = tab[node_finder(item.node(i).localId())]*2;
        //coords[i] = m_node_weight[IT_Triangle3][i];
    }

    center 
      = tab[node_finder(item.node(0).localId())] * this->m_coords[item.node(0)]
      + tab[node_finder(item.node(1).localId())] * this->m_coords[item.node(1)]
      + tab[node_finder(item.node(2).localId())] * this->m_coords[item.node(2)];
    center *= 2; // à cause du facteur /8 dans les m_node_weight et ici /4
  }
}

/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
void
TemisGeometryT<CoordinatesVariable>::ComputeQuad4::
computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords)
{
	// Héritage du cas général (pour orientation et mass_center), on écrase ensuite center avec un nouveau calcul
	typename EuclidianGeometryT<3,CoordinatesVariable>::ComputeQuad4(this->m_geom).computeOrientedMeasureAndCenter(item, orientation, center, mass_center,coords);

    center =
      computeQuadrilateralCenter(this->m_coords[item.node(0)],
                                 this->m_coords[item.node(1)],
                                 this->m_coords[item.node(2)],
                                 this->m_coords[item.node(3)]);

    coords.resize(4);

    for(Integer i=0;i<4;++i) {
        //coords[i] = m_node_weight[IT_Quad4][i];
        coords[i] = 1/4.;
    }

}

/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
void
TemisGeometryT<CoordinatesVariable>::ComputeInvalidSurface::
computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords)
{
  throw FatalErrorException(A_FUNCINFO,"Not supported Item Type");  
}

/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
void
TemisGeometryT<CoordinatesVariable>::ComputeGenericVolume::
computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real & measure, Real3 & center, Array<Real> & coords)
{
  // Choix d'un point arbitraire d'étoilement, mais "proche" du centre
  Real3 vcenter(0,0,0);
  for(Integer i=0;i<item.nbNode();++i) {
    vcenter += this->m_coords[item.node(i)];
  }
  vcenter /= item.nbNode();

  Real volume = 0;
  center = Real3(0,0,0);

  // Etoilement des faces puis du volume en tétraèdres
  const Cell cell = item.toCell();

  // Calcul du centre de la maille  facon TEMIS
  Integer nbNode = cell.nbNode();

  ARCANE_ASSERT((this->m_geom->m_node_weight.size() > cell.type()),("Incompatible Temis/Visco cell"));
  ARCANE_ASSERT((this->m_geom->m_node_weight[cell.type()].size() == nbNode),("Incompatible Temis/Visco cell"));

  {
    const Array<Real> & tab = this->m_geom->m_node_weight[cell.type()];
    coords.resize(nbNode);
    for(Integer i=0;i<nbNode;++i) {
      center += tab[i] * this->m_coords[cell.node(i)];
      coords[i] = tab[i];
	  }
  }
  
  for(Integer i=0;i<cell.nbFace();++i)
    {
      const Face face = cell.face(i);
      const Real orientation = (face.frontCell() == cell)?1:-1;

      if (face.nbNode() == 3) {

        Real v = orientation * E3Geometry::computeTetraedronVolume(this->m_coords[face.node(0)],
                                                       this->m_coords[face.node(1)],
                                                       this->m_coords[face.node(2)],
                                                       vcenter);
        volume += v;
      } else if (face.nbNode() == 4) {
        // Le tableau contient le modulo ...
        const Real3 coords[5] = { this->m_coords[face.node(0)],
                                  this->m_coords[face.node(1)],
                                  this->m_coords[face.node(2)],
                                  this->m_coords[face.node(3)],
                                  this->m_coords[face.node(0)] };
        const Real3 fcenter = computeQuadrilateralCenter(coords[0],coords[1],coords[2],coords[3]);
        for(Integer j=0;j<4;++j) {
          const Real v = orientation * E3Geometry::computeTetraedronVolume(coords[j], coords[j+1], fcenter, vcenter);
          volume += v;
        }
      } else {
        throw NotImplementedException(A_FUNCINFO,"Not implemented for face with more than 4 nodes");
      }
    }

  measure = volume;
}

/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
void
TemisGeometryT<CoordinatesVariable>::ComputeGenericVolume::
computeVolumeArea(const ItemWithNodes & item, Real & area)
{
  const Cell cell = item.toCell();
  for(Integer i=0;i<cell.nbFace();++i)
    {
      const Face face = cell.face(i);
      if (face.nbNode() == 3) {
        area += math::abs(this->m_geom->computeTriangleSurface(this->m_coords[face.node(0)],
                                                 this->m_coords[face.node(1)],
                                                 this->m_coords[face.node(2)]));
      } else if (face.nbNode() == 4) {
        area += math::abs(this->m_geom->computeTriangleSurface(this->m_coords[item.node(0)],
                                                 this->m_coords[item.node(1)],
                                                 this->m_coords[item.node(2)]))
          + math::abs(this->m_geom->computeTriangleSurface(this->m_coords[item.node(0)],
                                             this->m_coords[item.node(3)],
                                             this->m_coords[item.node(3)]));
      } else {
        throw NotImplementedException(A_FUNCINFO,"Not implemented for face with more than 4 nodes");
      }
    }
}

/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
void
TemisGeometryT<CoordinatesVariable>::ComputeInvalidVolume::
computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real & measure, Real3 & center, Array<Real> & coords)
{
  throw FatalErrorException(A_FUNCINFO,"Not supported Item Type");
}

/*---------------------------------------------------------------------------*/

template<typename CoordinatesVariable>
void
TemisGeometryT<CoordinatesVariable>::ComputeInvalidVolume::
computeVolumeArea(const ItemWithNodes & item, Real & area)
{
  throw FatalErrorException(A_FUNCINFO,"Not supported Item Type");  
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template class TemisGeometryT<VariableNodeReal3>;

template class TemisGeometryT<SharedMeshVariableScalarRefT<Node,Real3> >;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
