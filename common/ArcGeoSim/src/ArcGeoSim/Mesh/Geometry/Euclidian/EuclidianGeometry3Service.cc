// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
/* Author : dipietrd at Wed Jun 22 14:17:40 2011
 * Generated by createNew
 */

/* INFO: Les services et modules se conforment maintenant a la politique Arcane core.
 *       L'emploi des .h etait fictif. 
 *       Desormais les declarations de classe pour les modules et services seront
 *       localisees dans le fichier .cc correspondant.
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include <arcane/IMeshSubMeshTransition.h>
#include <arcane/SharedVariable.h>
#include <arcane/IItemFamily.h>
using namespace Arcane;

// Interface du service 
#include "ArcGeoSim/Mesh/Geometry/IGeometry.h"
#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"
#include "ArcGeoSim/Mesh/Geometry/Euclidian/EuclidianGeometry.h"
#include "EuclidianGeometry3_axl.h"
#include "ArcGeoSim/Mesh/Geometry/Impl/GeometryServiceBase.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class EuclidianGeometry3Service 
  : public ArcaneEuclidianGeometry3Object
  , public GeometryServiceBase
{
public:
  
  /** Constructeur de la classe */
  EuclidianGeometry3Service(const Arcane::ServiceBuildInfo & sbi) 
    : ArcaneEuclidianGeometry3Object(sbi)
    , GeometryServiceBase()
    , m_initialized(false)
  {
    ;
  }
  
  /** Destructeur de la classe */
  ~EuclidianGeometry3Service() 
  {
    for(SharedGeometryMap::iterator i = m_shared_geometry.begin(); i != m_shared_geometry.end(); ++i)
      {
        delete i->second.first; // SharedEuclidianGeometry3
        delete i->second.second; // SharedMeshVariableScalarRefT<Node,Real3>
      }

    for(UniqGeometryMap::iterator i = m_uniq_geometry.begin(); i != m_uniq_geometry.end(); ++i)
      {
        delete i->second; // EuclidianGeometry3
      }
  }

  
public:
  //! Initialisation
  void init();

  //@{ @name property management by group

  //! Update property values for an ItemGroup
  void update(ItemGroup group);

  //! Reset property for an ItemGroup
  void reset(ItemGroup group);
  
  //@}

  //! Get underlying geometry
  IGeometry * geometry(IMesh * mesh = NULL);

  //! Get dimension associated to this geometry mng
  Dimension dimension() const { return Dimension::e3Dxyz; }

  //! Remove geometry reference to a given mesh
  /*! Used for deleted sub-meshes */
  void unregisterMesh(IMesh * mesh);

public:
  //@{ Extended interface for GeometryServiceBase

  //! Access to traceMng
  ITraceMng * traceMng() { return ArcaneEuclidianGeometry3Object::traceMng(); }

  //! Access to Mesh
  IMesh * mesh() { return ArcaneEuclidianGeometry3Object::subDomain()->defaultMesh(); }

  //! Name of instancied class
  const char * className() const { return "Euclidian3Geometry"; }

  //@}

private:
  //! Shared geometry builder
  EuclidianGeometry::SharedEuclidianGeometry3 * sharedGeometry(IMesh * mesh);
  //! Uniq geometry builder
  EuclidianGeometry::EuclidianGeometry3 * uniqGeometry(IMesh * mesh);

private: 
  bool m_initialized;

  typedef std::map<IMesh*,
                   std::pair<EuclidianGeometry::SharedEuclidianGeometry3*, 
                             SharedMeshVariableScalarRefT<Node,Real3>* > > SharedGeometryMap;
  typedef std::map<IMesh*,EuclidianGeometry::EuclidianGeometry3*> UniqGeometryMap;
  SharedGeometryMap m_shared_geometry;  
  UniqGeometryMap m_uniq_geometry;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void EuclidianGeometry3Service::init()
{
  if (m_initialized)
    {
      info() << className() << " already initialized";
      return;
    }

  if (options()->variableSuffix.size() > 0)
    {
      setSuffix(options()->variableSuffix[0]);
    }
  else
    {
      setSuffix(String());
    }

  m_initialized = true;
}

/*---------------------------------------------------------------------------*/

void EuclidianGeometry3Service::update(ItemGroup group)
{
  IMesh * mesh = group.mesh();
  const bool isUniqMesh = (mesh->parentMesh() == NULL);
  
  if (isUniqMesh)
    updateGroup(group,*uniqGeometry(mesh));
  else
    updateGroup(group,*sharedGeometry(mesh));
}

/*---------------------------------------------------------------------------*/

void EuclidianGeometry3Service::reset(ItemGroup group)
{
  // Do nothing
}

/*---------------------------------------------------------------------------*/

EuclidianGeometry::EuclidianGeometry3 *
EuclidianGeometry3Service::
uniqGeometry(IMesh * mesh)
{
  UniqGeometryMap::iterator finder = m_uniq_geometry.find(mesh);
  if (finder == m_uniq_geometry.end()) 
    { // Build new shared geometry
      UniqGeometryMap::mapped_type & mapped = m_uniq_geometry[mesh];
      // L'implementation actuelle se construit sur le maillage par defaut
      mapped = new EuclidianGeometry::EuclidianGeometry3(PRIMARYMESH_CAST(mesh)->nodesCoordinates(), traceMng(), options()->fatalOnError());
      return mapped;
    }
  else
    {
      return finder->second;
    }
}

/*---------------------------------------------------------------------------*/

EuclidianGeometry::SharedEuclidianGeometry3 *
EuclidianGeometry3Service::
sharedGeometry(IMesh * mesh)
{
  SharedGeometryMap::iterator finder = m_shared_geometry.find(mesh);
  if (finder == m_shared_geometry.end()) 
    { // Build new shared geometry
      SharedGeometryMap::mapped_type & mapped = m_shared_geometry[mesh];
      mapped.second = new SharedMeshVariableScalarRefT<Node,Real3>(mesh->nodeFamily(),
                                                                   PRIMARYMESH_CAST(this->mesh())->nodesCoordinates());
      mapped.first = new EuclidianGeometry::SharedEuclidianGeometry3(*mapped.second, traceMng(), options()->fatalOnError());
      return mapped.first;
    }
  else
    {
      return finder->second.first;
    }
}
 
/*---------------------------------------------------------------------------*/

IGeometry * EuclidianGeometry3Service::geometry(IMesh * mesh)
{
  // Utilise le maillage par defaut si aucun maillage n'est fourni
  if (mesh == NULL) mesh = this->mesh();

  const bool isUniqMesh = (mesh->parentMesh() == NULL);

  if (isUniqMesh)
    return uniqGeometry(mesh);
  else
    return sharedGeometry(mesh);
}

/*---------------------------------------------------------------------------*/

void EuclidianGeometry3Service::unregisterMesh(IMesh * mesh)
{
  if (mesh == NULL) mesh = this->mesh();
  GeometryServiceBase::unregisterMesh(m_uniq_geometry, m_shared_geometry, mesh);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_EUCLIDIANGEOMETRY3(EuclidianGeometry3,EuclidianGeometry3Service);
ARCANE_REGISTER_SERVICE_EUCLIDIANGEOMETRY3(Euclidian3Geometry,EuclidianGeometry3Service);
