// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_MESH_GEOMETRY_EUCLIDIANGEOMETRY_EUCLIDIANGEOMETRY_H
#define ARCGEOSIM_MESH_GEOMETRY_EUCLIDIANGEOMETRY_EUCLIDIANGEOMETRY_H
/* Author : dipietrd at Wed Jun 22 13:30:16 2011
 * Generated by createNew
 */

#include "ArcGeoSim/Mesh/Geometry/IGeometry.h"
#include <arcane/ArcaneTypes.h>
#include <arcane/MeshVariableRef.h>
#include <arcane/VariableTypedef.h>
#include <arcane/MathUtils.h>
#include <arcane/IMeshSubMeshTransition.h>
#include <arcane/ArcaneVersion.h>
#include "ArcGeoSim/Mesh/Geometry/GeometryException.h"

#include <arcane/utils/FatalErrorException.h>
#include <arcane/utils/NotImplementedException.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/ItemPrinter.h>
#include <arcane/SharedVariable.h>

using namespace Arcane;  

namespace EuclidianGeometry
{
  template<Integer Dimension, typename CoordinatesVariable>
  class EuclidianGeometryT;

  // 1d elements

  template<Integer Dimension, typename CoordinatesVariable>
  struct IComputeLineT {
    IComputeLineT(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : m_geom(geom), m_coords(geom->m_coords) { }
    virtual ~IComputeLineT() { }
    virtual void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center) = 0;
    EuclidianGeometryT<Dimension, CoordinatesVariable> * m_geom;
    const CoordinatesVariable & m_coords;
  };

  template<Integer Dimension, typename CoordinatesVariable>
  struct ComputeLine2T { };

  template<typename CoordinatesVariable>
  struct ComputeLine2T<2, CoordinatesVariable> : public IComputeLineT<2, CoordinatesVariable> {
    ComputeLine2T(EuclidianGeometryT<2, CoordinatesVariable> * geom) : IComputeLineT<2, CoordinatesVariable>(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center);
  };

  template<typename CoordinatesVariable>
  struct ComputeLine2T<3, CoordinatesVariable> : public IComputeLineT<3, CoordinatesVariable> {
    ComputeLine2T(EuclidianGeometryT<3, CoordinatesVariable> * geom) : IComputeLineT<3, CoordinatesVariable>(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center);
  };

  /*----------------------------------------------------------------------------*/  

  // 2d elements

  template<Integer Dimension, typename CoordinatesVariable>
  struct IComputeSurfaceT {
    IComputeSurfaceT(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : m_geom(geom), m_coords(geom->m_coords) { }
    virtual ~IComputeSurfaceT() { }
    virtual void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords) = 0;
    EuclidianGeometryT<Dimension, CoordinatesVariable> * m_geom;
    const CoordinatesVariable & m_coords;
  };

  template<Integer Dimension, typename CoordinatesVariable>
  struct ComputeTriangle3T : public IComputeSurfaceT<Dimension, CoordinatesVariable> { 
    ComputeTriangle3T(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : IComputeSurfaceT<Dimension, CoordinatesVariable>(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords);
  };

  template<Integer Dimension, typename CoordinatesVariable>
  struct ComputeQuad4T : public IComputeSurfaceT<Dimension, CoordinatesVariable> { 
    ComputeQuad4T(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : IComputeSurfaceT<Dimension, CoordinatesVariable>(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords);
  };

  template<Integer Dimension, typename CoordinatesVariable>
  struct ComputePentagon5T : public IComputeSurfaceT<Dimension, CoordinatesVariable> { 
    ComputePentagon5T(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : IComputeSurfaceT<Dimension, CoordinatesVariable>(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords);
  };

  template<Integer Dimension, typename CoordinatesVariable>
  struct ComputeHexagon6T : public IComputeSurfaceT<Dimension, CoordinatesVariable> { 
    ComputeHexagon6T(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : IComputeSurfaceT<Dimension, CoordinatesVariable>(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords);
  };

#if ARCANE_VERSION > 12201 || (ARCANE_VERSION==12201 && ARCANE_VERSION_BETA > 0) 
  template<Integer Dimension, typename CoordinatesVariable>
  struct ComputeHeptagon7T : public IComputeSurfaceT<Dimension, CoordinatesVariable> {
    ComputeHeptagon7T(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : IComputeSurfaceT<Dimension, CoordinatesVariable>(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords);
  };
  template<Integer Dimension, typename CoordinatesVariable>
  struct ComputeOctogon8T : public IComputeSurfaceT<Dimension, CoordinatesVariable> {
    ComputeOctogon8T(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : IComputeSurfaceT<Dimension, CoordinatesVariable>(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real3 & orientation, Real3 & center, Real3 & mass_center, Array<Real> & coords);
  };
#endif

  /*----------------------------------------------------------------------------*/

  // 3d elements

  template<Integer Dimension, typename CoordinatesVariable>
  struct IComputeVolumeT {
    IComputeVolumeT(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : m_geom(geom), m_coords(geom->m_coords) { }
    virtual ~IComputeVolumeT() { }
    virtual void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real & measure, Real3 & center, Array<Real> & coords) = 0;
    virtual void computeVolumeArea(const ItemWithNodes & item, Real & area) = 0;
    EuclidianGeometryT<Dimension, CoordinatesVariable> * m_geom;
    const CoordinatesVariable & m_coords;
  };

  template<Integer Dimension, typename CoordinatesVariable>
  struct ComputeTetraedron4T : public IComputeVolumeT<Dimension, CoordinatesVariable> { 
    ComputeTetraedron4T(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : IComputeVolumeT<Dimension, CoordinatesVariable>(geom) { }    
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real & measure, Real3 & center, Array<Real> & coords);
    void computeVolumeArea(const ItemWithNodes & item, Real & area);
  };

  template<Integer Dimension, typename CoordinatesVariable>
  struct ComputeHeptaedron10T : public IComputeVolumeT<Dimension, CoordinatesVariable> { 
    ComputeHeptaedron10T(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : IComputeVolumeT<Dimension, CoordinatesVariable>(geom) { }    
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real & measure, Real3 & center, Array<Real> & coords) {
      throw FatalErrorException(A_FUNCINFO,"Not implemented");
    }
    void computeVolumeArea(const ItemWithNodes & item, Real & area) {
      throw FatalErrorException(A_FUNCINFO,"Not implemented");
    }
  };

  template<Integer Dimension, typename CoordinatesVariable>
  struct ComputeOctaedron12T : public IComputeVolumeT<Dimension, CoordinatesVariable> { 
    ComputeOctaedron12T(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : IComputeVolumeT<Dimension, CoordinatesVariable>(geom) { }    
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real & measure, Real3 & center, Array<Real> & coords) {
      throw FatalErrorException(A_FUNCINFO,"Not implemented");
    }
    void computeVolumeArea(const ItemWithNodes & item, Real & area) {
      throw FatalErrorException(A_FUNCINFO,"Not implemented");
    }
  };
#if ARCANE_VERSION > 12201 || (ARCANE_VERSION==12201 && ARCANE_VERSION_BETA > 0)
  template<Integer Dimension, typename CoordinatesVariable>
  struct ComputeEnneedron14T : public IComputeVolumeT<Dimension, CoordinatesVariable> {
    ComputeEnneedron14T(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : IComputeVolumeT<Dimension, CoordinatesVariable>(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real & measure, Real3 & center, Array<Real> & coords) {
      throw FatalErrorException(A_FUNCINFO,"Not implemented");
    }
    void computeVolumeArea(const ItemWithNodes & item, Real & area) {
      throw FatalErrorException(A_FUNCINFO,"Not implemented");
    }
  };
  template<Integer Dimension, typename CoordinatesVariable>
  struct ComputeDecaedron16T : public IComputeVolumeT<Dimension, CoordinatesVariable> {
    ComputeDecaedron16T(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : IComputeVolumeT<Dimension, CoordinatesVariable>(geom) { }
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real & measure, Real3 & center, Array<Real> & coords) {
      throw FatalErrorException(A_FUNCINFO,"Not implemented");
    }
    void computeVolumeArea(const ItemWithNodes & item, Real & area) {
      throw FatalErrorException(A_FUNCINFO,"Not implemented");
    }
  };
#endif


  template<Integer Dimension, typename CoordinatesVariable>
  struct ComputeGenericVolumeT : public IComputeVolumeT<Dimension, CoordinatesVariable> { 
    ComputeGenericVolumeT(EuclidianGeometryT<Dimension, CoordinatesVariable> * geom) : IComputeVolumeT<Dimension, CoordinatesVariable>(geom) { }    
    void computeOrientedMeasureAndCenter(const ItemWithNodes & item, Real & measure, Real3 & center, Array<Real> & coords);
    void computeVolumeArea(const ItemWithNodes & item, Real & area);
  };

  /*----------------------------------------------------------------------------*/
  /*----------------------------------------------------------------------------*/

  template<Integer Dimension, typename CoordinatesVariable>
  class EuclidianGeometryT : public IGeometry
  {
  public:
    //@{ @name specific computations on basic types (interface depends to the dimension)
    typedef ComputeLine2T<Dimension, CoordinatesVariable> ComputeLine2;
    typedef ComputeTriangle3T<Dimension, CoordinatesVariable> ComputeTriangle3;
    typedef ComputeQuad4T<Dimension, CoordinatesVariable> ComputeQuad4;
    typedef ComputePentagon5T<Dimension, CoordinatesVariable> ComputePentagon5;
    typedef ComputeHexagon6T<Dimension, CoordinatesVariable> ComputeHexagon6;
    typedef ComputeTetraedron4T<Dimension, CoordinatesVariable> ComputeTetraedron4;
    typedef ComputeGenericVolumeT<Dimension, CoordinatesVariable> ComputeHeptaedron10;
    typedef ComputeGenericVolumeT<Dimension, CoordinatesVariable> ComputeOctaedron12;
    typedef ComputeGenericVolumeT<Dimension, CoordinatesVariable> ComputePyramid5;
    typedef ComputeGenericVolumeT<Dimension, CoordinatesVariable> ComputePentaedron6;
    typedef ComputeGenericVolumeT<Dimension, CoordinatesVariable> ComputeHexaedron8;
    typedef ComputeGenericVolumeT<Dimension, CoordinatesVariable> ComputeHemiHexa7;
    typedef ComputeGenericVolumeT<Dimension, CoordinatesVariable> ComputeHemiHexa6;
    typedef ComputeGenericVolumeT<Dimension, CoordinatesVariable> ComputeHemiHexa5;
    typedef ComputeGenericVolumeT<Dimension, CoordinatesVariable> ComputeAntiWedgeLeft6;
    typedef ComputeGenericVolumeT<Dimension, CoordinatesVariable> ComputeAntiWedgeRight6;
    typedef ComputeGenericVolumeT<Dimension, CoordinatesVariable> ComputeDiTetra5;
#if ARCANE_VERSION > 12201 || (ARCANE_VERSION==12201 && ARCANE_VERSION_BETA > 0)
    typedef ComputeGenericVolumeT<Dimension, CoordinatesVariable> ComputeEnneedron14;
    typedef ComputeGenericVolumeT<Dimension, CoordinatesVariable> ComputeDecaedron16;
    typedef ComputeHeptagon7T<Dimension, CoordinatesVariable> ComputeHeptagon7;
    typedef ComputeOctogon8T<Dimension, CoordinatesVariable> ComputeOctogon8;
#endif
    //@}

  public:
    EuclidianGeometryT(const CoordinatesVariable & coords,
        ITraceMng * traceMng = NULL,
        bool fatal_on_error = false,
        Integer normal_2d_id = 0 );

    virtual ~EuclidianGeometryT() { }

    //@{ @name Inherited methods from IGeometry

    //! Calcul du centre de masse
    Real3 computeCenter(const ItemWithNodes & item);

    Real3 computeCenter(const ItemWithNodes & item, Array<Real> & coords);


    //! Calcul de la mesure orient�e
    /*! Dans le cas d'un �l�ment plan, ceci correspond �
     *  la normale moyenne unitaire * mesure de l'�l�ment
     *  et dans le cas d'un simple �l�ment volumique nous obtenons
     *  volume * z (ou z=(0,0,1))
     */

    Real3 computeOrientedMeasure(const ItemWithNodes & item);

    //! Calcul de la mesure (sans orientation)
    Real  computeMeasure(const ItemWithNodes & item);

    //! Calcul de la longueur
    /*! Uniquement pour les Items lin��ques */
    Real  computeLength(const ItemWithNodes & item);

    //! Calcul de l'aire 
    /*! Uniquement pour les Items surfaciques */
    Real  computeArea(const ItemWithNodes & item);

    //! Calcul du volume
    /*! Uniquement pour les Items volumiques */
    Real  computeVolume(const ItemWithNodes & item);

    // REMOVED FROM IGEOMETRY : CHECK USAGE
    //   //! Calcul du centre
    //   Real3 computeSurfaceCenter(Integer n, const Real3 * coords);

    //! Calcul de l'aire orient�e (ie normale)
    Real3 computeOrientedArea(Integer n, const Real3 * coords)
    {
      Real3 normal(0.,0.,0.);
      for(Integer i=1;i<n-1;++i)
        normal += computeTriangleNormal(coords[0],coords[i],coords[i+1]);
      return normal;
    }

    //! Calcul de longueur d'un segment d�fini par deux points
    Real computeLength(const Real3& m, const Real3& n)
    {
      const Real3 d = m-n ;
      return math::sqrt(math::scaMul(d,d)) ;
    }


    //@}

    //@{ @name primitives used for volume decomposition
    static inline Real3 computeTriangleNormal(const Real3 & n0, const Real3 & n1, const Real3 & n2)
    {
      return Arcane::math::vecMul(n1-n0,n2-n0) / 2.0;
    }

    static inline Real computeTriangleSurface(const Real3 & n0, const Real3 & n1, const Real3 & n2)
    {
      return Arcane::math::normeR3(computeTriangleNormal(n0,n1,n2));
    }

    static inline Real3 computeTriangleCenter(const Real3 & n0, const Real3 & n1, const Real3 & n2)
    {
      return (n0+n1+n2) / 3.0;
    }

    static inline Real computeTetraedronVolume(const Real3 & n0, const Real3 & n1, const Real3 & n2, const Real3 & n3)
    {
      return Arcane::math::mixteMul(n1-n0,n2-n0,n3-n0) / 6.0;
    }

    static inline Real3 computeTetraedronCenter(const Real3 & n0, const Real3 & n1, const Real3 & n2, const Real3 & n3)
    {
      return 0.25 * (n0+n1+n2+n3);
    }

    static inline Real3 computeQuadrilateralCenter(const Real3 & n0, const Real3 & n1, const Real3 & n2, const Real3 & n3)
    {
      Real s0 = computeTriangleSurface(n0,n1,n2);
      Real s1 = computeTriangleSurface(n0,n2,n3);
      Real s2 = computeTriangleSurface(n1,n2,n3);
      Real s3 = computeTriangleSurface(n0,n1,n3);
      Real totalS = (s0+s1+s2+s3);

      if(totalS == 0)
        {
          s0=1; s1=1; s2=1; s3=1;
          totalS = (s0+s1+s2+s3);
        }


      return (s0 * computeTriangleCenter(n0,n1,n2) +
          s1 * computeTriangleCenter(n0,n2,n3) +
          s2 * computeTriangleCenter(n1,n2,n3) +
          s3 * computeTriangleCenter(n0,n1,n3)) / totalS;
    }

    static inline Real3 computeQuadrilateralCenter(const Real3 & n0, const Real3 & n1, const Real3 & n2, const Real3 & n3,
        Real & s0, Real & s1, Real & s2, Real & s3, Real & totalS)
    {
      s0 = computeTriangleSurface(n0,n1,n2);
      s1 = computeTriangleSurface(n0,n2,n3);
      s2 = computeTriangleSurface(n1,n2,n3);
      s3 = computeTriangleSurface(n0,n1,n3);
      totalS = (s0+s1+s2+s3);

      if(totalS == 0)
        {
          s0=1; s1=1; s2=1; s3=1;
          totalS = (s0+s1+s2+s3);
        }


      return (s0 * computeTriangleCenter(n0,n1,n2) +
          s1 * computeTriangleCenter(n0,n2,n3) +
          s2 * computeTriangleCenter(n1,n2,n3) +
          s3 * computeTriangleCenter(n0,n1,n3)) / totalS;
    }

    static inline Real3 computePentagonalCenter(const Real3 & n0, const Real3 & n1, const Real3 & n2, const Real3 & n3, const Real3 & n4)
    {
      Real s0 = computeTriangleSurface(n4,n0,n1);
      Real s1 = computeTriangleSurface(n0,n1,n2);
      Real s2 = computeTriangleSurface(n1,n2,n3);
      Real s3 = computeTriangleSurface(n2,n3,n4);
      Real s4 = computeTriangleSurface(n3,n4,n0);
      Real s5 = computeTriangleSurface(n0,n2,n3);
      Real s6 = computeTriangleSurface(n1,n3,n4);
      Real s7 = computeTriangleSurface(n2,n4,n0);
      Real s8 = computeTriangleSurface(n3,n0,n1);
      Real s9 = computeTriangleSurface(n4,n1,n2);
      Real totalS = (2*(s0+s1+s2+s3+s4) + s5 + s6 + s7 + s8 + s9);

      if (totalS == 0.)
        {
          s0=1; s1=1; s2=1;
          s3=1; s4=1; s5=1;
          s6=1; s7=1; s8=1; s9=1;
          totalS=(2*(s0+s1+s2+s3+s4) + s5 + s6 + s7 + s8 + s9);
        }

      return (2*(s0 * computeTriangleCenter(n4,n0,n1) +
          s1 * computeTriangleCenter(n0,n1,n2) +
          s2 * computeTriangleCenter(n1,n2,n3) +
          s3 * computeTriangleCenter(n2,n3,n4) +
          s4 * computeTriangleCenter(n3,n4,n0)) +
          s5 * computeTriangleCenter(n0,n2,n3) +
          s6 * computeTriangleCenter(n1,n3,n4) +
          s7 * computeTriangleCenter(n2,n4,n0) +
          s8 * computeTriangleCenter(n3,n0,n1) +
          s9 * computeTriangleCenter(n4,n1,n2)) / totalS;
    }

    static inline Real3 computeHexagonalCenter(const Real3 & n0, const Real3 & n1, const Real3 & n2, const Real3 & n3, const Real3 & n4, const Real3 & n5)
    {
      Real s0 = computeTriangleSurface(n0,n1,n5);
      Real s1 = computeTriangleSurface(n1,n2,n3);
      Real s2 = computeTriangleSurface(n3,n4,n5);
      Real s3 = computeTriangleSurface(n1,n3,n5);
      Real s4 = computeTriangleSurface(n0,n1,n2);
      Real s5 = computeTriangleSurface(n2,n3,n4);
      Real s6 = computeTriangleSurface(n4,n5,n0);
      Real s7 = computeTriangleSurface(n0,n2,n4);
      Real totalS = (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7);

      if (totalS == 0.)
        {
          s0=1; s1=1; s2=1;
          s3=1; s4=1; s5=1;
          s6=1; s7=1;
          totalS = (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7);
        }

      return (s0 * computeTriangleCenter(n0,n1,n5) +
          s1 * computeTriangleCenter(n1,n2,n3) +
          s2 * computeTriangleCenter(n3,n4,n5) +
          s3 * computeTriangleCenter(n1,n3,n5) +
          s4 * computeTriangleCenter(n0,n1,n2) +
          s5 * computeTriangleCenter(n2,n3,n4) +
          s6 * computeTriangleCenter(n4,n5,n0) +
          s7 * computeTriangleCenter(n0,n2,n4)) / totalS;
    }

    static inline Real3 computeHeptagonalCenter(const Real3 & n0, const Real3 & n1, const Real3 & n2, const Real3 & n3, const Real3 & n4, const Real3 & n5, const Real3 & n6)
    {
      Real s0 = computeTriangleSurface(n0,n1,n2);
      Real s1 = computeTriangleSurface(n1,n2,n3);
      Real s2 = computeTriangleSurface(n2,n3,n4);
      Real s3 = computeTriangleSurface(n3,n4,n5);
      Real s4 = computeTriangleSurface(n4,n5,n6);
      Real s5 = computeTriangleSurface(n5,n6,n0);
      Real s6 = computeTriangleSurface(n6,n0,n1);
      Real s7 = computeTriangleSurface(n0,n2,n4);
      Real s8 = computeTriangleSurface(n1,n3,n5);
      Real s9 = computeTriangleSurface(n2,n4,n6);
      Real s10 = computeTriangleSurface(n3,n5,n0);
      Real s11 = computeTriangleSurface(n4,n6,n1);
      Real s12 = computeTriangleSurface(n5,n0,n2);
      Real s13 = computeTriangleSurface(n6,n1,n3);
      Real totalS = (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8 + s9 + s10 + s11 + s12 + s13);

      if (totalS == 0.)
        {
          s0=1; s1=1; s2=1;
          s3=1; s4=1; s5=1;
          s6=1; s7=1; s8=1;
          s9=1; s10=1; s11=1;
          s12=1; s13=1;
          totalS = (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8 + s9 + s10 + s11 + s12 + s13);
        }

      return (
          s0 * computeTriangleCenter(n0,n1,n2) +
          s1 * computeTriangleCenter(n1,n2,n3) +
          s2 * computeTriangleCenter(n2,n3,n4) +
          s3 * computeTriangleCenter(n3,n4,n5) +
          s4 * computeTriangleCenter(n4,n5,n6) +
          s5 * computeTriangleCenter(n5,n6,n0) +
          s6 * computeTriangleCenter(n6,n0,n1) +
          s7 * computeTriangleCenter(n0,n2,n4) +
          s8 * computeTriangleCenter(n1,n3,n5) +
          s9 * computeTriangleCenter(n2,n4,n6) +
          s10 * computeTriangleCenter(n3,n5,n0) +
          s11 * computeTriangleCenter(n4,n6,n1) +
          s12 * computeTriangleCenter(n5,n0,n2) +
          s13 * computeTriangleCenter(n6,n1,n3)) / totalS;

    }

    static inline Real3 computeOctogonalCenter(const Real3 & n0, const Real3 & n1, const Real3 & n2, const Real3 & n3, const Real3 & n4, const Real3 & n5, const Real3 & n6, const Real3 & n7)
    {
      Real s0 = computeTriangleSurface(n0,n1,n2);
      Real s1 = computeTriangleSurface(n2,n3,n4);
      Real s2 = computeTriangleSurface(n4,n5,n6);
      Real s3 = computeTriangleSurface(n6,n7,n0);
      Real s4 = computeTriangleSurface(n0,n2,n4);
      Real s5 = computeTriangleSurface(n2,n4,n6);
      Real s6 = computeTriangleSurface(n4,n6,n0);
      Real s7 = computeTriangleSurface(n1,n3,n5);
      Real s8 = computeTriangleSurface(n3,n5,n7);
      Real s9 = computeTriangleSurface(n5,n7,n1);
      Real totalS = (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8 + s9);

      if (totalS == 0.)
        {
          s0=1; s1=1; s2=1;
          s3=1; s4=1; s5=1;
          s6=1; s7=1; s8=1;
          s9=1;
          totalS = (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8 + s9);
        }

      return (
          s0 * computeTriangleCenter(n0,n1,n2) +
          s1 * computeTriangleCenter(n2,n3,n4) +
          s2 * computeTriangleCenter(n4,n5,n6) +
          s3 * computeTriangleCenter(n6,n7,n0) +
          s4 * computeTriangleCenter(n0,n2,n4) +
          s5 * computeTriangleCenter(n2,n4,n6) +
          s6 * computeTriangleCenter(n4,n6,n0) +
          s7 * computeTriangleCenter(n1,n3,n5) +
          s8 * computeTriangleCenter(n3,n5,n7) +
          s9 * computeTriangleCenter(n5,n7,n1)) / totalS;
    }

  public:
    const CoordinatesVariable & m_coords;
    ITraceMng * m_trace_mng;
    bool m_fatal_on_error;
    Integer m_2d_normal_id ;
  };

  // Implementation and typedefs
#include "ArcGeoSim/Mesh/Geometry/Euclidian/EuclidianGeometryT.h"

  typedef EuclidianGeometryT<2, VariableNodeReal3> EuclidianGeometry2;
  typedef EuclidianGeometryT<3, VariableNodeReal3> EuclidianGeometry3;

  typedef EuclidianGeometryT<2, SharedMeshVariableScalarRefT<Node,Real3> > SharedEuclidianGeometry2;
  typedef EuclidianGeometryT<3, SharedMeshVariableScalarRefT<Node,Real3> > SharedEuclidianGeometry3;
}

#endif /* ARCGEOSIM_MESH_GEOMETRY_EUCLIDIANGEOMETRY_EUCLIDIANGEOMETRY_H */
