// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "ArcGeoSim/Mesh/Geometry/Impl/GeometryServiceBase.h"
/* Author : havep at Thu Apr  3 09:09:09 2008
 * Generated by createNew
 */

#include <arcane/IMesh.h>
using namespace Arcane;

#include <arcane/IItemOperationByBasicType.h>
#include <arcane/IItemFamily.h>
#include <arcane/ArcaneVersion.h>
#include <arcane/ItemVectorView.h>
#include <arcane/IParallelMng.h>
#include <arcane/VariableBuildInfo.h>
#include <arcane/SharedVariable.h>

Integer GeometryServiceBase::s_suffix_count = 0;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

GeometryServiceBase::
GeometryServiceBase()
{
  m_changed_property = true; // par d�faut pour induire directement une erreur si update non appel�
  m_policy_tolerance = eUndef;
  m_policy = NULL ;
  m_first_update = true;
}

GeometryServiceBase::
~GeometryServiceBase()
{
  ;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
GeometryServiceBase::
addItemGroupProperty(ItemGroup group, Integer property, Integer storage)
{
  Trace::Setter setter(traceMng(),className());

  if (group.null())
    traceMng()->fatal() << "Cannot add geometry property on an empty group";

  m_changed_property = true;
  ItemGroupGeometryProperty & properties = m_group_property_map[group.internal()];
  properties.defined |= property;
  Integer current_property = 1;
  while (property) {
    if (property & current_property) {
      properties.storages[static_cast<IGeometryProperty::eProperty>(current_property)].storageType |= storage;
      traceMng()->debug() << "Add geometric property [" << IGeometryProperty::name(static_cast<IGeometryProperty::eProperty>(current_property)) << "] on group " << group.name() << " / " << group.mesh()->name();
    }
    property &= ~current_property;
    current_property <<= 1;
  }
}

void 
GeometryServiceBase::
addItemGroupProperty(ItemGroup group, IGeometryProperty::eProperty property, RealVariable var)
{
  Trace::Setter setter(traceMng(),className());

  if (group.null())
    traceMng()->fatal() << "Cannot add geometry property on an empty group";

  m_changed_property = true;
  ARCANE_ASSERT((IGeometryProperty::isScalar(property)),("Scalar property expected"));
  ItemGroupGeometryProperty & properties = m_group_property_map[group.internal()];
  ItemGroupGeometryProperty::StorageInfo & storage = properties.storages[property];
  if (storage.realVar) {
    if (storage.realVar->name() != var.name())
      traceMng()->fatal() << "Geometric property [" << IGeometryProperty::name(property) << "] storage already defined on group " << group.name() << " / " << group.mesh()->name() << " with variable " << storage.realVar->name();
    ARCANE_ASSERT((properties.defined & property),("Unconsistent state with undefined property with defined variable"));
    return;
  }
  traceMng()->debug() << "Add geometric property [" << IGeometryProperty::name(property) << "] on group " << group.name() << " / " << group.mesh()->name();
  properties.defined |= property;
  storage.realVar.reset(new RealVariable(var));
  storage.storageType |= IGeometryProperty::PVariable;
  storage.externStorage |= IGeometryProperty::PVariable;  
}

void 
GeometryServiceBase::
addItemGroupProperty(ItemGroup group, IGeometryProperty::eProperty property, Real3Variable var)
{
  Trace::Setter setter(traceMng(),className());

  if (group.null())
    traceMng()->fatal() << "Cannot add geometry property on an empty group";

  m_changed_property = true;
  ARCANE_ASSERT((IGeometryProperty::isVectorial(property)),("Vectorial property expected"));
  ItemGroupGeometryProperty & properties = m_group_property_map[group.internal()];
  ItemGroupGeometryProperty::StorageInfo & storage = properties.storages[property];
  if (storage.real3Var) {
    if (storage.real3Var->name() != var.name())
      traceMng()->fatal() << "Geometric property [" << IGeometryProperty::name(property) << "] storage already defined on group " << group.name() << " / " << group.mesh()->name() << " with variable " << storage.real3Var->name();
    ARCANE_ASSERT((properties.defined & property),("Unconsistent state with undefined property with defined variable"));
    return;
  }
  traceMng()->debug() << "Add geometric property [" << IGeometryProperty::name(property) << "] on group " << group.name() << " / " << group.mesh()->name();
  properties.defined |= property;
  storage.real3Var.reset(new Real3Variable(var));
  storage.storageType |= IGeometryProperty::PVariable;
  storage.externStorage |= IGeometryProperty::PVariable;  
}

Integer 
GeometryServiceBase::
getItemGroupProperty(ItemGroup group)
{
  PropertyMap::const_iterator iprop = m_group_property_map.find(group.internal());
  if (iprop == m_group_property_map.end()) return IGeometryProperty::PNone;
  return iprop->second.defined;
}

bool 
GeometryServiceBase::
hasItemGroupProperty(ItemGroup group, Integer property)
{
  return (getItemGroupProperty(group) & property) == property;
}

Integer
GeometryServiceBase::
getItemGroupPropertyStorage(ItemGroup group, IGeometryProperty::eProperty property)
{
  PropertyMap::const_iterator iprop = m_group_property_map.find(group.internal());
  if (iprop == m_group_property_map.end()) return IGeometryProperty::PNoStorage;
  return iprop->second.getStorage(property);
}

/*---------------------------------------------------------------------------*/

const IGeometryMng::RealVariable & 
GeometryServiceBase::
getRealVariableProperty(ItemGroup group, IGeometryProperty::eProperty property)
{
  Trace::Setter setter(traceMng(),className());
  if (m_policy_tolerance == eUndef)
    traceMng()->fatal() << "IGeometryMng::update called without defined policy tolerance";
  if (m_changed_property) {
    if (m_policy_tolerance == eLazy)
      traceMng()->error() << "Property requested without validation with update() : this error will become fatal soon";
    else
      traceMng()->fatal() << "Property requested without validation with update()";
  }

  if (not IGeometryProperty::isScalar(property))
    traceMng()->fatal() << "Non scalar property requested by scalar interface";
  ItemGroupGeometryProperty::StorageInfo & storage = _checkItemGroupProperty(group.internal(),property,IGeometryProperty::PVariable);  
  std::shared_ptr<RealVariable> & pvar = storage.realVar;
  if (not pvar)
    throw FatalErrorException(A_FUNCINFO,"Unexpected missing scalar field");
  storage.usageVarCount++;
  return *pvar;
}

const IGeometryMng::Real3Variable & 
GeometryServiceBase::
getReal3VariableProperty(ItemGroup group, IGeometryProperty::eProperty property)
{
  Trace::Setter setter(traceMng(),className());
  if (m_policy_tolerance == eUndef)
    traceMng()->fatal() << "IGeometryMng::update called without defined policy tolerance";
  if (m_changed_property) {
    if (m_policy_tolerance == eLazy)
      traceMng()->error() << "Property requested without validation with update() : this error will become fatal soon";
    else
      traceMng()->fatal() << "Property requested without validation with update()";
  }

  if (not IGeometryProperty::isVectorial(property)) 
    traceMng()->fatal() << "Non vectorial property requested by vectorial interface";  
  ItemGroupGeometryProperty::StorageInfo & storage = _checkItemGroupProperty(group.internal(),property,IGeometryProperty::PVariable);
  std::shared_ptr<Real3Variable> & pvar = storage.real3Var;
  if (not pvar)
    throw FatalErrorException(A_FUNCINFO,"Unexpected missing vectorial field");
  storage.usageVarCount++;
  return *pvar;
}

/*---------------------------------------------------------------------------*/

const IGeometryMng::RealGroupMap & 
GeometryServiceBase::
getRealGroupMapProperty(ItemGroup group, IGeometryProperty::eProperty property)
{
  Trace::Setter setter(traceMng(),className());
  if (m_policy_tolerance == eUndef)
    traceMng()->fatal() << "IGeometryMng::update called without defined policy tolerance";
  if (m_changed_property) {
    if (m_policy_tolerance == eLazy) {
      traceMng()->error() << "Property requested without validation with update() : this error will become fatal soon";
    } else {
      traceMng()->fatal() << "Property requested without validation with update()";
    }
  }

  if (not IGeometryProperty::isScalar(property)) 
    traceMng()->fatal() << "Non scalar property requested by scalar interface";  
  ItemGroupGeometryProperty::StorageInfo & storage = _checkItemGroupProperty(group.internal(),property,IGeometryProperty::PItemGroupMap);
  std::shared_ptr<RealGroupMap> & pmap = storage.realMap;
  if (not pmap)
    throw FatalErrorException(A_FUNCINFO,"Unexpected missing scalar field");
  storage.usageMapCount++;
  return *pmap;
}

/*---------------------------------------------------------------------------*/

const IGeometryMng::Real3GroupMap & 
GeometryServiceBase::
getReal3GroupMapProperty(ItemGroup group, IGeometryProperty::eProperty property)
{
  Trace::Setter setter(traceMng(),className());
  if (m_policy_tolerance == eUndef)
    traceMng()->fatal() << "IGeometryMng::update called without defined policy tolerance";
  if (m_changed_property) {
    if (m_policy_tolerance == eLazy)
      traceMng()->error() << "Property requested without validation with update() : this error will become fatal soon";
    else
      traceMng()->fatal() << "Property requested without validation with update()";
  }

  if (not IGeometryProperty::isVectorial(property)) 
    traceMng()->fatal() << "Non vectorial property requested by vectorial interface";  
  ItemGroupGeometryProperty::StorageInfo & storage = _checkItemGroupProperty(group.internal(),property,IGeometryProperty::PItemGroupMap);
  std::shared_ptr<Real3GroupMap> & pmap = storage.real3Map;
  if (not pmap)
    throw FatalErrorException(A_FUNCINFO,"Unexpected missing vectorial field");
  storage.usageMapCount++;
  return *pmap;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
GeometryServiceBase::
update(IGeometryPolicy * policy)
{
  Trace::Setter setter(traceMng(),className());
  if (m_policy_tolerance == eUndef)
    traceMng()->fatal() << "IGeometryMng::update called without defined policy tolerance";
  if (policy == NULL)
    traceMng()->fatal() << "IGeometryMng::update called with illegal policy";

  beginContext(policy);

  typedef Collection<IMesh *> MeshCollection;
  MeshCollection all_meshes = List<IMesh*>();

  // Ajout d'abord des top level meshes (ie sans parent)
  for(PropertyMap::iterator igroup = m_group_property_map.begin(); igroup != m_group_property_map.end(); ++igroup)
    {
      ItemGroupImpl * group = igroup->first;
      IMesh * mesh = group->mesh();
      if (mesh->parentMesh() == NULL) // top level mesh
        if (not all_meshes.contains(mesh))
          all_meshes.add(mesh);
    }
  
  for(PropertyMap::iterator igroup = m_group_property_map.begin(); igroup != m_group_property_map.end(); ++igroup)
    {
      ItemGroupImpl * group = igroup->first;
      IMesh * mesh = group->mesh();
      if (not all_meshes.contains(mesh))
        all_meshes.add(mesh);
    }

  for(MeshCollection::Enumerator imesh = all_meshes.enumerator(); ++imesh; ) 
    {
      _fullUpdate(*imesh);
    }

  m_changed_property = false;
  endContext();

  m_first_update = false;
}

/*---------------------------------------------------------------------------*/

void 
GeometryServiceBase::
update(IMesh * mesh, IGeometryPolicy * policy)
{
 Trace::Setter setter(traceMng(),className());
  if (m_policy_tolerance == eUndef)
    traceMng()->fatal() << "IGeometryMng::update called without defined policy tolerance";
  if (policy == NULL) {
    if (m_policy_tolerance == eLazy)
      traceMng()->debug() << "IGeometryMng::update called with null policy : disables optimizations";
    else
      traceMng()->fatal() << "IGeometryMng::update called with illegal policy";
  }

  beginContext(policy);

  _partialUpdate(mesh);

  m_changed_property = false;
  endContext();

  m_first_update = false;
}

/*---------------------------------------------------------------------------*/

void 
GeometryServiceBase::
setSuffix(const String & suffix) 
{ 
  if (suffix.null()) 
    {
      m_suffix = String("By")+(unsigned long)(s_suffix_count++);
      mesh()->parallelMng()->broadcastString(m_suffix, 0);
    }
  else
    {
      m_suffix = suffix; 
    }
}

/*---------------------------------------------------------------------------*/

void 
GeometryServiceBase::
_fullUpdate(IMesh * mesh)
{
  /* L'algo actuel factorise les calculs avec allItems et entre sous-maillage et parent
   * Si allItems est requis alors les sous-groupes sont d�l�gu�s (ie r�utilisent les calculs de allItems)
   * Le traitement est aussi fait dans l'ordre Face puis Cell pour factoriser les calculs 
   * (ex: centre des faces pour �toilement des volumes)
   */

  traceMng()->debug() << "Full update on " << mesh->name();

  const eItemKind all_kinds[] = { IK_Face, IK_Cell };
  const Integer all_kind_size = sizeof(all_kinds) / sizeof(eItemKind);

  // Traite par maillage la mise � jour des groupes
  for(Integer ikind=0;ikind<all_kind_size;++ikind) {
    const eItemKind current_kind = all_kinds[ikind];
    IItemFamily * family = mesh->itemFamily(current_kind);
    ItemGroup allItemGroup = family->allItems();

    PropertyMap::iterator finder = m_group_property_map.find(allItemGroup.internal());
    if (finder != m_group_property_map.end())
      {
        // Delegate all geometric properties already planned for allItems
        ItemGroupGeometryProperty & all_group_property = finder->second;
        update(allItemGroup);
        
        for(PropertyMap::iterator igroup = m_group_property_map.begin(); igroup != m_group_property_map.end(); ++igroup)
          {
            ItemGroup group(igroup->first);
            // Ne traite que les groupes du maillage courant de bon genre (sinon le h�ritage du calcul n'est pas possible)
            // on traduit cela sur les familles
            const bool isSameFamily = (family == group.itemFamily());
            const bool isSubFamily = (family == group.itemFamily()->parentFamily());
            const bool isSameKind = (family->itemKind() == group.itemKind());
            if (isSameFamily || isSubFamily)
              {
                ItemGroupGeometryProperty & group_property = igroup->second;
                for(ItemGroupGeometryProperty::StorageInfos::iterator iprop = group_property.storages.begin();
                    iprop != group_property.storages.end(); ++iprop)
                  {
                    const IGeometryProperty::eProperty property = iprop->first;
                    ItemGroupGeometryProperty::StorageInfo & storage = iprop->second;
                    
                    // propri�t� commune avec allItemGroup qui passe la dimension
                    if (property & all_group_property.defined && (isSameKind || IGeometryProperty::isKindIndependent(property)))
                      {
                        if (checkNeedUpdate(group,property,storage))
                          {
                            // Is a scalar property
                            if (IGeometryProperty::isScalar(property)) 
                              {
                                copyAllItemsPropertyStorage<Real>(property,allItemGroup,all_group_property.storages[property], group, storage);
                              }
                            else
                              {
                                ARCANE_ASSERT((IGeometryProperty::isVectorial(property)),("Vectorial property expected"));
                                copyAllItemsPropertyStorage<Real3>(property,allItemGroup,all_group_property.storages[property], group, storage);
                              }
                            setNewContext(storage);
                          }
                        else
                          {
                            if (group.isAllItems())
                              traceMng()->debug(Trace::High) << "Property " << IGeometryProperty::name(property) << " on " << group.name() << " / " << group.mesh()->name() << " is up-to-date";
                            else
                              traceMng()->debug() << "Property " << IGeometryProperty::name(property) << " on " << group.name() << " / " << group.mesh()->name() << " is up-to-date";
                          }
                      }
                  }
              }
          }
      }
  }

  // Mise � jour des autres propri�t�s (on repasse sur celles d�j� calcul�es mais on n'y fait rien)
  for(PropertyMap::iterator iprop = m_group_property_map.begin(); iprop != m_group_property_map.end(); ++iprop) 
    {
      if (iprop->first->mesh() == mesh)
        update(iprop->first);
    }
}

/*---------------------------------------------------------------------------*/

void 
GeometryServiceBase::
_partialUpdate(IMesh * mesh)
{
  /* L'algo actuel factorise les calculs avec allItems et le maillage est son parent �ventuel
   * Si allItems est requis alors les sous-groupes sont d�l�gu�s (ie r�utilisent les calculs de allItems)
   * Le traitement est aussi fait dans l'ordre Face puis Cell pour factoriser les calculs 
   * (ex: centre des faces pour �toilement des volumes)
   */

  traceMng()->debug() << "Partial update on " << mesh->name();

  const eItemKind all_kinds[] = { IK_Face, IK_Cell };
  const Integer all_kind_size = sizeof(all_kinds) / sizeof(eItemKind);

  // Traite par maillage la mise � jour des groupes
  for(Integer ikind=0;ikind<all_kind_size;++ikind) {
    const eItemKind current_kind = all_kinds[ikind];
    IItemFamily * family = mesh->itemFamily(current_kind);
    IItemFamily * parent_family = family->parentFamily();

    // 1- On privil�gie les calculs par h�ritage
    if (parent_family)
      {
        ItemGroup parentAllItemGroup = parent_family->allItems();
        PropertyMap::iterator finder = m_group_property_map.find(parentAllItemGroup.internal());
        if (finder != m_group_property_map.end())
          {
            // Delegate all geometric properties already done for parent allItems
            ItemGroupGeometryProperty & all_group_property = finder->second;
    
            for(PropertyMap::iterator igroup = m_group_property_map.begin(); igroup != m_group_property_map.end(); ++igroup)
              {
                ItemGroup group(igroup->first);
                // Ne traite que les groupes du maillage courant de bon genre
                // on traduit cela sur les familles
                const bool isSameFamily = (family == group.itemFamily());
                const bool isSameKind = (parent_family->itemKind() == group.itemKind());
                if (isSameFamily)
                  {
                    ItemGroupGeometryProperty & group_property = igroup->second;
                    for(ItemGroupGeometryProperty::StorageInfos::iterator iprop = group_property.storages.begin();
                        iprop != group_property.storages.end(); ++iprop)
                      {
                        const IGeometryProperty::eProperty property = iprop->first;
                        ItemGroupGeometryProperty::StorageInfo & storage = iprop->second;
                    
                        // propri�t� commune avec allItemGroup qui passe la dimension
                        if (property & all_group_property.defined && (isSameKind || IGeometryProperty::isKindIndependent(property)))
                          {
                            // Si besoin de mise � jour et que parent � jour
                            if (checkNeedUpdate(group,property,storage) && !checkNeedUpdate(parentAllItemGroup,property,all_group_property.storages[property]))
                              {
                                // Is a scalar property
                                if (IGeometryProperty::isScalar(property)) 
                                  {
                                    copyAllItemsPropertyStorage<Real>(property,parentAllItemGroup,all_group_property.storages[property], group, storage);
                                  }
                                else
                                  {
                                    ARCANE_ASSERT((IGeometryProperty::isVectorial(property)),("Vectorial property expected"));
                                    copyAllItemsPropertyStorage<Real3>(property,parentAllItemGroup,all_group_property.storages[property], group, storage);
                                  }
                                setNewContext(storage);
                              }
                            else
                              {
                                if (group.isAllItems())
                                  traceMng()->debug(Trace::High) << "Property " << IGeometryProperty::name(property) << " on " << group.name() << " / " << group.mesh()->name() << " is up-to-date";
                                else
                                  traceMng()->debug() << "Property " << IGeometryProperty::name(property) << " on " << group.name() << " / " << group.mesh()->name() << " is up-to-date";
                              }
                          }
                      }
                  }
              }
          }
      }

    // 2- Le compl�ment via le groupe allItems
    ItemGroup allItemGroup = family->allItems();
    PropertyMap::iterator finder = m_group_property_map.find(allItemGroup.internal());
    if (finder != m_group_property_map.end())
      {
        // Delegate all geometric properties already planned for allItems
        ItemGroupGeometryProperty & all_group_property = finder->second;
        update(allItemGroup);
    
        for(PropertyMap::iterator igroup = m_group_property_map.begin(); igroup != m_group_property_map.end(); ++igroup)
          {
            ItemGroup group(igroup->first);
            // Ne traite que les groupes du maillage courant de bon genre (sinon le h�ritage du calcul n'est pas possible)
            // on traduit cela sur les familles
            const bool isSameFamily = (family == group.itemFamily());
            if (isSameFamily)
              {
                ItemGroupGeometryProperty & group_property = igroup->second;
                for(ItemGroupGeometryProperty::StorageInfos::iterator iprop = group_property.storages.begin();
                    iprop != group_property.storages.end(); ++iprop)
                  {
                    const IGeometryProperty::eProperty property = iprop->first;
                    ItemGroupGeometryProperty::StorageInfo & storage = iprop->second;
                    
                    // propri�t� commune avec allItemGroup qui passe la dimension
                    if (property & all_group_property.defined)
                      {
                        if (checkNeedUpdate(group,property,storage))
                          {
                            // Is a scalar property
                            if (IGeometryProperty::isScalar(property)) 
                              {
                                copyAllItemsPropertyStorage<Real>(property,allItemGroup,all_group_property.storages[property], group, storage);
                              }
                            else
                              {
                                ARCANE_ASSERT((IGeometryProperty::isVectorial(property)),("Vectorial property expected"));
                                copyAllItemsPropertyStorage<Real3>(property,allItemGroup,all_group_property.storages[property], group, storage);
                              }
                            setNewContext(storage);
                          }
                        else
                          {
                            if (group.isAllItems())
                              traceMng()->debug(Trace::High) << "Property " << IGeometryProperty::name(property) << " on " << group.name() << " / " << group.mesh()->name() << " is up-to-date";
                            else
                              traceMng()->debug() << "Property " << IGeometryProperty::name(property) << " on " << group.name() << " / " << group.mesh()->name() << " is up-to-date";
                          }
                      }
                  }
              }
          }
      }
  }

  // 3- Mise � jour des autres propri�t�s (on repasse sur celles d�j� calcul�es mais on n'y fait rien)
  for(PropertyMap::iterator iprop = m_group_property_map.begin(); iprop != m_group_property_map.end(); ++iprop) 
    {
      if (iprop->first->mesh() == mesh)
        update(iprop->first);
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
GeometryServiceBase::
reset()
{
  for(PropertyMap::iterator iprop = m_group_property_map.begin(); iprop != m_group_property_map.end(); ++iprop) 
    {
      reset(iprop->first);
    }
}
 
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
GeometryServiceBase::
setPolicyTolerance(bool tolerance)
{
  if (tolerance)
    m_policy_tolerance = eLazy;
  else
    m_policy_tolerance = eStrict;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ItemGroupGeometryProperty::StorageInfo & 
GeometryServiceBase::_checkItemGroupProperty(ItemGroupImpl* group,
                                             IGeometryProperty::eProperty property,
                                             IGeometryProperty::eStorage storage) 
{
  PropertyMap::iterator iprop = m_group_property_map.find(group);
  if (iprop == m_group_property_map.end())
    traceMng()->fatal() << "Non declare group " << group->name() << " / " << group->mesh()->name();
  ItemGroupGeometryProperty & properties = iprop->second;
  if ((properties.defined & property) != property)
    traceMng()->fatal() << "Non available property [" << IGeometryProperty::name(property) << "] requested from group " << group->name() << " / " << group->mesh()->name();
  ItemGroupGeometryProperty::StorageInfo & storages = properties.storages[property];
  if ((storages.storageType & storage) != storage)
    traceMng()->fatal() << "Non available storage [" << IGeometryProperty::name(storage) << "] requested for property " << IGeometryProperty::name(property) << " on group " << group->name() << " / " << group->mesh()->name();
  return storages;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
GeometryServiceBase::
beginContext(IGeometryPolicy * policy)
{
  ARCANE_ASSERT((m_policy == NULL),("Geometry Context already begun"));
  m_policy = policy;
  m_policy->beginContext();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
GeometryServiceBase::
endContext()
{
  ARCANE_ASSERT((m_policy != NULL),("Geometry Context not yet begun"));
  m_policy->endContext();
  m_policy = NULL;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
GeometryServiceBase::
_checkItemGroupPropertyUsage(ItemGroup group, IGeometryProperty::eProperty property, IGeometryProperty::eStorage storage,
                             UInt32 count, Integer externStorage, Integer storageType)
{
  if ((externStorage & storage) == 0 && (storageType & storage) != 0) 
    {
      if (count == 0 && not m_first_update)
        traceMng()->debug() << "Geometric property " << IGeometryProperty::name(property) << " on group " << group.name() << " / " << group.mesh()->name() << " with " << IGeometryProperty::name(storage) << " storage never used since last update";
      traceMng()->debug(Trace::High) << "Geometric property " << IGeometryProperty::name(property) << " on group " << group.name() << " / " << group.mesh()->name() << " with " << IGeometryProperty::name(storage) << " storage has been used " << count << " times since last update";
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

bool 
GeometryServiceBase::
checkNeedUpdate(ItemGroup group, IGeometryProperty::eProperty property, const ItemGroupGeometryProperty::StorageInfo & storage_info)
{
  Int64 context = m_policy->context();
  if (context != -1) // -1 means undef
    return (storage_info.context != context);
  else
    return true;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
GeometryServiceBase::
setNewContext(ItemGroupGeometryProperty::StorageInfo & storage_info)
{
  storage_info.context = m_policy->context();
  storage_info.usageVarCount = 0;
  storage_info.usageMapCount = 0;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<typename T>
void
GeometryServiceBase::
copyAllItemsPropertyStorage(IGeometryProperty::eProperty property, ItemGroup allItemGroup, ItemGroupGeometryProperty::StorageInfo & src, ItemGroup group, ItemGroupGeometryProperty::StorageInfo & dest)
{
  typedef typename ContainerAccessorT<T>::RealTVariable RealTVariable; // ItemVariableScalarRefT<T>
  typedef typename ContainerAccessorT<T>::RealTGroupMap RealTGroupMap;

//#ifdef __GNUG__
//#warning "BUG: fails when ItemGroupMap storage only on allItems group"
//#endif

  // Suppose que la propri�t� associ� dans allItems existe en tant que variable
  RealTVariable & var = *ContainerAccessorT<T>::getVarContainer(src);
                        
  // Need Variable storage for that property ?
  if (dest.storageType & IGeometryProperty::PVariable)
    {
      if (dest.externStorage & IGeometryProperty::PVariable)
        {
          RealTVariable & lvar = *ContainerAccessorT<T>::getVarContainer(dest);
          ENUMERATE_ITEM(iitem,group)
            {
              lvar[iitem] = var[iitem];
            }
        }
      else
        {
          std::shared_ptr<RealTVariable> & lvar = ContainerAccessorT<T>::getVarContainer(dest);
          if (lvar)
            { // Comparaison des IVariables
              if (lvar->variable() != var.variable())
                {
                  if (lvar->variable()->itemFamily() == var.variable()->itemFamily())
                    {
                      // change reference to allItems container (dont need copy)
                      traceMng()->debug() << "Property " << IGeometryProperty::name(property) << " on " << group.name() << " / " << group.mesh()->name() << " delegated from " << allItemGroup.name() << " / " << allItemGroup.mesh()->name();
                      lvar.reset(new RealTVariable(var));
                    }
                  else
                    {
                      // this is an other mesh variable (need transposed copy)
                      traceMng()->debug() << "Property " << IGeometryProperty::name(property) << " on " << group.name() << " / " << group.mesh()->name() << " delegated from parent " << allItemGroup.name() << " / " << allItemGroup.mesh()->name();
                      SharedItemVariableScalarRefT<T> shared_var(group.itemFamily(), var);
                      ENUMERATE_ITEM(iitem,group)
                        {
                          (*lvar)[iitem] = shared_var[iitem];
                        }
                    }
                }
              // else nothing to copy; already well referenced
            }
          else
            {
              if (group.itemFamily() == var.variable()->itemFamily())
                {
                  // new reference on allItems container (dont need copy)
                  traceMng()->debug() << "Property " << IGeometryProperty::name(property) << " on " << group.name() << " / " << group.mesh()->name() << " delegated from " << allItemGroup.name() << " / " << allItemGroup.mesh()->name();
                  lvar.reset(new RealTVariable(var));
                }
              else
                {
                  // this is an other mesh variable (need transposed copy)
                  traceMng()->debug() << "Property " << IGeometryProperty::name(property) << " on " << group.name() << " / " << group.mesh()->name() << " delegated from parent " << allItemGroup.name() << " / " << allItemGroup.mesh()->name();
                  lvar = buildPropertyVariableT<T>(group,property);
                  SharedItemVariableScalarRefT<T> shared_var(group.itemFamily(), var);
                  ENUMERATE_ITEM(iitem,group)
                    {
                      (*lvar)[iitem] = shared_var[iitem];
                    }
                }
            }
        }
    }
                        
  // Need ItemGroupMap storage for that property ?
  if (dest.storageType & IGeometryProperty::PItemGroupMap) 
    {
      ARCANE_ASSERT(((dest.externStorage & IGeometryProperty::PItemGroupMap) == 0),("Unexpected extern ItemGroupMap storage"));
      std::shared_ptr<RealTGroupMap> & lvar = ContainerAccessorT<T>::getMapContainer(dest);
      if (not lvar) 
        {
          lvar.reset(new RealTGroupMap(group));
          traceMng()->debug() << "Building Map " << lvar->name();
        }
      ENUMERATE_ITEM(iitem,group)
      {
        (*lvar)[iitem] = var[iitem];
      }
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
