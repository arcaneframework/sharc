// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#ifndef ARCGEOSIM_GEOMETRY_GEOMETRYSERVICEBASE_H
#define ARCGEOSIM_GEOMETRY_GEOMETRYSERVICEBASE_H
/* Author : havep at Thu Apr  3 09:09:09 2008
 * Generated by createNew
 */

#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"
#include "ArcGeoSim/Mesh/Geometry/Impl/ItemGroupGeometryProperty.h"

#include <memory>

namespace Arcane {
  class ITraceMng;
  class ISubDomain;
}

class GeometryServiceBase 
  : public IGeometryMng
{
public:
  /** Constructeur de la classe */
  GeometryServiceBase();

  /** Destructeur de la classe */
  virtual ~GeometryServiceBase();
  
public:
  //@{ @name Geometric property management for ItemGroup 

  //! Set geometric properties on a ItemGroup
  void addItemGroupProperty(ItemGroup group, Integer property, Integer storage);

  //! Set geometric properties on a ItemGroup with an external container (real field)
  void addItemGroupProperty(ItemGroup group, IGeometryProperty::eProperty property, RealVariable var);

  //! Set geometric properties on a ItemGroup with an external container (real3 field)
  void addItemGroupProperty(ItemGroup group, IGeometryProperty::eProperty property, Real3Variable var);

  //! Get set of properties of an ItemGroup
  Integer getItemGroupProperty(ItemGroup group);

  //! Check is a property is activated on an ItemGroup
  bool hasItemGroupProperty(ItemGroup group, Integer property);

  //! Check if a storage is available on an ItemGroup
  Integer getItemGroupPropertyStorage(ItemGroup group, IGeometryProperty::eProperty property);

  //@}

  //@{ @name Access to geometric values

  //! Get geometric property values for a Real field
  const RealVariable & getRealVariableProperty(ItemGroup group, IGeometryProperty::eProperty property);

  //! Get geometric property values for a Real3 field
  const Real3Variable & getReal3VariableProperty(ItemGroup group, IGeometryProperty::eProperty property);

  //! Get geometric property values for a Real field
  const RealGroupMap & getRealGroupMapProperty(ItemGroup group, IGeometryProperty::eProperty property);

  //! Get geometric property values for a Real3 field
  const Real3GroupMap & getReal3GroupMapProperty(ItemGroup group, IGeometryProperty::eProperty property);

  //@}

  //@{ @name global property management 

  //! Update property values for all ItemGroups on all meshes
  void update(IGeometryPolicy * policy);

  //! Update property values for all ItemGroups on given mesh
  void update(IMesh * mesh, IGeometryPolicy * policy);

  //! Reset property for all ItemGroups
  void reset();
  
  //@}

  //! Temporary interface to set tolerance on geometry policy
  void setPolicyTolerance(bool tolerance);

  //! Access to mesh
  virtual IMesh * mesh() = 0;

protected:
  //@{ Local extension of the interface

  //! Access to traceMng
  virtual ITraceMng * traceMng() = 0;

  template<typename GeometryT>
  void updateGroup(ItemGroup group,GeometryT & geometry);

  //! Name of instancied class
  virtual const char * className() const = 0;

  template<typename UniqGeometryMap, typename SharedGeometryMap>
  void unregisterMesh(UniqGeometryMap & uniquMap, SharedGeometryMap & sharedMap, IMesh * mesh);

  //@}

protected:
  //@{ @name property management by group

  //! Update property values for an ItemGroup
  virtual void update(ItemGroup group) = 0;

  //! Reset property for an ItemGroup
  virtual void reset(ItemGroup group) = 0;
  //@}


public:
  //! Associe la politique avec le contexte de calcul courant
  void beginContext(IGeometryPolicy * policy);
  //! Dissocie la politique avec le contexte de calcul courant
  void endContext();
  //! Indique si la propriete definie par son StorageInfo a besoin d'une mise a jour
  bool checkNeedUpdate(ItemGroup group, IGeometryProperty::eProperty property, const ItemGroupGeometryProperty::StorageInfo & storage_info);
  //! Enregistre un nouveau context dans une propriete definie par son StorageInfo
  void setNewContext(ItemGroupGeometryProperty::StorageInfo & storage_info);

protected:
  typedef std::map<ItemGroupImpl*, ItemGroupGeometryProperty> PropertyMap;
  PropertyMap m_group_property_map;
  String m_suffix; //!< suffix for internal variable names
  bool m_changed_property; //!< Tracage des changements d'etat (addItemGroupProperty si la propritete est deja defini est aussi un changement d'etat)
  enum { eUndef, eLazy, eStrict } m_policy_tolerance;
  IGeometryPolicy * m_policy;

  //! Return ItemGroupGeometryProperty if requested property and storage are available
  ItemGroupGeometryProperty::StorageInfo & _checkItemGroupProperty(ItemGroupImpl* group,
                                                                   IGeometryProperty::eProperty property,
                                                                   IGeometryProperty::eStorage storage);
  /*! Using setSuffix allow to define a known extension for internal variable name.
   *  At this level, the user is responsible to the collision management of names */
  void setSuffix(const String & suffix);

  //! Ajout un avertissement sur l'usage d'une propriete
  void _checkItemGroupPropertyUsage(ItemGroup group, IGeometryProperty::eProperty property, IGeometryProperty::eStorage storage,
                                    UInt32 count, Integer externStorage, Integer storageType);

private:  
  template<typename T>
  void copyAllItemsPropertyStorage(IGeometryProperty::eProperty property, ItemGroup allItemGroup, ItemGroupGeometryProperty::StorageInfo & src, ItemGroup group, ItemGroupGeometryProperty::StorageInfo & dest);

  template<typename T>
  std::shared_ptr<ItemVariableScalarRefT<T> > buildPropertyVariableT(ItemGroup group, IGeometryProperty::eProperty property);

private:
  //! Traite le maillage \a mesh pour une mise a jour complete de la geometrie
  void _fullUpdate(IMesh * mesh); 
  //! Traite le maillage \a mesh pour une mise a jour partielle de la geometrie
  void _partialUpdate(IMesh * mesh);

  static Integer s_suffix_count; //!< Aide a la creation sans collision des variables propres a chaque instance de geometrie

  bool m_first_update;
};

#include "ArcGeoSim/Mesh/Geometry/Impl/GeometryServiceBaseT.h"

#endif /* ARCGEOSIM_GEOMETRY_GEOMETRYSERVICEBASE_H */
