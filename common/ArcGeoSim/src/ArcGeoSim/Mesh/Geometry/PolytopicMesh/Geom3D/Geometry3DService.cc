// -*- C++ -*-
/* Author : couletj at Fri Jun 23 09:58:28 2017
 * Generated by createNew
 */

/* INFO: Les services et modules se conforment maintenant e la politique Arcane core.
 *       L'emploi des .h etait fictif.
 *       Desormais les declarations de classe pour les modules et services seront
 *       localisees dans le fichier .cc correspondant.
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include <arcane/IVariableMng.h>
#include <arcane/MathUtils.h>
#include <arcane/utils/Math.h>
#include "ArcGeoSim/Numerics/Expressions/IIFunction.h" //Necessaire pour IVariable ...

#include "ArcGeoSim/Mesh/Geometry/PolytopicMesh/IGeom.h" // Renseigner le nom et chemin de l'interface
#include "Geometry3D_axl.h"

#include "PolyhedralGeometry.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class Geometry3DService
        : public ArcaneGeometry3DObject
{
public:

    /** Constructeur de la classe */
    Geometry3DService(const Arcane::ServiceBuildInfo & sbi)
    : ArcaneGeometry3DObject(sbi),
      m_geometry(NULL)
      {
        ;
      }

    /** Destructeur de la classe */
    ~Geometry3DService() ;

public:

    //! Initialisation
    void init();
    //! Apply service function
    void apply();

private:
    PolyhedralGeometry * m_geometry;
    void computeFaceGeometrics();
    void computeCellGeometricsOlderVersion();
    void computeCellGeometrics();
    Arcane::Real3 computeIntegralX2(Arcane::Real3, Arcane::Real3, Arcane::Real3);
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

Geometry3DService::
~Geometry3DService()
{
  if (m_geometry)
    delete m_geometry;
}


void 
Geometry3DService::
init()
{
    m_geometry = new PolyhedralGeometry( mesh()->nodesCoordinates(), mesh()->dimension() );
}

/*---------------------------------------------------------------------------*/

void 
Geometry3DService::
apply()
{
    //L'ordre importe : les calculs sur les cellules requierent des grandeurs
    //calculees sur les faces
    computeFaceGeometrics();
    computeCellGeometrics();
}

/*---------------------------------------------------------------------------*/
void Geometry3DService::computeFaceGeometrics()
{
    info() << "Geometry3DService::computeFaceGeometrics";

    // Fill Variables With Zero Values

    m_face_diameter.fill(0.);
    m_face_measure.fill(0);
    m_face_meancenter.fill(Arcane::Real3::zero());
    m_face_barycenter.fill(Arcane::Real3::zero());
    m_face_normal.fill(Arcane::Real3::zero());
    m_face_normal_flux.fill(Arcane::Real3::zero());

    // Compute Geometry

    //Fonction qui effectue une boucle sur les faces et calcule les grandeurs geometriques
    //suivantes : diametre, aire, centre moyen, barycentre, normales
    ENUMERATE_FACE(iface, ownFaces())
    {
        int nb_nodes=iface->nbNode();
        //Calcul du diametre du centre moyen des faces
        for (Arcane::NodeEnumerator inode(iface->nodes()); inode(); ++inode)
        {
            Arcane::NodeEnumerator inext=inode;
            bool has_next = (inext.index() < nb_nodes-1)? true: false;
            while(has_next)
            {
               ++inext;
               m_face_diameter[iface] = Arcane::math::max(
                        m_face_diameter[iface], (m_node_coord[inode] - m_node_coord[inext]).abs2());
               has_next = (inext.index() < nb_nodes-1)? true: false;

            }
            m_face_meancenter[iface] += m_node_coord[inode]/iface->nbNode();
        }
        m_face_diameter[iface]=sqrt(m_face_diameter[iface]);

        //Calculs d'aire et de barycentre en considerant le triangle Vi, Vinext, meancenter
        for (Arcane::NodeEnumerator inode(iface->nodes()); inode(); ++inode)
        {
            Arcane::Real  triarea(0);
            Arcane::Real3 tricenter(0,0,0);
            Arcane::Node inext = (inode.index() < iface->nbNode()-1)? iface->node(inode.index()+1):iface->node(0);
            triarea = 0.5 * (Arcane::math::crossProduct3(m_node_coord[inode]-m_face_meancenter[iface],
                    m_node_coord[inext]-m_face_meancenter[iface]).abs());
            tricenter = (1./3.)*(m_node_coord[inode] + m_node_coord[inext] + m_face_meancenter[iface]);
            m_face_measure[iface]    += triarea;
            m_face_barycenter[iface] += triarea * tricenter;
            m_face_normal[iface]+= Arcane::math::crossProduct3(m_node_coord[inode] - m_face_meancenter[iface],
                                                               m_node_coord[inext] - m_face_meancenter[iface]);


        }

        if ( m_face_measure[iface] > 0.0001)
            m_face_barycenter[iface] /= m_face_measure[iface];
        else
            m_face_barycenter[iface]=m_face_meancenter[iface];

        m_face_normal[iface]= m_face_normal[iface].normalize();
        /*Apparement, les points sont ordonnes de sorte que la normale e la face est toujours orientee
		de backcell vers frontcell. Autrement il faudrait corriger l'orientation.
		Une possibilite peut-etre de faire le produit scalaire entre la normale et vecteur
		(barycentre_face - centre_backcell), celui ci devant etre positif. Eventuel probleme : les normales
		aux faces sont utilisees pour le cacul des barycentres.
         */

        m_face_normal_flux[iface]=m_face_normal[iface]*m_face_measure[iface];

    }

    // Synchronize Variables

    m_face_diameter.synchronize();
    m_face_measure.synchronize();
    m_face_meancenter.synchronize();
    m_face_barycenter.synchronize();
    m_face_normal.synchronize();
    m_face_normal_flux.synchronize();

}
/*---------------------------------------------------------------------------*/
void Geometry3DService::computeCellGeometricsOlderVersion()
{
    info() << "Geometry3DService::computeCellGeometrics";

    // Fill Variables With Zero Values

    m_cell_diameter.fill(0);
    m_cell_measure.fill(0);
    m_cell_meancenter.fill(Arcane::Real3::zero());
    m_cell_barycenter.fill(Arcane::Real3::zero());

    // Compute Geometry

    //Fonction qui effectue une boucle sur les cellules et calcule les grandeurs geometriques
    //suivantes : diametre, volume, centre moyen, barycentre
    ENUMERATE_CELL(icell, ownCells())
    {
        Arcane::Real3 meancenter(0,0,0);

        //Calcul du diametre du centre moyen des cellules
        for (Arcane::NodeEnumerator inode(icell->nodes()); inode(); ++inode)
        {
            m_cell_meancenter[icell] += m_node_coord[inode]/icell->nbNode();
            for (Arcane::NodeEnumerator jnode(icell->nodes()); jnode(); ++jnode)
                m_cell_diameter[icell] = Arcane::math::max(
                        m_cell_diameter[icell], (m_node_coord[inode] - m_node_coord[jnode]).abs());
        }

        //Le volume d'un polygone est calcule e partir de ses faces http://wwwf.imperial.ac.uk/~rn/centroid.pdf
        //V = 1/3 | Sum_F Qf.nf Area(F) | oe Qf est n'importe quel point de la face F et nf sa normale sortante unitaire
        for (Arcane::FaceEnumerator iface(icell->faces()); iface(); ++iface)
        {
            const auto back_cell = iface->backCell();
            int signe = (!back_cell.null() && iface->backCell().uniqueId()==icell->uniqueId())? 1:-1;
            Arcane::Real3 outward_normal = signe * m_face_normal[iface];
            m_cell_measure[icell] += m_face_measure[iface]*Arcane::math::dot(outward_normal, m_node_coord[iface->node(0)]);
        }
        m_cell_measure[icell] = (1./3.) * fabs(m_cell_measure[icell]);

        //Pour le calcul du barycentre, on utilise egalement une formule de divergence pour se ramener aux faces.
        //Le barycentre verifie G = 1/V Int_P X. Or 1/2 div(x1^2, 0, 0) = x1 donc G1 = 1/V Int_P x1
        // = 1/2V Int_dP (x1^2, 0, 0) . Nf = 1/2V Sum_F x1^2 * Nf1. On peut calculer exactement cette integrale en
        // decoupant en triangles et en utilisant une quadrature d'ordre 2 (formule de Gauss)
        // Meme raisonnement pour les composantes G2 et G3 du barycentre
        for (Arcane::FaceEnumerator iface(icell->faces()); iface(); ++iface)
        {
            //Normale sortante e la face
            int signe = (iface->backCell().uniqueId()==icell->uniqueId())? 1:-1;
            Arcane::Real3 outward_normal = signe * m_face_normal[iface];


            //Decoupage en triangles inode, inext, face_barycenter
            for (Arcane::NodeEnumerator inode(iface->nodes()); inode(); ++inode)
            {
                Arcane::Node inext = (inode.index() < iface->nbNode()-1)? iface->node(inode.index()+1):iface->node(0);
                m_cell_barycenter[icell].x += (0.5/m_cell_measure[icell]) * (outward_normal.x *
                        computeIntegralX2(m_node_coord[inode], m_node_coord[inext], m_face_barycenter[iface]).x);
                m_cell_barycenter[icell].y += (0.5/m_cell_measure[icell]) * (outward_normal.y *
                        computeIntegralX2(m_node_coord[inode], m_node_coord[inext], m_face_barycenter[iface]).y);
                m_cell_barycenter[icell].z += (0.5/m_cell_measure[icell]) * (outward_normal.z *
                        computeIntegralX2(m_node_coord[inode], m_node_coord[inext], m_face_barycenter[iface]).z);
            }
        }
    }

    // Synchronize Variables
    m_cell_diameter.synchronize();
    m_cell_measure.synchronize();
    m_cell_meancenter.synchronize();
    m_cell_barycenter.synchronize();

}
/*---------------------------------------------------------------------------*/
void Geometry3DService::computeCellGeometrics()
{
    info() << "Geometry3DService::computeCellGeometrics";

    // Fill Variables With Zero Values

    m_cell_diameter.fill(0);
    m_cell_measure.fill(0);
    m_cell_meancenter.fill(Arcane::Real3::zero());
    m_cell_barycenter.fill(Arcane::Real3::zero());

    // Compute Geometry

    //Fonction qui effectue une boucle sur les cellules et calcule les grandeurs geometriques
    //suivantes : diametre, volume, centre moyen, barycentre
    ENUMERATE_CELL(icell, ownCells())
    {
        Arcane::Real3 meancenter(0,0,0);
        //Calcul du diametre du centre moyen des cellules
        for (Arcane::NodeEnumerator inode(icell->nodes()); inode(); ++inode)
        {
            m_cell_meancenter[icell] += m_node_coord[inode]/icell->nbNode();
            Arcane::NodeEnumerator inext=inode;
            bool has_next = (inext.index() < icell->nbNode()-1)? true: false;
            while(has_next)
            {
                ++inext;
                m_cell_diameter[icell] = Arcane::math::max(
                        m_cell_diameter[icell], (m_node_coord[inode] - m_node_coord[inext]).abs2());
                has_next = (inext.index() < icell->nbNode()-1)? true: false;

            }
        }
        m_cell_diameter[icell] = sqrt(m_cell_diameter[icell]);

        //Le volume d'un polygone est calcule e partir de ses faces http://wwwf.imperial.ac.uk/~rn/centroid.pdf
        //V = 1/3 | Sum_F Qf.nf Area(F) | oe Qf est n'importe quel point de la face F et nf sa normale sortante unitaire
        for (Arcane::FaceEnumerator iface(icell->faces()); iface(); ++iface)
        {
            const auto back_cell = iface->backCell();
            int signe = (!back_cell.null() && iface->backCell().uniqueId()==icell->uniqueId())? 1:-1;
            Arcane::Real3 outward_normal = signe * m_face_normal[iface];
            m_cell_measure[icell] += m_face_measure[iface]*Arcane::math::dot(outward_normal, m_node_coord[iface->node(0)]);
        }
        m_cell_measure[icell] = (1./3.) * fabs(m_cell_measure[icell]);
    }

    // calcul des centres de masse

    SharedArray<Real> coords;
    ENUMERATE_CELL(icell, ownCells()) {
        m_cell_barycenter[icell] = m_geometry->computeCenter(*icell,coords);
    }

    // Synchronize Variables
    m_cell_diameter.synchronize();
    m_cell_measure.synchronize();
    m_cell_meancenter.synchronize();
    m_cell_barycenter.synchronize();

}
/*---------------------------------------------------------------------------*/
Arcane::Real3 Geometry3DService::computeIntegralX2(Arcane::Real3 node1, Arcane::Real3 node2,
        Arcane::Real3 node3)
{
    //A partir de trois vecteurs Real3 representant les coordonees d'un triangle,
    //integre la fonction (x^2, y^2, z^2) par une formule de gauss d'ordre 2
    Arcane::Real triarea = 0.5 * (Arcane::math::crossProduct3(node1-node3, node2-node3).abs());
    Arcane::Real3 PGauss1(0.5*(node2+node3)), PGauss2(0.5*(node1+node2)), PGauss3(0.5*(node1+node3));
    Arcane::Real3 integral_x2(0,0,0);
    integral_x2.x = (2*triarea/6.) * (pow(PGauss1.x,2) + pow(PGauss2.x, 2) + pow(PGauss3.x, 2));
    integral_x2.y = (2*triarea/6.) * (pow(PGauss1.y,2) + pow(PGauss2.y, 2) + pow(PGauss3.y, 2));
    integral_x2.z = (2*triarea/6.) * (pow(PGauss1.z,2) + pow(PGauss2.z, 2) + pow(PGauss3.z, 2));
    return integral_x2;
}
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
using namespace Arcane;
ARCANE_REGISTER_SERVICE_GEOMETRY3D(Geometry3D,Geometry3DService);
