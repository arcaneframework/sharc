#ifndef ARCGEOSIM_GEOMETRY_POLYHEDRALGEOMETRY_H
#define ARCGEOSIM_GEOMETRY_POLYHEDRALGEOMETRY_H
/* Author : AGELAS at Fri Dec
 * Generated by createNew
 */

#include "ArcGeoSim/Mesh/Geometry/IGeometry.h"
#include <arcane/ArcaneTypes.h>
#include <arcane/MeshVariable.h>
#include <arcane/VariableTypedef.h>
#include <arcane/MathUtils.h>
#include <arcane/MeshVariableRef.h>
#include <arcane/ArcaneVersion.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/ItemPrinter.h>
#include <arcane/SharedVariable.h>
#include <arcane/utils/FatalErrorException.h>
#include <map>

using namespace Arcane;



class PolyhedralGeometry : public IGeometry
{
public :
  PolyhedralGeometry(const Arcane::VariableNodeReal3& node_coord, Integer dimension) : m_node_coords(node_coord),m_dimension(dimension){}
  virtual ~PolyhedralGeometry(){}

  Real  computeLength(const ItemWithNodes & item);
  Real  computeLength(const Real3& m, const Real3& n);
  
  Real3 computeCenter(const ItemWithNodes & item);
  Real3 computeCentroid(const ItemWithNodes & item);
  Real3 computeCenter(const ItemWithNodes & item, Array<Real> & coords);

  Real3 computeFaceCenter(const ItemWithNodes & item);

  Real3 computeFaceBarycenter(const ItemWithNodes & item);
  Real3 computeNormalizedFaceNormal(const ItemWithNodes & iface);

  Real3 computeOrientedMeasure(const ItemWithNodes & item)
  { 
    throw FatalErrorException(A_FUNCINFO,"not implemented"); 
  }
  
  Real  computeMeasure(const ItemWithNodes & item);

  Real  computeArea(const ItemWithNodes & item);
  
  // REMOVED FROM IGEOMETRY : CHECK USAGE
  //   Real3 computeSurfaceCenter(Integer n, const Real3 * coords)
  //   { 
  //     throw FatalErrorException(A_FUNCINFO,"not implemented"); 
  //   }
  
  Real3 computeOrientedArea(Integer n, const Real3 * coords)
  { 
    throw FatalErrorException(A_FUNCINFO,"not implemented"); 
  }

  Real  computeVolume(const ItemWithNodes & item)
  { 
    throw FatalErrorException(A_FUNCINFO,"not implemented"); 
  }

  Real3 computeIntegralX2(Arcane::Real3 node1, Arcane::Real3 node2,Arcane::Real3 node3);

  //@{ @name primitives used for volume decomposition

  static inline Real3 computeTriangleNormal(const Real3 & n0, const Real3 & n1, const Real3 & n2)
  {
      return Arcane::math::vecMul(n1-n0,n2-n0) / 2.0;
  }

  static inline Real3 computeTriangleCenter(const Real3 & n0, const Real3 & n1, const Real3 & n2)
  {
      return (n0+n1+n2) / 3.0;
  }

  static inline Real computeTriangleSurface(const Real3 & n0, const Real3 & n1, const Real3 & n2)
      {
        return Arcane::math::normeR3(computeTriangleNormal(n0,n1,n2));
      }

  static inline Real computeTetraedronVolume(const Real3 & n0, const Real3 & n1, const Real3 & n2, const Real3 & n3)
  {
      return Arcane::math::mixteMul(n1-n0,n2-n0,n3-n0) / 6.0;
  }

  static inline Real3 computeTetraedronCenter(const Real3 & n0, const Real3 & n1, const Real3 & n2, const Real3 & n3)
  {
      return 0.25 * (n0+n1+n2+n3);
  }

  static inline Real3 computeQuadrilateralCenter(const Real3 & n0, const Real3 & n1, const Real3 & n2, const Real3 & n3)
  {
      const Real s0 = computeTriangleSurface(n0,n1,n2);
      const Real s1 = computeTriangleSurface(n0,n2,n3);
      const Real s2 = computeTriangleSurface(n1,n2,n3);
      const Real s3 = computeTriangleSurface(n0,n1,n3);
      const Real totalS = (s0+s1+s2+s3);

      return (s0 * computeTriangleCenter(n0,n1,n2) +
              s1 * computeTriangleCenter(n0,n2,n3) +
              s2 * computeTriangleCenter(n1,n2,n3) +
              s3 * computeTriangleCenter(n0,n1,n3)) / totalS;
  }

  static inline Real3 computeQuadrilateralCenter(const Real3 & n0, const Real3 & n1, const Real3 & n2, const Real3 & n3,
          Real & s0, Real & s1, Real & s2, Real & s3, Real & totalS)
  {
      s0 = computeTriangleSurface(n0,n1,n2);
      s1 = computeTriangleSurface(n0,n2,n3);
      s2 = computeTriangleSurface(n1,n2,n3);
      s3 = computeTriangleSurface(n0,n1,n3);
      totalS = (s0+s1+s2+s3);

      return (s0 * computeTriangleCenter(n0,n1,n2) +
              s1 * computeTriangleCenter(n0,n2,n3) +
              s2 * computeTriangleCenter(n1,n2,n3) +
              s3 * computeTriangleCenter(n0,n1,n3)) / totalS;
  }

private:
  const Arcane::VariableNodeReal3& m_node_coords;
  const Integer m_dimension;
};

#endif


 



