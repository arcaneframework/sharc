// -*- C++ -*-
/* Author : encheryg at Mon Mar 27 17:45:07 2023
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include <arcane/IMesh.h>
#include "ArcGeoSim/Mesh/Geometry/PolytopicMesh/IGeom.h"

#include "Geometry3Dbis_axl.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class Geometry3DbisService 
  : public ArcaneGeometry3DbisObject
{
public:
  
  /** Constructeur de la classe */
  Geometry3DbisService(const Arcane::ServiceBuildInfo & sbi) 
    : ArcaneGeometry3DbisObject(sbi) {}
  
  /** Destructeur de la classe */
  ~Geometry3DbisService() {}

  //! Initialisation
  void init();

  //! Apply service function
  void apply();

private:
  Arcane::Real3 _triMeasureNormal(const Arcane::Face& f, const Arcane::NodeEnumerator& ne) ;
  Arcane::Real _orientation(const Arcane::Cell& c, const Arcane::Face& f, const Arcane::Real3& vector) ;
  Arcane::Real3 _X2AtTriGaussPoints(const Arcane::Face& f, const Arcane::NodeEnumerator& ne) ;
  Arcane::Real _diameter(const Arcane::ItemWithNodes* item) ;
  Arcane::Real3 _meanCenter(const Arcane::ItemWithNodes* item) ;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
Geometry3DbisService::
init()
{
  m_cell_measure.fill(0.) ;
}

/*---------------------------------------------------------------------------*/

void 
Geometry3DbisService::
apply()
{
  const auto&  nodeCenters(mesh() -> nodesCoordinates()) ;

  ENUMERATE_NODE(iNode, mesh() -> allNodes()) {
    m_node_coord[iNode] = nodeCenters[iNode] ;
  }

  // Mean centers should be first defined since they are used by _orientation
  m_cell_meancenter.fill(Arcane::Real3::zero()) ;

  ENUMERATE_CELL(iCell, mesh() -> allCells()) {
    const auto& cell(*iCell) ;
    m_cell_meancenter[cell] = _meanCenter(&cell);
  }

  m_face_meancenter.fill(Arcane::Real3::zero()) ;
  m_face_normal.fill(Arcane::Real3::zero()) ;
  m_face_normal_flux.fill(Arcane::Real3::zero()) ;
  m_face_measure.fill(0.0) ;
  m_face_barycenter.fill(Arcane::Real3::zero()) ;
  m_face_diameter.fill(0.) ;

  const auto epsilon(std::numeric_limits<double>::epsilon()) ;

  ENUMERATE_FACE(iFace, mesh() -> allFaces()) {
    const auto& face(*iFace) ;

    m_face_diameter[face] = _diameter(&face) ;

    m_face_meancenter[face]= _meanCenter(&face) ;

    const auto& upwindCell(face.isSubDomainBoundary() ? face.boundaryCell() : face.backCell()) ;
    auto& faceNormalFlux(m_face_normal_flux[face]) ;
    auto& faceBarycenter(m_face_barycenter[face]) ;
    ENUMERATE_NODE(iNode, face.nodes()) {
      const auto triMeasureNormal(_triMeasureNormal(face, iNode)) ;
      faceNormalFlux += triMeasureNormal ;
      const auto triMeasure(triMeasureNormal.abs());

      const auto& curNodeCenter(m_node_coord[iNode]) ;
      const auto curNodeIndex(iNode.index()) ;
      const auto& nextNode((curNodeIndex < face.nbNode() - 1) ? face.node(curNodeIndex + 1) : face.node(0)) ;
      const auto& nextNodeCenter(nodeCenters[nextNode]) ;
      const auto& triCenter((m_face_meancenter[face] + curNodeCenter + nextNodeCenter) / 3.) ;
      faceBarycenter += triMeasure * triCenter ;
    }
    const auto sign((iFace -> isSubDomainBoundary() && (! iFace -> isSubDomainBoundaryOutside())) ? -1. : 1.) ;
    const auto orientation(_orientation(upwindCell, face, faceNormalFlux)) ;
    const auto factor(orientation*sign);
    faceNormalFlux *= factor ;
    m_face_measure[face] = faceNormalFlux.abs() ;

    if(m_face_measure[face] > epsilon) {
      m_face_normal[face]= faceNormalFlux / m_face_measure[face] ;
      faceBarycenter /= m_face_measure[face] ;
    } else {
      throw std::runtime_error("Zero face measure") ;
    }
  }

  m_cell_measure.fill(0.) ;
  m_cell_barycenter.fill(Arcane::Real3::zero()) ;
  m_cell_diameter.fill(0.) ;
  ENUMERATE_CELL(iCell, mesh() -> allCells()) {
    const auto& cell(*iCell) ;

    m_cell_diameter[cell] = _diameter(&cell) ;

    // See https://www.ma.imperial.ac.uk/~rn/centroid.pdf
    auto& cellMeasure(m_cell_measure[cell]) ;
    auto& cellBarycenter(m_cell_barycenter[cell]) ;
    ENUMERATE_FACE(iFace, iCell -> faces()) {
      const auto& face(*iFace) ;

      ENUMERATE_NODE(iNode, face.nodes()) {
        auto triMeasureNormal(_triMeasureNormal(face, iNode)) ;
        const auto orientation(_orientation(cell, face, triMeasureNormal)) ;
        triMeasureNormal *= orientation ;

        const auto& nodeCoord(m_node_coord[iNode]) ;
        cellMeasure += Arcane::math::dot(nodeCoord, triMeasureNormal) ;

        const auto triMeasure(triMeasureNormal.abs()) ;

        if(triMeasure > epsilon) {
          const auto triNormal(triMeasureNormal / triMeasure);
          auto res(_X2AtTriGaussPoints(face, iNode));
          res.mul(triNormal);
          res *= triMeasure;
          cellBarycenter += res;
        } else {
          throw std::runtime_error("Zero triangle measure") ;
        }
      }
    }
    cellMeasure /= 3. ;

    if(cellMeasure > epsilon) {
      cellBarycenter /= 2. * cellMeasure ;
    } else {
      throw std::runtime_error("Zero cell measure") ;
    }
  }
}

/*---------------------------------------------------------------------------*/
Arcane::Real3 Geometry3DbisService::_triMeasureNormal(const Arcane::Face& f, const Arcane::NodeEnumerator& ne) {
  const auto curNodeIndex(ne.index()) ;
  const auto& curNode(*ne) ;
  const auto& nextNode((curNodeIndex < f.nbNode() - 1) ? f.node(curNodeIndex + 1) : f.node(0)) ;

  const auto&  nodeCenters(mesh() -> nodesCoordinates()) ;
  const auto& meanFaceCenter(m_face_meancenter[f]) ;
  const auto& curCenter(nodeCenters[curNode]) ;
  const auto& nextCenter(nodeCenters[nextNode]) ;
  auto triMeasureNormal(0.5 * (Arcane::math::cross(curCenter - meanFaceCenter,
                                                   nextCenter - meanFaceCenter))) ;

  return triMeasureNormal ;
}

/*---------------------------------------------------------------------------*/
Arcane::Real Geometry3DbisService::_orientation(const Arcane::Cell& c, const Arcane::Face& f,
                                                const Arcane::Real3& vector) {
  const auto& cellCenter(m_cell_meancenter[c]) ;
  const auto cellFaceCentersVector(m_face_meancenter[f] - cellCenter) ;
  const auto cellFaceCentersNormalDotProd(Arcane::math::dot(vector, cellFaceCentersVector)) ;
  const auto orientation(cellFaceCentersNormalDotProd >= 0. ? 1. : -1.) ;
  return orientation ;
}

/*---------------------------------------------------------------------------*/
Arcane::Real3 Geometry3DbisService::_X2AtTriGaussPoints(const Arcane::Face& f, const Arcane::NodeEnumerator& ne) {
  const auto curNodeIndex(ne.index()) ;
  const auto& curNode(*ne) ;
  const auto& nextNode((curNodeIndex < f.nbNode() - 1) ? f.node(curNodeIndex+ 1) : f.node(0)) ;

  const auto&  nodeCenters(mesh() -> nodesCoordinates()) ;

  const auto& s1(nodeCenters[curNode]) ;
  const auto& s2(nodeCenters[nextNode]) ;
  const auto& s3(m_face_meancenter[f]) ;
  const Arcane::Real3 p1(0.5 * (s2 + s3)), p2(0.5 * (s1 + s2)), p3(0.5 * (s1 + s3)) ;
  const auto factor(1 / 3.) ;
  return factor * Arcane::Real3(p1.x * p1.x + p2.x * p2.x + p3.x * p3.x,
                                p1.y * p1.y + p2.y * p2.y + p3.y * p3.y,
                                p1.z * p1.z + p2.z * p2.z + p3.z * p3.z) ;
}

/*---------------------------------------------------------------------------*/
Arcane::Real Geometry3DbisService::_diameter(const Arcane::ItemWithNodes* item) {
  const auto nbNodes(item -> nbNode());
  double diameter=0.;
  for(auto i(0) ; i < nbNodes ; ++i) {
    const auto& node1(m_node_coord[item -> node(i)]) ;

    for(auto j(i+1) ; j < nbNodes ; ++j) {
      const auto& node2(m_node_coord[item -> node(j)]) ;

      const Arcane::Real3 vect12(node2 - node1) ;
      const Arcane::Real dist12(vect12.abs()) ;

      diameter = Arcane::math::max(diameter, dist12) ;
    }
  }
  return diameter ;
}

/*---------------------------------------------------------------------------*/
Arcane::Real3 Geometry3DbisService::_meanCenter(const Arcane::ItemWithNodes* item) {
  Arcane::Real3 meanFaceCenter(Arcane::Real3::zero()) ;
  ENUMERATE_NODE(iNode, item->nodes()) {
    meanFaceCenter += m_node_coord[iNode] ;
  }
  meanFaceCenter /= item->nbNode() ;
  return meanFaceCenter;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_GEOMETRY3DBIS(Geometry3Dbis,Geometry3DbisService);
