// -*- C++ -*-
/* Author : couletj at Thu Jun 22 14:15:33 2017
 * Generated by createNew
 */

/* INFO: Les services et modules se conforment maintenant à la politique Arcane core.
 *       L'emploi des .h était fictif. 
 *       Désormais les déclarations de classe pour les modules et services seront
 *       localisées dans le fichier .cc correspondant.
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include <arcane/IVariableMng.h>
#include <arcane/MathUtils.h>
#include <arcane/IMesh.h>
#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"
#include "ArcGeoSim/Appli/AppService.h"
#include "ArcGeoSim/Mesh/EvolutiveMesh/IEvolutiveMesh.h"
#include "ArcGeoSim/Mesh/EvolutiveMesh/IEvolutiveMeshObserver.h"
#include "ArcGeoSim/Numerics/Expressions/IIFunction.h" //Nécessaire pour IVariable ...

// Interface du service 
#include "../IGeom.h" // Renseigner le nom et chemin de l'interface

#include "Geom2dxy_axl.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class Geom2dxyService 
        : public ArcaneGeom2dxyObject
{
public:

    /** Constructeur de la classe */
    Geom2dxyService(const Arcane::ServiceBuildInfo & sbi)
: ArcaneGeom2dxyObject(sbi) {}

    /** Destructeur de la classe */
    ~Geom2dxyService() {}

public:

    //! Initialisation
    void init();

    //! Apply service function
    void apply();
private:
    void treatMeshEvolution(IEvolutiveMesh*);
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
Geom2dxyService::
init()
{
    if (mesh()->dimension() != 2)
        fatal() << "Using a 2D geometric service with a " << mesh()->dimension()<< " mesh";
    //Initialisation des fonctions condition aux bords, vérification et création des groupes BCs
    for (int i=0; i<options()->inMeshBoundary.size(); i++)
        if (mesh()->faceFamily()->findGroup(options()->inMeshBoundary[i]).null())
            fatal() << "Le groupe de faces " << options()->inMeshBoundary[i] << " est absent du maillage";
    for (int i=0; i<options()->definedBoundary.size(); ++i)
        mesh()->faceFamily()->createGroup(options()->definedBoundary[i]->name());
    info() << options()->definedBoundary.size() + options()->inMeshBoundary.size() << " groups of boundary faces are defined";
    m_face_bc_group.resize(options()->definedBoundary.size() + options()->inMeshBoundary.size());
    //Déclaration du evolutive_mesh qui va effectuer les calculs géométriques en cas de màj du maillage
    //Si le maillage est statique, on passe force le calcul géométrique avec apply()
    IAppServiceMng* app_service_mng = IAppServiceMng::instance(subDomain()->serviceMng());
    IEvolutiveMesh* evolutive_mesh = app_service_mng->find<IEvolutiveMesh>(false);
    if (not evolutive_mesh == NULL)
        evolutive_mesh->addObserver(newEvolutiveMeshObserverT(this,&Geom2dxyService::treatMeshEvolution),IEvolutiveMesh::AfterAll);
    else
        apply();
}

/*---------------------------------------------------------------------------*/

void 
Geom2dxyService::
apply()
{
    info() << "Geometry is computed after a call to apply()";
    m_cell_diameter.fill(0);
    m_cell_measure.fill(0);
    m_cell_meancenter.fill(Arcane::Real3(0,0,0));
    m_cell_barycenter.fill(Arcane::Real3(0,0,0));
    m_cell_vfcenter.fill(Arcane::Real3(0,0,0));
    m_face_measure.fill(0);
    m_face_barycenter.fill(Arcane::Real3(0,0,0));
    m_face_normal.fill(Arcane::Real3(0,0,0));
    m_face_normal_flux.fill(Arcane::Real3(0,0,0));
    ENUMERATE_CELL(icell, allCells())
    {
        Arcane::Integer nb_nodes(icell->nbNode());
        Arcane::Real prodvec2d(0), diameter(0), measure(0);
        Arcane::Real3 meancenter(0,0,0), barycenter(0,0,0);
        for (Arcane::NodeEnumerator inode(icell->nodes()); inode(); ++inode)
        {
            meancenter += m_node_coord[inode];
            Arcane::Node inext = (inode.index() < nb_nodes-1)? icell->node(inode.index()+1):icell->node(0);
            prodvec2d= m_node_coord[inode].x*m_node_coord[inext].y - m_node_coord[inode].y*m_node_coord[inext].x;
            measure += prodvec2d;
            barycenter += prodvec2d * (m_node_coord[inode]+m_node_coord[inext]);
            for (Arcane::NodeEnumerator jnode(icell->nodes()); jnode(); ++jnode)
                diameter = Arcane::math::max(diameter, (m_node_coord[inode] - m_node_coord[jnode]).abs());
        }

        m_cell_diameter[icell] = diameter;
        m_cell_measure[icell] = 0.5 * fabs(measure);
        m_cell_meancenter[icell] = meancenter/nb_nodes;
        m_cell_barycenter[icell] = barycenter/(6*m_cell_measure[icell]);
    }
    //Lecture dans le maillage des centres volumes finis
    //La version modifiée du reader vtk supporte les vecteurs.
    IVariable* m_read_center = subDomain()->variableMng()->findMeshVariable(mesh(), "VFCENTER");
    if (not (m_read_center == NULL))
    {
        VariableCellReal3 cell_center(VariableBuildInfo(m_read_center->mesh(),m_read_center->name()));
        m_cell_vfcenter.copy(cell_center);
    }
    else
    {
        IVariable* m_read_center = subDomain()->variableMng()->findMeshVariable(mesh(), "CellCenter");
        if (not (m_read_center == NULL))
        {
            VariableCellReal3 cell_center(VariableBuildInfo(m_read_center->mesh(),m_read_center->name()));
            m_cell_vfcenter.copy(cell_center);
        }
        else
        {
            warning() << "finite volume center not found in mesh. Mass center will be used";
            m_cell_vfcenter.copy(m_cell_barycenter);
        }
    }

    ENUMERATE_FACE(iface, allFaces())
    {
        Arcane::Node node1 = iface->node(0), node2 = iface->node(1);
        m_face_barycenter[iface] = 0.5*(m_node_coord[node1] + m_node_coord[node2]);
        m_face_measure[iface] = (m_node_coord[node1] - m_node_coord[node2]).abs();
        m_face_normal[iface] = Arcane::Real3(m_node_coord[node2].y - m_node_coord[node1].y,
                m_node_coord[node1].x - m_node_coord[node2].x,
                0);
        //On oriente la normale pour qu'elle aille de backcell vers frontcell. Ce test est valable si
        //la maille est convexe. Il semble que l'ordonnancement des noeuds soit fait de sorte que ce
        //test soit inutile et que la normale soit toujours correctement orientée
        Arcane::Cell backcell(iface->backCell()), frontcell(iface->frontCell());
        if (backcell.uniqueId() >= 0 and
                Arcane::math::dot(m_face_normal[iface], m_face_barycenter[iface]-m_cell_barycenter[backcell] ) <0 )
            m_face_normal[iface] = -1*m_face_normal[iface];
        else if (backcell.uniqueId() < 0 and //Cas des faces de bords qui n'ont pas de backcell
                Arcane::math::dot(m_face_normal[iface], m_face_barycenter[iface]-m_cell_barycenter[frontcell] ) >0 )
            m_face_normal[iface] = -1*m_face_normal[iface];
        m_face_normal[iface] /= m_face_normal[iface].abs();
        m_face_normal_flux[iface] = m_face_normal[iface]*m_face_measure[iface];

        //Le centre "Volume finis" des faces correspond au barycentre pour les faces interne et à la projection
        //du centre VF de la maille sur l'arête de bord pour les bords
        if (not iface->isSubDomainBoundary())
            m_face_vfcenter[iface] = m_face_barycenter[iface];
        else
        {
            //Formule du projet : BK' = (BK.v)*v pour v vecteur directeur unitaire et B point de la droite
            //Formule de la distance : KK' = |BK^v| / |v|
            Arcane::Real3 v_dir(m_node_coord[iface->nodes()[0]] - m_node_coord[iface->nodes()[1]]);
            Arcane::Real3 node_in_face(m_node_coord[iface->nodes()[0]]);
            Arcane::Real dot = Arcane::math::dot(m_cell_vfcenter[iface->boundaryCell()] - node_in_face, v_dir);
            m_face_vfcenter[iface] = (v_dir/v_dir.abs2()) * dot + node_in_face;
        }
    }
    //Recherche des groupes de faces CLs et remplissage tableau
    m_face_bc_group.fill(0);
    for (int i=0; i<options()->inMeshBoundary.size(); i++)
        ENUMERATE_FACE(iface, mesh()->faceFamily()->findGroup(options()->inMeshBoundary[i]))
        m_face_bc_group[iface][i] = 1;
    //Si le groupe est défini par une équation, on le rempli avec les faces correspondantes
    for (int i=0; i<options()->definedBoundary.size(); i++)
    {
        const String groupname = options()->definedBoundary[i]->name();
        Arcane::StringSharedArray str_array;
        options()->definedBoundary[i]->eq().split(str_array,'=');
        String coord = str_array[0].lower();
        Real value = std::stod(str_array[1].localstr()); //Passage par localstr semble obligatoire
        IntegerUniqueArray face_lids;
        ENUMERATE_FACE(iface, allFaces())
        {
            if ((coord == "x") && (fabs(m_face_barycenter[iface].x - value) < 1e-8))
                face_lids.add(iface->localId());
            if ((coord == "y") && (fabs(m_face_barycenter[iface].y - value) < 1e-8))
                face_lids.add(iface->localId());
        }
        mesh()->faceFamily()->findGroup(groupname).addItems(face_lids, true);
        ENUMERATE_FACE(iface, mesh()->faceFamily()->findGroup(groupname))
        m_face_bc_group[iface][i+options()->inMeshBoundary.size()] = 1;
    }
}
/*---------------------------------------------------------------------------*/
void Geom2dxyService::treatMeshEvolution(IEvolutiveMesh *evo_mesh)
{
    info() << "Geometry is automatically computed due to a mesh evolution";
    apply();
}
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_GEOM2DXY(Geom2dxy,Geom2dxyService);
