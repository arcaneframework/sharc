// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
/* Author : dechaiss at Tue Oct  9 10:30:25 2012
 * Generated by createNew
 */

/* INFO: Les services et modules se conforment maintenant � la politique Arcane core.
 *       L'emploi des .h �tait fictif. 
 *       D�sormais les d�clarations de classe pour les modules et services seront
 *       localis�es dans le fichier .cc correspondant.
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

// Interface du service 
#include <arcane/ArcaneVersion.h>
#include <arcane/IMeshReader.h>
#include <arcane/BasicService.h>
#include <arcane/XmlNode.h>
#include <arcane/ISubDomain.h>
#include <arcane/FactoryService.h>
#include <arcane/ItemTypeMng.h>
#include <arcane/ItemTypeInfo.h>

#include "ArcGeoSim/Utils/ArcGeoSim.h"
#include "ArcGeoSim/Mesh/Utils/MeshUtils.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IIXMStaticMeshReader.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMStaticMeshBuilder.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMV4MeshReader.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMV3MeshReader.h"
#include <ArcGeoSim/Mesh/Utils/IXMTools/IXMV4_1MeshReader.h>

#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMTools.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMPropertyBuilder.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMDataExchanger.h"

#include "ArcGeoSim/Mesh/Utils/IXMTools/IIXMMeshChecker.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMStaticMeshChecker.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class IXMMeshReaderService 
  : public Arcane::BasicService
  , public Arcane::IMeshReader
{
public:
  
  /** Constructeur de la classe */
  IXMMeshReaderService(const Arcane::ServiceBuildInfo & sbi) 
    : Arcane::BasicService(sbi)
    , m_ixm_mesh_reader(NULL)
    , m_ixm_mesh_builder(sbi.subDomain())
    , m_ixm_property_builder(NULL)
    , m_uid2lid_mng(NULL){}
  
  /** Destructeur de la classe */
  ~IXMMeshReaderService()
  {
    if (m_ixm_mesh_reader) delete m_ixm_mesh_reader;
    if (m_ixm_property_builder) delete m_ixm_property_builder;
    if (m_uid2lid_mng) delete m_uid2lid_mng;
  }
  
public:

  //! V�rifie si le service supporte les fichiers avec l'extension \a str
  bool allowExtension(const String& str);

  //! Lit le maillage format xml � partir du fichier
  Arcane::IMeshReader::eReturnType readMeshFromFile(Arcane::IPrimaryMesh* mesh,
                                                    const Arcane::XmlNode& mesh_element,
                                                    const Arcane::String& file_name,
                                                    const Arcane::String& dir_name,
                                                    bool use_internal_partition);

private:

  ArcGeoSim::IIXMStaticMeshReader* m_ixm_mesh_reader = nullptr;
  ArcGeoSim::IXMStaticMeshBuilder m_ixm_mesh_builder;
  ArcGeoSim::IXMStaticPropertyBuilder* m_ixm_property_builder = nullptr;
  ArcGeoSim::IXMUidToLidMng* m_uid2lid_mng = nullptr;

  ArcGeoSim::IXMDataExchanger* ixmDataExchanger() { return ArcGeoSim::IXMDataExchanger::instance();}
};



/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

bool
IXMMeshReaderService::
allowExtension(const String& str)
{
  return str == "ixm";
}

/*---------------------------------------------------------------------------*/

Arcane::IMeshReader::eReturnType
IXMMeshReaderService::
readMeshFromFile(Arcane::IPrimaryMesh* mesh,
                 const Arcane::XmlNode& mesh_element,
                 const Arcane::String& file_name,
                 const Arcane::String& dir_name,
                 bool use_internal_partition)
{
  Arcane::Trace::Setter setter(traceMng(),"IXMMeshReader");

  info() << "=== READING IXM STATIC MESH ===";

  if (! use_internal_partition && subDomain()->parallelMng()->isParallel())
    warning() << "No partitioner plugged in. Initial mesh will not be distributed. OK for evolutive mesh case with empty initial mesh.";

  // Get Version : temporary for first sequential test. To be changed with parallel refactoring
  ArcGeoSim::IXMMeshVersion mesh_version = ArcGeoSim::IXMMeshFile(file_name).version(subDomain()->ioMng(),subDomain()->parallelMng());
  switch (mesh_version()) {
    case ArcGeoSim::IXMV4:
      m_ixm_mesh_reader = new ArcGeoSim::IXMV4MeshReader(subDomain()->ioMng(), subDomain()->parallelMng(), subDomain()->traceMng());
      break;
    case ArcGeoSim::IXMV3:
      m_ixm_mesh_reader = new ArcGeoSim::IXMV3MeshReader(subDomain()->ioMng(), subDomain()->parallelMng(), subDomain()->traceMng());
      break;
    case ArcGeoSim::IXMV4_1_0:
      m_ixm_mesh_reader = new ArcGeoSim::IXMV4_1MeshReader(subDomain()->ioMng(),
                                                           subDomain()->parallelMng(), subDomain()->traceMng());
      break;
    case ArcGeoSim::UndefinedIXMVersion:
      fatal() << "Cannot read ixm file : " << file_name << " Unknown ixm version : " << mesh_version.str();
      break;
  }

    // Load file. Share file name with possible evolutive mesh service
  m_ixm_mesh_reader->loadMeshFile(file_name);
  ixmDataExchanger()->setMeshFile(file_name);
  ixmDataExchanger()->setMeshType(m_ixm_mesh_reader->meshDimension().name());

    // Get mesh infos : data must be shared between static and evolutive mesh
  bool check_mesh_data = true;
  ArcGeoSim::IXMTools::IXMMeshInfo check_mesh_info(this->mesh()->dimension(),check_mesh_data);

  // Set dimension. Needed before reading to ensure coherence while reading (pre allocation is done here)
  m_ixm_mesh_builder.setDimension(mesh,m_ixm_mesh_reader->meshDimension());
    check_mesh_info.setMeshDimension(this->mesh()->dimension());

  // == Read mesh ==

  if ( !m_ixm_mesh_reader->hasMeshData() ) return RTOk;


  // Read Cells
  ArcGeoSim::IXMCellData cell_data;
  // Parallel V0
  ArcGeoSim::ParallelUtils parallel_utils(subDomain()->parallelMng());
  bool is_master = parallel_utils.isMaster();

    if (is_master) m_ixm_mesh_reader->readCellData(cell_data,check_mesh_info);

  // Read nodes
  ArcGeoSim::IXMNodeData node_data;
  if (is_master) m_ixm_mesh_reader->readNodeData(node_data,check_mesh_info);

  // Read Faces : parallel
  ArcGeoSim::IXMFaceData face_data;
  if (is_master) m_ixm_mesh_reader->readFaceData(face_data,check_mesh_info);

  // Read Edges : parallel
  ArcGeoSim::IXMEdgeData edge_data;
  if (is_master) m_ixm_mesh_reader->readEdgeData(edge_data,check_mesh_info);

  /*info() << "Number of edges" << edge_data.item_ids.size();
  for (int i=0;i<edge_data.item_ids.size();i++)
  {
	  info() << "edge" << i << " = " << edge_data.item_ids[i];
	  info() << "between node 1" " = " << edge_data.item_infos[2*i];
	  info() << "and node 2" " = " << edge_data.item_infos[2*i+1];
  }*/

  // Read Connections
  ArcGeoSim::IXMConnectionData connection_data;
  if (is_master) m_ixm_mesh_reader->readConnectionData(connection_data);

  // Read Groups : parallel
  ArcGeoSim::IXMGroupDataList group_data_list;
  m_ixm_mesh_reader->collectiveReadGroupData(group_data_list,parallel_utils);

  // Read Properties : parallel
  ArcGeoSim::IXMPropertyDataList property_data_list;
  m_ixm_mesh_reader->collectiveReadPropertyData(property_data_list,parallel_utils);

  // check  data JLP
  {
    String check = platform::getEnvironmentVariable("USE_IXMMESHCHECKER");
    if(!check.null())
    {
        ArcGeoSim::IXMStaticMeshChecker mesh_checker(cell_data,node_data,face_data,property_data_list,group_data_list,traceMng());
       mesh_checker.run();
    }
  }


  // == Build mesh ==

  // Create cells, faces and nodes
  m_ixm_mesh_builder.addCells(mesh,cell_data);
  m_ixm_mesh_builder.setNodeCoordinates(mesh,node_data);

  // Read Particles (ixm v4) should be after cell's builder
  if (mesh_version()==ArcGeoSim::IXMV4)
  {
    ArcGeoSim::IXMV4MeshReader* myReaderV4 = dynamic_cast<ArcGeoSim::IXMV4MeshReader*>(m_ixm_mesh_reader);
    myReaderV4->readParticleData(mesh);
  }

  // Faces : handle abstract ids. (choosing to use memory tracking to take into account initial mesh info when this option is true in evolutive mesh)
  bool use_memory = true;
  m_uid2lid_mng = new ArcGeoSim::IXMUidToLidMng(mesh,parallel_utils,use_memory,traceMng());
  bool do_check = true;

  // Faces
  m_uid2lid_mng->loadFaceAidMapping(face_data,do_check);

  // Edges
  m_uid2lid_mng->loadEdgeAidMapping(edge_data,do_check);

  // Connections
  m_ixm_mesh_builder.addConnections(mesh,connection_data,*m_uid2lid_mng);

  // Groups
  m_ixm_mesh_builder.addGroups(mesh,group_data_list,*m_uid2lid_mng);

  // Partition Constraints
  m_ixm_mesh_builder.applyMeshPartitionConstraints(mesh);

  // Properties
  m_ixm_property_builder = new ArcGeoSim::IXMStaticPropertyBuilder(mesh);
#if (ARCANE_VERSION >= 30003)
  m_ixm_property_builder->setGraph(GRAPH(mesh)) ;
#endif
  m_ixm_property_builder->setMeshDirectory(ArcGeoSim::IXMMeshFile(file_name).path());
  m_ixm_property_builder->createAndFillProperties(property_data_list,*m_uid2lid_mng);

  m_uid2lid_mng->endUsingAidMapping();

  return RTOk;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SUB_DOMAIN_FACTORY(IXMMeshReaderService,IMeshReader,IXMMeshReaderService);
