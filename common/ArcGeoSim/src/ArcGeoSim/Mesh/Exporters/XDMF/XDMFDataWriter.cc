#include "XDMFDataWriter.h"
/* Author : dechaiss at Wed Nov  3 11:03:03 2010
 * Generated by createNew
 */

#include <arcane/XmlNode.h>
#include <arcane/XmlNodeList.h>
#include <arcane/XmlNodeIterator.h>
#include <arcane/DomUtils.h>

#include <arcane/utils/ScopedPtr.h>
#include <arcane/ItemGroup.h>
#include <arcane/ISerializedData.h>
#include <arcane/IData.h>
#include <arcane/SerializeBuffer.h>
#include <arcane/IItemFamily.h>

#include <arcane/ArcaneTypes.h>
#include <arcane/utils/Array.h>
#include <arcane/utils/Real3.h>
#include "arcane/utils/List.h"
#include <arcane/utils/OStringStream.h>
#include <arcane/DomUtils.h>
#include <arcane/ISubDomain.h>
#include <arcane/ItemGroup.h>
#include <arcane/Directory.h>
#include <arcane/IPostProcessorWriter.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/IVariableMng.h>
#include <arcane/IMesh.h>
#include <arcane/IItemFamily.h>
#include <arcane/utils/PlatformUtils.h>
#include <arcane/IRessourceMng.h>
#include <arcane/PostProcessorWriterBase.h>
#include <arcane/Directory.h>

#include "ArcGeoSim/Mesh/Utils/StringToItemUtils.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMTools.h"

#include "ArcGeoSim/Utils/ArrayUtils.h"
#include "ArcGeoSim/Utils/DataTypeUtils.h"

#include "ArcGeoSim/Mesh/Exporters/IXM4/Formatter.h"
#include "ArcGeoSim/Mesh/Exporters/IXM4/VariableStrideFormatter.h"
#include "ArcGeoSim/Mesh/Exporters/IXM4/FixedStrideFormatter.h"
#include "ArcGeoSim/Mesh/Exporters/IXM4/NoFormatter.h"

#include "XDMFPropertyInfo.h"

#include <ctype.h>

#include <map>
#include <boost/shared_ptr.hpp>

using namespace Arcane;

/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/

XDMFDataWriter::
XDMFDataWriter(IMesh* mesh,IXmlDocumentHolder* output_doc,const String& directory_name,const Integer event_number, bool event_initialized) :
#ifdef USE_ARCANE_V3
  ArcGeoSim::DualGraphBasedModel(mesh,true),
#endif
  m_mesh(mesh)
, m_directory_name(directory_name)
, m_trace_mng(m_mesh->subDomain()->traceMng())
, m_ressource_mng(m_mesh->subDomain()->ressourceMng())
, m_io_mng(m_mesh->subDomain()->ioMng())
, m_event_number(event_number)
, m_events_initialized(event_initialized)
, m_supported_version("V4")
, m_save_increment_mesh(false)
, m_write_initial_grid_properties(false)
, m_begin_time(0)
#if (ARCANE_VERSION >= 30003)
, m_connection_mng(m_mesh,m_graph)
#else
, m_connection_mng(m_mesh)
#endif
, m_output_doc(output_doc)
{
}

/*---------------------------------------------------------------------------*/

XDMFDataWriter::
~XDMFDataWriter()
{
}


/*---------------------------------------------------------------------------*/

/**********************************************************************
 * [beginWrite]
 **********************************************************************/
void
XDMFDataWriter::
beginMeshWrite(const String& file_name, const String& format, ItemGroupCollection& groups,VariableCollection& vars){

	m_format = format;

	/****************************************
	 * Create/append Ixm files
	 ****************************************/
	createXdmfFile(file_name);

	/****************************************
	 * Create/update Ixm document
	 ****************************************/
	if(!m_events_initialized){
		createXdmfDoc();
	} else {
		//loadXdmfDoc();
	}

	/****************************************
	// record groups to be exported
	****************************************/
	m_groups=groups;
}


// Ecriture d'un maillage non-evolutif
/**********************************************************************
 * [writeMeshToFile]
 **********************************************************************/
void
XDMFDataWriter::
writeMeshToFile(const String& file_name){

	IParallelMng* pm=  m_mesh->subDomain()->parallelMng();

	// Get event parent node
	XmlNode xdmf_node = m_xdmf_doc.child("Xdmf");
	XmlNode xdmf_dom = xdmf_node.child("Domain");
	XmlNode grid_head = xdmf_dom.child("Grid");

	// Create initial grid

	XmlElement xdmf_initial_grid(grid_head,"Grid");

	xdmf_initial_grid.setAttrValue("Name","grid_000");
	xdmf_initial_grid.setAttrValue("Type","Uniform");

	// Create initial time

	XmlElement xdmf_time(xdmf_initial_grid,"Time");

	xdmf_time.setAttrValue("Type","Single");
	xdmf_time.setAttrValue("Value","0.00000000");

    // Retrieve nodes unique ids

	Int64SharedArray nodesUniqueIDs; // Unique nodes-IDs array

	ENUMERATE_NODE(iNode,m_mesh->allNodes()){
		nodesUniqueIDs.add(iNode->uniqueId().asInt64());
	}

	// Fill tab for formatting ixm output
	Integer nbCells = m_mesh->allCells().size();
	SharedArray<Integer> strides(nbCells);

	// Retrieve topology

	SharedArray<Integer> arcCellConnectivityArray;

	ENUMERATE_CELL(iCell,m_mesh->allCells()){// Scanning the cells' nodes to get type and connectivity
		Cell cell = *iCell;
		Integer  nbNodes = cell.nbNode();

		Integer arcBefore = arcCellConnectivityArray.size();

		_switchXmfType(cell.type(), arcCellConnectivityArray);

		Integer meshNbNodes=m_mesh->nbNode();

		for(Integer j=0; j<nbNodes;++j){
			Int64 uid=cell.node(j).uniqueId().asInt64();
			for(Integer i=0; i<meshNbNodes; ++i){
				if (nodesUniqueIDs[i] != uid) continue;
				arcCellConnectivityArray.add(i);
				break;
			}
		}

		Integer arcAfter = arcCellConnectivityArray.size();
		strides[iCell.index()] = arcAfter - arcBefore;

	}

	// Create topology

	if(pm->isMasterIO())
	{

		XmlElement xdmf_topology(xdmf_initial_grid,"Topology");

		xdmf_topology.setAttrValue("NumberOfElements",String::format("{0}",m_mesh->allCells().size()));
		xdmf_topology.setAttrValue("Type","Mixed");

		if(m_format == "XML")
		{
			XDMFDataNode<Int32>::createXDMFDataNode(xdmf_topology, arcCellConnectivityArray, XMLFormatBuildInfo<Int32>(VariableStrideFormatter<Int32>(strides)));
		}
		else
		{
			String hdata_ids(String::format("{0}/{1}/incid",m_hdf_path,xdmf_initial_grid.attrValue("Name")));
			XDMFDataNode<Int32>::createXDMFDataNode(xdmf_topology,arcCellConnectivityArray, HDFFormatBuildInfo(hdata_ids,m_output_directory));
		}
	}

	// Retrieve geometry

	SharedArray<Real> nodeValues ;

	VariableItemReal3& nodes_coords =m_mesh->nodesCoordinates();

	SharedArray<Real3> coords;
	coords.reserve(m_mesh->nbNode());

	ENUMERATE_NODE(inode,m_mesh->ownNodes()){
		coords.add(nodes_coords[inode]);
	}

	// Create geometry

	if(pm->isMasterIO())
	{
		XmlElement xdmf_geometry(xdmf_initial_grid,"Geometry");
		xdmf_geometry.setAttrValue("Type","XYZ");

		if(m_format == "XML")
		{
			XDMFDataNode<Real3>::createXDMFDataNode(xdmf_geometry, coords,XMLFormatBuildInfo<Real3>(FixedStrideFormatter<Real3>(1)));
		}
		else
		{
			String str_coords(String::format("{0}/{1}/coords",m_hdf_path,xdmf_initial_grid.attrValue("Name")));
			XDMFDataNode<Real3>::createXDMFDataNode(xdmf_geometry,coords, HDFFormatBuildInfo(str_coords,m_output_directory));
		}
	}

	// Prepare properties dump (done in write(ivar,idata))
	m_initial_grid_node = xdmf_initial_grid;
	m_write_initial_grid_properties = true;
}

// Ecriture d'un maillage dynamique
/**********************************************************************
 * [writeEventToFile]
 **********************************************************************/
void
XDMFDataWriter::
writeEventToFile(const String& file_name, const Real& begin_time, const Real& end_time, const Integer& event_number){

	m_begin_time = begin_time;

	updateXdmfDoc(m_begin_time,end_time,event_number);

	/****************************************
	 * Build a mesh increment element if needed
	 ****************************************/
	buildMeshIncrement(m_format,m_save_increment_mesh);

}

/**********************************************************************
 * [endWrite]
 **********************************************************************/
void
XDMFDataWriter::
endMeshWrite()
{

	 ByteSharedArray xml_bytes;
	 m_output_doc->save(xml_bytes);

	 m_io_mng->writeXmlFile(m_output_doc, String::format("{0}/{1}.xmf",m_output_directory,m_output_file),true);

}


// mesh-increment Element
/**********************************************************************
 * [meshIncrementElement]
 **********************************************************************/
void
XDMFDataWriter::
buildMeshIncrement(const String& format, const bool& save_it) {

	IParallelMng* pm=  m_mesh->subDomain()->parallelMng();

	// Retrieve nodes unique ids

		Int64SharedArray nodesUniqueIDs; // Unique nodes-IDs array

		ENUMERATE_NODE(iNode,m_mesh->allNodes()){
			nodesUniqueIDs.add(iNode->uniqueId().asInt64());
		}

		// Fill tab for formatting ixm output
		Integer nbCells = m_mesh->allCells().size();
		SharedArray<Integer> tab(nbCells);

		// Retrieve topology

		SharedArray<Integer> arcCellConnectivityArray;

		ENUMERATE_CELL(iCell,m_mesh->allCells()){// Scanning the cells' nodes to get type and connectivity
			Cell cell = *iCell;
			Integer  nbNodes = cell.nbNode();

			Integer arcBefore = arcCellConnectivityArray.size();

			_switchXmfType(cell.type(), arcCellConnectivityArray);

			Integer meshNbNodes=m_mesh->nbNode();

			for(Integer j=0; j<nbNodes;++j){
				Int64 uid=cell.node(j).uniqueId().asInt64();
				for(Integer i=0; i<meshNbNodes; ++i){
					if (nodesUniqueIDs[i] != uid) continue;
					arcCellConnectivityArray.add(i);
					break;
				}
			}

			Integer arcAfter = arcCellConnectivityArray.size();
			tab[iCell.index()] = arcAfter - arcBefore;

		}

		// Create topology
		if(pm->isMasterIO())
		{
			XmlElement xdmf_topology(m_current_grid_node,"Topology");

			xdmf_topology.setAttrValue("NumberOfElements",String::format("{0}",m_mesh->allCells().size()));
			xdmf_topology.setAttrValue("Type","Mixed");

			if(m_format == "XML")
			{
				XDMFDataNode<Int32>::createXDMFDataNode(xdmf_topology, arcCellConnectivityArray, XMLFormatBuildInfo<Int32>(VariableStrideFormatter<Int32>(tab)));
			}
			else
			{
				String hdata_ids(String::format("{0}/{1}/incid",m_hdf_path,m_current_grid_node.attrValue("Name")));
				XDMFDataNode<Int32>::createXDMFDataNode(xdmf_topology,arcCellConnectivityArray, HDFFormatBuildInfo(hdata_ids,m_output_directory));
			}
		}

		// Retrieve geometry

		SharedArray<Real> nodeValues ;

		VariableItemReal3& nodes_coords =m_mesh->nodesCoordinates();

		SharedArray<Real3> coords;
		coords.reserve(m_mesh->nbNode());

		ENUMERATE_NODE(inode,m_mesh->ownNodes()){
			coords.add(nodes_coords[inode]);
		}

		// Create geometry

		if(pm->isMasterIO())
		{
			XmlElement xdmf_geometry(m_current_grid_node,"Geometry");
			xdmf_geometry.setAttrValue("Type","XYZ");

			if(m_format == "XML")
			{
				XDMFDataNode<Real3>::createXDMFDataNode(xdmf_geometry, coords,XMLFormatBuildInfo<Real3>(FixedStrideFormatter<Real3>(1)));
			}
			else
			{
				String str_coords(String::format("{0}/{1}/coords",m_hdf_path,m_current_grid_node.attrValue("Name")));
				XDMFDataNode<Real3>::createXDMFDataNode(xdmf_geometry,coords, HDFFormatBuildInfo(str_coords,m_output_directory));
			}
		}
}


void
XDMFDataWriter::
beginWrite(const VariableCollection &vars)
{
	//if (m_write_initial_grid_properties) m_initial_grid_properties_node = XmlElement(m_initial_grid,"Attribute");

	//m_current_grid_properties_node = XmlElement(m_current_grid,"Attribute");
}

/*---------------------------------------------------------------------------*/

void
XDMFDataWriter::
write(Arcane::IVariable* ivar, Arcane::IData* data)
{
	  Trace::Setter trace(m_trace_mng,"XDMFDataWriter");

	  m_trace_mng->debug() << "Write Variable " << ivar->name();

	  XDMFPropertyInfo* prop = XDMFPropertyInfo::create(ivar);

	  if (m_format == "HDF") prop->setPath(m_hdf_path,m_output_directory);

	  if (m_write_initial_grid_properties) prop->writeProperty(m_initial_grid_node,m_format);

	  prop->writeProperty(m_current_grid_node,m_format,m_begin_time);

}


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/


/**********************************************************************
 * [createXdmfFile]
 **********************************************************************/
void
XDMFDataWriter::
createXdmfFile(const String& file_name)
{
	// output file name

	Arcane::SharedArray<String> temp_array;

	Arcane::String outputfilename;

	// use m_directory_name instead of ArcGeoSim::getOuputRootPath()
	// but problem in ArcGeoSimPostProcessorBase init method
	m_output_directory = ArcGeoSim::getOuputRootPath() + "/" + platform::getFileDirName(file_name);

	Arcane::SharedArray<String> small_array;

	file_name.split(small_array,'/');

	small_array.back().split(temp_array,'.');

	m_output_base_file = temp_array[0];

	outputfilename = temp_array[0]+".xmf";

	m_trace_mng->info() << " output directory = " <<  m_output_directory ;

	m_trace_mng->info() << " output file = " <<  outputfilename ;

	// create directory if necessary

	platform::recursiveCreateDirectory(m_output_directory);

	// init m_output_file

	Arcane::StringSharedArray array;
	//file_name.split(array,'.');
	outputfilename.split(array,'.');

	m_output_file=array[0];

	m_trace_mng->info() << " output file = " <<  m_output_file ;

	if(m_format=="HDF"){

		String hdf_file_name_with_path = hdfFileName();
		Arcane::StringSharedArray str_array;
		hdf_file_name_with_path.split(str_array,'/');
		String hdf_file_name = str_array.back();

		// m_hdf_path is relative to xmf file
		m_hdf_path=String::format("{0}:",hdf_file_name);

		Hdf5Utils::HFile hdf_file;
		if(m_mesh->subDomain()->parallelMng()->isMasterIO())
		{
			if(m_events_initialized)
				hdf_file.openAppend(Arcane::String::concat(m_output_directory,"/",hdf_file_name));
			else
				hdf_file.openTruncate(Arcane::String::concat(m_output_directory,"/",hdf_file_name));
		}

	}

}


/**********************************************************************
 * [createXdmfDoc]
 **********************************************************************/
void
XDMFDataWriter::
createXdmfDoc()
{
	//m_output_doc = m_ressource_mng->createXmlDocument();
	m_xdmf_doc = m_output_doc->documentNode();
	// Create xdmf root node with supported version
	XmlElement xdmf_root(m_xdmf_doc,"Xdmf");
	xdmf_root.setAttrValue("Version","2.0");
	// Create domain node
	XmlElement xdmf_domain(xdmf_root,"Domain");
	// Create head of grid nodes
	XmlElement xdmf_grid_head(xdmf_domain,"Grid");
	xdmf_grid_head.setAttrValue("CollectionType","Temporal");
	xdmf_grid_head.setAttrValue("GridType","Collection");

}

/**********************************************************************
 * [loadXdmfDoc]
 **********************************************************************/
void
XDMFDataWriter::
loadXdmfDoc()
{

	m_mesh->subDomain()->parallelMng()->barrier();

	//m_output_doc = m_io_mng->parseXmlFile(xmfFileName(),NULL,"");

	dom::DOMImplementation domimp;
	const char* cschemaname = 0;
	m_output_doc =  domimp._load(xmfFileName(),m_trace_mng,cschemaname);
	m_xdmf_doc = m_output_doc->documentNode();

	// Check
	if (m_output_doc == NULL)
		m_trace_mng->fatal() << "Could not load Xdmf file " << xmfFileName();
}


/**********************************************************************
 * [updateIxmDoc]
 **********************************************************************/
void
XDMFDataWriter::
updateXdmfDoc(const Real& begin_time, const Real& end_time, const Integer& event_number)
{
	// Get event parent node
	m_xdmf_doc = m_output_doc->documentNode();
	XmlNode xdmf_node = m_xdmf_doc.child("Xdmf");
	XmlNode xdmf_dom = xdmf_node.child("Domain");
	XmlNode grid_head = xdmf_dom.child("Grid");

	// Create current grid

	XmlElement xdmf_current_grid(grid_head,"Grid");

	xdmf_current_grid.setAttrValue("Name",String::format("Grid_{0}",event_number));
	xdmf_current_grid.setAttrValue("Type","Uniform");

	// Create time

	XmlElement xdmf_time(xdmf_current_grid,"Time");

	xdmf_time.setAttrValue("Type","Single");
	xdmf_time.setAttrValue("Value",String::format("{0}",begin_time) );

	// Set current grid
	m_current_grid_node = xdmf_current_grid;
}


/**********************************************************************
 * [baseFileName]
 **********************************************************************/
const String
XDMFDataWriter::
baseFileName() const
{
	// File name
	return String::format("{0}/{1}",m_output_directory,m_output_file);
}

/**********************************************************************
 * [IxmFileName]
 **********************************************************************/
const String
XDMFDataWriter::
xmfFileName() const
{
	// File name
	return String::format("{0}/{1}.xmf",m_output_directory,m_output_file);
}

/**********************************************************************
 * [hdf5FileName]
 **********************************************************************/
const String
XDMFDataWriter::
hdfFileName() const
{
	// File name
    // SDC hdf file is relative to xmf file => no directory

	 return String::format("{0}.h5",m_output_base_file);
}

/*****************************************************************************\
* [_switchXmfType]			 																	*
\*****************************************************************************/
void XDMFDataWriter::_switchXmfType(Integer arc_type, Array<Integer>& arcConnectivityArray){
  if (arc_type > ItemTypeMng::nbBasicItemType()){
	 arcConnectivityArray.add(XDMF_NOTOPOLOGY);
	 return;
  }

  switch(arc_type){
  case (IT_NullType): arcConnectivityArray.add(XDMF_NOTOPOLOGY);return;

  case (IT_Vertex):
	 arcConnectivityArray.add(XDMF_POLYVERTEX);
	 arcConnectivityArray.add(1ul); return;

  case (IT_Line2):
	 arcConnectivityArray.add(XDMF_POLYLINE);
	 arcConnectivityArray.add(2ul); return;

  case (IT_Triangle3): arcConnectivityArray.add(XDMF_TRI); return;
  case (IT_Quad4): arcConnectivityArray.add(XDMF_QUAD);  return;
  case (IT_Pentagon5): arcConnectivityArray.add(XDMF_POLYGON); return;
  case (IT_Hexagon6): arcConnectivityArray.add(XDMF_POLYGON); return;
  case (IT_Tetraedron4): arcConnectivityArray.add(XDMF_TET); return;
  case (IT_Pyramid5): arcConnectivityArray.add(XDMF_PYRAMID); return;
  case (IT_Pentaedron6): arcConnectivityArray.add(XDMF_WEDGE); return;
  case (IT_Hexaedron8):	arcConnectivityArray.add(XDMF_HEX); return;
  case (IT_Heptaedron10):	arcConnectivityArray.add(XDMF_TET_10); return;

  case (IT_Octaedron12):
	 arcConnectivityArray.add(XDMF_POLYVERTEX);
	 arcConnectivityArray.add(12ul); return;
  case (IT_HemiHexa7):
	 arcConnectivityArray.add(XDMF_POLYVERTEX);
	 arcConnectivityArray.add(7ul); return;

	 //warning IT_AntiWedgeLeft6 IT_AntiWedgeRight6 and IT_HemiHexa6 are merged
  case (IT_HemiHexa6):
  case (IT_AntiWedgeLeft6):
  case (IT_AntiWedgeRight6):
	 arcConnectivityArray.add(XDMF_POLYVERTEX);
	 arcConnectivityArray.add(6ul); return;

	 //warning IT_HemiHexa5 and IT_DiTetra5 are merged
  case (IT_HemiHexa5):
  case (IT_DiTetra5):
	 arcConnectivityArray.add(XDMF_POLYVERTEX);
	 arcConnectivityArray.add(5ul); return;

  case (IT_DualNode):
  case (IT_DualEdge):
  case (IT_DualFace):
  case (IT_DualCell): arcConnectivityArray.add(XDMF_NOTOPOLOGY); return;

#if ARCANE_VERSION > 12201 || (ARCANE_VERSION==12201 && ARCANE_VERSION_BETA > 0)
  case (IT_Enneedron14):
         arcConnectivityArray.add(XDMF_POLYVERTEX);
         arcConnectivityArray.add(14ul); return;
  case (IT_Decaedron16):
         arcConnectivityArray.add(XDMF_POLYVERTEX);
         arcConnectivityArray.add(16ul); return;

  case (IT_Heptagon7): arcConnectivityArray.add(XDMF_POLYGON); return;
  case (IT_Octogon8): arcConnectivityArray.add(XDMF_POLYGON); return;
#endif

  default: arcConnectivityArray.add(XDMF_NOTOPOLOGY);return;
  }
  arcConnectivityArray.add(XDMF_NOTOPOLOGY);
}


/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
