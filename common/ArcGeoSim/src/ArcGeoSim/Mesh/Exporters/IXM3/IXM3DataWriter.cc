/* Author : dechaiss at Wed Nov  3 11:03:03 2010
 * Generated by createNew
 */

#include <arcane/XmlNode.h>
#include <arcane/XmlNodeList.h>
#include <arcane/XmlNodeIterator.h>
#include <arcane/DomUtils.h>

#include <arcane/utils/ScopedPtr.h>
#include <arcane/ItemGroup.h>
#include <arcane/ISerializedData.h>
#include <arcane/IData.h>
#include <arcane/SerializeBuffer.h>
#include <arcane/IItemFamily.h>

#include "IXM3DataWriter.h"

#include "ArcGeoSim/Mesh/Utils/StringToItemUtils.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/IXMTools.h"
#include "ArcGeoSim/Mesh/Utils/IXMTools/ixm_v3_xsd.h"
#include "ArcGeoSim/Utils/ArrayUtils.h"
#include "ArcGeoSim/Utils/DataTypeUtils.h"

#include <ctype.h>

#include <map>
#include <boost/shared_ptr.hpp>

/*---------------------------------------------------------------------------*/

class IXM3DataWriter::InternalArrayRegister {
public:
  class IArrayCopier {
  public:
    virtual ~IArrayCopier() { }
    virtual void write(std::ostream & o) const = 0;
  };

  template<typename T>
  String registerArray(SharedArray<T> array)
  {
    IArrayCopier * copier = new ArrayCopierT<T>(array);
    String array_key = String::format("{0}",copier);
    if (m_data_map.find(array_key) != m_data_map.end())
      throw FatalErrorException(A_FUNCINFO,"Conflicting existing key in InternalArrayRegister");
    m_data_map[array_key].reset(copier);
    return array_key;
  }

  const IArrayCopier * retrieveArray(String key) const
  {
    std::map<String, boost::shared_ptr<IArrayCopier> >::const_iterator finder = m_data_map.find(key);
    if (finder == m_data_map.end()) 
      return NULL;
    else
      return finder->second.get();
  }

private:
  template<typename T>
  class ArrayCopierT : public IArrayCopier {
  public:
    ArrayCopierT(SharedArray<T> array) : m_array(array) { }
    void write(std::ostream & o) const
    {
      for(Integer i=0;i<m_array.size();++i)
        o << ' ' << m_array[i];
    }
  private:
    SharedArray<T> m_array;
  };

  std::map<String, boost::shared_ptr<IArrayCopier> > m_data_map;
};

template<>
class IXM3DataWriter::InternalArrayRegister::ArrayCopierT<Real3> : public IArrayCopier {
public:
  ArrayCopierT(SharedArray<Real3> array) : m_array(array) { }
  void write(std::ostream & o) const
  {
    for(Integer i=0;i<m_array.size();++i)
      {
        const Real3 & v = m_array[i];
        o << ' ' << v.x << ' ' << v.y << ' ' << v.z;
      }
  }
private:
  SharedArray<Real3> m_array;
};

/*---------------------------------------------------------------------------*/

IXM3DataWriter::
IXM3DataWriter(PostProcessorWriterBase* post_pro_base,IMesh* mesh,
               const Integer event_number, bool event_initialized,
               const bool want_face_aid)
  : m_post_pro_base(post_pro_base)
  , m_mesh(mesh)
  , m_trace_mng(post_pro_base->traceMng())
  , m_ressource_mng(post_pro_base->subDomain()->ressourceMng())
  , m_io_mng(post_pro_base->subDomain()->ioMng())
  , m_events_doc(NULL)
  , m_current_event_doc(NULL)
  , m_events_filename("Events.xml")
  , m_event_number(event_number)
  , m_events_initialized(event_initialized)
  , m_common_variables(post_pro_base->subDomain()->commonVariables())
  , m_default_event_filename("Event")
  , m_var(NULL)
  , m_data(NULL)
  , m_parallel_mng(post_pro_base->subDomain()->parallelMng())
  , m_is_parallel(m_parallel_mng->isParallel())
  , m_is_master(m_parallel_mng->isMasterIO())
  , m_supported_version("V3")
  , m_has_face_aids(want_face_aid)
  , m_array_register(NULL)
  , m_magic_intern_keyword("magic-intern-reference")
  , m_magic_comment_keyword("magic-comment")
{
  m_array_register = new InternalArrayRegister();
}

/*---------------------------------------------------------------------------*/

IXM3DataWriter::
~IXM3DataWriter()
{
  delete m_array_register;
}

/*---------------------------------------------------------------------------*/

void
IXM3DataWriter::
beginWrite(const VariableCollection &vars)
{
  // FaceOfInterest handling
  FaceOfInterestData face_of_interest_data;
  _getFaceOfInterestData(face_of_interest_data,vars);

  // Create global event doc: only by IO master.
  if (m_is_master)
    {
      // Create or load Events XML Doc
      if (!m_events_initialized) _createEventsDoc();
      else
        _loadEventsDoc();

      // Update Events Doc
      _updateEventsDoc();

      // Write Event file (return true if error)
      // Add argument true to writeXmlFile (for indentation) as soon as available in Arcane.
      if (m_io_mng->writeXmlFile(m_events_doc, _eventsFileName(),true)) 
        m_trace_mng->fatal() << "Could not write events document in " << _eventsFileName() << " File";

      // Create current event tag
      // Present strategy: only IO master holds current event doc
      _createCurrentEventDoc(face_of_interest_data);
    }
}

/*---------------------------------------------------------------------------*/

void
IXM3DataWriter::
write(Arcane::IVariable* var, Arcane::IData* data)
{
  // Parallel: all processes.
  //
  // Present strategy: only IO master writes => support_string and values_string are empty
  // on all processes except IO master. IO Master collects info from other processes in the methods
  // _getPropertySupport() and _getPropertyValues()

  // Store current var and data
  m_var = var;
  m_data = data;

  //-- Property --
  _getPropertyGroup();
  const String support_key = _getPropertySupport();
  const String values_key = _getPropertyValues();

  //---create property node in current_event_doc
  if (m_is_master) _createPropertyNode(support_key,values_key);
}

/*---------------------------------------------------------------------------*/

void
IXM3DataWriter::
endWrite()
{
  // Write current event doc
  // Connection to file system: depends on parallelism strategy
  // Present strategy: only master writes
  if (m_is_master)
    {
      // IIOMng::writeXmlFile return true if error.

      // if (m_io_mng->writeXmlFile(m_current_event_doc, _currentEventFileName(),true))
      //  m_trace_mng->fatal() << "Could not write events document in " << _currentEventFileName() << " File";

      if (_magicWriteXmlFile(m_current_event_doc, _currentEventFileName())) 
        m_trace_mng->fatal() << "Could not write events document in " << _currentEventFileName() << " File";

      // Free memory. Doc only allocated in the master IO process
      delete m_current_event_doc;
      delete m_events_doc;
      m_var = NULL;
      m_data = NULL;
      m_group = ItemGroup();
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
IXM3DataWriter::
_createEventsDoc()
{
  m_events_doc = m_ressource_mng->createXmlDocument();
  XmlNode doc_node = m_events_doc->documentNode();
  // Create mesh root node with supported version
  XmlElement root_element(doc_node,"mesh");
  root_element.setAttrValue("version",m_supported_version);
  // Create grid node
  XmlElement grid_node(root_element,"grid");
  grid_node.setAttrValue("type", "unstructured-grid");
  // Get mesh dimension - kind of brute version : this is the behavior of ArcTem and affiliates (user of ixmV3)
  // For a smart dimension handling move to ixmV4.
  if (m_mesh->dimension() == 3) grid_node.setAttrValue("dimension", "3Dxyz");
  else if (m_mesh->dimension() == 2) grid_node.setAttrValue("dimension", "2Dyz");
  // If 1D : do not export dimension attribute.
}

/*---------------------------------------------------------------------------*/

void
IXM3DataWriter::
_loadEventsDoc()
{
  // Integrated xsd parse
  m_events_doc = m_io_mng->parseXmlFile(_eventsFileName(), "ixm_v3.xsd",
      ByteConstArrayView(strlen((const char*) ixm_v3_xsd), ixm_v3_xsd));

  // Check
  if (m_events_doc == NULL)
    m_trace_mng->fatal() << "Could not load Events file " << _eventsFileName();
}

/*---------------------------------------------------------------------------*/

void
IXM3DataWriter::
_updateEventsDoc()
{
  // Get event parent node
  XmlNode root_node = m_events_doc->documentNode();
  XmlNode mesh_node = root_node.child("mesh");
  XmlNode grid_node = mesh_node.child("grid");

  // Create event tag in global events doc
  XmlElement current_event_node(grid_node,"event");

  // Set event tag attributes
  current_event_node.setAttrValue("name",String::format("Event{0}",m_event_number));
  const String str_time = String::format("{0}",_getOutputTime());
  current_event_node.setAttrValue("begin-time",str_time);
  current_event_node.setAttrValue("end-time",str_time);

  // Create event tag child
  XmlElement extern_file_node(current_event_node,"extern-file");
  extern_file_node.setValue(_currentEventFileName());
}

/*---------------------------------------------------------------------------*/

void
IXM3DataWriter::
_createCurrentEventDoc(const FaceOfInterestData& face_of_interest_data)
{
  //-- In current event doc
  m_current_event_doc = m_ressource_mng->createXmlDocument();
  XmlNode doc_node = m_current_event_doc->documentNode();
  XmlElement root_element(doc_node, "extern");
  if (face_of_interest_data.m_has_face_property) _createFacesTag(root_element,face_of_interest_data);
  XmlElement properties_element(root_element, "properties");
}

/*---------------------------------------------------------------------------*/

const String
IXM3DataWriter::
_getPropertySupport()
{
  // get unique ids
  if (m_var->itemKind() == IK_Unknown) m_trace_mng->fatal()
      << "Item kind of Property unknown. Cannot write Property. Exiting";

  Arcane::ItemGroup local_item_group = m_group.own();
  Arcane::Integer local_item_group_size = local_item_group.size();
  Int64SharedArray unique_ids;
  unique_ids.reserve(local_item_group_size);
  // write unique ids
  ENUMERATE_ITEM(iitem, local_item_group) unique_ids.add(iitem->uniqueId());

  // write abstract ids if face property and if mapping is available
  bool is_face_property = (m_group.itemKind() == IK_Face);
  if (is_face_property && m_has_face_aids)
    {
      Arcane::Int64SharedArray face_aids;
      ArcGeoSim::IXMItemUidToAidMapper face_aid_mapper(m_mesh,m_parallel_mng, m_mesh->subDomain()->variableMng(),Arcane::IK_Face);
      face_aid_mapper.itemUniqueIdToAbstractId(face_aids,unique_ids);
      unique_ids = face_aids;
    }

  // Parallel treatment: unique_ids is modified only for masterIO. It contains the uids for the whole mesh.
  if (m_is_parallel) _getParallelWantedDataT<Int64>(unique_ids);

  //- save internally array and return a reference key
  String support_key;
  if (m_is_master)
    support_key = m_array_register->registerArray(unique_ids);

  return support_key;
}

/*---------------------------------------------------------------------------*/

const String
IXM3DataWriter::
_getPropertyValues()
{
  // Get data type
  eDataType data_type = m_var->dataType();

  // Get typed value : handle only types defined in mesh scheme topogeoprop.xsd
  String values_string;
  if (data_type == DT_Real) values_string = _getValuesT<Real> (); // "real-data"
  else if (data_type == DT_Int32) values_string = _getValuesT<Int32> (); //"int32-data"
  else if (data_type == DT_Int64) values_string = _getValuesT<Int64> (); // "int64-data"
  else if (data_type == DT_Real3) values_string = _getValuesT<Real3> (); // "real3-data"
  else if (data_type == DT_Byte) values_string = _getValuesT<Byte> (); // "bool-data"
  else
    m_trace_mng->fatal() << "Data type " << ArcGeoSim::DataTypeConversion::dataTypeToString(data_type) 
                         << " not supported to write in IXM format";

  return values_string;
}

/*---------------------------------------------------------------------------*/

void
IXM3DataWriter::
_getPropertyGroup()
{
  m_group = m_var->itemGroup();
}

/*---------------------------------------------------------------------------*/

template<typename T>
const String
IXM3DataWriter::
_getValuesT()
{
  //--Create ISerialized Data
//  IData* write_idata = m_data;

  // Serialize IData
#if ARCANE_VERSION > 30003
  //--- get IData for local items
  auto write_idata = _getLocalItemsData();

  auto sdata = write_idata->createSerializedDataRef(false);
  const void * ptr = ((ISerializedData const*)sdata.get())->bytes().data();
#else
  //--- get IData for local items
  IData* write_idata = _getLocalItemsData();

  ScopedPtrT<const ISerializedData> sdata(write_idata->createSerializedData(false));
  const void * ptr = sdata.get()->buffer().unguardedBasePointer();
#endif
  //-- Write buffer (type ByteConstArrayView) in a string
  //-- Remark: creating directly a string from the buffer (ByteConstArrayView) failed (return empty string).
  //---First store buffer in an Array
  Integer nb_element = sdata.get()->nbElement();
  ConstArrayView<T> values(nb_element, (const T*) ptr);
  SharedArray<T> values_array(values);

  // Parallel: values_array is modified only for masterIO. values_array on masterIO contains the values for the whole mesh.
  if (m_is_parallel) _getParallelWantedDataT<T>(values_array);

  //- save internally array and return a reference key
  String values_key;
  if (m_is_master) 
    values_key = m_array_register->registerArray(values_array);

#if ARCANE_VERSION <= 30003
  // Delete write_idata (created form a clone of m_data)
  delete write_idata;
#endif
  return values_key;
}

/*---------------------------------------------------------------------------*/

void
IXM3DataWriter::
_createPropertyNode(const String & support_key, const String & values_key)
{
  // Get Property parent node
  XmlNode root_node = m_current_event_doc->documentNode();
  XmlNode extern_node = root_node.child("extern");
  XmlNode properties_node = extern_node.child("properties");

  // Check node OK
  if (properties_node.null()) 
    m_trace_mng->fatal() << "parent node in _createProperyNode is empty; Exiting";

  // Create node
  XmlElement property_node(properties_node, "property");

  // Set attributes
  String data_type = ArcGeoSim::DataTypeConversion::dataTypeToString(m_var->dataType());
  property_node.setAttrValue("type", data_type);
  property_node.setAttrValue("group-name", m_group.name());
  property_node.setAttrValue("kind", ArcGeoSim::StringToItemUtils::itemKindToString(m_var->itemKind()));
  property_node.setAttrValue("name", m_var->name());

  // Create and fill support node
  XmlElement support_node(property_node, "support");
  XmlElement support_magic_node(support_node, m_magic_intern_keyword);
  support_magic_node.setAttrValue("reference",support_key);

  // Create values node
  XmlElement values_node(property_node, "values");
  values_node.setAttrValue("time", String::format("{0}",_getOutputTime()));

  // Create child data node and fill with values
  XmlElement data_node(values_node, "data");
  XmlElement typed_data_node(data_node,_dataNodeName(data_type));
  XmlElement typed_data_magic_node(typed_data_node, m_magic_intern_keyword);
  typed_data_magic_node.setAttrValue("reference",values_key);
}

/*---------------------------------------------------------------------------*/

template<typename T>
void
IXM3DataWriter::
_getParallelWantedDataT(SharedArray<T>& array)
{
  // Parallel strategy: gather all the data in masterIO process

  // Allocate reception buffer
  SharedArray<T> recv_buff;

  // gather data information in one process: masterIO process
  // Hypothesis each call of gather variable concatenate in the same order
  // (support and values of the variable created separately)
  m_parallel_mng->gatherVariable(array.constView(), recv_buff, m_parallel_mng->masterIORank());

  // store in original array, only in masterIO
  if (m_is_master)
    {
      array = recv_buff;
    }
}

/*---------------------------------------------------------------------------*/

#if ARCANE_VERSION > 30003
Arcane::Ref<IData>
#else
IData*
#endif
IXM3DataWriter::
_getLocalItemsData() const
{
  // Get IData only for items local to current process using method _createPartialIData(data,ids)

  //--First get local_ids of items owned by the current process

  //--Get unique_ids
  ItemGroup local_item_group = m_group.own();
  Integer nb_local_item = local_item_group.size();
  Int64SharedArray unique_ids;
  unique_ids.reserve(nb_local_item);
  ENUMERATE_ITEM(iitem, local_item_group)
    {
      unique_ids.add(iitem->uniqueId());
    }

  //--Create IData containing only data owned by the current process
  if (m_var->isPartial())
    {
      Int32SharedArray local_ids(nb_local_item);
      for(Integer i=0;i<nb_local_item;++i)
        local_ids[i] = i;
      return _createPartialIData(m_data,local_ids.constView());
    } 
  else 
    {
      //--Convert into local_ids
      Int32SharedArray local_ids(nb_local_item);
      m_var->itemFamily()->itemsUniqueIdToLocalId(local_ids,unique_ids.constView(),true);      
      return _createPartialIData(m_data,local_ids.constView());
    }
}

/*---------------------------------------------------------------------------*/

#if ARCANE_VERSION > 30003
Arcane::Ref<IData>
#else
IData*
#endif
IXM3DataWriter::
_createPartialIData(IData* const data, Int32ConstArrayView ids) const
{
  // Create a new IData from data, containing only the items described by ids
  // new IData*
#if ARCANE_VERSION > 30003
  auto local_data = data->cloneEmptyRef();
#else
  IData* local_data = data->cloneEmpty();
#endif
  // Algorithm :
  // 1-Allocate buffer to receive values of wanted items;
  // 2-Using method data->serialize, store in a buffer the values of data for theses items;
  // 3-Using method local_data->serialize copy in the new IData local_data the values previously stored in the buffer.

  //1--Allocate buffer
  SerializeBuffer sbuf;
  sbuf.setMode(ISerializer::ModeReserve);
  data->serialize(&sbuf,ids,0);
  sbuf.allocateBuffer();

  //--2-Store in the buffer data values for wanted items using serialize method
  sbuf.setMode(ISerializer::ModePut);
  data->serialize(&sbuf,ids,0);

  //--3-Store these values: from the buffer into the new IData local_data

  //--First resize local_data with the number of items present on the current process
  Integer nb_items = ids.size();
  local_data->resize(nb_items);

  // Get from buffer into new IData
  sbuf.setMode(ISerializer::ModeGet);
  local_data->serialize(&sbuf,0);
  return local_data;
}

/*---------------------------------------------------------------------------*/

const String
IXM3DataWriter::
_eventsFileName() const
{
  // File name
  return String::format("{0}/{1}",m_post_pro_base->baseDirectoryName(),m_events_filename);
}

/*---------------------------------------------------------------------------*/

const String
IXM3DataWriter::
_currentEventFileName() const
{
  // Check if PostProcessorWriterBase::baseName() exists otherwise use Event_x.xml
  String base_name = m_post_pro_base->baseFileName();
  if (base_name.empty())
    {
      base_name = String::format("{0}_{1}.xml",m_default_event_filename,m_event_number);
    }
  // Create name with path included
  return String::format("{0}/{1}",m_post_pro_base->baseDirectoryName(),base_name);
}

/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

const String
IXM3DataWriter::
_dataNodeName(const String& data_type) const
{
  String data_node_name;
  if (data_type == "Real") data_node_name = "real-data";
  else if (data_type == "Real3") data_node_name = "real3-data";
  else if (data_type == "Int32") data_node_name = "int32-data";
  else if (data_type == "Int64") data_node_name = "int64-data";
  else if (data_type == "Byte") data_node_name = "bool-data";
  else m_trace_mng->fatal() << "data type " << data_type << " not supported to write in IFP mesh format.";

  return data_node_name;
}

/*---------------------------------------------------------------------------*/

void
IXM3DataWriter::
_createFacesTag(XmlNode& event_root_node,const FaceOfInterestData& face_of_interest_data)
{
  // Create face description
  XmlElement topology_node(event_root_node,"topology");
  XmlElement faces_node(topology_node,"faces");

  if (m_has_face_aids)
    XmlElement(faces_node,m_magic_comment_keyword,"<faces> contains all faces defined in input file. They are described using abstract identifiers (aids).");
  else
    XmlElement(faces_node,m_magic_comment_keyword,"<faces> contains all mesh faces. They are described using unique identifiers (uids).");

  // Create xml nodes
  XmlElement node_number_node(faces_node,"nodes-number");
  XmlElement node_number_magic_node(node_number_node, m_magic_intern_keyword);
  node_number_magic_node.setAttrValue("reference",face_of_interest_data.m_all_face_node_number);

  XmlElement face_id_node(faces_node,"faces-id");
  XmlElement face_id_magic_node(face_id_node, m_magic_intern_keyword);
  face_id_magic_node.setAttrValue("reference",face_of_interest_data.m_all_face_ids);

  XmlElement node_id_node(faces_node,"nodes-id");
  XmlElement node_id_magic_node(node_id_node, m_magic_intern_keyword);
  node_id_magic_node.setAttrValue("reference",face_of_interest_data.m_all_face_node_uids);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

bool
IXM3DataWriter::
_magicWriteXmlFile(IXmlDocumentHolder* xml_doc_holder, const String & filename)
{
  // TODO g�rer les erreurs d'�criture
  XmlNode doc_node = xml_doc_holder->documentNode();
  std::ofstream file(filename.localstr());
  _magicWriteXmlNode(file, doc_node.domNode(), String(""));
  return false;
}

/*---------------------------------------------------------------------------*/

bool
IXM3DataWriter::
_writeNodeChildren(std::ostream& o,const dom::Node& node, const String & indent)
{
  // Affiche r�cursivement les noeuds fils
  bool do_indent = false;
  for(dom::Node next = node.firstChild(); !next._null(); next = next.nextSibling()) 
    do_indent |= _magicWriteXmlNode(o,next,indent);
  return do_indent;
}

bool 
IXM3DataWriter::
_magicWriteXmlNode(std::ostream& o,const dom::Node& node, const String & indent)
{
  switch(node.nodeType()) {
  case dom::Node::ELEMENT_NODE:
    {
      if (node.nodeName() == m_magic_intern_keyword) {
        dom::Element element(node);
        String reference = element.getAttribute("reference");
        m_array_register->retrieveArray(reference)->write(o);
        return false;
      } else if (node.nodeName() == m_magic_comment_keyword) {
        o << "\n" << indent << "<!-- ";
        _writeNodeChildren(o,node,indent + "  ");
        o << " -->";
        return true;
      } else {
        o << "\n" << indent << '<' << node.nodeName();
        dom::NamedNodeMap attr_list = node.attributes();
        for( dom::ULong i=0, s=attr_list.length(); i<s; ++i ){
          o << ' ';
          _magicWriteXmlNode(o,attr_list.item(i),indent);
        }
        o << '>';
        bool do_indent = _writeNodeChildren(o,node,indent + "  ");
        if (do_indent) o << "\n" << indent;
        o << "</" << node.nodeName() << ">";
        return true;
      }
    }
  case dom::Node::ATTRIBUTE_NODE:
    o << node.nodeName() << '=' << '"' << node.nodeValue() << '"';
    return false;
  case dom::Node::TEXT_NODE:
    o << _collapseWhiteString(node.nodeValue());
    return false;
  case dom::Node::COMMENT_NODE:
    o << "<!--" << node.nodeValue() << "-->";
    return false;
  case dom::Node::DOCUMENT_NODE:
    o << "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>";
    _writeNodeChildren(o,node,indent);
    return true;
  case dom::Node::CDATA_SECTION_NODE:
    throw NotImplementedException(A_FUNCINFO,"Unhandled CDATA_SECTION_NODE dom::Node");
  case dom::Node::ENTITY_REFERENCE_NODE:
    throw NotImplementedException(A_FUNCINFO,"Unhandled ENTITY_REFERENCE_NODE dom::Node");
  case dom::Node::ENTITY_NODE:
    throw NotImplementedException(A_FUNCINFO,"Unhandled ENTITY_NODE dom::Node");
  case dom::Node::PROCESSING_INSTRUCTION_NODE:
    throw NotImplementedException(A_FUNCINFO,"Unhandled PROCESSING_INSTRUCTION_NODE dom::Node");
  case dom::Node::DOCUMENT_TYPE_NODE:
    throw NotImplementedException(A_FUNCINFO,"Unhandled DOCUMENT_TYPE_NODE dom::Node");
  case dom::Node::DOCUMENT_FRAGMENT_NODE:
    throw NotImplementedException(A_FUNCINFO,"Unhandled DOCUMENT_FRAGMENT_NODE dom::Node");
  case dom::Node::NOTATION_NODE:
    throw NotImplementedException(A_FUNCINFO,"Unhandled NOTATION_NODE dom::Node");
  default:
    throw NotImplementedException(A_FUNCINFO,"Unhandled unknown dom::Node");
  }
  return false;
}

String
IXM3DataWriter::
_collapseWhiteString(const String & str)
{
  const char * localstr = str.localstr();
#ifdef WIN32
  while(isspace(*localstr)) ++localstr;
#else
  while(std::isspace(*localstr)) ++localstr;
#endif
  if (*localstr == 0)
    return String();
  else
    return str;
}

/*---------------------------------------------------------------------------*/

void
IXM3DataWriter::
_getFaceOfInterestData(FaceOfInterestData& face_of_interest_data, const Arcane::VariableCollection& vars)
{
  // Check if has file property
  face_of_interest_data.m_has_face_property = false;
  for (Arcane::VariableCollection::Enumerator ivar = vars.enumerator(); ++ ivar;)
    {
      if ((*ivar)->itemKind() == IK_Face) face_of_interest_data.m_has_face_property = true;
    }
  if (face_of_interest_data.m_has_face_property)
    {
      SharedArray<Integer> node_number;
      SharedArray<Int64> face_aids;
      SharedArray<Int64> node_uids;
      _fillFaceTagArrays(face_aids,node_number,node_uids);
      _registerFaceTagArrays(face_of_interest_data,face_aids,node_number,node_uids);
    }
}

/*---------------------------------------------------------------------------*/

void
IXM3DataWriter::
_fillFaceTagArrays(Array<Int64>& face_ids, Array<Integer>& node_number, Array<Int64>& node_ids)
{
  // Get faces abstract ids (= face unique ids in the workflow) if availables

  // Check if face aids are available
  Arcane::IVariableMng * var_mng = m_mesh->subDomain()->variableMng();
  Arcane::IVariable * variable = var_mng->findVariable(ArcGeoSim::IXMItemAidToUidMapper::itemAidMemoryVariableName(m_mesh,Arcane::IK_Face));

  if (m_has_face_aids && (!variable || Arcane::VariableArrayInt64(variable).empty())) 
    {
      m_trace_mng->warning() << "Cannot find face description with abstract ids. Writing face description using unique ids.";
      m_has_face_aids = false;
    }

  if (m_has_face_aids)
    {
      FaceGroup face_group = m_mesh->ownFaces();
      SharedArray<Int64> face_uids;
      ENUMERATE_FACE(iface, face_group)
        {
          face_uids.add(iface->uniqueId().asInt64());
        }

      // Get faces abstract ids (= face unique ids in the workflow) if availables
      // Create face uid to aid mapper
      SharedArray<Int64> face_aids;
      ArcGeoSim::IXMItemUidToAidMapper face_aid_mapper(m_mesh,m_parallel_mng, m_mesh->subDomain()->variableMng(),Arcane::IK_Face);
      // Get aid if possible
      face_aid_mapper.itemUniqueIdToAbstractId(face_aids,face_uids);

      face_ids.reserve(face_group.size());
      node_number.reserve(face_group.size());
      // Fill data on current process
      ENUMERATE_FACE(iface, face_group)
        {
          if (face_aids[iface.index()] != NULL_ITEM_UNIQUE_ID)
            {
              face_ids.add(face_aids[iface.index()]);
              node_number.add(iface->nbNode());
              NodeVectorView face_nodes = iface->nodes();
              ENUMERATE_NODE(inode,face_nodes)
                {
                  node_ids.add(inode->uniqueId().asInt64());
                }
            }
        }
    }
  else
    {
      FaceGroup face_group = m_mesh->ownFaces();
      face_ids.reserve(face_group.size());
      node_number.reserve(face_group.size());
      // Fill data on current process
      ENUMERATE_FACE(iface, face_group)
        {
          face_ids.add(iface->uniqueId().asInt64());
          node_number.add(iface->nbNode());
          NodeVectorView face_nodes = iface->nodes();
          ENUMERATE_NODE(inode,face_nodes)
            {
              node_ids.add(inode->uniqueId().asInt64());
            }
        }
    }  
}

/*---------------------------------------------------------------------------*/

void
IXM3DataWriter::
_registerFaceTagArrays(FaceOfInterestData& face_of_interest_data, const Array<Int64>& face_ids, const Array<Integer>& node_number, const Array<Int64>& node_ids) const
{
  // Parallel strategy : gather information on master process
  Arcane::Int64SharedArray all_face_ids;
  Arcane::IntegerSharedArray all_node_number;
  Arcane::Int64SharedArray all_node_ids;
  Arcane::Integer master_rank = m_parallel_mng->masterIORank();
  m_parallel_mng->gatherVariable(face_ids,all_face_ids,master_rank);
  m_parallel_mng->gatherVariable(node_number,all_node_number,master_rank);
  m_parallel_mng->gatherVariable(node_ids,all_node_ids,master_rank);
  if (m_is_master)
    {
      face_of_interest_data.m_all_face_node_number = m_array_register->registerArray(all_node_number);
      face_of_interest_data.m_all_face_ids = m_array_register->registerArray(all_face_ids);
      face_of_interest_data.m_all_face_node_uids = m_array_register->registerArray(all_node_ids);
    }
}

/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
