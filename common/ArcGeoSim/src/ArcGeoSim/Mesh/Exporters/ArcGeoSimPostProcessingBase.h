// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_MESH_EXPORTERS_ARCGEOSIMPOSTPROCESSINGBASE_H
#define ARCGEOSIM_MESH_EXPORTERS_ARCGEOSIMPOSTPROCESSINGBASE_H
/* Author : havep at Tue Dec 20 16:40:39 2011
 * Generated by createNew
 */

#include <arcane/Timer.h>
#include <arcane/Directory.h>
#include <arcane/VariableCollection.h>
#include <arcane/MeshVariable.h>
#include <arcane/VariableTypedef.h>
#include <arcane/VariableRefArray.h>
#include <arcane/ArcaneTypes.h>
#include <arcane/utils/Array.h>
#include <arcane/ISubDomain.h>
#include <arcane/ItemGroup.h>
#include <arcane/utils/List.h>
#include <arcane/IPostProcessorWriter.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/IVariableMng.h>
#include <arcane/IMesh.h>
#include <arcane/IItemFamily.h>

#include <set>

#ifdef ARCGEOSIM_USE_EXPORT
#include "ArcGeoSim/Mesh/ArcGeoSim_meshExport.h"
#else
#define ARCGEOSIM_MESH_EXPORT
#endif 

class ArcGeoSimPostProcessingBase
{
public:
  
  /** Constructeur de la classe */
  ArcGeoSimPostProcessingBase(Arcane::ISubDomain* sd, const Arcane::String name);
  
  /** Destructeur de la classe */
  virtual ~ArcGeoSimPostProcessingBase();
  
public:
  //! Initialisation
  /*! Initialise le chemin d'enregistrement */
  void init(Arcane::String output_path);

  //! Ajout d'un post-processing et de variables d�crites par leurs noms
  //! init_variables sont les variables supplementaires a ecrire au temps initial (premier appel � saveAtTime)
  /*! Le type g�n�rique des variables prises en arguement requiert uniquement qu'elles soient accessibles par un operateur[] */
  template<typename Variables>
  void addPostProcessing(Arcane::IPostProcessorWriter * writer, const Variables & variables, const Arcane::String& mesh_name=m_default_mesh_name);
  template<typename Variables>
  void addPostProcessing(Arcane::IPostProcessorWriter * writer, const Variables & variables, const Variables & init_variables, const Arcane::String& mesh_name=m_default_mesh_name);

  //! Demande un post-processing pour le temps fourni en argument
  /*! Non test� si diff�rent du temps courant ou non croissant au fil des appels */
  void saveAtTime(Arcane::Real);
  void saveAtInitialTime(Arcane::Real);

  //! Ecrit sur le canal standard les statistiques de post-processing
  void stats();

private:
    void _checkCreateOutputDir();
    void _saveVariablesAtTime(Arcane::Real saved_time, const Arcane::Array<Arcane::VariableList>& pp_variables);
    template<typename Variables>
    void _addPostProcessingVariables(const Variables & variables, Arcane::VariableList& pp_variables, Arcane::ItemGroupList& pp_groups );
    void _addPostProcessingMesh(const Arcane::String& mesh_name);

private:
  Arcane::ISubDomain * m_sub_domain;
  bool m_has_post_processing;
  Arcane::VariableArrayReal m_times; //!< Instants de temps des sauvegardes
  Arcane::String m_output_path;
  Arcane::Directory m_output_directory; //!< R�pertoire de sortie
  bool m_output_dir_created; //!< \a true si r�pertoire cr��.
  Arcane::SharedArray<Arcane::Timer> m_pp_timer; //!< Timer pour le temps pass� � �crire
  Arcane::SharedArray<Arcane::IPostProcessorWriter*> m_pp_writer;
  Arcane::SharedArray<Arcane::VariableList> m_pp_variables;
  Arcane::SharedArray<Arcane::VariableList> m_pp_init_variables;
  Arcane::SharedArray<Arcane::ItemGroupList> m_pp_groups;
  Arcane::SharedArray<Arcane::IMesh*> m_pp_meshes;
  Arcane::SharedArray<Arcane::String> m_pp_base_directory_names;

  static ARCGEOSIM_MESH_EXPORT Arcane::String m_default_mesh_name;

  Arcane::String m_name;
};

template<typename Variables>
void
ArcGeoSimPostProcessingBase::
addPostProcessing(Arcane::IPostProcessorWriter * pp_writer, const Variables & variables, const Arcane::String& mesh_name)
{
  _addPostProcessingMesh(mesh_name);

  Arcane::VariableList pp_variables;
  Arcane::ItemGroupList pp_groups;
  _addPostProcessingVariables(variables,pp_variables,pp_groups);
  m_pp_init_variables.add(pp_variables);
  m_pp_variables.add(pp_variables);

  m_pp_groups.add(pp_groups);
  m_pp_writer.add(pp_writer);
  m_pp_timer.add(Arcane::Timer(m_sub_domain,Arcane::String::format("{0} for mesh {1} PostProcessorTimer",m_name,mesh_name),Arcane::Timer::TimerReal));

  m_has_post_processing = true;
}

template<typename Variables>
void
ArcGeoSimPostProcessingBase::
addPostProcessing(Arcane::IPostProcessorWriter * pp_writer, const Variables & variables, const Variables & init_variables, const Arcane::String& mesh_name)
{
  _addPostProcessingMesh(mesh_name);

  Arcane::VariableList pp_variables;
  Arcane::ItemGroupList pp_groups;
  m_sub_domain->traceMng()->info() << "Output variables stored at time ";
  _addPostProcessingVariables(variables,pp_variables,pp_groups);
  m_pp_variables.add(pp_variables);

  Arcane::VariableList pp_variables_init(pp_variables.clone());
  m_sub_domain->traceMng()->info() << "Output variables stored at initial time ";
  _addPostProcessingVariables(init_variables,pp_variables_init,pp_groups);
  m_pp_init_variables.add(pp_variables_init);

  m_pp_groups.add(pp_groups);
  m_pp_writer.add(pp_writer);
  // TODO: it should be nice to have the service name for pp_writer
  m_pp_timer.add(Arcane::Timer(m_sub_domain,Arcane::String::format("{0} for mesh {1} PostProcessorTimer",m_name,mesh_name),Arcane::Timer::TimerReal));

  m_has_post_processing = true;
}

template<typename Variables>
void
ArcGeoSimPostProcessingBase::
_addPostProcessingVariables(const Variables & variables, Arcane::VariableList& pp_variables, Arcane::ItemGroupList& pp_groups )
{
  Arcane::IVariableMng * var_mng = m_sub_domain->variableMng();
  Arcane::IMesh * mesh = m_pp_meshes.back();
  Arcane::ITraceMng * traceMng = m_sub_domain->traceMng();

  const Arcane::Integer nb_var = variables.size();
  if (nb_var!=0)
    {
      std::set<Arcane::String> used_variables; // Liste des variables d�j� indiqu�es
      std::set<Arcane::String> used_groups; // Liste des groupes d�j� indiqu�es
      for(Arcane::VariableList::Enumerator j(pp_variables);++j;)
        used_variables.insert((*j)->name());
      for(Arcane::ItemGroupList::Enumerator j(pp_groups);++j;)
        used_groups.insert((*j).name());

      traceMng->info() << " ";
      traceMng->info() << "-- Output Variable List: (" << nb_var << " variables):";
      for( Arcane::Integer i=0; i<nb_var; ++i )
        {
          Arcane::String varname = variables[i];
          Arcane::IVariable* var = var_mng->findMeshVariable(mesh, varname);
          if (!var)
            traceMng->fatal() << "PostProcessing: the variable named '" << varname << "' does not exist";
          Arcane::eItemKind ik = var->itemKind();
          if (ik!=Arcane::IK_Node && ik!=Arcane::IK_Edge && ik!=Arcane::IK_Face && ik!=Arcane::IK_Cell && ik!=Arcane::IK_Particle && ik!=Arcane::IK_Unknown)
            traceMng->fatal() << "PostProcessing: variable (" << varname << ") must"
                              << " be a mesh variable (node, edge, face, cell or particle support)";
          if (used_variables.find(varname)==used_variables.end())
            {
              if (var->computeFunction())
                traceMng->info() << "Variable <" << varname << "> with compute function";
              else
                traceMng->info() << "Variable <" << varname << ">";
              pp_variables.add(var);
              used_variables.insert(varname);

              // Acc�s au groupe de la variable m�me pour les variables d�sactiv�es
              if(ik==Arcane::IK_Node || ik==Arcane::IK_Edge || ik==Arcane::IK_Face || ik==Arcane::IK_Cell || ik==Arcane::IK_Particle)
              {
                Arcane::IItemFamily * family;
                if (ik==Arcane::IK_Particle)
                  family = mesh->findItemFamily(ik, "Particle", false);
                else
                  family = mesh->itemFamily(var->itemKind());
                Arcane::ItemGroup variable_group;
                if (var->itemGroupName().null())
                  variable_group = family->allItems();
                else
                  variable_group = family->findGroup(var->itemGroupName());
                ARCANE_ASSERT((!variable_group.null()),("Unexpected associated group for variable '%s'",var->fullName().localstr()));
                if (used_groups.find(variable_group.name()) == used_groups.end())
                {
                  used_groups.insert(variable_group.name());
                  pp_groups.add(variable_group);
                }
              }
            }
          else
            {
              traceMng->warning() << "Variable <" << varname << "> registered twice for post processing";
            }
        }
    }
}

#endif /* ARCGEOSIM_MESH_EXPORTERS_ARCGEOSIMPOSTPROCESSINGBASE_H */
