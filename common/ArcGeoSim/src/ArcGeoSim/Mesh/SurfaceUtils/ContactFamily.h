// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#ifndef ARCGEOSIM_ARCGEOSIM_SURFACEUTILS_CONTACTFAMILY_H
#define ARCGEOSIM_ARCGEOSIM_SURFACEUTILS_CONTACTFAMILY_H
/* Author : havep at Thu Jun  4 14:46:21 2009
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/

#include <map>
#include <set>
#include <boost/shared_ptr.hpp>

#include <arcane/ArcaneVersion.h>
#include <arcane/ArcaneTypes.h>
#include <arcane/utils/TraceInfo.h>
#include "arcane/utils/Event.h"
#include <arcane/Item.h>
#include <arcane/ItemSharedInfo.h>
#include <arcane/ItemInternal.h>
#include <arcane/ItemTypes.h>
#include <arcane/IItemFamily.h>
#include <arcane/utils/TraceAccessor.h>
#include <arcane/utils/ArgumentException.h>
#include <arcane/utils/Collection.h>
#include <arcane/VariableCollection.h>
#include <arcane/ItemPairGroup.h>
#include <arcane/utils/ITraceMng.h>
#if (ARCANE_VERSION >= 12201)
#include <arcane/IItemConnectivityInfo.h>
#endif

#if (ARCANE_VERSION >= 20200)
  #include <arcane/IItemConnectivity.h>
  #include <arcane/IItemConnectivityMng.h>
#if (ARCANE_VERSION >= 22200)
  #include <arcane/mesh/ItemConnectivity.h>
#else
  #include <arcane/dof/ItemConnectivity.h>
#endif
  using Arcane::IItemConnectivityMng;
  using Arcane::IItemConnectivity;
#if (ARCANE_VERSION >= 20202)
  #include <arcane/IIncrementalItemConnectivity.h>
#endif
#else
  #include <arcane/dof/IConnectivity.h>
  #include <arcane/dof/IConnectivityManager.h>
  typedef Arcane::IConnectivityManager IItemConnectivityMng;
  typedef Arcane::IConnectivity IItemConnectivity;
#endif

#include "ArcGeoSim/Utils/ArcGeoSim.h"
#include "ArcGeoSim/Mesh/SurfaceUtils/ContactSharedInfo.h"
#include "ArcGeoSim/Mesh/SurfaceUtils/Contact.h"
#include "ArcGeoSim/Mesh/SurfaceUtils/ContactGroupImpl.h"
#include "ArcGeoSim/Mesh/SurfaceUtils/ContactGroup.h"
#include "ArcGeoSim/Mesh/SurfaceUtils/IContactFamily.h"

#ifdef USE_ARCANE_V3
#include <arcane/mesh/DoFFamily.h>
#include <arcane/mesh/DoFManager.h>
#endif

#if (ARCANE_VERSION >= 31600)
#include <arcane/utils/Event.h>
#include <arcane/core/ItemFamilyItemListChangedEventArgs.h>
#endif

/*---------------------------------------------------------------------------*/

//! Famille concrete de contacts
class ContactFamily 
  : protected Arcane::TraceAccessor
  , public IContactFamily
{
public:
  /** Constructeur de la classe */
  ContactFamily(Arcane::ITraceMng * traceMng, Arcane::IItemFamily * family1, Arcane::IItemFamily * family2);
  
  /** Destructeur de la classe */
  virtual ~ContactFamily ();
  
public:
  //!@{ Heritage de IContactFamily

  //! Nom de la famille
  const String& name() const override {return m_name;}

  //! Genre de la premiere entite du contact
  eContactKind contactKind() const override { return m_shared_info.kind(); }

  //! Nombre d'entites.
  Integer nbContact() const override { return m_internals.size()  ; }

  //! Taille necessaire pour dimensionner les variables sur ces contacts
  Int32 maxLocalId() const override { return m_internals.size(); }
  
  //! Groupe de tous les contacts
  ContactGroup allContacts() override;

  //! Ajout d'une variable sur la famille
  void registerVariable(IContactVariable * var) override;

  //! Retrait d'une variable sur la famille
  void unregisterVariable(IContactVariable * var) override;

  //! Ajout d'un contact
  Int32 addContact(const Int32 lid1, const Int32 lid2) override;

  //! Acces aux internals des contacts
  ContactInternal * contactsInternal() override;

  //! Acces aux internals des contacts
  const ContactInternal * contactsInternal() const override;

  //! Creation d'un groupe sur la famille
  ContactGroup createGroup(const String & name) override;

  //! Recherche d'un groupe sur la famille
  ContactGroup findGroup(const String & name) override;

  //! Informe la famille d'un changement sur un groupe
  void notifyGroupChange(ContactGroupImpl * group) override;

  //! Synchroniser sur toutes les entites de la famille. La methode computeSynchronizeInfos() doit etre appele avant.
  Arcane::IVariableSynchronizer* allItemsSynchronizer() override;

  //! Calcul des entite fantomes. Cette operation est collective.
  void computeSynchronizeInfos() override;

  //! Fin de remplissage de la famille
  void endUpdate() override;

  void updateInternalList() override;

  //! Acces aux donnees partagees des contacts
  ContactSharedInfo *sharedInfo() override;

  //! Acces au maillage associe
  Arcane::IMesh* mesh() const override { return m_shared_info.m_family1->mesh(); }
  //!@}

protected:
  //! Donnees partageables des contacts
  ContactSharedInfo m_shared_info;
  
  //! Liste des contacts de la famille
  Arcane::SharedArray<ContactInternal> m_internals;
  
  //! Tous les identifiants locaux
  Arcane::SharedArray<Int32> m_local_ids;
  
  //! Ensemble des variables sur la famille
  std::set<IContactVariable *> m_variables;
  
  //! Ensemble des groupes sur la famille
  std::map<String,ContactGroupImpl*> m_groups;

  //! Synchronizeur du groupe AllContacts
  Arcane::IVariableSynchronizer* m_synchronizer;
  
  //! Nom de la famille
  Arcane::String m_name;

  bool m_is_synchronized = false; // internal. Synchronize infos must be computed before call to allItemsSynchronizer
};

/*---------------------------------------------------------------------------*/

//! Famille de contacts de type face-face
class FaceFaceContactFamily : public ContactFamily
{
public:
  typedef FaceFaceContact ContactType;

public:
  /** Constructeur de la classe */
  FaceFaceContactFamily(Arcane::ITraceMng * traceMng, Arcane::IItemFamily * family);

  /** Destructeur de la classe */
  virtual ~FaceFaceContactFamily() {}
  
public:
  //!@{ Extension de ContactFamily
  //! Ajout d'un contact type
  Int32 addContact(const Face & item1, const Face & item2) { return ContactFamily::addContact(item1.localId(),item2.localId()); }
  //!@}

  //! Groupe de toutes les faces
  Arcane::FaceGroup allFaces();

private :
  //!build group of all faces involved in FaceFaceContacts
  void _updateFaceGroup() ;
  
  //!group of all faces involved in FaceFaceContacts
  Arcane::FaceGroup m_face_group ;
  
  //!true if m_face_group needs to be updated
  bool m_face_group_need_update ;
  
  //!m_face_group name
  Arcane::String m_face_group_name ;
};

/*---------------------------------------------------------------------------*/

//! Famille de contacts de type node-face
class NodeFaceContactFamily : public ContactFamily
{
public:
  typedef NodeFaceContact ContactType;

public:
  /** Constructeur de la classe */
  NodeFaceContactFamily(Arcane::ITraceMng * traceMng, Arcane::IItemFamily * node_family, Arcane::IItemFamily * face_family);
  
  /** Destructeur de la classe */
  virtual ~NodeFaceContactFamily() {}
  
public:
  //!@{ Extension de ContactFamily
  //! Ajout d'un contact type
  Int32 addContact(const Node & item1, const Face & item2) { return ContactFamily::addContact(item1.localId(),item2.localId()); }
  //!@}
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

//! Proxy pour implementer IItemFamily, afin de pouvoir beneficier des outils autour de ItemConnectivity
//! Temporaire, a terme les contacts devraient etre implementes par des DoF

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class ContactItemFamily : public Arcane::IItemFamily
{
public:
  ContactItemFamily(IContactFamily* contact_family)
    : m_contact_family(contact_family)
#if ARCANE_VERSION >= 31307
    , m_dof_mng(contact_family->mesh())
#endif

  {}
  virtual ~ContactItemFamily(){
#ifndef USE_ARCANE_V3
    for (auto internal : m_internals) delete internal;
#endif
  }


private:
  IContactFamily* m_contact_family;
  Arcane::String m_empty_string;
  Arcane::SharedArray<Arcane::ItemInternal*> m_internals;
  Arcane::Int64SharedArray m_uids;
  Arcane::Int64ArrayView m_uids_view;
  Arcane::ItemSharedInfo m_shared_info;

  void _notImplemented() const {throw Arcane::NotImplementedException("ContactFamily does not cover the whole IItemFamily scope");}
  void _updateInternals();
  Arcane::Int64 _uniqueId(ContactInternal& contact);
  IItemFamily* oneFamily() const {return m_contact_family->sharedInfo()->m_family1;}

public:

  IContactFamily* contactFamily() {return m_contact_family;}

  //!@{ Heritage de IItemFamily necessaire pour la gestion de la distribution des contacts
   void build() override{}
   Int32 maxLocalId() const override { return m_contact_family->maxLocalId(); }
   void endUpdate() override {m_contact_family->endUpdate();};
   Arcane::ITraceMng*   traceMng() const override {return oneFamily()->traceMng();}
   Arcane::ISubDomain* subDomain() const override{return oneFamily()->subDomain();}
   Arcane::IMesh* mesh() const override {return oneFamily()->mesh();}
   Arcane::IParallelMng* parallelMng() const override {return oneFamily()->parallelMng();}
   Arcane::IVariableSynchronizer* allItemsSynchronizer() override{return m_contact_family->allItemsSynchronizer();}
#ifdef USE_ARCANE_V3
  String name() const override {return m_contact_family->name();}
#if ARCANE_VERSION >= 31307
  Arcane::DoFManager m_dof_mng;
  String m_associated_dof_family_name = "ContactAssociatedDoFFamily";
#endif
#else
  const String& name() const override {return m_contact_family->name();}
#endif
   Arcane::ItemInternalArrayView itemsInternal() override{_updateInternals();return m_internals.view();}
   Arcane::ItemVectorView view(Int32ConstArrayView local_ids) override{_updateInternals();return Arcane::ItemVectorView(m_internals,local_ids);}
   Arcane::ItemVectorView view() override{_updateInternals();return Arcane::ItemVectorView(m_internals,m_contact_family->allContacts().impl()->itemsLocalId());} // attention ne marche pas si itemsInternal pas appele
   void itemsUniqueIdToLocalId(Int32ArrayView local_ids,Int64ConstArrayView unique_ids,bool do_fatal=true) const override;
  //!@}


public:
  //!@{  Heritage de IItemFamily non necessaire et non implementee
#ifdef USE_ARCANE_V3
   String fullName() const override {_notImplemented();return m_empty_string;}
#else
  const String& fullName() const override {_notImplemented();return m_empty_string;}
#endif
   Arcane::eItemKind itemKind() const override {_notImplemented(); return Arcane::eItemKind();}
   Integer nbItem() const override{_notImplemented(); return 0;}
#ifndef USE_ARCANE_V3
   ARCANE_DEPRECATED_112 Int32 variableMaxSize() const override {_notImplemented();return 0;}
#endif
   IItemFamily* parentFamily() const override {_notImplemented();return nullptr;}
   void setParentFamily(IItemFamily * parent) override{_notImplemented();}
   Integer parentFamilyDepth() const override {_notImplemented(); return 0;}
   void addChildFamily(IItemFamily * family) override{_notImplemented();}
   Arcane::IItemFamilyCollection childFamilies() override{_notImplemented();return Arcane::IItemFamilyCollection();}
   Arcane::VariableItemInt32& itemsNewOwner() override{_notImplemented(); return m_contact_family->contactsInternal()->m_shared_info->m_family1->itemsNewOwner();} // return has no impact, to avoir warning
   void checkValid() override{_notImplemented();}
   void checkUniqueIds(Int64ConstArrayView unique_ids) override{_notImplemented();}
#ifndef USE_ARCANE_V3
   void addItems(Int64ConstArrayView unique_ids,Int32ArrayView items) override{_notImplemented();}
   void addItems(Int64ConstArrayView unique_ids,ArrayView<Item> items){_notImplemented();}
   void addItems(Int64ConstArrayView unique_ids,Arcane::ItemGroup item_group) override{_notImplemented();}
   void exchangeItems() override{_notImplemented();}
   void removeItems(Int32ConstArrayView local_ids,bool keep_ghost=false) override{_notImplemented();}
#endif
#if (ARCANE_VERSION >= 30003)
  Arcane::ItemInfoListView itemInfoListView() override { _notImplemented(); return Arcane::ItemInfoListView() ;}
   void checkValidConnectivity() override{_notImplemented();}
   void removeItems2(Arcane::mesh::ItemDataList& item_data_list) override{_notImplemented();}
   void removeNeedRemoveMarkedItems() override{_notImplemented();}
#endif
   Arcane::ItemInternal* findOneItem(Int64 unique_id) override{_notImplemented();return nullptr;}
#ifndef USE_ARCANE_V3
   void mergeItems(Int32 local_id1,Int32 local_id2) override{_notImplemented();};
   Int32 getMergedItemLID(Int32 local_id1,Int32 local_id2) override{_notImplemented();return 0;}
#endif
   void partialEndUpdate() override{_notImplemented();}
   void partialEndUpdateGroup(const Arcane::ItemGroup& group) override{_notImplemented();}
   void partialEndUpdateVariable(Arcane::IVariable* variable) override{_notImplemented();}
   void notifyItemsOwnerChanged() override{_notImplemented();}
   void notifyItemsUniqueIdChanged() override{_notImplemented();}
   void resizeVariables(bool force_resize=false) override{_notImplemented();}
#if (ARCANE_VERSION < 30003)
   Integer maxNodePerItem() const override {_notImplemented(); return 0;}
   Integer maxEdgePerItem() const override {_notImplemented();return 0;}
   Integer maxFacePerItem() const override {_notImplemented();return 0;}
   Integer maxCellPerItem() const override {_notImplemented();return 0;}
   Integer maxLocalNodePerItemType() const override {_notImplemented();return 0;}
   Integer maxLocalEdgePerItemType() const override {_notImplemented();return 0;}
   Integer maxLocalFacePerItemType() const override {_notImplemented();return 0;}
#endif
#if (ARCANE_VERSION >= 12201)
   Arcane::IItemConnectivityInfo* localConnectivityInfos()  const override {_notImplemented();return nullptr;}
   Arcane::IItemConnectivityInfo* globalConnectivityInfos() const override {_notImplemented();return nullptr;}
#endif
   void setHasUniqueIdMap(bool v) override{_notImplemented();}
   bool hasUniqueIdMap() const override {_notImplemented(); return false;}
   void itemsUniqueIdToLocalId(Int32ArrayView local_ids,
                                      ConstArrayView<Arcane::ItemUniqueId> unique_ids,
                                      bool do_fatal=true) const override {_notImplemented();}
   void setItemSortFunction(Arcane::IItemInternalSortFunction* sort_function) override{_notImplemented();}
   Arcane::IItemInternalSortFunction* itemSortFunction() const override {_notImplemented();return nullptr;}
   void endAllocate() {_notImplemented();}
   void notifyEndUpdateFromMesh() {_notImplemented();}
   Arcane::ItemGroup allItems() const override {_notImplemented();return Arcane::ItemGroup();}
   Arcane::ItemGroupCollection groups() const override {_notImplemented();return Arcane::ItemGroupCollection();}
   Arcane::ItemGroup findGroup(const String& name) const override {_notImplemented();return Arcane::ItemGroup();}
   Arcane::ItemGroup findGroup(const String& name,bool create_if_needed) override{_notImplemented();return Arcane::ItemGroup();}
   Arcane::ItemGroup createGroup(const String& name,Int32ConstArrayView local_ids,bool do_override=false) override{_notImplemented();return Arcane::ItemGroup();}
   Arcane::ItemGroup createGroup(const String& name) override{_notImplemented();return Arcane::ItemGroup();}
   void destroyGroups() override{_notImplemented();}
   Arcane::ItemGroup createGroup(const String& name,const Arcane::ItemGroup& parent,bool do_override=false) override{_notImplemented();return Arcane::ItemGroup();}
   Arcane::IVariable* findVariable(const String& name,bool throw_exception=false) override{_notImplemented();return nullptr;}
   void usedVariables(Arcane::VariableCollection collection) override{_notImplemented();}
   void prepareForDump() override{_notImplemented();}
   void readFromDump() override{_notImplemented();}
   void copyItemsValues(Int32ConstArrayView source, Int32ConstArrayView destination) override{_notImplemented();}
   void copyItemsMeanValues(Int32ConstArrayView first_source,
                                   Int32ConstArrayView second_source,
                                   Int32ConstArrayView destination) override{_notImplemented();}
   void clearItems() override{_notImplemented();}
   void compactItems(bool do_sort) override{_notImplemented();}
   void addVariable(Arcane::IVariable* var) {_notImplemented();}
   void removeVariable(Arcane::IVariable* var) {_notImplemented();}
   void computeSynchronizeInfos() override{m_contact_family->computeSynchronizeInfos();}
   void getCommunicatingSubDomains(Int32Array& sub_domains) const override {_notImplemented();}
   void synchronize(Arcane::VariableCollection variables) override{_notImplemented();}
   void reduceFromGhostItems(Arcane::IVariable* v,Arcane::IDataOperation* operation) override{_notImplemented();}
   void reduceFromGhostItems(Arcane::IVariable* v,Arcane::Parallel::eReduceType operation) override{_notImplemented();}
   Arcane::ItemPairGroup findAdjencyItems(const Arcane::ItemGroup& group,
                                         const Arcane::ItemGroup& sub_group,
                                         Arcane::eItemKind link_kind,
                                         Integer nb_layer) override{_notImplemented();return Arcane::ItemPairGroup();}
   Arcane::IParticleFamily* toParticleFamily() override{_notImplemented();return nullptr;}
   void internalRemoveItems(Arcane::Int32ConstArrayView local_ids,bool keep_ghost=false) override{_notImplemented();}
   void addSourceConnectivity(IItemConnectivity* connectivity) override{_notImplemented();}
   void addTargetConnectivity(IItemConnectivity* connectivity) override{_notImplemented();}
   void removeSourceConnectivity(IItemConnectivity* connectivity) override{_notImplemented();}
   void removeTargetConnectivity(IItemConnectivity* connectivity) override{_notImplemented();}
#if (ARCANE_VERSION >= 20202)
   void addSourceConnectivity(Arcane::IIncrementalItemConnectivity* connectivity) {_notImplemented();}
   void addTargetConnectivity(Arcane::IIncrementalItemConnectivity* connectivity) {_notImplemented();}
#else
   void resizeVariables(){_notImplemented();}
#endif

   void setConnectivityMng(IItemConnectivityMng* connectivity_mng) override{_notImplemented();}
   void addGhostItems(Int64ConstArrayView unique_ids, Int32ArrayView items,Int32ConstArrayView owners) override{_notImplemented();}
#if (ARCANE_VERSION >= 20405)
   Arcane::IItemFamilyPolicyMng* policyMng() override{_notImplemented();return nullptr;}
   Arcane::Properties* properties() override{_notImplemented();return nullptr;}
   Arcane::IItemFamilyTopologyModifier* _topologyModifier() override{_notImplemented();return nullptr;}
#endif

#if (ARCANE_VERSION >= 22200)
   Arcane::ItemInternalConnectivityList* _unstructuredItemInternalConnectivityList() {_notImplemented();return nullptr;}
#endif

#ifdef USE_ARCANE_V3
  Arcane::IItemFamilyInternal* _internalApi() override { _notImplemented(); return nullptr; }
#endif

#if (ARCANE_VERSION >= 31303)
    void synchronize(Arcane::VariableCollection variables, Int32ConstArrayView local_ids) override{
        ARCANE_UNUSED(variables);
        ARCANE_UNUSED(local_ids);
        _notImplemented();
   }
#endif
  //!@}

#if (ARCANE_VERSION >= 31600)
   Arcane::EventObservableView<const Arcane::ItemFamilyItemListChangedEventArgs&> itemListChangedEvent() override{
     _notImplemented();
     Arcane::EventObservable<const Arcane::ItemFamilyItemListChangedEventArgs&> item_list_change_event;
     return Arcane::EventObservableView<const Arcane::ItemFamilyItemListChangedEventArgs&>{item_list_change_event};
   }
  void experimentalChangeUniqueId(Arcane::ItemLocalId,Arcane::ItemUniqueId) {
     _notImplemented();
   }
#endif
};


/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_ARCGEOSIM_SURFACEUTILS_CONTACTFAMILY_H */
