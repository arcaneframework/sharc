// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "FaceVectorAnalysis.h"
/* Author : havep at Wed Mar 30 14:46:01 2011
 * Generated by createNew
 */

#ifdef WIN32
#include <ciso646>
#endif

#include <stack>
#include "ArcGeoSim/Numerics/Utils/lapackUtils.h"
#include <boost/shared_ptr.hpp>
#include <boost/shared_array.hpp>
#include <arcane/utils/HashTableMap.h>
#include <arcane/IMesh.h>
#include <arcane/IItemFamily.h>
#include <arcane/ArcaneVersion.h>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

// Objet de construction de connectivit�
class FaceVectorAnalysis::FaceVectorConnectivity {
public:
  FaceVectorConnectivity(FaceVectorView group, IMesh * mesh) 
    : m_view(group)
  {
    m_max_edge_count = 0;
    ENUMERATE_FACE(iface, group)
      {
        const Face & face = *iface;
        m_max_edge_count = math::max(m_max_edge_count, face.nbNode());
      }
    m_fast_connectivity.resize(group.size() * m_max_edge_count, -1);

    // Pour construire une fonction de hashage des ar�tes en fonction des sommets
    const Int64 max_node_localId = mesh->nodeFamily()->maxLocalId();

    // Le Int64 est une valeur de hash de l'ar�te, la paire en valeur est compos�e des index de face et ar�tes qui ont d�j� vues cette ar�te
    typedef HashTableMapT<Int64, std::pair<Integer, Integer> > LookupTable;
    Integer edge_count_approximation = m_max_edge_count * group.size();
    edge_count_approximation = 2 * edge_count_approximation / 3; // heuristique pour mod�rer la taille de la table de hashage
    LookupTable fast_lookup(edge_count_approximation, true);

    if (mesh->dimension() == 2)
      { //2D 
        ENUMERATE_FACE(iface, group)
          {
            const Face & face = *iface;
            NodeVectorView nodes = face.nodes();
            for(Integer i=0, nnodes=nodes.size();i<nnodes;++i)
              {
                const Int64 edge_hash_index = nodes[i].localId();
                bool is_add = false;
                const std::pair<Integer, Integer> value(iface.index(), i);
                LookupTable::Data * data = fast_lookup.lookupAdd(edge_hash_index, value, is_add);
                if (not is_add)
                  {
                    const Integer other_face = data->value().first;
                    Integer & other_edge = data->value().second;
                    ARCANE_ASSERT((other_edge >= 0),("Non manifold surface")); // code de contr�le d'erreur
                    m_fast_connectivity[iface.index() * m_max_edge_count + i] = other_face;
                    m_fast_connectivity[other_face * m_max_edge_count + other_edge] = iface.index();
                    other_edge = -1; // code d'erreur si vue une seconde fois
                  }
              }
          }
      }
    else if (mesh->dimension() == 3)
      { // 3D
        ENUMERATE_FACE(iface, group)
          {
            const Face & face = *iface;
            NodeVectorView nodes = face.nodes();
            for(Integer i=0, nnodes=nodes.size();i<nnodes;++i)
              {
                const Int64 first_node = face.node(i).localId();
                const Int64 second_node = face.node((i+1)%nnodes).localId();
                const Int64 edge_hash_index = 
                  (first_node > second_node)
                  ?(first_node * max_node_localId + second_node)
                  :(first_node + max_node_localId * second_node);
                bool is_add = false;
                const std::pair<Integer, Integer> value(iface.index(), i);
                LookupTable::Data * data = fast_lookup.lookupAdd(edge_hash_index, value, is_add);
                if (not is_add)
                  {
                    const Integer other_face = data->value().first;
                    Integer & other_edge = data->value().second;
                    ARCANE_ASSERT((other_edge >= 0),("Non manifold surface")); // code de contr�le d'erreur
                    m_fast_connectivity[iface.index() * m_max_edge_count + i] = other_face;
                    m_fast_connectivity[other_face * m_max_edge_count + other_edge] = iface.index();
                    other_edge = -1; // code d'erreur si vue une seconde fois
                  }
              }
          }
      }
    else
      {
        throw NotImplementedException(A_FUNCINFO,String::format("Not implemected connectivity for mesh dimension {0}",mesh->dimension()));
      }

  }

  Integer neighbor(const Integer face_idx, const Integer index) const
  {
    return m_fast_connectivity[face_idx * m_max_edge_count + index];
  }

private:
  FaceVectorView m_view;
  Integer m_max_edge_count;
  IntegerSharedArray m_fast_connectivity;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

RealSharedArray
FaceVectorAnalysis::
computeLocalMeanNormal(const FaceVectorView group,
                       IMesh * mesh)
{
  RealSharedArray normal_parameters(10,0.);
  Real & vx2 = normal_parameters[0];
  Real & vy2 = normal_parameters[1];
  Real & vz2 = normal_parameters[2];
  Real & bbx = normal_parameters[3];
  Real & bby = normal_parameters[4];
  Real & bbz = normal_parameters[5];
  Real3 mean_normal(0,0,0);
    
  VariableNodeReal3 & nodes_coordinates = PRIMARYMESH_CAST(mesh)->nodesCoordinates();

  ENUMERATE_FACE(iface,group) {
    const Face & face = *iface;
    if (face.isOwn())
      {
        const Real face_factor = ((face.isSubDomainBoundaryOutside())?1:-1); // isBoundaryOutside since own

        Real3 normal;
        switch (face.type()) {
        case IT_Triangle3:
          normal 
            = face_factor*computeNormal(nodes_coordinates, face.node(0), face.node(1), face.node(2));
          break;
        case IT_Quad4:
          normal 
            = face_factor*computeNormal(nodes_coordinates, face.node(0), face.node(1), face.node(2))
            + face_factor*computeNormal(nodes_coordinates, face.node(2), face.node(3), face.node(0));
          break;
        case IT_Line2:
          normal = face_factor * Real3( nodes_coordinates[face.node(1)].z - nodes_coordinates[face.node(0)].z,
                                        0,
                                        nodes_coordinates[face.node(0)].x - nodes_coordinates[face.node(1)].x );
          break;
        default:
          throw NotImplementedException(A_FUNCINFO,"Non Tri3 or Quad4 face type");
        }
            
        vx2 += normal.x * normal.x;
        vy2 += normal.y * normal.y;
        vz2 += normal.z * normal.z;
        bbx += normal.y * normal.z;
        bby += normal.x * normal.z;
        bbz += normal.x * normal.y;
        mean_normal += normal;
        normal_parameters[9] += 1;
      }
  }

  normal_parameters[6] = mean_normal.x;
  normal_parameters[7] = mean_normal.y;
  normal_parameters[8] = mean_normal.z;
  return normal_parameters;
}

/*---------------------------------------------------------------------------*/

Real3 
FaceVectorAnalysis::
computeGlobalMeanNormal(RealConstArrayView local_normal_parameters, 
                        IParallelMng * parallelMng, 
                        ITraceMng * traceMng, 
                        bool use_minimization_algorithm)
{
  RealSharedArray normal_parameters = local_normal_parameters;
  parallelMng->reduce(Parallel::ReduceSum,normal_parameters);

  if (use_minimization_algorithm)
    {
      const Real & vx2 = normal_parameters[0];
      const Real & vy2 = normal_parameters[1];
      const Real & vz2 = normal_parameters[2];
      Real sum2 = vx2 + vy2 + vz2; // Pour normaliser les immenses coefficients issus de normal_parameters
      if (sum2 == 0) sum2 = 1;
  
      const Real ax = (vy2 + vz2) / sum2;
      const Real ay = (vx2 + vz2) / sum2;
      const Real az = (vx2 + vy2) / sum2;
      const Real bx = -2 * normal_parameters[3] / sum2;
      const Real by = -2 * normal_parameters[4] / sum2;
      const Real bz = -2 * normal_parameters[5] / sum2;
      Real3 normal(normal_parameters[6],normal_parameters[7],normal_parameters[8]);
      // const Real nface = normal_parameters[9];

      {
        Integer N = 3;
        Integer LDA = 3;
        Real matrix[9] = { 2*ax, bz, by, bz, 2*ay, bx, by, bx, 2*az };
        Real w[3] = { 0., 0., 0. }; // eigenvalues
        Integer lwork = 8; // taille zone de travail; >= max(1,3*N-1) 
        boost::shared_array<Real> work(new Real[lwork]);
        Integer code = 0;
        XSYEV<Real>::apply('V', 'U', N, matrix, LDA, w, work.get(), lwork, code);
        if (code != 0) traceMng->fatal() << "Cannot compute eigenvectors for mean plane";
  
        Real3 n1(matrix[0], matrix[1], matrix[2]);
        Real3 n2(matrix[3], matrix[4], matrix[5]);
        Real3 n3(matrix[6], matrix[7], matrix[8]);

        struct F {
          F(const Real & ax_, const Real & ay_, const Real & az_, 
            const Real & bx_, const Real & by_, const Real & bz_)
            : ax(ax_), ay(ay_), az(az_), bx(bx_), by(by_), bz(bz_) { }
          Real operator()(const Real3 & n) { 
            return ax * n.x*n.x + ay * n.y*n.y + az * n.z*n.z + bx * n.y*n.z + by * n.x*n.z + bz * n.x*n.y;
          }
        private: const Real ax, ay, az, bx, by, bz;
        } f(ax,ay,az,bx,by,bz);

        const Real fn1 = f(n1);
        const Real fn2 = f(n2);
        const Real fn3 = f(n3);

        //         traceMng->info() << "Eigenvalues " << w[0] << " " << w[1] << " " << w[2] << " code=" << code;
        //         traceMng->info() << "Eigenvectors " << n1 << " " << n2 << " " << n3;
        //         traceMng->info() << "f(Eigenvectors) " << fn1 << " " << fn2 << " " << fn3;
        //         traceMng->info() << "log f(Eigenvectors)" 
        //                          << " " << ((fn1>0)?::log(fn1):0.)
        //                          << " " << ((fn2>0)?::log(fn2):0.)
        //                          << " " << ((fn3>0)?::log(fn3):0.);
        //         traceMng->info() << "Normal = " << normal;

        if (fn1 < fn2)
          if (fn1 < fn3)
            return n1;
          else 
            return n3;
        else
          if (fn2 < fn3)
            return n2;
          else 
            return n3;
      }
    }
  else
    {
      return Real3(normal_parameters[6],normal_parameters[7],normal_parameters[8]);
    }
}

/*---------------------------------------------------------------------------*/

void 
FaceVectorAnalysis::
computeConnexComponents(const FaceVectorView & group,
                        IMesh * mesh,
                        IntegerArray & faceColors,
                        Integer & maxColor)
{
  FaceVectorConnectivity connectivity(group, mesh);

  const Integer nb_faces = group.size();
  faceColors.resize(nb_faces, -1);
  maxColor = 0;
  Integer first_isolated_face = 0;

 // Une face ne peut conceptuellement �tre scann�e deux fois => pas de reinit
  BoolSharedArray scanned_faces(nb_faces, false);
  Integer remaining_faces = nb_faces;
  std::stack<Integer> to_scan_faces;

  // Coloration en composantes connexes
  while(remaining_faces > 0)
    {
      while (faceColors[first_isolated_face] >= 0)
        ++first_isolated_face;
      to_scan_faces.push(first_isolated_face);
      scanned_faces[first_isolated_face] = true;
      first_isolated_face++;

      ARCANE_ASSERT((not to_scan_faces.empty()),("Invalid empty stack"));
      while (not to_scan_faces.empty())
        {
          const Integer current_face = to_scan_faces.top();
          to_scan_faces.pop();
          ARCANE_ASSERT((faceColors[current_face] == -1),("Invalid default color"));
          faceColors[current_face] = maxColor;
          remaining_faces--;
          const Integer nedges = group[current_face].nbNode(); // nbEdge n'est pas bien calcul� si les ar�tes ne sont pas activ�es
          for(Integer i=0;i<nedges;++i)
            {
              const Integer other_face = connectivity.neighbor(current_face, i);
              if (other_face >= 0 and scanned_faces[other_face] == false)
                {
                  to_scan_faces.push(other_face);
                  scanned_faces[other_face] = true;
                }
            }
        }
      ++maxColor;
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
