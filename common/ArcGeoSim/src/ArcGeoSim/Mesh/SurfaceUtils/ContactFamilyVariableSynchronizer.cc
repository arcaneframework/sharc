// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
/* Author : encheryg at Tue Apr 12 17:12:12 2016
 * Generated by createNew
 */

#include <ArcGeoSim/Mesh/SurfaceUtils/ContactFamily.h>
#include <ArcGeoSim/Utils/VMap.h>

#include "ContactFamilyVariableSynchronizer.h"

// S'inspire de VariableSynchronizer
/*---------------------------------------------------------------------------*/
Arcane::Int64 ContactFamilyVariableSynchronizer::
_form_unique_id(const ContactInternal & contact) const 
{
  const Arcane::Integer integer_size = 29;
  const Arcane::Int64 integer_mask = (Arcane::Int64(1)<<integer_size)-1 ;

  const Arcane::Item item_1(contact.item1Internal());
  const Arcane::Item item_2(contact.item2Internal());

  if (item_1.null())
    {
      ARCANE_ASSERT((not item_2.null()),("Inconsistent (null,null) contact"));
      const Arcane::Int64 item_2_uid = item_2.uniqueId();
      ARCANE_ASSERT(((item_2_uid & ~integer_mask) == 0 and item_2_uid < integer_mask),("Too large item2 unique id %d", item_2_uid));
      return item_2_uid << integer_size | integer_mask;
    }
  else
    {
      const Arcane::Int64 item_1_uid = item_1.uniqueId();
      ARCANE_ASSERT(((item_1_uid & ~integer_mask) == 0 and item_1_uid < integer_mask),("Too large item1 unique id %d", item_1_uid));

      if (item_2.null())
        {
          return integer_mask << integer_size | item_1_uid;
        }
      else
        {
          const Arcane::Int64 item_2_uid = item_2.uniqueId();
          ARCANE_ASSERT(((item_2_uid & ~integer_mask and item_2_uid < integer_mask) == 0),("Too large item2 unique id %d", item_2_uid));
          return item_2_uid << integer_size | item_1_uid;
        }
    }
}

/*---------------------------------------------------------------------------*/
void 
ContactFamilyVariableSynchronizer::
_uniqueIdToLocalId(Arcane::Int32ArrayView localIds, Arcane::Int64ConstArrayView uniqueIds) const 
{
  ARCANE_ASSERT((localIds.size() == uniqueIds.size()),("Incompatible array argument sizes"));

  const Arcane::Integer family_size = m_contactGroup.family() -> maxLocalId();
  ArcGeoSim::VMap<Int64, Int32> uid_to_lid_map(family_size);

  const ContactInternal * internals = m_contactGroup.family() -> contactsInternal();
  for(Arcane::Integer i=0;i<family_size;++i)
    {
      const Arcane::Int64 uid = _form_unique_id(internals[i]);
      const Arcane::Int32 lid = i;
      uid_to_lid_map[uid] = lid;
    }

  const Arcane::Integer sample_size = uniqueIds.size();
  for(Arcane::Integer i=0;i<sample_size;++i)
    {
      ArcGeoSim::VMap<Int64, Int32>::const_iterator finder = uid_to_lid_map.find(uniqueIds[i]);
      if (finder == uid_to_lid_map.end())
        throw Arcane::FatalErrorException(A_FUNCINFO, "Cannot find contact uid");
      localIds[i] = finder.value();
    }
}

/*---------------------------------------------------------------------------*/
void 
ContactFamilyVariableSynchronizer::
_checkValid(Arcane::ArrayView<GhostRankInfo> ghost_rank_info,
            Arcane::ArrayView<ShareRankInfo> share_rank_info)
{
  Arcane::Integer nb_comm_proc = ghost_rank_info.size();
  Arcane::Integer nb_error  = 0;
  bool has_error = false;
  const Arcane::Integer max_error = 10; 
  Arcane::Int32 my_rank = m_parallelMng->commRank();
  IContactFamily* contactFamily = m_contactGroup.family() ;
  ContactInternal* contactsInternal = contactFamily -> contactsInternal() ;

  Arcane::SharedArray<bool> marked_elem(contactFamily -> maxLocalId());
  marked_elem.fill(false);
  ENUMERATE_CONTACT(i, m_contactGroup){
    const Contact contact = *i;
    if(contact.isOwn()) {
      marked_elem[contact.localId()] = true;
    }
  }

  for(Arcane::Integer i_comm=0; i_comm<nb_comm_proc; ++i_comm ){
    GhostRankInfo& ghost_info = ghost_rank_info[i_comm];
    ShareRankInfo& share_info = share_rank_info[i_comm];
    if (ghost_info.rank()!=share_info.rank()){
      throw Arcane::FatalErrorException(A_FUNCINFO, Arcane::String::format("Inconsistency between the subdomain numbers")) ; 
    }
    Arcane::Integer current_proc = ghost_info.rank();
    Arcane::Int32ConstArrayView ghost_grp = ghost_info.localIds();
    Arcane::Int32ConstArrayView share_grp = share_info.localIds();

    if(share_grp.empty() && ghost_grp.empty()){
      has_error = true;
      continue;
    }
    if(current_proc==my_rank){
      has_error = true;
      continue;
    }

    for(Arcane::Integer z=0, zs=ghost_grp.size(); z<zs; ++z ){
      const ContactInternal ci = contactsInternal[ghost_grp[z]];
      bool is_marked = marked_elem[ci.localId()];
      if(is_marked){
        if (nb_error<max_error)
        ++nb_error;
        continue;
      }
      marked_elem[ci.localId()] = true;
    }

    bool is_send_first = current_proc < my_rank;
    m_sync_list.add( VariableSyncInfo (share_grp,ghost_grp,current_proc,is_send_first) );
  }

  ENUMERATE_CONTACT(i, m_contactGroup){
    const Contact contact = *i;
    if(!marked_elem[contact.localId()]){
      ++nb_error;
    }
  }

  if(nb_error!=0){
    has_error = true;
  }
  if(has_error)
    throw Arcane::FatalErrorException(A_FUNCINFO, Arcane::String::format("Fatal error while creating the exchange structures of the contact family"));
}

/*---------------------------------------------------------------------------*/
void ContactFamilyVariableSynchronizer::compute() {
  Arcane::Integer my_rank = m_parallelMng -> commRank() ;
  Arcane::Integer nb_rank = m_parallelMng -> commSize() ;

  Arcane::SharedArray<Arcane::Int32SharedArray> boundary_items(nb_rank) ;

  ENUMERATE_CONTACT(i, m_contactGroup){
    Arcane::Integer owner = i -> owner() ;
    if(owner == my_rank)
      continue ;
    boundary_items[owner].add(i -> localId()) ;
  }

  m_sync_list.clear() ;

  m_communicating_ranks.clear() ;
  Arcane::Int32SharedArray communicating_ghost_ranks ;
  for(Arcane::Integer i = 0 ; i < nb_rank ; ++i){
    if(boundary_items[i].empty())
      continue ;
    communicating_ghost_ranks.add(i) ;
  }

  Arcane::Integer nb_comm_rank = communicating_ghost_ranks.size() ;

  Arcane::Int32SharedArray nb_ghost(nb_rank) ;
  Arcane::Int32SharedArray nb_share(nb_rank) ;
  nb_ghost.fill(0) ;

  Arcane::Integer max_comm_rank = m_parallelMng -> reduce(Arcane::Parallel::ReduceMax, nb_comm_rank) ;

  Arcane::SharedArray<Arcane::Int32SharedArray> ghost_group_list(boundary_items.size()) ;

  for(Arcane::Integer i = 0 ; i < nb_comm_rank ; ++i){
    Arcane::Int32 current_rank = communicating_ghost_ranks[i] ;
    Arcane::Int32SharedArray ghost_grp = boundary_items[current_rank] ;
    ghost_group_list[i] = ghost_grp ;
    nb_ghost[current_rank] = ghost_grp.size() ;
  }

  Arcane::SharedArray<ShareRankInfo> share_rank_info ;
  Arcane::SharedArray<GhostRankInfo> ghost_rank_info;
  {
    Arcane::Integer gather_size = 1+(max_comm_rank*2) ;
    Arcane::Int32SharedArray global_ghost_info(gather_size*nb_rank) ;
    {
      Arcane::Int32SharedArray local_ghost_info(gather_size);
      Arcane::Integer pos = 0;
      local_ghost_info[pos++] = nb_comm_rank;

      for(Arcane::Integer index = 0, s = communicating_ghost_ranks.size(); index<s; ++index ){
        local_ghost_info[pos++] = communicating_ghost_ranks[index];
        local_ghost_info[pos++] = ghost_group_list[index].size();
      }

      m_parallelMng -> allGather(local_ghost_info,global_ghost_info);
    }
    {
      for(Arcane::Integer index=0, s=nb_rank; index<s; ++index ){
        Arcane::Integer pos = gather_size*index;
        Arcane::Integer sub_size = global_ghost_info[pos++];
        for(Arcane::Integer sub_index=0; sub_index<sub_size; ++sub_index ){
          Arcane::Integer proc_id = global_ghost_info[pos++];
          Arcane::Integer nb_elem = global_ghost_info[pos++];
          if (proc_id==my_rank){
            share_rank_info.add(ShareRankInfo(index,nb_elem));
          }
        }
      }
    }    
    {
      Arcane::Integer nb_send = communicating_ghost_ranks.size() ;
      ghost_rank_info.resize(nb_send) ;
      for(Arcane::Integer i=0; i<nb_send; ++i ){
          Arcane::Int32SharedArray gr = ghost_group_list[i] ;
          ghost_rank_info[i].setInfos(communicating_ghost_ranks[i],gr) ;
      }
    }
  }

  IContactFamily* contactFamily = m_contactGroup.family() ;
  ContactInternal* contactsInternal = contactFamily -> contactsInternal() ;
  {
    {
      Arcane::Integer nb_recv = share_rank_info.size();
      Arcane::Integer nb_send = ghost_rank_info.size();

      for(Arcane::Integer i = 0 ; i < nb_send ; ++i){
          Arcane::Integer proc_id = ghost_rank_info[i].rank();
          Arcane::Integer z = 0;
        for( ; z<nb_recv; ++z )
          if(share_rank_info[z].rank()==proc_id)
            break;
        if (z==nb_recv){
          share_rank_info.add(ShareRankInfo(proc_id));
        }
      }

      for(Arcane::Integer i=0; i<nb_recv; ++i ){
        Arcane::Integer proc_id = share_rank_info[i].rank();
        Arcane::Integer z = 0;
        for( ; z<nb_send; ++z )
          if(ghost_rank_info[z].rank()==proc_id)
            break;
        if (z==nb_send){
          ghost_rank_info.add(GhostRankInfo(proc_id));
        }
      }

      if (ghost_rank_info.size()!=share_rank_info.size()){
        throw Arcane::FatalErrorException(A_FUNCINFO, Arcane::String::format("Problem with the number of subdomain shared ({0}) and ghsots ({1})",
                                                                             share_rank_info.size(), ghost_rank_info.size())) ;
      }
      std::sort(share_rank_info.begin(),share_rank_info.end());
      std::sort(ghost_rank_info.begin(),ghost_rank_info.end());
    }
  
    Arcane::Integer nb_comm_proc = ghost_rank_info.size();
    Arcane::SharedArray<Arcane::Parallel::Request> requests;
    {
      Arcane::Integer current_send_index = 0;
      Arcane::Integer current_recv_index = 0;
      for(Arcane::Integer i=0; i<nb_comm_proc*2; ++i ){
        Arcane::Integer send_proc = nb_rank;
        Arcane::Integer recv_proc = nb_rank;
        if(current_send_index!=nb_comm_proc)
          send_proc = ghost_rank_info[current_send_index].rank();
        if(current_recv_index!=nb_comm_proc)
          recv_proc = ghost_rank_info[current_recv_index].rank();
        bool do_send = true;
        if(send_proc==recv_proc){
          if(send_proc<my_rank)
            do_send = true;
          else
            do_send = false;
        }
        else if(send_proc<recv_proc)
          do_send = true;
        else
          do_send = false;
        if(do_send){
          GhostRankInfo& asdi = ghost_rank_info[current_send_index];
          asdi.resize();
          Arcane::Int64ArrayView uids = asdi.uniqueIds();
          Arcane::Int32ConstArrayView asdi_local_ids = asdi.localIds();
          Arcane::Integer nb_local = asdi_local_ids.size();
          for(Arcane::Integer z=0, zs=nb_local; z<zs; ++z ){
            const ContactInternal elem = contactsInternal[asdi_local_ids[z]];
            uids[z] = _form_unique_id(elem) ; 
          }
          if (!uids.empty())
            requests.add(m_parallelMng->send(uids,send_proc,false));
          ++current_send_index;
        }
        else{
          ShareRankInfo& asdi = share_rank_info[current_recv_index];
          asdi.resize();
          Arcane::Int64ArrayView contacts_unique_id = asdi.uniqueIds();
          if(!contacts_unique_id.empty())
            m_parallelMng -> recv(contacts_unique_id,recv_proc);
          Arcane::Int32SharedArray contacts_local_id(contacts_unique_id.size());
          _uniqueIdToLocalId(contacts_local_id, contacts_unique_id) ;
          Arcane::Int32SharedArray share_group = contacts_local_id;
          asdi.setLocalIds(share_group);
          ++current_recv_index;
        }
      }
      m_parallelMng -> waitAllRequests(requests) ;
    }
  }
  _checkValid(ghost_rank_info, share_rank_info);

  for(Arcane::Integer i=0; i<m_sync_list.size(); ++i ){
    const VariableSyncInfo & sync_info = m_sync_list[i];
    const Arcane::Integer target_rank = sync_info.targetRank();
    m_communicating_ranks.add(target_rank);
    ARCANE_ASSERT((sync_info.m_ghost_ids.size() == boundary_items[target_rank].size()),("Inconsistent ghost count"));
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
