// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "ContactFamily.h"
/* Author : havep at Thu Jun  4 14:46:21 2009
 * Generated by createNew
 */

#ifdef WIN32
#include <ciso646>
#endif

#include <arcane/utils/ArgumentException.h>
#include <arcane/utils/FatalErrorException.h>
#include <arcane/utils/NotImplementedException.h>
#include <arcane/ItemGroup.h>
#ifdef USE_ARCANE_V3
#include <arcane/mesh/DualUniqueIdMng.h>
#else
#include <arcane/utils/DualUniqueIdMng.h>
#endif
#include <arcane/ArcaneTypes.h>

#include "ArcGeoSim/Mesh/SurfaceUtils/ContactGroupImpl.h"
#include "ArcGeoSim/Mesh/SurfaceUtils/IContactVariable.h"
#include "ArcGeoSim/Mesh/SurfaceUtils/ContactGroup.h"
#include "ArcGeoSim/Mesh/SurfaceUtils/ContactFamilyVariableSynchronizer.h"
#include "ArcGeoSim/Utils/ArrayUtils.h"

/*---------------------------------------------------------------------------*/

ContactFamily::
ContactFamily(Arcane::ITraceMng * traceMng, Arcane::IItemFamily * family1, Arcane::IItemFamily * family2)
  : TraceAccessor(traceMng)
  , m_shared_info(family1,family2)
  , m_synchronizer(nullptr)
  , m_name(Arcane::String::format("Contact{0}{1}",m_shared_info.m_family1->name(),m_shared_info.m_family2->name()))
{
  m_groups["AllContacts"] = new ContactGroupImpl(this,m_local_ids,"AllContacts",true);
  m_synchronizer = new ContactFamilyVariableSynchronizer(family1->parallelMng(),allContacts());

}

/*---------------------------------------------------------------------------*/

ContactFamily::
~ContactFamily()
{
  debug() << "Destroying family " << this;
  while(not m_variables.empty()) {
    std::set< IContactVariable* >::iterator i = m_variables.begin();
    (*i)->detachFromFamily();
  }

  for(std::map<String,ContactGroupImpl*>::iterator i = m_groups.begin();
      i != m_groups.end(); ++i)
    {
      delete i->second;
    }
  delete m_synchronizer;
}

void ContactFamily::updateInternalList()
{
  m_shared_info.update() ;
}
/*---------------------------------------------------------------------------*/

ContactGroup
ContactFamily::
allContacts()
{
  std::map<String,ContactGroupImpl*>::iterator finder = m_groups.find("AllContacts");
  ARCANE_ASSERT((finder != m_groups.end()),("Missing AllContacts internal group"));
  return finder->second;
}

/*---------------------------------------------------------------------------*/

ContactInternal * 
ContactFamily::
contactsInternal()
{
 return m_internals.unguardedBasePointer(); 
}

/*---------------------------------------------------------------------------*/

const ContactInternal * 
ContactFamily::
contactsInternal() const
{
 return m_internals.unguardedBasePointer(); 
}



/*---------------------------------------------------------------------------*/

void
ContactFamily::
registerVariable(IContactVariable* var)
{
  /* const bool insertion = */ m_variables.insert(var);
  debug() << "ContactFamily " << this << " register Variable " << var;
}

/*---------------------------------------------------------------------------*/

void
ContactFamily::
unregisterVariable(IContactVariable* var)
{
  std::set<IContactVariable*>::iterator finder = m_variables.find(var);
  if (finder == m_variables.end())   
    {
      fatal() << "Cannot unregister a variable never registered";
    }
  else 
    {
      debug() << "ContactFamily " << this << " unregister Variable " << var;
      m_variables.erase(finder);
    }
}

/*---------------------------------------------------------------------------*/

Int32
ContactFamily::
addContact(const Int32 lid1, const Int32 lid2)
{
  if (not m_variables.empty())
    fatal() << "Management of addContact with existing variables not implemented";
  const Int32 lid = m_internals.size();
  m_internals.add(ContactInternal());
  ContactInternal & internal = m_internals[lid];
  m_local_ids.add(lid);
  internal.m_local_id = lid;
  internal.m_lid1 = lid1;
  internal.m_lid2 = lid2;
  internal.m_shared_info = &m_shared_info;
  return lid;
}

/*---------------------------------------------------------------------------*/

ContactGroup
ContactFamily::
createGroup(const String & name)
{
  ContactGroup group = findGroup(name);
  if (!group.null()) {
    fatal() << "Cannot create existing ContactGroup '" << name << "'";
  }
  ContactGroupImpl * new_group = new ContactGroupImpl(this,Arcane::Int32SharedArray(),name,false);
  m_groups[name] = new_group;
  debug(Arcane::Trace::Medium) << "Create new contact group '" << name << "' with impl " << new_group;
  return new_group;
}

/*---------------------------------------------------------------------------*/

ContactGroup
ContactFamily::
findGroup(const String & name)
{
  std::map<String,ContactGroupImpl*>::iterator finder = m_groups.find(name);
  if (finder == m_groups.end())
    return ContactGroup();
  else
    return finder->second;
}

/*---------------------------------------------------------------------------*/

void
ContactFamily::
notifyGroupChange(ContactGroupImpl * group)
{
  // Avertir les variables partiels utilisant ce groupe
}

/*---------------------------------------------------------------------------*/

void
ContactFamily::
computeSynchronizeInfos()
{
  if (m_synchronizer->parallelMng()->isParallel())
    {
      m_synchronizer->compute();
    }
  m_is_synchronized = true;
}

/*---------------------------------------------------------------------------*/

Arcane::IVariableSynchronizer*
ContactFamily::
allItemsSynchronizer()
{
  if (!m_is_synchronized)
    m_synchronizer->parallelMng()->traceMng()->fatal() <<
      Arcane::String::format("In contact family ({0}) ContactFamily::computeSynchronizeInfos() must be called before call to ContactFamily::allItemsSynchronizer()",
                             m_name);
  return m_synchronizer;

}

/*---------------------------------------------------------------------------*/

void
ContactFamily::
endUpdate()
{
//#ifndef NO_USER_WARNING
//#ifndef WIN32
//#warning "TODO: or CHECK"
//#endif
//#endif /* NO_USER_WARNING */
  m_is_synchronized = false;
}

/*---------------------------------------------------------------------------*/

ContactSharedInfo*
ContactFamily::sharedInfo() {
  return &m_shared_info;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

FaceFaceContactFamily::
FaceFaceContactFamily(Arcane::ITraceMng * traceMng, Arcane::IItemFamily * family) 
  : ContactFamily(traceMng,family,family)
  , m_face_group_need_update(true)
{
  if (family->itemKind() != Arcane::IK_Face)
    throw Arcane::ArgumentException(A_FUNCINFO,"FaceFaceContactFamily requires a family of face");
}

/*---------------------------------------------------------------------------*/

NodeFaceContactFamily::
NodeFaceContactFamily(Arcane::ITraceMng * traceMng, Arcane::IItemFamily * node_family, Arcane::IItemFamily * face_family) 
  : ContactFamily(traceMng,node_family,face_family) 
{ 
  if (node_family->itemKind() != Arcane::IK_Node or face_family->itemKind() != Arcane::IK_Face)
    throw Arcane::ArgumentException(A_FUNCINFO,"NodeFaceContactFamily requires families of nodes and faces");
}

/*---------------------------------------------------------------------------*/

Arcane::FaceGroup 
FaceFaceContactFamily::
allFaces()
{
  if(m_face_group_need_update)
  {
//#ifndef NO_USER_WARNING
//#ifndef WIN32
//#warning "BUG: remise ��� jour non effective si les contacts sont modifi���s"
//#endif
//#endif
    _updateFaceGroup() ;
    m_face_group_need_update = false ;
  }
  return m_face_group ;
}

/*---------------------------------------------------------------------------*/


void
FaceFaceContactFamily::
_updateFaceGroup()
{
//#ifndef NO_USER_WARNING
//#ifndef WIN32
//#warning "TODO: A optimiser en utilisant les techniques classiques Arcane"
//#warning "TODO: A calculer de mani���re incr���mental pour stabiliser le groupe si c'est un support"
//#endif
//#endif
  std::set<Integer> mark ;
  SharedArray<Integer> lids ;
  ContactGroup contacts = allContacts() ;
  lids.reserve(2*contacts.size()) ;
  ENUMERATE_FACEFACECONTACT(icontact,contacts)
  {
    const ContactType& contact = *icontact ;
    Integer face_local_id = contact.face1().localId() ;
    if(face_local_id != Arcane::NULL_ITEM_LOCAL_ID && mark.find(face_local_id)==mark.end())
      {
        mark.insert(face_local_id) ;
        lids.add(face_local_id) ;
      }
    face_local_id = contact.face2().localId() ;
    if(face_local_id != Arcane::NULL_ITEM_LOCAL_ID && mark.find(face_local_id)==mark.end())
      {
        mark.insert(face_local_id) ;
        lids.add(face_local_id) ;
      }
  }
  m_face_group_name ="FaceFaceContactFaceGroup" ;
  m_face_group = m_shared_info.m_family1->createGroup(m_face_group_name,lids,true) ;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
ContactItemFamily::
_updateInternals()
{
  m_uids.resize(m_contact_family->nbContact());
  m_uids_view = m_uids.view();
#ifdef USE_ARCANE_V3
#if ARCANE_VERSION < 31307
  ARCANE_FATAL("Not yet implemented with this Arcane version. Use at least Arcane 3.13.8");
#else
  auto *associated_dof_family =
      m_dof_mng.getFamily(m_associated_dof_family_name);
  auto nb_dofs = associated_dof_family->nbItem();
  auto nb_contacts = m_contact_family->nbContact();
  Arcane::Int64UniqueArray new_contact_uids(Arcane::math::max(nb_contacts-nb_dofs,0));
  Arcane::Int32UniqueArray new_contact_lids(Arcane::math::max(nb_contacts-nb_dofs,0));
  auto index = 0;
  for (auto contact_index = nb_dofs; contact_index < nb_contacts ; ++contact_index) {
    auto contact_internal = m_contact_family->contactsInternal()[contact_index];
    new_contact_lids[index] = contact_internal.localId();
    new_contact_uids[index] = _uniqueId(contact_internal);
    index++;
  }
  auto nb_new_contacts = new_contact_uids.size();
  Arcane::Int32UniqueArray dof_lids(new_contact_uids.size());
  associated_dof_family->addDoFs(new_contact_uids,dof_lids);
  // the only thing needed : an array with the internals!
  m_internals = associated_dof_family->itemFamily()->itemsInternal();
  // Change the internals lids to make them match with contact ones. Attention it changes dof lids...
  for (auto index = 0; index < nb_new_contacts; ++index) {
    m_internals[dof_lids[index]]->setLocalId(new_contact_lids[index]);
  }
#endif // ARCANE VERSION
#else
  m_shared_info.m_unique_ids = &m_uids_view;
  for (Arcane::Integer contact_index = m_internals.size(); contact_index < m_contact_family->nbContact(); ++contact_index) {
    Arcane::ItemInternal *internal = new Arcane::ItemInternal();
    ContactInternal contact =
        m_contact_family->contactsInternal()[contact_index];
    internal->setSharedInfo(&m_shared_info);
    internal->setLocalId(contact.localId());
    internal->setUniqueId(_uniqueId(contact));
    m_internals.add(internal);
  }
#endif
}

/*---------------------------------------------------------------------------*/

template <typename Item1T, typename Item2T>
Arcane::Int64
_computeUniqueId(ContactInternal const& contact)  {
  auto null_uid = Arcane::NULL_ITEM_UNIQUE_ID;
  Arcane::Int64 unique_id = null_uid;
  if (contact.item1Internal()->uniqueId() != null_uid && contact.item2Internal()->uniqueId() != null_uid) {
    unique_id = Arcane::DualUniqueIdMng::uniqueIdOf<Item1T,Item2T>(contact.item1Internal(),
                                                                   contact.item2Internal());
  }
  else if (contact.item1Internal()->uniqueId() == null_uid && contact.item2Internal()->uniqueId() != null_uid) {
    unique_id = Arcane::DualUniqueIdMng::uniqueIdOf<Item2T>(contact.item2Internal());
  }
  else if (contact.item1Internal()->uniqueId() != null_uid && contact.item2Internal()->uniqueId() == null_uid){
    unique_id = Arcane::DualUniqueIdMng::uniqueIdOf<Item1T>(contact.item1Internal());
  }
  else unique_id = Arcane::NULL_ITEM_UNIQUE_ID;
  return unique_id;
}

/*---------------------------------------------------------------------------*/

Arcane::Int64
ContactItemFamily::
_uniqueId(ContactInternal& contact)
{
  auto unique_id = Arcane::NULL_ITEM_UNIQUE_ID;

  switch (contact.m_shared_info->m_kind) {
    case IContactFamily::IK_FaceFace:
      unique_id = _computeUniqueId<Arcane::Face, Arcane::Face>(contact);
      break;
    case IContactFamily::IK_NodeFace:
      unique_id = _computeUniqueId<Arcane::Node, Arcane::Face>(contact);
      break;
  }
  if (unique_id == Arcane::NULL_ITEM_UNIQUE_ID)
    traceMng()->fatal()
      << Arcane::String::format("Cannot create a uid for a null contact (with local id {1}). Both contact items have null uid. In family {0}.",
                                name(),contact.localId());
  return unique_id;
}

/*---------------------------------------------------------------------------*/

void
ContactItemFamily::
itemsUniqueIdToLocalId(Int32ArrayView local_ids,Int64ConstArrayView unique_ids,bool do_fatal) const
{
  ARCANE_ASSERT(local_ids.size() == unique_ids.size(),("Lids and Uids array sizes must be equal."))
  ARCANE_ASSERT(unique_ids.size() <= m_uids.size(), ("Contact uids have not been generated.")) // contact uids are generated calling view() methods. If you come up with
  // uids, it means you have already generated them...Assertion should always be ok
  Arcane::Integer index, i = 0;
  for (auto uid : unique_ids)
    {
      index = ArcGeoSim::ArrayScan::exhaustiveScan(uid,m_uids.constView());
      if (index == -1)
        {
          local_ids[i++] = Arcane::NULL_ITEM_LOCAL_ID;
          if (do_fatal) throw Arcane::FatalErrorException(Arcane::String::format("No contact with unique id {0}",uid));
        }
      else
        {
          local_ids[i++] = m_contact_family->contactsInternal()[index].localId();
        }
    }
}


/*---------------------------------------------------------------------------*/
