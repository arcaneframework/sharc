// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_PROPERTYMAPPING_H
#define ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_PROPERTYMAPPING_H
/* Author : desrozis at Tue Nov 13 08:40:09 2012
 * Generated by createNew
 */

/*
 * \ingroup Law
 * \brief Outil permettant d'effectuer le mapping de proprietes
 *
 */

#include "ArcGeoSim/Physics/Law2/PropertyVector.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE
  
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class PropertyMapping
{
public:

  PropertyMapping()
    : m_property_offset(-1) {} // Pour etre dans les conteneurs

  PropertyMapping(const Property& property,
                  const PropertyVector& dependencies)
    : m_property(property)
    , m_user_dependencies(dependencies)
    , m_reference_dependencies(dependencies)
    , m_properties(dependencies.properties())
    , m_user_offset(dependencies.offset())
    , m_user_size(dependencies.propertySize())
    , m_reference_offset(dependencies.offset())
    , m_property_offset(-1)
  {
    ARCANE_ASSERT((not m_user_dependencies.contains(m_property)),("Property is in dependencies"));
  }

  PropertyMapping(const Property& property,
                  const PropertyVector& user_properties,
                  const PropertyVector& reference_dependencies)
    : m_property(property)
    , m_user_dependencies(user_properties)
    , m_reference_dependencies(reference_dependencies)
    , m_property_offset(-1)
  {
    SharedArray<Property> user = m_user_dependencies.properties();           // recopie
    SharedArray<Property> reference = m_reference_dependencies.properties(); // recopie

    std::sort(user.begin(), user.end());
    std::sort(reference.begin(), reference.end());
    
    SharedArray<Property> properties(user.size() + reference.size());
    
    SharedArray<Property>::iterator it = std::set_intersection(user.begin(), user.end(),
                                                         reference.begin(), reference.end(),
                                                         properties.begin());
      
    const Integer size = static_cast<Integer>(it - properties.begin());
      
    m_properties.reserve(size);

    for(Integer i = 0; i < size; ++i) {
      const Property& p = properties[i];
      if(p.id() == m_property.id()) continue;
      m_properties << p;
      m_user_offset.add(m_user_dependencies.offset(p));
      m_reference_offset.add(m_reference_dependencies.offset(p));
      m_user_size.add(m_user_dependencies.size(p));
    }
    
    if(m_user_dependencies.contains(m_property))
      m_property_offset = m_user_dependencies.offset(m_property);
  }
    
  inline const Property& property() const { return m_property; }
  inline const IntegerArray& userOffset() const { return m_user_offset; }
  inline const IntegerArray& userSize() const { return m_user_size; }
  inline const IntegerArray& referenceOffset() const { return m_reference_offset; }
  inline const PropertyVector& properties() const { return m_properties; }
  inline Integer propertyOffset() const { return m_property_offset; }
  
  const PropertyVector& userDependencies() const { return m_user_dependencies; }
  const PropertyVector& referenceDependencies() const { return m_reference_dependencies; }
  
private:

  Property m_property;
  
  PropertyVector m_user_dependencies;
  PropertyVector m_reference_dependencies;
    
  PropertyVector m_properties;
  Arcane::IntegerSharedArray m_user_offset;
  Arcane::IntegerSharedArray m_user_size;
  Arcane::IntegerSharedArray m_reference_offset;
  
  Integer m_property_offset;
};
  
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_PROPERTYMAPPING_H */
