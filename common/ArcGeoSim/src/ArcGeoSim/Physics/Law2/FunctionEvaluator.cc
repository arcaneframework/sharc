// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#ifdef WIN32
#include <ciso646>
#endif

#include "FunctionEvaluator.h"
/* Author : desrozis at Tue Nov 13 08:40:09 2012
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

FunctionEvaluator::
FunctionEvaluator(const FunctionManager& f, Integer max_nb_unknowns)
  : m_function_mng(f)
  , m_functions(f.functions())
  , m_parameters(f.parameters())
  , m_max_nb_unknowns(max_nb_unknowns)
  , m_is_first_derivate_eval(true) {}

/*---------------------------------------------------------------------------*/

FunctionEvaluator::
FunctionEvaluator(const FunctionManager& f, IntegerConstArrayView ids, Integer max_nb_unknowns)
  : m_function_mng(f)
  , m_functions(f.functions(ids))
  , m_parameters(f.parameters())
  , m_max_nb_unknowns(max_nb_unknowns)
  , m_is_first_derivate_eval(true) {}

/*---------------------------------------------------------------------------*/

void 
FunctionEvaluator::
evaluate(const ArrayAccessor& accessor, Integer begin, Integer end, EvaluationMode mode)
{
  switch(mode) {
  case eWithoutDerivative:
    _evaluate(m_parameters, accessor, begin, end);
    _evaluate(m_functions, accessor, begin, end);
    break;
  case eWithDerivative:
    evaluateWithDerivatives(accessor, begin, end);
    break;
  default:
    throw Arcane::FatalErrorException("Not implemented");
  }
}

/*---------------------------------------------------------------------------*/
  
void 
FunctionEvaluator::
evaluate(const ScalarAccessor& accessor, EvaluationMode mode)
{
  switch(mode) {
  case eWithoutDerivative:
    _evaluate(m_parameters, accessor);
    _evaluate(m_functions, accessor);
    break;
  case eWithDerivative:
    evaluateWithDerivatives(accessor);
    break;
  default:
    throw Arcane::FatalErrorException("Not implemented");
  }
}

/*---------------------------------------------------------------------------*/

void
FunctionEvaluator::
evaluateWithDerivatives(const ArrayAccessor& accessor, Integer begin, Integer end)
{
  _evaluate(m_parameters, accessor, begin, end);
  _evaluateWithDerivatives(m_functions, accessor, begin, end);
}

/*---------------------------------------------------------------------------*/

void 
FunctionEvaluator::
evaluateWithDerivatives(const ScalarAccessor& accessor)
{
  _evaluate(m_parameters, accessor);
  _evaluateWithDerivatives(m_functions, accessor);
}

/*---------------------------------------------------------------------------*/

void 
FunctionEvaluator::
symbolic_evaluate(const Accessor& accessor, Arcane::ITraceMng* trace) 
{
  trace->info() << "Symbolic evaluation :";
  if(m_parameters.size() == 0)
    trace->info() << "no parameter functions to evaluate";
  else {
    trace->info() << "- parameter functions :";
    _symbolic_evaluate(accessor, trace, m_parameters);
  }

  if(m_functions.size() == 0)
    trace->info() << "No functions to evaluate";
  else {
    trace->info() << "- functions :";
    _symbolic_evaluate(accessor, trace, m_functions);
  }
}

/*---------------------------------------------------------------------------*/

void 
FunctionEvaluator::
_symbolic_evaluate(const Accessor& accessor, Arcane::ITraceMng* trace, FunctionEnumerator& functions)
{
  functions.reset();
  for( ; functions.hasNext(); ++functions) {
    const IFunction& f = functions.function();
    trace->info() << "   evaluation of " << f;
    _check(f.in(), accessor, trace);
    _check(f.out(), accessor, trace);
    _check(f.parameters(), accessor, trace);
  }
} 

/*---------------------------------------------------------------------------*/
  
void 
FunctionEvaluator::
_check(const PropertyVector& properties, const Accessor& accessor, Arcane::ITraceMng* trace) 
{
  for(Integer i = 0; i < properties.size(); ++i)
    if(not accessor.contains(properties[i]))
      trace->fatal() << "Property " << properties[i].name() << " is not registered";
}
 
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
