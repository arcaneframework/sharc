// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_DERIVATIVE_H
#define ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_DERIVATIVE_H
/* Author : desrozis at Mon Apr 18 15:05:40 2011
 * Generated by createNew
 */

/*
 * \ingroup Law
 * \brief Outils pour l'�valuation point � point des d�riv�es des fonctions
 *
 * Le derivative est une base de donn�es de propri�t�s et de valeurs des d�riv�es associ�es
 * Son remplissage est � la charge des outils des lois lors de l'�valuation
 *
 * \code
 *
 * ScalarRealProperty In_1(0,"In_1");
 * ScalarRealProperty In_2(1,"In_2");
 * VectorialRealProperty In_3(2,"In_3",2);
 *
 * ScalarRealProperty Out_1(3,"Out_1");
 * ScalarRealProperty Out_2(4,"Out_2");
 * VectorialRealProperty Out_3(5,"Out_3",3);
 *
 * Derivative d;
 * 
 * // Utilisation lors d'une �valuation d'une fonction (In_1,In_2,In_3) -> (Out_1,Out_2,Out_3) 
 * ...
 *
 * // Accession aux d�riv�es :
 *
 * ... d[Out_1][In_1] ...
 * ... d[Out_1][In_2] ...
 * ... d[Out_1][In_3][0] ...
 * ... d[Out_1][In_3][1] ...
 *   
 * ... d[Out_2][In_1] ...
 * ... d[Out_2][In_2] ...
 * ... d[Out_2][In_3][0] ...
 * ... d[Out_2][In_3][1] ...
 *   
 * for(Integer i = 0; i < Out_3.size(); ++i) {
 *   ... d[Out_3][i][In_1] ...
 *   ... d[Out_3][i][In_2] ...
 *   ... d[Out_3][i][In_3][0] ...
 *   ... d[Out_3][i][In_3][1] ...
 * }
 
 * info() << d;
 *
 * \endcode
 *
 */

#include "ArcGeoSim/Physics/Law2/DerivativeView.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace details {
   
  /*
   * \brief Classe interne g�n�rique g�rant un type de propri�t� (Scalaire/vectorielle)
   *
   */
  template<typename P>
  class PartialDerivativeT
  { 
  public:
    
    typedef DerivativeView<P> ViewType;
    
    typedef typename ViewType::ReferenceType ReferenceType;
    typedef typename ViewType::ConstReferenceType ConstReferenceType;
    
  public:
    
    PartialDerivativeT(const PropertyVector& dependencies) 
      : m_dependencies(dependencies) {}
   
    PartialDerivativeT<P>& operator<<(const P& p)
    {
      m_properties << p;
      m_views.resize(m_properties.size());
      m_views[m_properties[p]] = ViewType(m_dependencies,p);
      return *this;
    }
    
    //! Valeurs pour une propri�t�
    ReferenceType values(const Property& p)
    {
      ARCANE_ASSERT( (contains(p)), ("Property not registered in derivative"));
      
      return m_views[m_properties[p]].values();
    }
   
    //! Vue pour une propri�t�
    ViewType& operator[](const Property& p)
    {
      ARCANE_ASSERT( (contains(p)), ("Property not registered in derivative"));
      
      return m_views[m_properties[p]];
    }
    
    //! Vue pour une propri�t�
    const ViewType& operator[](const Property& p) const
    {
      ARCANE_ASSERT( (contains(p)), ("Property not registered in derivative"));
      
      return m_views[m_properties[p]];
    }
   
    //! Teste si la propri�t� est pr�sente
    bool contains(const Property& p) const 
    {
      return m_properties.contains(p);
    }
    
    //! D�pendances
    const PropertyVector& dependencies() const { return m_dependencies; }
    
    //! Tableau des vues
    ConstArrayView<ViewType> views() const { return m_views; }
    
  private:
    
    PropertyVector m_properties;

    const PropertyVector& m_dependencies;
    
    SharedArray<ViewType> m_views;
  };

}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \brief Classe Derivative pour l'�valuation des d�riv�es des fonctions
 *
 * Le traitement des propri�t�s scalaires/vectorielles a �t� s�par� et le choix se fait statiquement
 * par le type de propri�t�s
 *
 */
template<typename T>
class DerivativeT
{
private:
  
  typedef PropertyT<eScalar,T> ScalarProperty;
  typedef details::PartialDerivativeT<ScalarProperty> ScalarDerivative;
  
  typedef PropertyT<eVectorial,T> VectorialProperty;
  typedef details::PartialDerivativeT<VectorialProperty> VectorialDerivative;

public:
  
  DerivativeT() 
    : m_scalar_derivative(m_dependencies) 
    , m_vectorial_derivative(m_dependencies) {}
  
  DerivativeT(const PropertyVector& dependencies) 
    : m_scalar_derivative(m_dependencies) 
    , m_vectorial_derivative(m_dependencies)
  {
    m_dependencies << dependencies; // Recopie
  }
    
public:

  //! Appel� par la m�canique pour placer les d�pendances de la fonction
  void setFunctionDependencies(const ScalarProperty& p, const PropertyVector& properties)
  {
    m_scalar_derivative[p].reorder(properties);
  }
  
  //! Appel� par la m�canique pour placer les d�pendances de la fonction
  void setFunctionDependencies(const VectorialProperty& p, const PropertyVector& properties)
  {
    m_vectorial_derivative[p].reorder(properties);
  }

  void setFunctionDependencies(PropertyVector const& dependencies)
  {
    m_function_dependencies = dependencies ;
  }

  PropertyVector const& getFunctionDependencies() const
  {
    return m_function_dependencies ;
  }

  bool hasFunctionDependencies() const
  {
    return ! m_function_dependencies.empty() ;
  }

  //! Ajout d'une propri�t� scalaire  
  DerivativeT<T>& operator<<(const ScalarProperty& p)
  {
    m_scalar_derivative << p;
    return *this;
  }
  
  //! Ajout d'une propri�t� vectorielle  
  DerivativeT<T>& operator<<(const VectorialProperty& p)
  {
    m_vectorial_derivative << p;
    return *this;
  }
    
  //! Valeurs pour une propri�t� scalaire
  typename ScalarDerivative::ReferenceType values(const ScalarProperty& p)
  {
    return m_scalar_derivative.values(p);
  }
  
  //! Valeurs pour une propri�t� scalaire
  typename ScalarDerivative::ConstReferenceType values(const ScalarProperty& p) const
  {
    return m_scalar_derivative.values(p);
  }
  
  //! Valeurs pour une propri�t� vectorielle
  typename VectorialDerivative::ReferenceType values(const VectorialProperty& p)
  {
    return m_vectorial_derivative.values(p);
  }

  //! Valeurs pour une propri�t� vectorielle
  typename VectorialDerivative::ConstReferenceType values(const VectorialProperty& p) const
  {
    return m_vectorial_derivative.values(p);
  }
  
  //! Vue pour une propri�t� scalaire
  const typename ScalarDerivative::ViewType& operator[](const ScalarProperty& p) const
  {
    return m_scalar_derivative[p];
  }

  //! Vue pour une propri�t� vectorielle
  const typename VectorialDerivative::ViewType& operator[](const VectorialProperty& p) const
  {
    return m_vectorial_derivative[p];
  }
  
  //! D�pendences de l'utilisateur (doit �tre un ensemble de propri�t�s
  //  contenant l'ensemble des propri�t�s de d�pendance de la fonction)
  PropertyVector& dependencies() { return m_dependencies; }

private:
  
  //! D�pendances
  PropertyVector m_dependencies;
  
  ScalarDerivative m_scalar_derivative;
  VectorialDerivative m_vectorial_derivative;

  PropertyVector m_function_dependencies ;

  template<typename U> friend std::ostream& operator<<(std::ostream& nout, const DerivativeT<U>& d) ;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

typedef DerivativeT<Real> Derivative;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

// Pour le debug
template<typename T>
inline std::ostream& operator<<(std::ostream& nout, const DerivativeT<T>& d) 
{
  nout << "Derivative : ";
  
  bool empty = true;
 
  const PropertyVector& init_deps = d.m_dependencies;
       
  {
    typedef typename DerivativeT<T>::ScalarDerivative ScalarDerivative;
    const ScalarDerivative& derivative = d.m_scalar_derivative; 
    typedef typename ScalarDerivative::ViewType ViewType;
    ConstArrayView<ViewType> views = derivative.views();
    for(Integer k = 0; k < views.size(); ++k) {
      const PropertyVector& deps = views[k].dependencies();
      nout << "\nscalar['" << views[k].property().name() << "']{\n";
      for(Integer i = 0; i < init_deps.size(); ++i) {
        const Property& p = init_deps[i]; 
        nout << "  ['" << p.name() << "']={ ";
        for(Integer j = 0; j < p.size(); ++j)
          nout << views[k].values()[deps.offset(p)+j] << " ";
        nout << "}\n";
        empty = false;
      }
      nout << "} ";
    }
  }
  {
    typedef typename DerivativeT<T>::VectorialDerivative VectorialDerivative;
    const VectorialDerivative& derivative = d.m_vectorial_derivative; 
    typedef typename VectorialDerivative::ViewType ViewType;
    ConstArrayView<ViewType> views = derivative.views();
    for(Integer k = 0; k < views.size(); ++k) {
      nout << "\nvectorial['" << views[k].property().name() << "']{\n";
      const PropertyVector& deps = views[k].dependencies();
      for(Integer i = 0; i < init_deps.size(); ++i) {
        const Property& p = init_deps[i];
        nout << "  ['" << p.name() << "']={ ";
        for(Integer l = 0; l < views[k].values().dim1Size(); ++l) {
          for(Integer j = 0; j < p.size(); ++j)
            nout << views[k].values()[l][deps.offset(p)+j] << " ";
          if(l < views[k].values().dim1Size()-1) nout << "; ";
        }
        nout << "}\n";
      }
      nout << "} ";
    }
  }
  
  if(empty) nout << "empty!";
  
  return nout;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_DERIVATIVE_H */
