// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_PHYSICS_LAW_VARIABLEALLOCATOR_H
#define ARCGEOSIM_PHYSICS_LAW_VARIABLEALLOCATOR_H
/* Author : desrozis at Mon May  2 17:39:07 2011
 * Generated by createNew
 */

/*
 * \ingroup Law
 * \brief Outil pour l'allocation des references de variables pour les valeurs + derivees pour :
 * - variables
 * - variables partielles
 * - tableaux
 * - scalaires
 *
 */

#include "ArcGeoSim/Physics/Law2/VariableRef.h"
#include "ArcGeoSim/Physics/Law2/EvaluationMode.h"

#include <arcane/IMesh.h>
#include <arcane/ISubDomain.h>
#include <arcane/utils/StringBuilder.h>

#include <map>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Interface d'allocateur de reference de variables
 *
 */
struct IAllocator
{
  virtual ~IAllocator() {}

  //! Ajoute des noms de famille par defaut
  virtual void setDefaultFamilyNames(const std::map<Arcane::eItemKind,Arcane::String>&) {}

  //! Alloue une reference
  virtual std::shared_ptr<VariableRef> create(Arcane::IMesh* mesh) const = 0;

  //! Ajout d'un prefixe
  virtual void addPrefix(Arcane::String prefix) = 0;
  
  //! Pour savoir si la variable existait deja
  virtual bool firstAllocation() const = 0;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Allocateur abstrait de reference de variables pour un type de propriete
 *
 * Classe de factorisation
 *
 */
template<typename Ref>
class AllocatorT
  : public IAllocator
{
  typedef typename Ref::PropertyType PropertyType;
  typedef typename Ref::ValueType ValueType;
  typedef typename Ref::DerivType DerivType;

public:

  AllocatorT(PropertyType property,
             const String prefix,
             const EvaluationMode derivative) 
    : m_property(property)
    , m_name(prefix + m_property.name()) 
    , m_dname(m_name + "_Derivatives")
    , m_derivative(derivative) {}
 
  virtual ~AllocatorT() {}

  void addPrefix(Arcane::String prefix)
  {
    if(prefix.empty()) return;
    {
      Arcane::StringBuilder sb;
      sb += prefix;
      sb += "_";
      sb += m_name;
      m_name = sb.toString();
    }
    {
      Arcane::StringBuilder sb;
      sb += prefix;
      sb += "_";
      sb += m_dname;
      m_dname = sb.toString();
    }
  }

  //! Alloue une reference
  std::shared_ptr<VariableRef> create(Arcane::IMesh* mesh) const 
  {
    m_first_allocation = !mesh->variableMng()->findMeshVariable(mesh, m_name);

    ValueType* v = new ValueType(buildInfo(mesh,m_name));
   
    if(m_derivative == eWithoutDerivative) {
      
      return std::shared_ptr<VariableRef>(new Ref(m_property, v));
    
    } else {
      
      DerivType* dv = new DerivType(buildInfo(mesh,m_dname));
      
      return std::shared_ptr<VariableRef>(new Ref(m_property, v, dv));
    }
  }
  
  static VariableRef* reference(PropertyType p, const ValueType& v)
  {
    return new Ref(p, new ValueType(v));
  }
  
  static VariableRef* reference(PropertyType p, const ValueType& v, const DerivType& dv)
  {
    return new Ref(p, new ValueType(v), new DerivType(dv));
  }
  
  bool firstAllocation() const { return m_first_allocation; }

protected:
    
  virtual Arcane::VariableBuildInfo buildInfo(Arcane::IMesh* mesh, const String& name) const = 0;
  
protected:
  PropertyType m_property;
  String m_name;
  String m_dname;
  const EvaluationMode m_derivative; 
  mutable bool m_first_allocation;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Allocateur de reference de variables sur le maillage
 *
 * Voir methodes utilisateur de creation dans la suite
 *
 */
template<typename P, typename K>
class VariableAllocatorT
  : public AllocatorT< VariableRefT<P,K> >
{  
  typedef AllocatorT< VariableRefT<P,K> > Base;
  
public:
    
  VariableAllocatorT(P property,
                     EvaluationMode derivative,
                     Arcane::String prefix = "")
    : Base(property, prefix, derivative)
    , m_has_default_family(false) {}
  
  void setDefaultFamilyNames(const std::map<Arcane::eItemKind,Arcane::String>& default_family_names)
  {
    auto it = default_family_names.find(Arcane::ItemTraitsT<K>::kind());
    
    if(it != default_family_names.end()) {
      m_has_default_family = true;
      m_default_family_name = it->second;
    }
  }
  
  Arcane::VariableBuildInfo buildInfo(Arcane::IMesh* mesh, const String& name) const 
  {
    if(m_has_default_family) {
      return Arcane::VariableBuildInfo(mesh, name, m_default_family_name);
    } else {
      return Arcane::VariableBuildInfo(mesh, name);
    }
  }

private:
  
  bool m_has_default_family;
  Arcane::String m_default_family_name;
};

template<typename K>
struct VariableReference
{
  template<Dimension D, typename T, typename V> 
  static VariableRef* get(PropertyT<D,T> property, const V& v)
  {
    using P = PropertyT<D,T>;
    return VariableAllocatorT<P,K>::reference(property, v);
  }

  template<Dimension D, typename T, typename V, typename DV> 
  static VariableRef* get(PropertyT<D,T> property, const V& v, const DV& dv)
  {
    using P = PropertyT<D,T>;
    return VariableAllocatorT<P,K>::reference(property, v, dv);
  }
};

template<typename K>
struct VariableAllocator
{
  template<Dimension D, typename T> 
  static IAllocator* get(PropertyT<D,T> property, EvaluationMode mode)
  {
    using P = PropertyT<D,T>;
    return new VariableAllocatorT<P,K>(property, mode);
  }
};

template<typename P, typename K>
class PartialVariableAllocatorT
  : public AllocatorT< PartialVariableRefT<P,K> >
{  
  typedef AllocatorT< PartialVariableRefT<P,K> > Base;
  
public:
    
  PartialVariableAllocatorT(P property,
                            Arcane::ItemGroupT<K> group,
                            EvaluationMode derivative, 
                            Arcane::String prefix = "_Partial")
    : Base(property, prefix, derivative)
    , m_group(group) {}
  
  Arcane::VariableBuildInfo buildInfo(Arcane::IMesh* mesh, const String& name) const 
  {
    const Arcane::String group_name = m_group.name();
    const Arcane::String family_name = m_group.itemFamily()->name();
      
    return Arcane::VariableBuildInfo(mesh, name, family_name, group_name);
  }

private:

  Arcane::ItemGroupT<K> m_group;
};

template<typename P>
class ArrayAllocatorT
  : public AllocatorT< ArrayRefT<P> >
{  
  typedef AllocatorT< ArrayRefT<P> > Base;
  
public:
    
  ArrayAllocatorT(P property,
                  EvaluationMode derivative, 
                  Arcane::String prefix = "_Array")
    : Base(property, prefix, derivative) {}
  
  Arcane::VariableBuildInfo buildInfo(Arcane::IMesh* mesh, const String& name) const 
  {
    return Arcane::VariableBuildInfo(mesh, name);
  }
};

template<typename P>
class ScalarAllocatorT
  : public AllocatorT< ScalarRefT<P> >
{
  typedef AllocatorT< ScalarRefT<P> > Base;

public:

  ScalarAllocatorT(P property,
                  EvaluationMode derivative,
                  Arcane::String prefix = "_Scalar")
    : Base(property, prefix, derivative) {}

  Arcane::VariableBuildInfo buildInfo(Arcane::IMesh* mesh, const String& name) const
  {
    return Arcane::VariableBuildInfo(mesh, name);
  }
};

/*---------------------------------------------------------------------------*/

// Fonctions de creation utilisateur

template<typename K, typename P>
std::shared_ptr<IAllocator> variable(P property, EvaluationMode mode = eWithoutDerivative)
{
  return std::shared_ptr<IAllocator>(VariableAllocator<K>::get(property,mode));
}

template<typename K, typename P>
std::shared_ptr<IAllocator> variableWithDerivative(P property)
{
  return std::shared_ptr<IAllocator>(VariableAllocator<K>::get(property,eWithDerivative));
}

template<typename K, typename P, typename V>
std::shared_ptr<VariableRef> variable(P property, const V& v)
{  
  return std::shared_ptr<VariableRef>(VariableReference<K>::get(property, v));
}

template<typename K, typename P, typename V, typename U>
std::shared_ptr<VariableRef> variable(P property, const V& v, const U& dv)
{
  return std::shared_ptr<VariableRef>(VariableReference<K>::get(property, v, dv)); 
}

/*---------------------------------------------------------------------------*/

// Fonctions de creation utilisateur

template<typename K, typename P>
std::shared_ptr<IAllocator> partialVariable(P property, const Arcane::ItemGroupT<K>& group, EvaluationMode mode = eWithoutDerivative)
{
  return std::shared_ptr<IAllocator>(new PartialVariableAllocatorT<P,K>(property, group, mode));
}

template<typename K, typename P>
std::shared_ptr<IAllocator> partialVariableWithDerivative(P property, const Arcane::ItemGroupT<K>& group)
{
  return std::shared_ptr<IAllocator>(new PartialVariableAllocatorT<P,K>(property, group, eWithDerivative));
}

template<typename K, typename P, typename V>
std::shared_ptr<VariableRef> partialVariable(P property, const V& v)
{
  return std::shared_ptr<VariableRef>(PartialVariableAllocatorT<P,K>::reference(property, v));
}

template<typename K, typename P, typename V, typename U>
std::shared_ptr<VariableRef> partialVariable(P property, const V& v, const U& dv)
{
  return std::shared_ptr<VariableRef>(PartialVariableAllocatorT<P,K>::reference(property, v, dv));
}

/*---------------------------------------------------------------------------*/

// Fonctions de creation utilisateur

template<typename P>
std::shared_ptr<IAllocator> array(P property, EvaluationMode mode = eWithoutDerivative)
{
  return std::shared_ptr<IAllocator>(new ArrayAllocatorT<P>(property, mode));
}

template<typename P>
std::shared_ptr<IAllocator> arrayWithDerivative(P property)
{
  return std::shared_ptr<IAllocator>(new ArrayAllocatorT<P>(property, eWithDerivative));
}

template<typename P, typename V>
std::shared_ptr<VariableRef> array(P property, const V& v)
{
  return std::shared_ptr<VariableRef>(ArrayAllocatorT<P>::reference(property, v));
}

template<typename P, typename V, typename U>
std::shared_ptr<VariableRef> array(P property, const V& v, const U& dv)
{
  return std::shared_ptr<VariableRef>(ArrayAllocatorT<P>::reference(property, v, dv));
}

/*---------------------------------------------------------------------------*/

// Fonctions de creation utilisateur

template<typename P>
std::shared_ptr<IAllocator> scalar(P property, EvaluationMode mode = eWithoutDerivative)
{
  return std::shared_ptr<IAllocator>(new ScalarAllocatorT<P>(property, mode));
}

template<typename P>
std::shared_ptr<IAllocator> scalarWithDerivative(P property)
{
  return std::shared_ptr<IAllocator>(new ScalarAllocatorT<P>(property, eWithDerivative));
}

template<typename P, typename V>
std::shared_ptr<VariableRef> scalar(P property, const V& v)
{
  return std::shared_ptr<VariableRef>(ScalarAllocatorT<P>::reference(property, v));
}

template<typename P, typename V, typename U>
std::shared_ptr<VariableRef> scalar(P property, const V& v, const U& dv)
{
  return std::shared_ptr<VariableRef>(ScalarAllocatorT<P>::reference(property, v, dv));
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_PHYSICS_LAW_VARIABLEALLOCATOR_H */
