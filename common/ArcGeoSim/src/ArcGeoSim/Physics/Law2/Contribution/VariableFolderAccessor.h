// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef LAW_VARIABLE_ACCESSOR_VARIABLEACCESSOR_H
#define LAW_VARIABLE_ACCESSOR_VARIABLEACCESSOR_H
/* Author : desrozis at Thu Mar 26 09:54:51 2015
 * Generated by createNew
 */

#include "ArcGeoSim/Physics/Law2/Contribution/VariableFolder.h"

#include "ArcGeoSim/Physics/Gump/Pack.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK, ItemKind::eType IK>
class VariableFolderAccessor
{
public:
  
  using AccessorType = AccessorTraits<CK,IK>;

  template<typename P>
  using ValueType = typename AccessorType::template ValueType<typename GumpToLaw<P>::type>;

  template<typename P>
  using DerivType = typename AccessorType::template DerivType<typename GumpToLaw<P>::type>;

  template<typename P>
  using LawValueType = typename AccessorType::template ValueType<P>;

  template<typename P>
  using LawDerivType = typename AccessorType::template DerivType<P>;

public:

  VariableFolderAccessor(const VariableFolder<CK,IK>& folder)
    : m_accessor(AccessorType::accessor(folder.lawVariableManager())) {}
  
  ~VariableFolderAccessor() {}
  
  template<Gump::Dimension D, typename T>
  bool contains(const Gump::PropertyT<D,T>& p) const
  {
    return m_accessor.contains(p);
  }

  template<Dimension D, typename T>
  LawValueType<PropertyT<D,T>>& getValues(const PropertyT<D,T>& p) const
  {
    return m_accessor.values(p);
  }
  
  template<Gump::Dimension D, typename T>
  ValueType<Gump::PropertyT<D,T>>& getValues(const Gump::PropertyT<D,T>& p) const
  {
    return m_accessor.values(p.cast());
  }
  
  template<Gump::Dimension D, typename T>
  DerivType<Gump::PropertyT<D,T>>& getDerivatives(const Gump::PropertyT<D,T>& p) const
  {
    return m_accessor.derivatives(p.cast());
  }

  template<Dimension D, typename T>
  LawDerivType<PropertyT<D,T>>& getDerivatives(const PropertyT<D,T>& p) const
  {
    return m_accessor.derivatives(p);
  }

  template<typename P, typename E>
  ValueType<typename P::Base>& getValues(const Gump::EntityT<E>& e) const
  {
    return getValues(P(e.cast()));
  }

  template<typename P, typename E>
  DerivType<typename P::Base>& getDerivatives(const Gump::EntityT<E>& e) const
  {
    return getDerivatives(P(e.cast()));
  }

  template<typename P, typename E>
  Gump::Pack<E, ValueType<typename P::Base>> getValues(Gump::EnumeratorT<E> e) const
  {
    auto size = e.maxFamilyId()+1;
    Arcane::SharedArray<E> entities(size);
    Arcane::SharedArray<std::shared_ptr<ValueType<typename P::Base>>> variables(size);
    for( ; e.hasNext(); ++e) {
      E ee = *e;
      auto index = ee.familyId();
      entities[index] = ee;
      variables[index].reset(new ValueType<typename P::Base>(getValues<P>(ee)));
    }
    return Gump::Pack<E, ValueType<typename P::Base>>(variables, entities);
  }

  template<typename E>
  ValueType<Gump::ScalarRealProperty>& getValues(const Gump::UserProperty<E>& p) const
  {
    return getValues(p.cast());
  }

  template<typename E>
  DerivType<Gump::ScalarRealProperty>& getDerivatives(const Gump::UserProperty<E>& p) const
  {
    return getDerivatives(p.cast());
  }

  template<typename E>
  Gump::Pack<E, ValueType<Gump::ScalarRealProperty>> getValues(const Arcane::Array< Gump::UserProperty<E> >& p) const
  {
    Arcane::Integer size = 0;
    for(Arcane::Integer i = 0 ; i < p.size(); ++i) {
      size = Arcane::math::max(size, p[i].owner().familyId());
    }
    Arcane::SharedArray<E> entities(size+1);
    Arcane::SharedArray<std::shared_ptr<ValueType<Gump::ScalarRealProperty>>> variables(size+1);
    for(Arcane::Integer i = 0 ; i < p.size(); ++i) {
      E ee = p[i].owner();
      const Arcane::Integer index = ee.familyId();
      entities[index] = ee;
      auto property = p[i].cast();
      variables[index] = std::make_shared<ValueType<Gump::ScalarRealProperty>>(getValues(property));
    }
    return Gump::Pack<E, ValueType<Gump::ScalarRealProperty>>(variables,entities);
  }

private:

  const typename AccessorType::Type m_accessor;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK, ItemKind::eType IK, typename E>
typename VariableFolderAccessor<CK,IK>::template ValueType<Gump::ScalarRealProperty>&
values(const VariableFolder<CK,IK>& folder,
       const Gump::UserProperty<E>& p)
{
  return VariableFolderAccessor<CK,IK>(folder).getValues(p);
}

template<ContainerKind::eType CK, ItemKind::eType IK, Gump::Dimension D, typename T>
typename VariableFolderAccessor<CK,IK>::template ValueType<Gump::PropertyT<D,T>>&
values(const VariableFolder<CK,IK>& folder, Gump::PropertyT<D,T> p)
{
  return VariableFolderAccessor<CK,IK>(folder).getValues(p);
}

template<typename P, ContainerKind::eType CK, ItemKind::eType IK>
typename VariableFolderAccessor<CK,IK>::template ValueType<typename P::Base>&
values(const VariableFolder<CK,IK>& folder, Gump::Entity e)
{
  return VariableFolderAccessor<CK,IK>(folder).getValues(P(e));
}

template<ContainerKind::eType CK, ItemKind::eType IK, typename E>
Gump::Pack<E, typename VariableFolderAccessor<CK,IK>::template ValueType<Gump::ScalarRealProperty>>
values(const VariableFolder<CK,IK>& folder,
       const Arcane::Array< Gump::UserProperty<E> >& p)
{
  return VariableFolderAccessor<CK,IK>(folder).getValues(p);
}

template<typename P, ContainerKind::eType CK, ItemKind::eType IK, typename E>
Gump::Pack<E, typename VariableFolderAccessor<CK,IK>::template ValueType<typename P::Base>>
values(const VariableFolder<CK,IK>& folder,
       const Gump::EnumeratorT<E>& e)
{
  return VariableFolderAccessor<CK,IK>(folder).template getValues<P>(e);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK, ItemKind::eType IK, typename E>
typename VariableFolderAccessor<CK,IK>::template DerivType<Gump::ScalarRealProperty>&
derivatives(const VariableFolder<CK,IK>& folder,
            const Gump::UserProperty<E>& p)
{
  return VariableFolderAccessor<CK,IK>(folder).getDerivatives(p);
}

template<ContainerKind::eType CK, ItemKind::eType IK, Gump::Dimension D, typename T>
typename VariableFolderAccessor<CK,IK>::template DerivType<Gump::PropertyT<D,T>>&
derivatives(const VariableFolder<CK,IK>& folder, Gump::PropertyT<D,T> p)
{
  return VariableFolderAccessor<CK,IK>(folder).getDerivatives(p);
}

template<typename P, ContainerKind::eType CK, ItemKind::eType IK, typename E>
typename VariableFolderAccessor<CK,IK>::template DerivType<typename P::Base>&
derivatives(const VariableFolder<CK,IK>& folder, Gump::EntityT<E> e)
{
  return VariableFolderAccessor<CK,IK>(folder).template getDerivatives<P>(e);
}

template<ContainerKind::eType CK, ItemKind::eType IK, typename E>
Gump::Pack<E, typename VariableFolderAccessor<CK,IK>::template DerivType<Gump::ScalarRealProperty>>
derivatives(const VariableFolder<CK,IK>& folder,
            const Arcane::Array< Gump::UserProperty<E> >& p)
{
  return VariableFolderAccessor<CK,IK>(folder).getDerivatives(p);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* LAW_VARIABLE_ACCESSOR_VARIABLEACCESSOR_H */
