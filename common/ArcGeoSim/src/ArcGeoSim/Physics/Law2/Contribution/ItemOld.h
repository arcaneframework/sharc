// -*- C++ -*-
#ifndef LAW_STENCIL_ITEM_H
#define LAW_STENCIL_ITEM_H
/* Author : desrozis at Wed Sep  4 10:21:36 2013
 * Generated by createNew
 */

// Outil pour la gestion de stencil / connectivit�
// A d�velopper pour le MPFA / Hybrid FV / MFD

#include <arcane/Item.h>
#include <arcane/ItemEnumerator.h>
#ifdef USE_ARCANE_V3
#include <arcane/ItemLocalId.h>
#endif


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class Item
{
public:
  Item()
    : m_size(1)
    , m_index(0) {}
  Item(Arcane::Integer size, Arcane::Integer index)
    : m_size(size)
    , m_index(index)
  {
    ARCANE_ASSERT((m_index < m_size),("index / size error in item of a stencil"));
  }
  Item(const Item& item)
    : m_size(item.m_size)
    , m_index(item.m_index) {}
  Item& operator=(const Item& item)
  {
    m_size = item.m_size;
    m_index = item.m_index;
    return *this;
  }
  Arcane::Integer size() const { return m_size; }
  Arcane::Integer index() const { return m_index; }
private:
  Arcane::Integer m_size;
  Arcane::Integer m_index;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<typename T>
class ItemT;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<>
class ItemT<Arcane::Cell>
  : public Item
{
public:
  ItemT() {}
  ItemT(Arcane::Cell cell)
    : m_cell(cell) {}
  ItemT(Arcane::Cell cell,
        Arcane::Integer size,
        Arcane::Integer index)
    : Item(size, index)
    , m_cell(cell) {}
  ItemT(const ItemT<Arcane::Cell>& cell)
    : Item(cell)
    , m_cell(cell.m_cell) {}
  operator const Arcane::Cell&() const { return m_cell; }
  const Arcane::Cell& cell() const { return m_cell; }
  Arcane::Integer localId() const { return m_cell.localId(); }
  bool isOwn() const { return m_cell.isOwn(); }
#ifdef USE_ARCANE_V3
  inline Arcane::ItemInternal* internal() const { return m_cell.internal(); }
#endif
private:
  Arcane::Cell m_cell;
};

typedef ItemT<Arcane::Cell> Cell;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<>
class ItemT<Arcane::Node>
  : public Item
{
public:
  ItemT() {}
  ItemT(Arcane::Node node)
    : m_node(node) {}
  ItemT(Arcane::Node node,
        Arcane::Integer size,
        Arcane::Integer index)
    : Item(size, index)
    , m_node(node) {}
  ItemT(const ItemT<Arcane::Node>& node)
    : Item(node)
    , m_node(node.m_node) {}
  operator const Arcane::Node&() const { return m_node; }
  const Arcane::Node& node() const { return m_node; }
  Arcane::Integer localId() const { return m_node.localId(); }
#ifdef USE_ARCANE_V3
  inline Arcane::ItemInternal* internal() const { return m_node.internal(); }
#endif
  bool isOwn() const { return m_node.isOwn(); }
private:
  Arcane::Node m_node;
};

typedef ItemT<Arcane::Node> Node;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<>
class ItemT<Arcane::Face>
  : public Item
{
public:
  ItemT(Arcane::Face face)
    : m_face(face)
    , m_cells(m_face.cells())
    , m_nb_cells(m_cells.size()) {}
  ItemT(const Arcane::ItemEnumeratorT<Arcane::Face>& face)
    : m_face(*face)
    , m_cells(m_face.cells())
    , m_nb_cells(m_cells.size()) {}
  ItemT(Arcane::Face face,
        Arcane::Integer size,
        Arcane::Integer index)
    : Item(size, index)
    , m_face(face)
    , m_cells(m_face.cells())
    , m_nb_cells(m_cells.size()) {}
  ItemT(const Arcane::ItemEnumeratorT<Arcane::Face>& face,
        Arcane::Integer size,
        Arcane::Integer index)
    : Item(size, index)
    , m_face(*face)
    , m_cells(m_face.cells())
    , m_nb_cells(m_cells.size()) {}
  operator const Arcane::Face&() const { return m_face; }
  Cell     backCell() const { return Cell(m_cells[0], m_nb_cells, 0); }
  Cell    frontCell() const { return Cell(m_cells[1], m_nb_cells, 1); }
  Cell boundaryCell() const { return backCell(); }
  Arcane::Integer localId() const { return m_face.localId(); }
  bool isOwn() const { return m_face.isOwn(); }
  bool isSubDomainBoundary() const { return m_face.isSubDomainBoundary(); }
#ifdef USE_ARCANE_V3
  inline Arcane::ItemInternal* internal() const { return m_face.internal(); }
#endif
private:
  Arcane::Face m_face;
  Arcane::CellVectorView m_cells;
  Arcane::Integer m_nb_cells;
};

typedef ItemT<Arcane::Face> Face;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<>
class ItemT<Arcane::Integer>
  : public Item
{
public:
  ItemT(Arcane::Integer id,
        Arcane::Integer size,
        Arcane::Integer index)
    : Item(size, index)
    , m_id(id) {}
  operator const Arcane::Integer&() const { return m_id; }
#ifdef USE_ARCANE_V3
  inline Arcane::ItemLocalId internal() const { return Arcane::ItemLocalId(m_id); }
#endif
private:
  Arcane::Integer m_id;
};

typedef ItemT<Arcane::Integer> IntegerIndex;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* GEOXIM_NUMERICS_STENCIL_ITEM_H */
