// -*- C++ -*-
#ifndef LAW_TRAITS_H
#define LAW_TRAITS_H
/* Author : desrozis at Thu Mar 26 10:41:13 2015
 * Generated by createNew
 */


#include "ArcGeoSim/Physics/Law2/Contribution/Utils/ContainerKind.h"
#include "ArcGeoSim/Physics/Law2/Contribution/Utils/ItemKind.h"
#include "ArcGeoSim/Physics/Law2/Contribution/Utils/Range.h"

#include "ArcGeoSim/Physics/Law2/Contribution/Variable/Variable.h"
#include "ArcGeoSim/Physics/Law2/Contribution/Variable/PartialVariable.h"
#include "ArcGeoSim/Physics/Law2/Contribution/Variable/VariableArray.h"
#include "ArcGeoSim/Physics/Law2/Contribution/Variable/VariableScalar.h"

#include "ArcGeoSim/Physics/Gump/Property.h"

#include "ArcGeoSim/Physics/Law2/VariableManager.h"
#include "ArcGeoSim/Physics/Law2/EvaluationMode.h"
#include "ArcGeoSim/Physics/Law2/ContainerTraits.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

// Pourrait etre fait avec decltype mais probleme sous Windows :(

template<typename P> 
struct GumpToLaw;

template<typename T>
struct GumpToLaw<Gump::PropertyT<Gump::eScalar,T>>
{
  using type = Law::PropertyT<Law::eScalar,T>;
};

template<typename T>
struct GumpToLaw<Gump::PropertyT<Gump::eVectorial,T>>
{
  using type = Law::PropertyT<Law::eVectorial,T>;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<ItemKind::eType IK>
struct ItemTraits;

template<>
struct ItemTraits<ItemKind::Node>
{
  typedef Arcane::Node Type;
};

template<>
struct ItemTraits<ItemKind::Cell>
{
  typedef Arcane::Cell Type;
};

template<>
struct ItemTraits<ItemKind::Face>
{
  typedef Arcane::Face Type;
};

template<>
struct ItemTraits<ItemKind::IntegerIndex>
{
  typedef Arcane::Integer Type;
};

template<>
struct ItemTraits<ItemKind::None>
{
  typedef void Type;
};

/*---------------------------------------------------------------------------*/

template<ItemKind::eType IK>
struct SupportTraits
{
  typedef Arcane::ItemGroupT<typename ItemTraits<IK>::Type> Type;
};

template<>
struct SupportTraits<ItemKind::IntegerIndex>
{
  typedef Range Type;
};

template<>
struct SupportTraits<ItemKind::None>
{
  struct NoSupport {};

  typedef NoSupport Type;
};

/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK, ItemKind::eType IK, typename DT>
struct AllocatorTraits;

template<ItemKind::eType IK, typename DT>
struct AllocatorTraits<ContainerKind::Variable, IK, DT>
{
  typedef Law::VariableAllocatorT<Law::PropertyT<Law::eScalar, DT>, typename ItemTraits<IK>::Type> Type;

  template<typename PropertyT>
  static std::shared_ptr<Law::IAllocator> allocator(
      PropertyT p,
      Law::EvaluationMode flag,
      typename SupportTraits<IK>::Type  g,
      Arcane::String key
  )
  {
    return std::make_shared<Type>(p, flag, Arcane::String::format("{0}_", key));
  }
};

template<ItemKind::eType IK, typename DT>
struct AllocatorTraits<ContainerKind::PartialVariable, IK, DT>
{
  typedef Law::PartialVariableAllocatorT<Law::PropertyT<Law::eScalar, DT>, typename ItemTraits<IK>::Type> Type;

  template<typename PropertyT>
  static std::shared_ptr<Law::IAllocator> allocator(
      PropertyT p,
      Law::EvaluationMode flag,
      typename SupportTraits<IK>::Type  g,
      Arcane::String key
  )
  {
    return std::make_shared<Type>(p, g, flag, Arcane::String::format("{0}_", key));
  }
};

template<typename DT>
struct AllocatorTraits<ContainerKind::Array, ItemKind::IntegerIndex, DT>
{
  typedef Law::ArrayAllocatorT<Law::PropertyT<Law::eScalar, DT>> Type;

  template<typename PropertyT>
  static std::shared_ptr<Law::IAllocator> allocator(
      PropertyT p,
      Law::EvaluationMode flag,
      Range g,
      Arcane::String key
  )
  {
    return std::make_shared<Type>(p, flag, Arcane::String::format("{0}_", key));
  }
};

template<typename DT>
struct AllocatorTraits<ContainerKind::Scalar, ItemKind::None, DT>
{
  typedef Law::ScalarAllocatorT<Law::PropertyT<Law::eScalar, DT>> Type;

  template<typename PropertyT>
  static std::shared_ptr<Law::IAllocator> allocator(
      PropertyT p,
      Law::EvaluationMode flag,
      typename SupportTraits<ItemKind::None>::Type g,
      Arcane::String key
  )
  {
    return std::make_shared<Type>(p, flag, Arcane::String::format("{0}_", key));
  }
};

template<ContainerKind::eType CK, ItemKind::eType IK, typename DT>
std::shared_ptr<Law::IAllocator> allocator(
    Law::PropertyT<Law::eScalar, DT> p,
    Law::EvaluationMode flag,
    typename SupportTraits<IK>::Type g,
    Arcane::String key
)
{
  return AllocatorTraits<CK, IK, DT>::allocator(p, flag, g, key);
}

/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK, ItemKind::eType IK>
struct AccessorTraits;

template<ItemKind::eType IK>
struct AccessorTraits<ContainerKind::Variable, IK>
{
  using ItemType = typename ItemTraits<IK>::Type;

  using Type = Law::VariableAccessorT<ItemType>;

  static Type accessor(const Law::VariableManager& variables)
  {
    return variables.variables<ItemType>();
  }

  template<typename P>
  using Container = Law::VariableContainer<P, ItemType>;

  template<typename P>
  using ValueType = typename Container<P>::ValueType;

  template<typename P>
  using DerivType = typename Container<P>::DerivType;
};

template<ItemKind::eType IK>
struct AccessorTraits<ContainerKind::PartialVariable, IK>
{
  using ItemType = typename ItemTraits<IK>::Type;

  using Type = Law::PartialVariableAccessorT<ItemType>;

  static Type accessor(const Law::VariableManager& variables)
  {
    return variables.partialVariables<ItemType>();
  }

  template<typename P>
  using Container = Law::PartialVariableContainer<P, ItemType>;

  template<typename P>
  using ValueType = typename Container<P>::ValueType;

  template<typename P>
  using DerivType = typename Container<P>::DerivType;
};

template<>
struct AccessorTraits<ContainerKind::Array, ItemKind::IntegerIndex>
{
  using Type = Law::ArrayAccessor;

  static Type accessor(const Law::VariableManager& variables)
  {
    return variables.arrays();
  }

  template<typename P>
  using Container = Law::ArrayContainer<P>;

  template<typename P>
  using ValueType = typename Container<P>::ValueType;

  template<typename P>
  using DerivType = typename Container<P>::DerivType;
};

template<>
struct AccessorTraits<ContainerKind::Scalar, ItemKind::None>
{
  using Type = Law::ScalarAccessor;

  static Type accessor(const Law::VariableManager& variables)
  {
    return variables.scalars();
  }

  template<typename P>
  using Container = Law::ScalarContainer<P>;

  template<typename P>
  using ValueType = typename Container<P>::ValueType;

  template<typename P>
  using DerivType = typename Container<P>::DerivType;
};

/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK, ItemKind::eType IK>
struct ValuesContainerTraits;

template<ItemKind::eType IK>
struct ValuesContainerTraits<ContainerKind::Variable, IK>
{
  typedef Arcane::MeshVariableScalarRefT<typename ItemTraits<IK>::Type,Arcane::Real> Type;
};

template<ItemKind::eType IK>
struct ValuesContainerTraits<ContainerKind::PartialVariable, IK>
{
  typedef Arcane::MeshPartialVariableScalarRefT<typename ItemTraits<IK>::Type,Arcane::Real> Type;
};

template<>
struct ValuesContainerTraits<ContainerKind::Array, ItemKind::IntegerIndex>
{
  typedef Arcane::VariableRefArrayT<Arcane::Real> Type;
};

template<>
struct ValuesContainerTraits<ContainerKind::Scalar, ItemKind::None>
{
  typedef Arcane::VariableRefScalarT<Arcane::Real> Type;
};

/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK, ItemKind::eType IK>
struct DerivativesContainerTraits;

template<ItemKind::eType IK>
struct DerivativesContainerTraits<ContainerKind::Variable, IK>
{
  typedef Arcane::MeshVariableArrayRefT<typename ItemTraits<IK>::Type,Arcane::Real> Type;
};

template<ItemKind::eType IK>
struct DerivativesContainerTraits<ContainerKind::PartialVariable, IK>
{
  typedef Arcane::MeshPartialVariableArrayRefT<typename ItemTraits<IK>::Type,Arcane::Real> Type;
};

template<>
struct DerivativesContainerTraits<ContainerKind::Array, ItemKind::IntegerIndex>
{
  typedef Arcane::VariableRefArray2T<Arcane::Real> Type;
};

template<>
struct DerivativesContainerTraits<ContainerKind::Scalar, ItemKind::None>
{
  typedef Arcane::VariableRefArrayT<Arcane::Real> Type;
};

/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK, ItemKind::eType IK>
struct ContributionContainerTraits;

template<ItemKind::eType IK>
struct ContributionContainerTraits<ContainerKind::Variable, IK>
{
  typedef audi::Variable<typename ItemTraits<IK>::Type> Type;
};

template<ItemKind::eType IK>
struct ContributionContainerTraits<ContainerKind::PartialVariable, IK>
{
  typedef audi::PartialVariable<typename ItemTraits<IK>::Type> Type;
};

template<>
struct ContributionContainerTraits<ContainerKind::Array, ItemKind::IntegerIndex>
{
  typedef audi::VariableArray Type;
};

template<>
struct ContributionContainerTraits<ContainerKind::Scalar, ItemKind::None>
{
  typedef audi::VariableScalar Type;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* LAW_TRAITS_H */
