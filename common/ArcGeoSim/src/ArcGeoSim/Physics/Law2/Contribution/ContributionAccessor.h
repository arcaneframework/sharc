// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef LAW_CONTRIBUTIONACCESSOR_H
#define LAW_CONTRIBUTIONACCESSOR_H
/* Author : desrozis at Thu Mar 26 09:54:51 2015
 * Generated by createNew
 */

#include "ArcGeoSim/Physics/Law2/Contribution/VariableFolder.h"
#include "ArcGeoSim/Physics/Gump/Pack.h"
#include "ArcGeoSim/Physics/Law2/EvaluationResults.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK, ItemKind::eType IK>
class ContributionAccessor
{
public:

  ContributionAccessor(const VariableFolder<CK,IK>& folder,
      const FunctionManager& fonctions,
      const Law::PropertyVector& um)
  : m_variables(folder.lawVariableManager())
  , m_accessor(AccessorTraitsType::accessor(m_variables))
  , m_fonctions(fonctions)
  , m_results(m_fonctions, m_variables)
  {
    Arcane::SharedArray<Law::PropertyVector> properties(1);
    auto dependencies = um.properties();
    for(auto p : dependencies) {
      properties[0] << Law::ScalarRealProperty(p);
    }
    m_results.setExtraDependencies(properties);
  }

  ContributionAccessor(const VariableFolder<CK,IK>& folder,
      const FunctionManager& fonctions,
      const Law::PropertyVector& um_1,
      const Law::PropertyVector& um_2)
  : m_variables(folder.lawVariableManager())
  , m_accessor(AccessorTraitsType::accessor(m_variables))
  , m_fonctions(fonctions)
  , m_results(m_fonctions, m_variables)
  {
    Arcane::SharedArray<Law::PropertyVector> properties(2);
    {
      auto dependencies = um_1.properties();
      for(auto p : dependencies) {
        properties[0] << Law::ScalarRealProperty(p);
      }
    }
    {
      auto dependencies = um_2.properties();
      for(auto p : dependencies) {
        properties[1] << Law::ScalarRealProperty(p);
      }
    }
    m_results.setExtraDependencies(properties);
  }

  ContributionAccessor(const VariableFolder<CK,IK>& folder,
                       const FunctionManager& fonctions,
                       const Arcane::SharedArray<Law::PropertyVector>& ums)
                       : m_variables(folder.lawVariableManager())
                       , m_accessor(AccessorTraitsType::accessor(m_variables))
                       , m_fonctions(fonctions)
                       , m_results(m_fonctions, m_variables)
                       {m_results.setExtraDependencies(ums) ;}

  ~ContributionAccessor() {}

  typedef typename FolderTraits<CK,IK>::Contributions ContributionType;

  ContributionType getVariable(Gump::ScalarRealProperty p) const
  {
    _resizeDerivativesIfExist(p);
    return _getVariable(p);
  }

  template<typename P, typename E>
  ContributionType getVariable(const Gump::EntityT<E>& e) const
  {
    return getVariable(P(e.cast()));
  }

  template<typename P, typename E>
  Gump::Pack<E, ContributionType> getVariable(Gump::EnumeratorT<E> e) const
  {
    auto size = e.maxFamilyId()+1;
    Arcane::SharedArray<E> entities(size);
    Arcane::SharedArray<std::shared_ptr<ContributionType>> variables(size);
    for( ; e.hasNext(); ++e) {
      E ee = *e;
      const Arcane::Integer index = ee.familyId();
      entities[index] = ee;
      variables[index] = std::make_shared<ContributionType>(getVariable<P>(ee));
    }
    return Gump::Pack<E, ContributionType>(variables, entities);
  }

  template<typename E>
  ContributionType getVariable(const Gump::UserProperty<E>& p) const
  {
    _resizeDerivativesIfExist(p);
    return _getVariable(p);
  }

  template<typename E>
  Gump::Pack<E, ContributionType> getVariable(const Arcane::Array< Gump::UserProperty<E> >& p) const
  {
    Arcane::Integer size = 0;
    for(Arcane::Integer i = 0 ; i < p.size(); ++i) {
      size = Arcane::math::max(size, p[i].owner().familyId());
    }
    Arcane::SharedArray<E> entities(size+1);
    Arcane::SharedArray<std::shared_ptr<ContributionType>> variables(size+1);
    for(Arcane::Integer i = 0 ; i < p.size(); ++i) {
      E ee = p[i].owner();
      const Arcane::Integer index = ee.familyId();
      entities[index] = ee;
      variables[index] = std::make_shared<ContributionType>(getVariable(p[i]));
    }
    return Gump::Pack<E, ContributionType>(variables,entities);
  }

private:

  typedef typename FolderTraits<CK,IK>::AccessorTraitsType AccessorTraitsType;
  typedef typename FolderTraits<CK,IK>::Accessor AccessorType;

  template<typename P>
  void _resizeDerivativesIfExist(P p) const
  {
    Law::ScalarRealProperty _p(p);
    if(m_accessor.hasDerivatives(p))
    {
      int size = m_fonctions.dependencies(p).size();
      m_accessor.derivatives(_p).resize(size);
    }
  }

  ContributionType _getVariable(Law::ScalarRealProperty p) const
  {
    return m_results[p];
  }

public:

  const Law::VariableManager& m_variables;

  const AccessorType m_accessor;

  const FunctionManager& m_fonctions;

  Law::EvaluationResults m_results;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<typename P,
ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
typename ContributionAccessor<CK,IK>::ContributionType
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
    const Law::PropertyVector& um,
    const Gump::EntityT<E>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, um).template getVariable<P>(e);
}

template<typename P,
ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
Gump::Pack<E, typename ContributionAccessor<CK,IK>::ContributionType>
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
    const Law::PropertyVector& um,
    const Gump::EnumeratorT<E>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, um).template getVariable<P>(e);
}

/*---------------------------------------------------------------------------*/

template<typename P,
ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
typename ContributionAccessor<CK,IK>::ContributionType
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
    const Law::PropertyVector& um1, const Law::PropertyVector& um2,
    const Gump::EntityT<E>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, um1, um2).template getVariable<P>(e);
}

template<typename P,
ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
Gump::Pack<E, typename ContributionAccessor<CK,IK>::ContributionType>
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
    const Law::PropertyVector& um1, const Law::PropertyVector& um2,
    const Gump::EnumeratorT<E>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, um1, um2).template getVariable<P>(e);
}

/*---------------------------------------------------------------------------*/

template<typename P,
    ContainerKind::eType CK,
    ItemKind::eType IK,
    typename E>
typename ContributionAccessor<CK,IK>::ContributionType
contribution(const VariableFolder<CK,IK>& vars,
             const FunctionManager& fonctions,
             const Arcane::SharedArray<Law::PropertyVector>& ums,
             const Gump::EntityT<E>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, ums).template getVariable<P>(e);
}

template<typename P,
    ContainerKind::eType CK,
    ItemKind::eType IK,
    typename E>
Gump::Pack<E, typename ContributionAccessor<CK,IK>::ContributionType>
contribution(const VariableFolder<CK,IK>& vars,
             const FunctionManager& fonctions,
             const Arcane::SharedArray<Law::PropertyVector>& ums,
             const Gump::EnumeratorT<E>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, ums).template getVariable<P>(e);
}

/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
typename ContributionAccessor<CK,IK>::ContributionType
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
    const Law::PropertyVector& um,
    const Gump::UserProperty<E>& e)
{
  return ContributionAccessor<CK,IK>(vars,fonctions, um).getVariable(e);
}

template<ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
typename ContributionAccessor<CK,IK>::ContributionType
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
    const Law::PropertyVector& um1, const Law::PropertyVector& um2,
    const Gump::UserProperty<E>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, um1, um2).getVariable(e);
}

template<ContainerKind::eType CK,
    ItemKind::eType IK,
    typename E>
typename ContributionAccessor<CK,IK>::ContributionType
contribution(const VariableFolder<CK,IK>& vars,
             const FunctionManager& fonctions,
             const Arcane::SharedArray<Law::PropertyVector>& ums,
             const Gump::UserProperty<E>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, ums).getVariable(e);
}

/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
Gump::Pack<E, typename ContributionAccessor<CK,IK>::ContributionType >
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
    const Law::PropertyVector& um,
    const Arcane::Array<Gump::UserProperty<E>>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, um).getVariable(e);
}

template<ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
Gump::Pack<E, typename ContributionAccessor<CK,IK>::ContributionType >
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
    const Law::PropertyVector& um1, const Law::PropertyVector& um2,
    const Arcane::Array<Gump::UserProperty<E>>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, um1, um2).getVariable(e);
}

template<ContainerKind::eType CK,
    ItemKind::eType IK,
    typename E>
Gump::Pack<E, typename ContributionAccessor<CK,IK>::ContributionType >
contribution(const VariableFolder<CK,IK>& vars,
             const FunctionManager& fonctions,
             const Arcane::SharedArray<Law::PropertyVector>& ums,
             const Arcane::Array<Gump::UserProperty<E>>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, ums).getVariable(e);
}


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* LAW_CONTRIBUTIONACCESSOR_H */
