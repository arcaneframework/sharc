// -*- C++ -*-
#ifndef LAW_CONTRIBUTIONACCESSOR_H
#define LAW_CONTRIBUTIONACCESSOR_H
/* Author : desrozis at Thu Mar 26 09:54:51 2015
 * Generated by createNew
 */

#include "ArcGeoSim/Physics/Law2/Contribution/VariableFolder.h"
#include "ArcGeoSim/Physics/Gump/Pack.h"
#include "ArcGeoSim/Physics/Law2/EvaluationResults.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK, ItemKind::eType IK>
class ContributionAccessor
{
public:

  ContributionAccessor(const VariableFolder<CK,IK>& folder,
        const FunctionManager& fonctions,
		const Arcane::Integer stencil_size,
        const Law::PropertyVector& um)
  : m_variables(folder.lawVariableManager())
  , m_accessor(AccessorTraitsType::accessor(m_variables))
  , m_fonctions(fonctions)
  , m_results(m_fonctions, m_variables)
  {
    Arcane::SharedArray<Law::PropertyVector> properties(stencil_size);
    {
      auto dependencies = um.properties();
      for(Arcane::Integer istencil=0; istencil<stencil_size;++istencil){
        for(auto p : dependencies) {
          properties[istencil] << Law::ScalarRealProperty(p);
        }
      }
    }
    m_results.setExtraDependencies(properties);
  }

  ~ContributionAccessor() {}

  typedef typename FolderTraits<CK,IK>::Contributions ContributionType;

  ContributionType getVariable(Gump::ScalarRealProperty p) const
  {
    _resizeDerivativesIfExist(p);
    return _getVariable(cast(p));
  }

  template<typename P, typename E>
  ContributionType getVariable(const Gump::EntityT<E>& e) const
  {
    return getVariable(P(e.cast()));
  }

  template<typename P, typename E>
  Gump::Pack<E, ContributionType> getVariable(Gump::EnumeratorT<E> e) const
  {
    auto size = e.maxFamilyId()+1;
    Arcane::SharedArray<E> entities(size);
    Arcane::SharedArray<std::shared_ptr<ContributionType>> variables(size);
    for( ; e.hasNext(); ++e) {
      E ee = *e;
      const Arcane::Integer index = ee.familyId();
      entities[index] = ee;
      variables[index] = std::make_shared<ContributionType>(getVariable<P>(ee));
    }
    return Gump::Pack<E, ContributionType>(variables, entities);
  }

  template<typename E>
  ContributionType getVariable(const Gump::UserProperty<E>& p) const
  {
    _resizeDerivativesIfExist(p);
    return _getVariable(p);
  }

  template<typename E>
  Gump::Pack<E, ContributionType> getVariable(const Arcane::Array< Gump::UserProperty<E> >& p) const
  {
    Arcane::Integer size = 0;
    for(Arcane::Integer i = 0 ; i < p.size(); ++i) {
      size = Arcane::math::max(size, p[i].owner().familyId());
    }
    Arcane::SharedArray<E> entities(size+1);
    Arcane::SharedArray<std::shared_ptr<ContributionType>> variables(size+1);
    for(Arcane::Integer i = 0 ; i < p.size(); ++i) {
      E ee = p[i].owner();
      const Arcane::Integer index = ee.familyId();
      entities[index] = ee;
      variables[index] = std::make_shared<ContributionType>(getVariable(p[i]));
    }
    return Gump::Pack<E, ContributionType>(variables,entities);
  }

private:

  typedef typename FolderTraits<CK,IK>::AccessorTraitsType AccessorTraitsType;
  typedef typename FolderTraits<CK,IK>::Accessor AccessorType;

  template<typename P>
  void _resizeDerivativesIfExist(P p) const
  {
    Law::ScalarRealProperty _p(p);
    if(m_accessor.hasDerivatives(_p))
    {
      int size = m_fonctions.dependencies(_p).size();
      m_accessor.derivatives(_p).resize(size);
    }
  }

  ContributionType _getVariable(Law::ScalarRealProperty p) const
  {
    return m_results[p];
  }

public:

  const Law::VariableManager& m_variables;

  const AccessorType m_accessor;

  const FunctionManager& m_fonctions;

  Law::EvaluationResults m_results;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<typename P,
ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
typename ContributionAccessor<CK,IK>::ContributionType
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
    const Law::PropertyVector& um,
    const Gump::EntityT<E>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, 1, um).template getVariable<P>(e);
}

template<typename P,
ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
Gump::Pack<E, typename ContributionAccessor<CK,IK>::ContributionType>
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
    const Law::PropertyVector& um,
    const Gump::EnumeratorT<E>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, 1, um).template getVariable<P>(e);
}

/*---------------------------------------------------------------------------*/

template<typename P,
ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
typename ContributionAccessor<CK,IK>::ContributionType
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
	const Arcane::Integer stencil_size,
    const Law::PropertyVector& um,
    const Gump::EntityT<E>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, stencil_size, um).template getVariable<P>(e);
}

template<typename P,
ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
Gump::Pack<E, typename ContributionAccessor<CK,IK>::ContributionType>
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
	const Arcane::Integer stencil_size,
    const Law::PropertyVector& um,
    const Gump::EnumeratorT<E>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, stencil_size, um).template getVariable<P>(e);
}

/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
typename ContributionAccessor<CK,IK>::ContributionType
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
    const Law::PropertyVector& um,
    const Gump::UserProperty<E>& e)
{
  return ContributionAccessor<CK,IK>(vars,fonctions, 1, um).getVariable(e);
}

template<ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
typename ContributionAccessor<CK,IK>::ContributionType
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
	const Arcane::Integer stencil_size,
    const Law::PropertyVector& um,
    const Gump::UserProperty<E>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, stencil_size, um).getVariable(e);
}

/*---------------------------------------------------------------------------*/

template<ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
Gump::Pack<E, typename ContributionAccessor<CK,IK>::ContributionType >
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
    const Law::PropertyVector& um,
    const Arcane::Array<Gump::UserProperty<E>>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, 1, um).getVariable(e);
}

template<ContainerKind::eType CK,
ItemKind::eType IK,
typename E>
Gump::Pack<E, typename ContributionAccessor<CK,IK>::ContributionType >
contribution(const VariableFolder<CK,IK>& vars,
    const FunctionManager& fonctions,
	const Arcane::Integer stencil_size,
    const Law::PropertyVector& um,
    const Arcane::Array<Gump::UserProperty<E>>& e)
{
  return ContributionAccessor<CK,IK>(vars, fonctions, stencil_size, um).getVariable(e);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* LAW_CONTRIBUTIONACCESSOR_H */
