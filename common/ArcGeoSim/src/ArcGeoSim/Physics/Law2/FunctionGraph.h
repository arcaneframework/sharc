// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_PHYSICS_LAW_FUNCTIONGRAPH_H
#define ARCGEOSIM_PHYSICS_LAW_FUNCTIONGRAPH_H
/* Author : gaynor at 11/O5/13
 * Generated by createNew
 */

/*
 * \ingroup Law
 * \brief Graphe de fonctions base sur boost
 *
 * Les fonctions sont sur les noueds
 * Les aretes sont des vecteurs de proprietes
 * Les proprietes racines sont stockees a part
 *
 */

#include <arcane/utils/ITraceMng.h>
#include "ArcGeoSim/Physics/Law2/IFunction.h"
#include "ArcGeoSim/Physics/Law2/PropertyVector.h"
#include "ArcGeoSim/Physics/Law2/DerivativesMode.h"
#include <arcane/utils/TraceAccessor.h>
#include <map>
#include <list>
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/depth_first_search.hpp>
#include <boost/tuple/tuple.hpp>
#include <arcane/utils/TraceAccessor.h>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Graphe de fonctions base sur boost
 *
 */
class FunctionGraph
{
private:
  // Types sortants
  typedef std::shared_ptr<IFunction> FunctionPtr;
  typedef SharedArray<FunctionPtr> FunctionVector;
  typedef std::map<Property, PropertyVector> DependenciesMap;

  //! Fonctions sur les noeuds
  struct VertexProperty
  {
    VertexProperty(FunctionPtr _function) : function(_function){
      std::string func_id = std::to_string(_function->id());
      name  = "Law[id="+func_id+']';
    };
    VertexProperty() {};
    FunctionPtr function;
    std::string name;
  };

  //! Vecteur de proprietes sur les aretes
  struct EdgeProperty
  {
    EdgeProperty(PropertyVector _linked_properties) : linked_properties(_linked_properties){
      String out = "["+linked_properties[0].name();
      for(int i = 1; i < linked_properties.size(); ++i) {
        out = out+"; " + linked_properties[i].name();
      }
      out= out+"]";
      name = out.localstr();
    };
    EdgeProperty() {};
    PropertyVector linked_properties;
    std::string name;
  };

  // Format du graphe boost direct bidirectionnel
  typedef boost::adjacency_list<
      boost::vecS,
      boost::vecS,
      boost::bidirectionalS,
      VertexProperty,
      EdgeProperty
      > GraphType;

  // Types utiles lies au graphe boost
  typedef boost::graph_traits<GraphType>  GraphTraits;
  typedef GraphTraits::vertex_descriptor  VertexType;
  typedef GraphTraits::adjacency_iterator AdjacencyIterator;
  typedef GraphTraits::vertex_iterator    VertexIterator;
  typedef GraphTraits::edge_descriptor    EdgeType;
  typedef GraphTraits::edge_iterator      EdgeIterator;
  typedef GraphTraits::in_edge_iterator   InEdgeIterator;
  typedef GraphTraits::out_edge_iterator  OutEdgeIterator;
  //
  typedef std::list<VertexType>           VertexList;
  typedef std::map<int, VertexList>       VerticesMap;
  typedef std::map<int, VertexType>       VertexMap;

  //! Visiteur de graphe pour detecter les cycles
  struct cycle_detector : public boost::default_dfs_visitor
  {
    cycle_detector(bool& _has_cycle): has_cycle(_has_cycle){};
    template <class Edge, class Graph>
    void back_edge(Edge, Graph&){ has_cycle = true;}
  private:
    bool& has_cycle;
  };

  public:

  FunctionGraph(bool fatal_if_unregistered, Arcane::ITraceMng* trace);

  virtual ~FunctionGraph(){}

  //! Ajoute une fonction dans le graphe
  void add(FunctionPtr f);

  //! Remplace une fonction dans le graphe selon son id
  void replace(FunctionPtr f);

  //! Nombre de fonctions
  inline Integer size() const { return num_vertices(m_graph); }

  //! Existance d un cycle dans le graphe (interdit dag)
  bool hasCycle() const;

  //! Retourne une exception si il existe un cycle dans le graphe (interdit dag)
  void checkCycle() const;

  //! Trouve une fonction par son id
  const FunctionPtr find(Integer i) const;

  //! Trouve une fonction par propriete de sortie
  const FunctionPtr find(const Property& p) const;

  //! Existence de la fonction
  const FunctionPtr end() const { return nullptr; }

  //! Calcule des dependances entre proprietes
  DependenciesMap computeDependencies(DerivativesMode mode = eDirect) const;

  //! Vecteur de fonctions trie
  FunctionVector toSortVector() const;

  //! Vecteur de fonctions trie pour une selection de propriete a calculer
  FunctionVector toSortVector(IntegerConstArrayView idx_output, const bool recursive) const;

  //! Ecriture du graph au farmat .dot
  void printDotGraph(std::ostream& nout) const;

  private:

  //! cree une aretes entre 2 noeuds
  void _createEdge(const VertexType& in_vertex, const VertexType& out_vertex, const PropertyVector& link);

  //! ajoute un vertex dans la map des properties out
  void _addVertexInOutputPropertyMap(const VertexType& new_vertex);

  //! Insertion du noeud et creation des aretes hautes
  void _createAddDownEdge(const VertexType& new_vertex);

  //! Insertion du noeud et creation des aretes basses
  void _createAddUpEdge(const VertexType& new_vertex);

  //! Trie des noeuds
  VertexList _sortedVertex() const;

  //! Marque les noeuds se trouvant au dessus du noeud specifie (recursif)
  void _tagUpVertex(const VertexType& source_vertex, std::vector<bool>& is_find) const;

  //! Supprime les noeuds se trouvant au dessous des proprietes specifiees
  void _deleteSubProperty(IntegerConstArrayView ids, VertexList& sort_vertices, const bool recursive) const;

  //! Calcul des noeuds racines (.eq. n ayant que des proprietes non racines)
  VertexList _computeGraphRootVertex(const VertexList& vertices, const bool is_sort=false) const;

  //! Calcule des dependances entre proprietes d une partie du graphe
  void _computeDependencies(const VertexList& sort_vertices, DependenciesMap& dependencies) const;

  //! Calcule des dependances entre proprietes d un noeud (recursif)
  void _dependencies(const VertexType& parent_vertex, DependenciesMap& dependencies, PropertyVector& in_dependencies) const;

  //! Transforme une liste de noeuds en vecteur de fonction (format d echane avec les autre classes)
  FunctionVector _toFunctionsVector(const VertexList& vertices) const;

  // gestion des messages message
  //! Stragtegie si fonction absente mais demandee
  bool m_fatal_if_unregistered;
  //! Manageur de traces
  Arcane::ITraceMng* m_trace;
  //! Graphe de type dag base sur boost (functions sur les noeuds - vecteur de propietes sur les aretes)
  GraphType   m_graph;
  //! Gestion des proprietes racines (.eq. proprietes input de fonctions non connectees au graphe)
  VerticesMap m_free_input_property_to_function_vertices;
  //! Map de correspondance entre les proprietes output et function (evite beaucoup de recalcule)
  VertexMap   m_output_property_to_function_vertex;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_PHYSICS_LAW_FUNCTIONGRAPH_H */
