// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_DERIVATIVEVIEW_H
#define ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_DERIVATIVEVIEW_H
/* Author : desrozis at Mon Apr 18 15:05:40 2011
 * Generated by createNew
 */

/*
 * \ingroup Law
 * \brief Outils pour la representation des derivees des fonctions
 *
 */

#include "ArcGeoSim/Physics/Law2/Property.h"
#include "ArcGeoSim/Physics/Law2/PropertyVector.h"
#include "ArcGeoSim/Physics/Law2/ContainerTraits.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace details {
   
  /*
   * \brief Classe interne generique gerant une vue des derivees 1D
   *
   * Cette vue correspond a :
   * - derivees d'une propriete scalaire
   * - derivees d'un indice d'une propriete vectorielle
   *
   */
  template<typename T>
  class DerivativeView1D
  {
  public:
    
    DerivativeView1D() {}

    DerivativeView1D(const PropertyVector& dependencies, ConstArrayView<T> values)
      : m_dependencies(dependencies)
      , m_values(values)
    {
      ARCANE_ASSERT((m_values.size() == m_dependencies.dataSize()),("Values size and dependencies size not coherent"));
    }

    void initialize(ConstArrayView<T> values)
    {
      ARCANE_ASSERT((values.size() == m_dependencies.dataSize()),("Values size and dependencies size not coherent"));

      m_values = values;
    }
       
    //! Accession aux valeurs de derivees par rapport a une propriete scalaire
    T operator[](const PropertyT<eScalar,T>& p) const
    {
      ARCANE_ASSERT((m_dependencies.contains(p)),("Property not registered in dependencies"));
      
      return m_values[m_dependencies.offset(p)];
    }
    
    //! Accession aux valeurs de derivees par rapport a une propriete vectorielle
    ConstArrayView<T> operator[](const PropertyT<eVectorial,T>& p) const
    {
      ARCANE_ASSERT((m_dependencies.contains(p)),("Property not registered in dependencies"));
      
      return m_values.subConstView(m_dependencies.offset(p),p.size());
    }
      
    const PropertyVector& dependencies() const { return m_dependencies; }

  protected:
    
    PropertyVector m_dependencies;
  
  private:
  
    ConstArrayView<T> m_values;
  };

}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \brief Classe interne gerant une vue des derivees pour une propriete
 *
 * Les derivees sont stockees en memoire contigue dans l'ordre des dependances
 *
 */
template<typename P>
class DerivativeView;
  
/*
 * \brief Vue pour une prorpiete scalaire
 *
 */
template<typename T>
class DerivativeView< PropertyT<eScalar,T> > : public details::DerivativeView1D<T>
{
public:

  typedef details::DerivativeView1D<T> ViewBase;
  typedef SharedArray<T>& ReferenceType;
  typedef const SharedArray<T>& ConstReferenceType;

public:

  DerivativeView() {}
    
  DerivativeView(const PropertyVector& dependencies, const PropertyT<eScalar,T>& p)
    : m_property(p)
    , m_values(dependencies.dataSize()) 
  {
    this->m_dependencies << dependencies; // recopie car reorder possible

    this->initialize(m_values);
    
    m_values.fill(0);
  }
    
  DerivativeView(const PropertyVector& dependencies, const PropertyT<eScalar,T>& p, SharedArray<T> values)
    : ViewBase(dependencies, values) // les donnees viennent de l'exterieur, recopie par reference
    , m_property(p)
    , m_values(values) {}
    
  DerivativeView operator=(const DerivativeView r) 
  {
    m_property = r.m_property;
    this->m_dependencies = r.m_dependencies;
    m_values = r.m_values;

    this->initialize(m_values);

    return *this;
  }

  //! Accession aux valeurs globales de derivees
  ReferenceType values() { return m_values; }
    
  //! Accession aux valeurs globales de derivees
  ConstReferenceType values() const { return m_values; }
    
  //! Propriete
  const Property& property() const { return m_property; }
  
  void reorder(const PropertyVector& p) 
  {
    SharedArray<Property> properties = this->m_dependencies.properties(); // recopie
    this->m_dependencies.reset();
    this->m_dependencies << p << properties;
    
    m_values.resize(this->m_dependencies.dataSize());
  }
  
private:
    
  Property m_property;
  
  SharedArray<T> m_values;
};
  
/*
 * \brief Vue pour une prorpiete vectorielle
 *
 */
template<typename T>
class DerivativeView< PropertyT<eVectorial,T> >
{ 
public:

  typedef Arcane::SharedArray2<T>& ReferenceType;
  typedef const Arcane::SharedArray2<T>& ConstReferenceType;

public:
    
  DerivativeView() {}

  DerivativeView(const PropertyVector& dependencies, const PropertyT<eVectorial,T>& p)
    : m_property(p)
    , m_values(m_property.size(), dependencies.dataSize()) 
  {
    m_dependencies << dependencies; // recopie car reorder possible

    m_values.fill(0);
  }
 
  DerivativeView(const PropertyVector& dependencies, const PropertyT<eVectorial,T>& p, Arcane::SharedArray2<T> values)
    : m_property(p)
    , m_dependencies(dependencies)
    , m_values(values) 
  {
    ARCANE_ASSERT((values.dim1Size() == m_property.size()),("Values size and dependencies size not coherent"));
    ARCANE_ASSERT((values.dim2Size() == dependencies.dataSize()),("Values size and dependencies size not coherent"));
  }
    
  //! Accession aux valeurs globales de derivees
  ReferenceType values() { return m_values; }

  //! Accession aux valeurs globales de derivees
  ConstReferenceType values() const { return m_values; }

  //! Vue 1D pour le ieme indice de la propriete
  details::DerivativeView1D<T> operator[](Integer i) const
  {
    ARCANE_ASSERT((i >= 0 && i < m_property.size()),("Property index error"));
  
    return details::DerivativeView1D<T>(m_dependencies, m_values[i]);
  }
    
  //! Propriete
  const Property& property() const { return m_property; }
  
  void reorder(const PropertyVector& p) 
  {
    SharedArray<Property> properties = m_dependencies.properties(); // recopie
    m_dependencies.reset();
    m_dependencies << p << properties;

    m_values.resize(m_property.size(), m_dependencies.dataSize());
  }

  const PropertyVector& dependencies() const { return m_dependencies; }
 
private:

  Property m_property;
    
  PropertyVector m_dependencies;

  Arcane::SharedArray2<T> m_values;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_DERIVATIVEVIEW_H */
