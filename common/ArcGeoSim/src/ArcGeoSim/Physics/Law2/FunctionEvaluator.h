// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_FUNCTIONEVALUATOR_H
#define ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_FUNCTIONEVALUATOR_H
/* Author : desrozis at Tue Nov 13 08:40:09 2012
 * Generated by createNew
 */
         
/*
 * \ingroup Law
 * \brief Outils pour l'�valuation des fonctions
 *
 */

#include "ArcGeoSim/Physics/Law2/FunctionManager.h"
#include "ArcGeoSim/Physics/Law2/VariableManager.h"
#include "ArcGeoSim/Physics/Law2/Enumerator.h"
#include "ArcGeoSim/Physics/Law2/Property.h"
#include "ArcGeoSim/Physics/Law2/PropertyVector.h"
#include "ArcGeoSim/Physics/Law2/ContainerTraits.h"
#include "ArcGeoSim/Physics/Law2/IFunction.h"
#include "ArcGeoSim/Utils/Utils.h"
#include <arcane/IMesh.h>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Classe pour l'�valuation des fonctions associ�es � une base
 * de donn�es de variables
 *
 */

class FunctionEvaluator
{
public:
  
  using FunctionEnumerator = FunctionManager::Enumerator;

  FunctionEvaluator(const FunctionManager& f,Integer max_nb_unknowns=0);

  FunctionEvaluator(const FunctionManager& f, IntegerConstArrayView ids, Integer max_nb_unknowns=0);

public:
  
  template<typename K, template<typename> class Accessor>
  void evaluate(const Accessor<K>& accessor, 
                Arcane::ItemGroupT<K> group, 
                EvaluationMode mode = eWithoutDerivative)
  {
    switch(mode) {
    case eWithoutDerivative:
      _evaluate(m_parameters, accessor, group);
      _evaluate(m_functions, accessor, group);
      break;
    case eWithDerivative:
      evaluateWithDerivatives(accessor, group);
      break;
    default:
      throw Arcane::FatalErrorException("Not implemented");
    }
  }
  
  template<typename Accessor>
  void evaluate(const Accessor& accessor,
                Arcane::ItemGroup group,
                EvaluationMode mode = eWithoutDerivative)
  {
    switch(mode) {
    case eWithoutDerivative:
      _evaluate(m_parameters, accessor, group);
      _evaluate(m_functions, accessor, group);
      break;
    case eWithDerivative:
      evaluateWithDerivatives(accessor, group);
      break;
    default:
      throw Arcane::FatalErrorException("Not implemented");
    }
  }

  template<typename K, template<typename> class Accessor>
  void evaluateWithDerivatives(const Accessor<K>& accessor, Arcane::ItemGroupT<K> group)
  {
    _evaluate(m_parameters, accessor, group);
    _evaluateWithDerivatives(m_functions, accessor, group);
  }
  
  template<typename Accessor>
  void evaluateWithDerivatives(const Accessor& accessor, Arcane::ItemGroup group)
  {
    _evaluate(m_parameters, accessor, group);
    _evaluateWithDerivatives(m_functions, accessor, group);
  }

  void evaluate(const ArrayAccessor& accessor, 
                Integer begin, Integer end, 
                EvaluationMode mode = eWithoutDerivative);
  
  void evaluateWithDerivatives(const ArrayAccessor& accessor, Integer begin, Integer end);

  void evaluate(const ScalarAccessor& accessor, 
                EvaluationMode mode = eWithoutDerivative);

  void evaluateWithDerivatives(const ScalarAccessor& accessor);

  void symbolic_evaluate(const Accessor& accessor, Arcane::ITraceMng* trace);

private:

  template<typename... T>
  void _evaluate(FunctionEnumerator& functions, const T&... args)
  {
    functions.reset();
    for( ; functions.hasNext(); ++functions) 
      functions.function().evaluate(args..., eWithoutDerivative);
  } 

  template<typename... T>
  void _evaluateWithDerivatives(FunctionEnumerator& functions, const T&... args)
                                
  {

    functions.reset();
    for(; functions.hasNext(); ++functions){
      auto& current_function = functions.function();
      if(m_function_mng.isRoot(current_function))
        current_function.evaluate(args..., eWithDerivative, m_max_nb_unknowns);
      else
      {
        Law::PropertyVector graph_dependencies = m_function_mng.dependencies(current_function);
        std::map<Law::Property, Law::PropertyVector> in_composed_dependencies =  m_function_mng.dependenciesGraph(current_function);
        // a verifier remettre dans le code genere et passer strategie
        int nb_unknown_resize = graph_dependencies.size() + in_composed_dependencies.size();
        nb_unknown_resize = (nb_unknown_resize>m_max_nb_unknowns) ? nb_unknown_resize:m_max_nb_unknowns;
        // voir apres evaluate avec redirection
        current_function.evaluate(args..., eWithDerivative, nb_unknown_resize);
        //
        nb_unknown_resize = graph_dependencies.size();
        nb_unknown_resize = (nb_unknown_resize>m_max_nb_unknowns) ? nb_unknown_resize:m_max_nb_unknowns;
        current_function.derivativesCorrection(args..., graph_dependencies, in_composed_dependencies, nb_unknown_resize);
      }
    }
  }

  void _symbolic_evaluate(const Accessor& accessor, Arcane::ITraceMng* trace, FunctionEnumerator& functions);
  
  void _check(const PropertyVector& properties, const Accessor& accessor, Arcane::ITraceMng* trace);
  
private:
  
  const FunctionManager& m_function_mng;

  FunctionEnumerator m_functions;

  FunctionEnumerator m_parameters;

  Arcane::Integer m_max_nb_unknowns ;

  bool m_is_first_derivate_eval;
};


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_EVALUATOR_H */
