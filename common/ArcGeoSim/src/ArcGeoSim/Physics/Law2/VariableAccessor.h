// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_PHYSICS_LAW_VARIABLEACCESSOR_H
#define ARCGEOSIM_PHYSICS_LAW_VARIABLEACCESSOR_H
/* Author : desrozis at Fri Nov  9 09:49:32 2012
 * Generated by createNew
 */

/*
 * \ingroup Law
 * \brief Outil d'accession aux variables stock�es dans une base de donn�es VariableDataBase
 *
 * On acc�s indiff�rement aux variables sur maillage ou variable tableau
 *
 * Des accesseurs typ�s sont d�finis pour un meilleur contr�le � la compilation
 * 
 * \code 
 * ScalarRealProperty Prop_1(0,"Prop_1");
 * VectorialRealProperty Prop_2(1,"Prop_2",2);
 *
 * VariableManager variable_mng(mesh());
 *
 * variable_mng << variable<Cell>(Prop_1)
 *              << variable<Cell>(Prop_2)
 *  
 * VariableAccessorT<Cell> accessor = variable_mng.variableAccessor<Cell>();
 * 
 * VariableCellReal p_1(accessor.values(Prop_1));
 * VariableCellArrayReal p_2(accessor.values(prop2));
 * \endcode
 *
 */

#include "ArcGeoSim/Physics/Law2/VariableRef.h"
#include "ArcGeoSim/Physics/Law2/VariableDataBase.h"

#include <boost/fusion/include/for_each.hpp>

#include <map>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Accesseur g�n�rique
 *
 */
class Accessor
{
public:

  typedef std::map<Property, VariableDataBase> DataBase;

public:
  
  Accessor(const DataBase& properties, 
           Arcane::eItemKind kind = Arcane::IK_Unknown) 
    : m_properties(properties)
    , m_kind(kind) {}
  
  //! Teste si la propri�t�s est enregistr�e
  bool contains(const Property& p) const { return m_properties.find(p) != m_properties.end(); }

  //! Teste si la propri�t�s � un conteneur d�riv�e
  bool hasDerivatives(const Property& p) const { return _checkAndFind(p)->hasDerivatives(); }
  
  //! Pour cr�er une r�f�rence de variable
  template<typename V, Dimension dim, typename T>
  V& values(const PropertyT<dim,T>& p) const { return _checkAndFind(p)->template values<V>(); }
  
  //! Pour cr�er une r�f�rence de variable
  template<typename V, Dimension dim, typename T>
  V& derivatives(const PropertyT<dim,T>& p) const { return _checkAndFind(p)->template derivatives<V>(); }
  
  Arcane::SharedArray<Property> properties() const
  {
    Arcane::SharedArray<Property> props;
    for(auto p : m_properties)
      props.add(p.first);
    return props;
  }

protected:
 
  std::shared_ptr<VariableRef> _checkAndFind(const Property& p) const
  {
    auto it = m_properties.find(p); 
    if(it == m_properties.end())
      throw Arcane::FatalErrorException(Arcane::String::format("Property '{0}' not registered",p.name()));
    
    return it->second.reference(m_kind, p.dataType());
  }
  
  template<typename T>
  T convertTo() const
  {
    return T(m_properties, m_kind);
  }

protected:
  
  //! Base de donn�es
  const DataBase& m_properties;
  
private:
  
  //! Type d'item
  const Arcane::eItemKind m_kind;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#define ACCESSORS(...)                                                  \
  template<Dimension dim, typename T>                                   \
  typename __VA_ARGS__::ValueType& values(const PropertyT<dim,T>& p) const \
  {                                                                     \
    return Accessor::values<typename __VA_ARGS__::ValueType>(p);        \
  }                                                                     \
                                                                        \
  template<Dimension dim, typename T>                                   \
  typename __VA_ARGS__::DerivType& derivatives(const PropertyT<dim,T>& p) const \
  {                                                                     \
    return Accessor::derivatives<typename __VA_ARGS__::DerivType>(p);   \
  }                                                                     \
                                                                        \
  template<Dimension dim, typename T>                                   \
  Arcane::SharedArray<typename __VA_ARGS__::ValueType> values(const Arcane::Array<PropertyT<dim,T>>& p) const \
  {                                                                     \
    Arcane::SharedArray<typename __VA_ARGS__::ValueType> variables;     \
    for(auto ps : p) {                                                  \
      variables.add(values(ps));                                        \
    }                                                                   \
    return variables;                                                   \
  }                                                                     \
                                                                        \
  template<Dimension dim, typename T>                                   \
  Arcane::SharedArray<typename __VA_ARGS__::DerivType> derivatives(const Arcane::Array<PropertyT<dim,T>>& p) const \
  {                                                                     \
    Arcane::SharedArray<typename __VA_ARGS__::DerivType> variables;     \
    for(auto ps : p) {                                                  \
      variables.add(derivatives(ps));                                   \
    }                                                                   \
    return variables;                                                   \
  }                                                                    

/*
 * \ingroup Law
 * \brief Accesseur statique pour les variables sur maillages
 *
 */
struct VariableAccessor : public Accessor
{
  VariableAccessor(const DataBase& properties, 
                   Arcane::eItemKind kind) 
    : Accessor(properties, kind) {}

  ACCESSORS(GenericVariableContainer<PropertyT<dim,T>>);
};

template<typename K>
struct VariableAccessorT : public VariableAccessor
{
  VariableAccessorT(const DataBase& properties)
    : VariableAccessor(properties, Arcane::ItemTraitsT<K>::kind()) {}
  
  ACCESSORS(VariableContainer<PropertyT<dim,T>,K>);
};

/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Accesseur statique pour les variables partielles sur maillages
 *
 */

struct PartialVariableAccessor : public Accessor
{
  PartialVariableAccessor(const Accessor::DataBase& properties,
                          Arcane::eItemKind kind) 
    : Accessor(properties, kind) {}
 
  ACCESSORS(GenericPartialVariableContainer<PropertyT<dim,T>>);
};

template<typename K>
struct PartialVariableAccessorT : public PartialVariableAccessor
{
  PartialVariableAccessorT(const Accessor::DataBase& properties)
    : PartialVariableAccessor(properties, Arcane::ItemTraitsT<K>::kind()) {}
 
  ACCESSORS(PartialVariableContainer<PropertyT<dim,T>,K>);
};

/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Accesseur statique pour les variables tableaux
 *
 */
struct ArrayAccessor : public Accessor
{
  ArrayAccessor(const Accessor::DataBase& properties)
    : Accessor(properties) {}

  ACCESSORS(ArrayContainer<PropertyT<dim,T>>);

  void resize(Integer size) const
  {  
    {
      //! Redimensionnement de toutes les variables sur tableau (propri�t�s)
       for(auto p : m_properties) {
        for(auto pp : p.second) {
          pp->resize(size);
        }
      }
    }
  }
};

/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Accesseur statique pour les variables scalaires
 *
 */
struct ScalarAccessor : public Accessor
{
  ScalarAccessor(const Accessor::DataBase& properties)
    : Accessor(properties) {}

  ACCESSORS(ScalarContainer<PropertyT<dim,T>>);
};

#undef ACCESSORS

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_PHYSICS_LAW_VARIABLEMANAGER_H */
