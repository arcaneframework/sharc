// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_PHYSICS_LAW_VARIABLE_H
#define ARCGEOSIM_PHYSICS_LAW_VARIABLE_H
/* Author : desrozis at Tue Nov 13 08:40:09 2012
 * Generated by createNew
 */
         
#include "ArcGeoSim/Physics/Law2/BuildInfo.h"
#include "ArcGeoSim/Physics/Law2/DerivativeView.h"
#include "ArcGeoSim/Physics/Law2/Contribution/Item.h"

#include <algorithm>
#include <numeric>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace details {
  
  struct ArrayUtils
  {  
    template<typename T>
    static void resize(Arcane::Array<T>& array, Arcane::Integer size_p, Arcane::Integer size) 
    {
      array.resize(size);
      array.fill(T(0));
    }
    
    template<typename T>
    static void resize(Arcane::Array2<T>& array, Arcane::Integer size_p, Arcane::Integer size) 
    {
      array.resize(size_p, size);
      array.fill(T(0));
    }
  
    template<typename From, typename To>
    static void std_copy(const From& from, To& to, 
                         const Arcane::Integer from_begin_offset,
                         const Arcane::Integer from_end_offset,
                         const Arcane::Integer to_begin_offset) 
    { 
      std::copy(from.begin() + from_begin_offset,
                from.begin() + from_end_offset,
                to.begin() + to_begin_offset);
    }
    
    template<typename T>
    static void copy(const Arcane::ConstArrayView<T>& from, 
                     Arcane::Array<T>& to,
                     const PropertyMapping& offset,
                     const Arcane::Integer shift) 
    {
      const Arcane::IntegerArray& reference_offset = offset.referenceOffset();
      const Arcane::IntegerArray& user_offset = offset.userOffset();
      const Arcane::IntegerArray& user_size = offset.userSize();
      const PropertyVector& properties = offset.properties();
      
      const Arcane::Integer size = properties.size();
     
      for(Arcane::Integer j = 0; j < size; ++j) {
        //for(Arcane::Integer i = 0; i< user_size[j]; ++i)
        //{
        //    to[user_offset[j] + shift + i] = from[reference_offset[j]+i];
        //}

        // BUG: TEST LawContribution use "to" array beyond boundary
        ArrayUtils::std_copy(from,
                             to,
                             reference_offset[j],
                             reference_offset[j] + user_size[j],
                             user_offset[j] + shift);
      }
    } 

    template<typename T>
    static void copy(const Arcane::ConstArrayView<T>& from,
        Arcane::ArrayView<T>& to,
        const PropertyMapping& offset,
        const Arcane::Integer shift)
    {
      const Arcane::IntegerArray& reference_offset = offset.referenceOffset();
      const Arcane::IntegerArray& user_offset = offset.userOffset();
      const Arcane::IntegerArray& user_size = offset.userSize();
      const PropertyVector& properties = offset.properties();

      const Arcane::Integer size = properties.size();

      for(Arcane::Integer j = 0; j < size; ++j) {
        //for(Arcane::Integer i = 0; i< user_size[j]; ++i)
        //{
        //  to[user_offset[j] + shift + i] = from[reference_offset[j]+i];
        //}

        // BUG: TEST LawContribution use "to" array beyond boundary
        ArrayUtils::std_copy(from,
                             to,
                             reference_offset[j],
                             reference_offset[j] + user_size[j],
                             user_offset[j] + shift);
      }
    }

    template<typename T>
    static void copy(const Arcane::ConstArray2View<T>& from, 
                     Arcane::Array2<T>& to,
                     const PropertyMapping& offset,
                     const Arcane::Integer shift) 
    {
      ARCANE_ASSERT((from.dim1Size() == to.dim1Size()),("Copy array error"));
      
      const Arcane::IntegerArray& reference_offset = offset.referenceOffset();
      const Arcane::IntegerArray& user_offset = offset.userOffset();
      const Arcane::IntegerArray& user_size = offset.userSize();
      const PropertyVector& properties = offset.properties();
      
      const Arcane::Integer size = properties.size();

      for(Arcane::Integer i = 0; i < from.dim1Size(); ++i) {
        
        for(Arcane::Integer j = 0; j < size; ++j) {
          
          Arcane::ConstArrayView<T> from_ = from[i];
          Arcane::ArrayView<T> to_ = to[i];

          ArrayUtils::std_copy(from_, 
                               to_, 
                               reference_offset[j],
                               reference_offset[j] + user_size[j],
                               user_offset[j] + shift);
        }
      }
    }
    
    template<typename T>
    static void copy_first(const T& from, Arcane::Array<T>& to)
    {
      to[0] = from;
    }

    template<typename T>
    static void copy_first(const Arcane::ConstArrayView<T>& from, Arcane::Array2<T>& to)
    {
      ARCANE_ASSERT((from.size() == to.dim1Size()),("Copy array error"));
      
      for(Arcane::Integer i = 0; i < from.size(); ++i)
        to[i][0] = from[i];
    }

    template<typename T>
    static void set_identity(Arcane::Array<T>& to, Arcane::Integer id)
    {
      to[id] = 1;
    }

    template<typename T>
    static void set_identity(Arcane::ArrayView<T>& to, Arcane::Integer id)
    {
      to[id] = 1;
    }

    template<typename T>
    static void set_identity(Arcane::Array2<T>& to, Arcane::Integer id)
    {
      for(Arcane::Integer i = 0; i < to.dim1Size(); ++i)
        to[i][id+i] = 1;
    }
  };
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<typename Ref>
class VariableT
{
public:
  
  typedef typename Ref::PropertyType PropertyType;
  typedef typename Ref::ValueType ValueType;
  typedef typename Ref::DerivType DerivType;
  
  // Ce qui est issu directement des conteneurs Arcane
  typedef typename ValueType::ConstReturnReferenceType ConstReturnReferenceType;
  typedef typename DerivType::ConstReturnReferenceType DerivativesReturnType;

  // Ce qu'on reconstruit
  typedef typename StateContainer<PropertyType>::DerivType ArrayType;
  typedef typename StateContainer<PropertyType>::DerivViewType ArrayViewType;

public:
  
  VariableT()
    : m_values(NULL)
    , m_derivatives(NULL) {}

  VariableT(const VariableT<Ref>& rhs)
    : m_property(rhs.m_property)
    , m_values(rhs.m_values)
    , m_derivatives(rhs.m_derivatives)
    , m_property_mappings(rhs.m_property_mappings)
    , m_cache_values_array(rhs.m_cache_values_array)
    , m_cache_derivatives_array(rhs.m_cache_derivatives_array) {}

  VariableT(const PropertyType& property,
            const Arcane::SharedArray<PropertyMapping>& offsets,
            const Accessor& accessor)
    : m_property(property)
    , m_values(NULL)
    , m_derivatives(NULL)
    , m_property_mappings(offsets)
  {
    m_values = &(accessor.values<ValueType>(m_property));

    if(accessor.hasDerivatives(property)) {
      m_derivatives = &(accessor.derivatives<DerivType>(m_property));
    }
    
    if(offsets.size() == 0) { std::cout << "ERROR\n"; exit(-1); }

    m_cache_values_array.resize(m_property_mappings.size());
    for(Arcane::Integer i = 0; i < m_property_mappings.size(); ++i)
      details::ArrayUtils::resize(m_cache_values_array[i],
                                  m_property.size(),
                                  m_property_mappings[i].userDependencies().dataSize()+1);

    m_cache_derivatives_array.resize(m_property_mappings.size());
    for(Arcane::Integer i = 0; i < m_property_mappings.size(); ++i)
      details::ArrayUtils::resize(m_cache_derivatives_array[i],
                                  m_property.size(),
                                  m_property_mappings[i].userDependencies().dataSize());
  }

  virtual ~VariableT() {}

public:

  inline bool hasDerivatives() const { return not m_property_mappings[0].userDependencies().empty(); }

  inline const PropertyType& property() const { return m_property; }
  
  void resizeCacheArray(Arcane::Integer size)
  {
    m_cache_values_array.resize(size);
    m_cache_derivatives_array.resize(size);
  }

  template<typename I>
  inline ConstReturnReferenceType operator[](const I& iter) const
  {
    const auto& values = *m_values;
    if constexpr (std::is_same_v<I,Integer>)
		   return values[Arcane::ItemLocalId(iter)];
    else
      return values[iter.internal()];
  }

  template<typename I>
  inline DerivativesReturnType storedDerivatives(const I& iter) const
  {
    const auto& derivatives = *m_derivatives;
    return derivatives[iter];
  }
  
  // Pour le debug uniquement !!!!
  template<typename I>
  inline DerivativeView<PropertyType> view(const I& iter) const 
  {
    return DerivativeView<PropertyType>(m_property_mappings[0].userDependencies(),
                                        m_property, derivatives(iter));
  }

  template<typename I>
  inline DerivativeView<PropertyType> view(const I& iter, Arcane::Integer i) const 
  {
    return DerivativeView<PropertyType>(m_property_mappings[i+1].userDependencies(),
                                        m_property, derivatives(iter,i));
  }
  
  template<typename I>
  inline const ArrayType& values(const I& iter) const
  {
    ArrayType& array = m_cache_values_array[0];
    _values(iter, 0, array);
    return array;
  }

  template<typename I>
  inline const ArrayType& derivatives(const I& iter) const 
  {
    ArrayType& array = m_cache_derivatives_array[0];
    _derivatives(iter, 0, array);
    return array;
  }
  
  template<typename I>
  inline void values(const I& iter, ArrayType& array) const 
  {
    _values(iter, 0, array);
  }

  template<typename I>
  inline void derivatives(const I& iter, ArrayType& array) const 
  {
    _derivatives(iter, 0, array);
  }
  
  template<typename I>
  inline void derivatives(const I& iter, ArrayViewType& array) const
  {
    _derivatives(iter, 0, array);
  }

  template<typename I>
  inline const ArrayType& values(const I& iter, Arcane::Integer i) const
  {
    ArrayType& array = m_cache_values_array[i+1];
    _values(iter, i+1, array);
    return array;
  }

  template<typename I>
  inline const ArrayType& derivatives(const I& iter, Arcane::Integer i) const 
  {
    ArrayType& array = m_cache_derivatives_array[i+1];
    _derivatives(iter, i+1, array);
    return array;
  }
  
  template<typename I>
  inline void values(const I& iter, Arcane::Integer i, ArrayType& array) const 
  {
    _values(iter, i+1, array);
  }

  template<typename I>
  inline void derivatives(const I& iter, Arcane::Integer i, ArrayType& array) const 
  {
    _derivatives(iter, i+1, array);
  }
 
  template<typename I>
  inline void derivatives(const I& iter, Arcane::Integer i, ArrayViewType& array) const
  {
    _derivatives(iter, i+1, array);
  }

  const PropertyMapping& mapping(Arcane::Integer i) const { return m_property_mappings[i]; }
  
  void synchronize()
  {
    if(m_values != nullptr) {
      m_values->synchronize();
    }
    if(m_derivatives != nullptr) {
      m_derivatives->synchronize();
    }
  }

private:
  
  template<typename I>
  inline void _values(const I& iter, Arcane::Integer i, ArrayType& array) const
  {
    const PropertyMapping& offset = m_property_mappings[i];
    const auto& values = *m_values;
    details::ArrayUtils::copy_first(values[iter], array);
    if(m_derivatives) {
      const auto& derivatives = *m_derivatives;
      details::ArrayUtils::copy(derivatives[iter], array, offset, 1);
    }
    const Arcane::Integer deriv_against_offset = offset.propertyOffset();
    if(deriv_against_offset != -1) {
      details::ArrayUtils::set_identity(array, deriv_against_offset+1);
    }
  }

  template<typename I, typename Container>
  inline void _derivatives(const I& iter, Arcane::Integer i, Container& array) const
  {
    const PropertyMapping& offset = m_property_mappings[i];
    if(m_derivatives) {
      const auto& derivatives = *m_derivatives;
      if constexpr (std::is_same_v<I,Integer>)
		     details::ArrayUtils::copy(derivatives[Arcane::ItemLocalId(iter)], array, offset, 0);
      else
	details::ArrayUtils::copy(derivatives[iter.internal()], array, offset, 0);
    }
    const Arcane::Integer deriv_against_offset = offset.propertyOffset();
    if(deriv_against_offset != -1) {
      details::ArrayUtils::set_identity(array, deriv_against_offset);
    }
  }

private:
  
  PropertyType m_property;
  
  ValueType* m_values;
  DerivType* m_derivatives;
  
protected:

  Arcane::SharedArray<PropertyMapping> m_property_mappings;

private:

  mutable Arcane::SharedArray<ArrayType> m_cache_values_array;
  mutable Arcane::SharedArray<ArrayType> m_cache_derivatives_array;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<typename P, typename K>
struct Variable
  : public VariableT< VariableRefT<P,K> >
{
  typedef VariableT< VariableRefT<P,K> > Base;
  
  Variable() {}

  Variable(const Variable& rhs)
    : Base(rhs) {}
 
  Variable(const BuildInfo<P>& bi)
    : Base(bi.property(),
           bi.offsets(),
           bi.variableMng().template variables<K>()) {}
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#ifdef USE_ARCANE_V3
#define VARIABLE(type)                                                  \
  typedef Variable<Scalar##type##Property,Cell> ScalarVariableCell##type; \
  typedef Variable<Scalar##type##Property,Face> ScalarVariableFace##type; \
  typedef Variable<Scalar##type##Property,Node> ScalarVariableNode##type; \
  typedef Variable<Scalar##type##Property,Edge> ScalarVariableEdge##type; \
  typedef Variable<Scalar##type##Property,DoF> ScalarVariableDoF##type; \
  typedef Variable<Vectorial##type##Property,Cell> VectorialVariableCell##type; \
  typedef Variable<Vectorial##type##Property,Face> VectorialVariableFace##type; \
  typedef Variable<Vectorial##type##Property,Node> VectorialVariableNode##type; \
  typedef Variable<Vectorial##type##Property,Edge> VectorialVariableEdge##type; \
  typedef Variable<Vectorial##type##Property,DoF> VectorialVariableDoF##type;
#else
#define VARIABLE(type)                                                  \
  typedef Variable<Scalar##type##Property,Cell> ScalarVariableCell##type; \
  typedef Variable<Scalar##type##Property,Face> ScalarVariableFace##type; \
  typedef Variable<Scalar##type##Property,Node> ScalarVariableNode##type; \
  typedef Variable<Scalar##type##Property,Edge> ScalarVariableEdge##type; \
  typedef Variable<Scalar##type##Property,Link> ScalarVariableLink##type; \
  typedef Variable<Scalar##type##Property,DualNode> ScalarVariableDualNode##type; \
  typedef Variable<Scalar##type##Property,DoF> ScalarVariableDoF##type; \
  typedef Variable<Vectorial##type##Property,Cell> VectorialVariableCell##type; \
  typedef Variable<Vectorial##type##Property,Face> VectorialVariableFace##type; \
  typedef Variable<Vectorial##type##Property,Node> VectorialVariableNode##type; \
  typedef Variable<Vectorial##type##Property,Edge> VectorialVariableEdge##type; \
  typedef Variable<Vectorial##type##Property,Link> VectorialVariableLink##type; \
  typedef Variable<Vectorial##type##Property,DualNode> VectorialVariableDualNode##type; \
  typedef Variable<Vectorial##type##Property,DoF> VectorialVariableDoF##type;
#endif

VARIABLE(Real);
VARIABLE(Integer);

#undef VARIABLE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<typename P, typename K>
class PartialVariable
  : public VariableT< PartialVariableRefT<P,K> >
{
  typedef VariableT< PartialVariableRefT<P,K> > Base;

public:
  
  PartialVariable(const BuildInfo<P>& bi)
    : Base(bi.property(),
           bi.offsets(),
           bi.variableMng().template partialVariables<K>()) {}
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#ifdef USE_ARCANE_V3
typedef PartialVariable<ScalarRealProperty,Cell> ScalarPartialVariableCellReal;
typedef PartialVariable<ScalarRealProperty,Face> ScalarPartialVariableFaceReal;
typedef PartialVariable<ScalarRealProperty,Node> ScalarPartialVariableNodeReal;
typedef PartialVariable<ScalarRealProperty,Edge> ScalarPartialVariableEdgeReal;
typedef PartialVariable<ScalarRealProperty,DoF> ScalarPartialVariableDoFReal;

typedef PartialVariable<VectorialRealProperty,Cell> VectorialPartialVariableCellReal;
typedef PartialVariable<VectorialRealProperty,Face> VectorialPartialVariableFaceReal;
typedef PartialVariable<VectorialRealProperty,Node> VectorialPartialVariableNodeReal;
typedef PartialVariable<VectorialRealProperty,Edge> VectorialPartialVariableEdgeReal;
typedef PartialVariable<VectorialRealProperty,DoF> VectorialPartialVariableDoFReal;
#else
typedef PartialVariable<ScalarRealProperty,Cell> ScalarPartialVariableCellReal;
typedef PartialVariable<ScalarRealProperty,Face> ScalarPartialVariableFaceReal;
typedef PartialVariable<ScalarRealProperty,Node> ScalarPartialVariableNodeReal;
typedef PartialVariable<ScalarRealProperty,Edge> ScalarPartialVariableEdgeReal;
typedef PartialVariable<ScalarRealProperty,Link> ScalarPartialVariableLinkReal;
typedef PartialVariable<ScalarRealProperty,DualNode> ScalarPartialVariableDualNodeReal;
typedef PartialVariable<ScalarRealProperty,DoF> ScalarPartialVariableDoFReal;

typedef PartialVariable<VectorialRealProperty,Cell> VectorialPartialVariableCellReal;
typedef PartialVariable<VectorialRealProperty,Face> VectorialPartialVariableFaceReal;
typedef PartialVariable<VectorialRealProperty,Node> VectorialPartialVariableNodeReal;
typedef PartialVariable<VectorialRealProperty,Edge> VectorialPartialVariableEdgeReal;
typedef PartialVariable<VectorialRealProperty,Link> VectorialPartialVariableLinkReal;
typedef PartialVariable<VectorialRealProperty,DualNode> VectorialPartialVariableDualNodeReal;
typedef PartialVariable<VectorialRealProperty,DoF> VectorialPartialVariableDoFReal;
#endif

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<typename P>
class ArrayVariable
  : public VariableT< ArrayRefT<P> >
{
  typedef VariableT< ArrayRefT<P> > Base;

public:
  
  ArrayVariable(const BuildInfo<P>& bi)
    : Base(bi.property(),
           bi.offsets(),
           bi.variableMng().arrays()) {}
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

typedef ArrayVariable<ScalarRealProperty> ScalarArrayReal;

typedef ArrayVariable<VectorialRealProperty> VectorialArrayReal;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace details
{
  template<typename T> struct ScalarReturnType;

  template<typename T>
  struct ScalarReturnType< PropertyT<eScalar,T> >
  {
    typedef const T&                  ValueType;
    typedef Arcane::ConstArrayView<T> DerivType;
  };

  template<typename T>
  struct ScalarReturnType< PropertyT<eVectorial,T> >
  {
    typedef Arcane::ConstArrayView<T>  ValueType;
    typedef Arcane::ConstArray2View<T> DerivType;
  };

  template<typename T>
  inline const T& ScalarAccessorTraits(const Arcane::VariableRefScalarT<T>& v)
  {
    return v();
  };
  template<typename T>
  inline Arcane::ConstArrayView<T> ScalarAccessorTraits(const Arcane::VariableRefArrayT<T>& v)
  {
    return v;
  };
  template<typename T>
  inline Arcane::ConstArray2View<T> ScalarAccessorTraits(const Arcane::VariableRefArray2T<T>& v)
  {
    return v;
  };
};

template<typename Ref>
class ScalarT
{
public:

  typedef typename Ref::PropertyType PropertyType;
  typedef typename Ref::ValueType ValueType;
  typedef typename Ref::DerivType DerivType;

  // Ce qui est issu directement des conteneurs Arcane
  typedef typename details::ScalarReturnType<PropertyType>::ValueType ConstReturnReferenceType;
  typedef typename details::ScalarReturnType<PropertyType>::DerivType DerivativesReturnType;

  // Ce qu'on reconstruit
  typedef typename StateContainer<PropertyType>::DerivType ArrayType;
  typedef typename StateContainer<PropertyType>::DerivViewType ArrayViewType;

public:

  ScalarT()
    : m_values(NULL)
    , m_derivatives(NULL) {}

  ScalarT(const ScalarT<Ref>& rhs)
    : m_property(rhs.m_property)
    , m_values(rhs.m_values)
    , m_derivatives(rhs.m_derivatives)
    , m_property_mappings(rhs.m_property_mappings)
    , m_cache_values_array(rhs.m_cache_values_array)
    , m_cache_derivatives_array(rhs.m_cache_derivatives_array) {}

  ScalarT(const PropertyType& property,
          const SharedArray<PropertyMapping>& offsets,
          const Accessor& accessor)
    : m_property(property)
    , m_values(NULL)
    , m_derivatives(NULL)
    , m_property_mappings(offsets)
  {
    m_values = &(accessor.values<ValueType>(m_property));

    if(accessor.hasDerivatives(property)) {
      m_derivatives = &(accessor.derivatives<DerivType>(m_property));
    }

    if(offsets.size() == 0) { std::cout << "ERROR\n"; exit(-1); }

    m_cache_values_array.resize(m_property_mappings.size());
    for(Arcane::Integer i = 0; i < m_property_mappings.size(); ++i)
      details::ArrayUtils::resize(m_cache_values_array[i],
                                  m_property.size(),
                                  m_property_mappings[i].userDependencies().dataSize()+1);

    m_cache_derivatives_array.resize(m_property_mappings.size());
    for(Arcane::Integer i = 0; i < m_property_mappings.size(); ++i)
      details::ArrayUtils::resize(m_cache_derivatives_array[i],
                                  m_property.size(),
                                  m_property_mappings[i].userDependencies().dataSize());
  }

  virtual ~ScalarT() {}

public:

  inline bool hasDerivatives() const { return not m_property_mappings[0].userDependencies().empty(); }

  inline const PropertyType& property() const { return m_property; }

  void resizeCacheArray(Arcane::Integer size)
  {
    m_cache_values_array.resize(size);
    m_cache_derivatives_array.resize(size);
  }

  inline ConstReturnReferenceType operator()() const
  {
    return details::ScalarAccessorTraits(*m_values);
  }

  inline DerivativesReturnType storedDerivatives() const
  {
    return details::ScalarAccessorTraits(*m_derivatives);
  }

  // Pour le debug uniquement !!!!
  inline DerivativeView<PropertyType> view() const
  {
    return DerivativeView<PropertyType>(m_property_mappings[0].userDependencies(),
                                        m_property, derivatives());
  }

  inline DerivativeView<PropertyType> view(Arcane::Integer i) const
  {
    return DerivativeView<PropertyType>(m_property_mappings[i+1].userDependencies(),
                                        m_property, derivatives(i));
  }

  inline const ArrayType& values() const
  {
    ArrayType& array = m_cache_values_array[0];
    _values(0, array);
    return array;
  }

  inline const ArrayType& derivatives() const
  {
    ArrayType& array = m_cache_derivatives_array[0];
    _derivatives(0, array);
    return array;
  }

  inline void values(ArrayType& array) const
  {
    _values(0, array);
  }

  inline void derivatives(ArrayType& array) const
  {
    _derivatives(0, array);
  }

  inline void derivatives(ArrayViewType& array) const
  {
    _derivatives(0, array);
  }

  inline const ArrayType& values(Arcane::Integer i) const
  {
    ArrayType& array = m_cache_values_array[i+1];
    _values(i+1, array);
    return array;
  }

  inline const ArrayType& derivatives(Arcane::Integer i) const
  {
    ArrayType& array = m_cache_derivatives_array[i+1];
    _derivatives(i+1, array);
    return array;
  }

  inline void values(Arcane::Integer i, ArrayType& array) const
  {
    _values(i+1, array);
  }

  inline void derivatives(Arcane::Integer i, ArrayType& array) const
  {
    _derivatives(i+1, array);
  }

  inline void derivatives(Arcane::Integer i, ArrayViewType& array) const
  {
    _derivatives(i+1, array);
  }

  const PropertyMapping& mapping(Arcane::Integer i) const { return m_property_mappings[i]; }

private:

  inline void _values(Arcane::Integer i, ArrayType& array) const
  {
    const PropertyMapping& offset = m_property_mappings[i];
    details::ArrayUtils::copy_first(details::ScalarAccessorTraits(*m_values), array);
    if(m_derivatives) {
      details::ArrayUtils::copy(details::ScalarAccessorTraits(*m_derivatives), array, offset, 1);
    }
    const Arcane::Integer deriv_against_offset = offset.propertyOffset();
    if(deriv_against_offset != -1) {
      details::ArrayUtils::set_identity(array, deriv_against_offset+1);
    }
  }

  template<typename Container>
  inline void _derivatives(Arcane::Integer i, Container& array) const
  {
    const PropertyMapping& offset = m_property_mappings[i];
    if(m_derivatives) {
      details::ArrayUtils::copy(details::ScalarAccessorTraits(*m_derivatives), array, offset, 0);
    }
    const Arcane::Integer deriv_against_offset = offset.propertyOffset();
    if(deriv_against_offset != -1) {
      details::ArrayUtils::set_identity(array, deriv_against_offset);
    }
  }

private:

  PropertyType m_property;

  const ValueType* m_values;
  const DerivType* m_derivatives;

protected:

  Arcane::SharedArray<PropertyMapping> m_property_mappings;

private:

  mutable Arcane::SharedArray<ArrayType> m_cache_values_array;
  mutable Arcane::SharedArray<ArrayType> m_cache_derivatives_array;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<typename P>
struct Scalar
  : public ScalarT< ScalarRefT<P> >
{
  typedef ScalarT< ScalarRefT<P> > Base;

  Scalar() {}

  Scalar(const Scalar& rhs)
    : Base(rhs) {}

  Scalar(const BuildInfo<P>& bi)
    : Base(bi.property(),
           bi.offsets(),
           bi.variableMng().scalars()) {}
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#define VARIABLE(type)                                                  \
  typedef Scalar<Scalar##type##Property> VariableScalar##type; \
  typedef Scalar<Vectorial##type##Property> VariableVectorial##type;

VARIABLE(Real);
VARIABLE(Integer);

#undef VARIABLE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_PHYSICS_LAW_VARIABLE_H */
