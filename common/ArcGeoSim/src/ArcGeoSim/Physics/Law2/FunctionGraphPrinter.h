// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_PHYSICS_LAW_FUNCTIONGRAPHPRINTER_H
#define ARCGEOSIM_PHYSICS_LAW_FUNCTIONGRAPHPRINTER_H
/* Author : gaynor at 11/O5/13
 * Generated by createNew
 */

/*
 * \ingroup Law
 * \brief Eciture d un jolie graphe au format .dot
 * base sur boost graph
 * pourrait etre completer par d autres formats
 *
 * \code
 *
 * FunctionGraphPrinter::printDotGraph(FunctionVector& functions, std::ostream& nout)
 *
 * \endcode
 *
 */

#include "ArcGeoSim/Physics/Law2/PropertyVector.h"
#include <map>
#include <list>
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/graphviz.hpp>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

class FunctionGraphPrinter
{
private:
  typedef std::shared_ptr<IFunction> FunctionPtr;
  typedef SharedArray<FunctionPtr> FunctionVector;
  // Noeud du graphe nomn d une fonction
  typedef boost::property<boost::vertex_name_t, std::string, boost::property<boost::vertex_index1_t, unsigned> > PrinterVertexProperty;
  // Arete du graphe nom d une propriete
  typedef boost::property<boost::edge_name_t, std::string> PrintexEdgeProperty;
  // Definition graphe boost (dag)
  typedef boost::adjacency_list<
      boost::vecS,
      boost::vecS,
      boost::directedS,
      PrinterVertexProperty,
      PrintexEdgeProperty
      > PrinterGraphType;
  // Types lies au graphe boost
  typedef boost::graph_traits<PrinterGraphType>  PrinterGraphTraits;
  typedef PrinterGraphTraits::vertex_descriptor  PrinterVertexType;
  typedef PrinterGraphTraits::edge_descriptor    PrinterEdgeType;

  //! Ecrit un noeud
  template <class NameMap, class Index1Map>
  class vertex_writer {
  public:
    vertex_writer(const NameMap& _name_map, const Index1Map& _index_map) : m_name_map(_name_map), m_index_map(_index_map) {}
    template <class Vertex>
    void operator()(std::ostream& out, const Vertex& v) const {
      if(m_index_map[v]==1)
        out << "[label=\""<<m_name_map[v]<<"\" shape=box style=filled tailport=s headport=s]";
      else
        out << "[label=\""<<m_name_map[v]<<"\"]";
    }
  private:
    const NameMap m_name_map;
    const Index1Map m_index_map;
  };

  //! Ecrit un noeud
  template <class NameMap, class Index1Map>
  static vertex_writer<NameMap,Index1Map>
  make_vertex_writer(const NameMap& _name, const Index1Map& _index) {
    return vertex_writer<NameMap,Index1Map>(_name, _index);
  };

  // All static constructeur desctructeur private
  FunctionGraphPrinter(){};
  ~FunctionGraphPrinter(){}

public :

  //! Ecrit un graphe de fonction au format .dot
  static void printDotGraph(const FunctionVector& functions, std::ostream& nout)
  {
    PrinterGraphType graph_printer;
    // construction du graphe
    std::map<int, PrinterVertexType> prop_uid_to_vertex;
    bool is_linked = false;
    for(Arcane::Integer i_func = 0 ; i_func < functions.size() ; ++i_func) {
      FunctionPtr func = functions[i_func];
      const std::string name_law  = func->name().localstr();
      const PrinterVertexType vertex_func = boost::add_vertex(name_law, graph_printer);
      get(boost::vertex_index1, graph_printer)[vertex_func] = 0;
      const PropertyVector in_prop_vect = func->in();
      for(Integer i = 0; i<in_prop_vect.size(); ++i){
        PrinterVertexType vertex_prop = _findOrAddVertexProperty(in_prop_vect[i], prop_uid_to_vertex, graph_printer);
        PrinterEdgeType new_edge ;
        const std::string name_edge = "in " +  std::to_string(i);
        boost::tie(new_edge, is_linked) = boost::add_edge(vertex_prop, vertex_func, name_edge, graph_printer);
      }
      const PropertyVector out_prop_vect = func->out();
      for(Integer i = 0; i<out_prop_vect.size(); ++i){
        PrinterVertexType vertex_prop = _findOrAddVertexProperty(out_prop_vect[i], prop_uid_to_vertex, graph_printer);
        PrinterEdgeType new_edge ;
        const std::string name_edge =  "out " + std::to_string(i);
        boost::tie(new_edge, is_linked) = boost::add_edge(vertex_func, vertex_prop, name_edge, graph_printer);
      }
    }
    // Ecriture du graphe
    boost::write_graphviz(nout,graph_printer,
        make_vertex_writer(boost::get(boost::vertex_name, graph_printer),boost::get(boost::vertex_index1, graph_printer)),
        boost::make_label_writer(boost::get(boost::edge_name, graph_printer)));
  };

private:

  //! Gestion des ajouts dans la map
  static PrinterVertexType _findOrAddVertexProperty(const Property& prop,
      std::map<int, PrinterVertexType>& prop_uid_to_vertex, PrinterGraphType& graph_printer)
  {
    const int prop_id = prop.id();
    PrinterVertexType vertex_prop;
    if(prop_uid_to_vertex.find(prop_id)==prop_uid_to_vertex.end()){
      const std::string name =prop.name().localstr();
      vertex_prop = boost::add_vertex(name, graph_printer);
      get(boost::vertex_index1, graph_printer)[vertex_prop] = 1;
      prop_uid_to_vertex.insert(std::make_pair(prop_id, vertex_prop));
    }
    else{
      vertex_prop = prop_uid_to_vertex[prop_id];
    }
    return vertex_prop;
  };
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_FUNCTIONTREE_H */
