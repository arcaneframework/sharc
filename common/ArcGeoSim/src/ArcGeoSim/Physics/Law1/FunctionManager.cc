// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "FunctionManager.h"
/* Author : desrozis at Tue Nov  6 12:32:59 2012
 * Generated by createNew
 */

#include <arcane/utils/TraceAccessor.h>
#include <arcane/ISubDomain.h>

#include <set>

extern "C" Arcane::ISubDomain* _arcaneGetDefaultSubDomain();

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

FunctionManager::
FunctionManager(bool fatal_if_unregistered, bool verbose)
  : m_verbose(verbose)
  , m_trace(_arcaneGetDefaultSubDomain()->traceMng())
  , m_fatal_if_unregistered(fatal_if_unregistered) {}

/*---------------------------------------------------------------------------*/

FunctionManager&
FunctionManager::
operator<<(FunctionPtr f)
{
  const Integer id = f->id();

  auto it = m_all_functions.find(id);

  if(it != m_all_functions.end())
    m_trace->fatal() << "Function with id='" << id << "' is already registered";

  m_all_functions[id] = f;

  auto out = f->out();

  auto deps = f->in();

  if(m_verbose)
    m_trace->info() << "Register function with id='" << id << "' : IN={ " << deps << "}, OUT={ " << out << "}";

  for(Integer i = 0; i < out.size(); ++i) {
    m_dependencies.insert(std::make_pair(out[i],deps));
    if(m_functions_by_property.find(out[i].id()) != m_functions_by_property.end())
      m_trace->fatal() << "Property '" << out[i].name() << "' computed by multiple functions";
    m_functions_by_property[out[i].id()] = f;
  }

  if(f->isParameter()) {
    m_parameters.add(f);
  } else {
    m_functions.add(f);
  }

  return *this;
}

/*---------------------------------------------------------------------------*/

void
FunctionManager::
registerOrReplace(FunctionPtr f)
{
  const Integer id = f->id();

  auto it = m_all_functions.find(id);

  if(it != m_all_functions.end()) {

    // pointer is replaced
    it->second = f;

    // clone vector (containing new function)
    auto functions = m_functions.clone();

    // clear
    m_functions.clear();
    m_parameters.clear();
    m_all_functions.clear();
    m_functions_by_property.clear();

    // insert
    for(Arcane::Integer i = 0; i < functions.size(); ++i) {
      *this << functions[i];
    }

  } else {

    // add
    *this << f;

  }
}

/*---------------------------------------------------------------------------*/

void
FunctionManager::
recomputeDependencies()
{
  m_dependencies.clear();
  auto it = m_all_functions.begin();
  for(; it != m_all_functions.end(); ++it) {
    auto f = it->second;
    auto deps(f->in());
    auto out = f->out();
    for(Integer i = 0; i < out.size(); ++i) {
      m_dependencies.insert(std::make_pair(out[i],deps));
    }
  }
}

/*---------------------------------------------------------------------------*/

const IFunction&
FunctionManager::
operator[](Integer i) const
{
  auto it = m_all_functions.find(i);

  if(it == m_all_functions.end())
    m_trace->fatal() << "Function with id='" << i << "' is not registered";

  return *it->second;
}

/*---------------------------------------------------------------------------*/

bool
FunctionManager::
contains(const Property& p) const
{
  auto it = m_functions_by_property.find(p.id());

  return it != m_functions_by_property.end();
}

/*---------------------------------------------------------------------------*/

const IFunction&
FunctionManager::
operator[](const Property& p) const
{
  auto it = m_functions_by_property.find(p.id());

  if(it == m_functions_by_property.end())
    m_trace->fatal() << "Function to compute property '" << p.name() <<"' is not registered";

  return *it->second;
}

/*---------------------------------------------------------------------------*/

FunctionManager::Enumerator
FunctionManager::
functions(IntegerConstArrayView ids) const
{
  std::set<FunctionPtr> function_set;

  for(Integer i = 0; i < ids.size(); ++i) {
    auto it = m_functions_by_property.find(ids[i]);

    if(it == m_functions_by_property.end()) {
      if(m_fatal_if_unregistered)
        m_trace->fatal() << "Function of property id='" << i << "' is not registered";
      // else
      //   m_trace->warning() << "Function of property id='" << i << "' is not registered";
    }
    else
      function_set.insert(it->second);
  }

  FunctionVector functions;
  functions.reserve(static_cast<Arcane::Integer>(function_set.size()));

  for(auto it = function_set.begin(); it != function_set.end(); ++it) {
    functions.add(*it);
  }

  return functions;
}

FunctionManager::Enumerator
FunctionManager::
functions(IntegerConstArrayView idx_input, IntegerConstArrayView idx_ouput) const
{
	m_trace->fatal() << "FunctionManager: Unavailable enumerator with input properties";
	return FunctionVector();
}

/*---------------------------------------------------------------------------*/

std::ostream& operator<<(std::ostream& nout, const FunctionManager& f)
{
  nout << "Function manager info :";

  if(f.size() == 0) {
    nout << " {empty}";
    return nout;
  }

  for(auto e = f.functions(); e.hasNext(); ++e)
    nout << "\n" << e.function();

  for(auto p = f.parameters(); p.hasNext(); ++p)
    nout << "\n" << p.function();

  return nout;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
