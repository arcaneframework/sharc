// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_STATE_H
#define ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_STATE_H
/* Author : desrozis at Tue Nov  6 15:11:02 2012
 * Generated by createNew
 */

/*
 * \ingroup Law
 * \brief Outils pour l'�valuation point � point des fonctions
 *
 * Le state est une base de donn�es de propri�t�s et de valeurs associ�es
 *
 * \code
 * ScalarRealProperty P_1(0,"P_1");
 * ScalarRealProperty P_2(1,"P_2");
 * VectorialRealProperty P_3(2,"P_3",2);
 *
 * Real r_1, r_2;
 * RealArray r_3(P_3.size());
 *
 * State s;
 * 
 * s.reserve(3);
 * 
 * s << In_1 << In_2 << In_3;
 *
 * s[P_1] = r_1;
 * s[P_2] = r_2;
 * s[P_3] = r_3;     // Par r�f�rence ...
 * s[P_3].copy(r_3); // ... ou par copie
 * 
 * info() << s;
 * \endcode
 *
 */

#include "ArcGeoSim/Physics/Law1/Property.h"
#include "ArcGeoSim/Physics/Law1/PropertyVector.h"
#include "ArcGeoSim/Physics/Law1/ContainerTraits.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace details {

  // Fonctions pour le redimensionnement des donn�es
  // Utile pour �tre g�n�rique
  // Cas scalaire, on ne fait rien
  template<typename T>
  void resize_if_necessary(const PropertyT<eScalar,T>& p, T& a) {}
  // Cas vectoriel, on dimension � la taille de la propri�t�
  template<typename T>
  void resize_if_necessary(const PropertyT<eVectorial,T>& p, Array<T>& a) 
  {
    a.resize(p.size());
  }

  /*
   * \brief Classe interne g�n�rique g�rant un type de propri�t� (Scalaire/vectorielle)
   *
   */
  template<typename P>
  class PartialStateT
  { 
  public:
    
    typedef typename StateContainer<P>::ValueType ValueType;
    typedef ValueType& ReferenceType;
   
  public:
    
    PartialStateT() {}
    
    //! Ajout d'une propri�t�
    PartialStateT<P>& operator<<(const P& p) {
      m_properties << p;
      m_values.resize(m_properties.size());
      resize_if_necessary(p, m_values[m_properties[p]]);
      return *this;
    }
    
    //! Reservation de la m�moire
    void reserve(const Integer size) 
    {
      m_values.reserve(size);
    }

    //! Accesseurs
    ReferenceType operator[](const P& p)
    {
      _check(p);
      return m_values[m_properties[p]];
    }
    
    //! Teste si la propri�t� est contenu dans le state
    bool contains(const P& p) const 
    {
      return m_properties.contains(p);
    }
    
    //! Vecteur de propri�t�
    const PropertyVector& properties() const { return m_properties; }

    //! Valeurs dans un tableau 1D
    const Array<ValueType>& values() const { return m_values; }

  private:
    
    void _check(const P& p) const
    {
      if(not  m_properties.contains(p))
        throw Arcane::FatalErrorException(String::format("Property '{0}' not registered in state",p.name()));
    }

  private:
    
    //! Vecteur de propri�t�s
    PropertyVector m_properties;

    //! Valeurs par propri�t�s
    SharedArray<ValueType> m_values;
  };
  
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \brief Classe State pour l'�valuation des lois
 *
 * Le traitement des propri�t�s scalaires/vectorielles a �t� s�par� et le choix se fait statiquement
 * par le type de propri�t�s
 *
 */
class State
  : protected details::PartialStateT<ScalarRealProperty>
  , protected details::PartialStateT<ScalarIntegerProperty>
  , protected details::PartialStateT<ScalarBooleanProperty>
  , protected details::PartialStateT<VectorialRealProperty>
  , protected details::PartialStateT<VectorialIntegerProperty>
  , protected details::PartialStateT<VectorialBooleanProperty>
{
public:
  
  State() {}
  
  //! Reservation de la m�moire
  void reserve(const Integer size) 
  {
    details::PartialStateT<ScalarRealProperty>::reserve(size);
    details::PartialStateT<ScalarIntegerProperty>::reserve(size);
    details::PartialStateT<ScalarBooleanProperty>::reserve(size);
    details::PartialStateT<VectorialRealProperty>::reserve(size);
    details::PartialStateT<VectorialIntegerProperty>::reserve(size);
    details::PartialStateT<VectorialBooleanProperty>::reserve(size);
  }

  template<typename P>
  State& operator<<(const P& p) {
    m_properties << p;
    details::PartialStateT<P>::operator<<(p);
    return *this;
  }
  
  template<typename P>
  typename details::PartialStateT<P>::ReferenceType operator[](const P& p)
  {
    m_properties << p;
    return details::PartialStateT<P>::operator[](p);
  }
  
  template<typename P>
  bool contains(const P& p) const
  {
    return details::PartialStateT<P>::contains(p);
  }
  
  const PropertyVector& properties() const { return m_properties; }
  
private:
  
  // Ensemble des propri�t�s du state
  PropertyVector m_properties;

  friend std::ostream& operator<<(std::ostream& nout, const State& s);  
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#define SCALAR(type) details::PartialStateT<Scalar##type##Property>
#define VECTORIAL(type) details::PartialStateT<Vectorial##type##Property>

#define PRINT_INFO(type)                                                \
  {                                                                     \
    const PropertyVector& properties = s.SCALAR(type)::properties();   \
    for(Integer ip = 0; ip < properties.size(); ++ip) {                    \
      const Property& p = properties[ip];                                \
      const Integer i = properties[p];                                  \
      nout << "\nscalar['" << p.name() << "']=" << s.SCALAR(type) ::values()[i] << " "; \
      empty = false;                                                    \
    }                                                                   \
  }                                                                     \
  {                                                                     \
    const PropertyVector& properties = s. VECTORIAL(type) ::properties(); \
    for(Integer ip = 0; ip < properties.size(); ++ip) {                    \
      const Property& p = properties[ip];                                \
      const Integer i = properties[p];                                  \
      nout << "\nvectorial['" << p.name() << "']={" << s. VECTORIAL(type) ::values()[i] << "}"; \
      empty = false;                                                    \
    }                                                                   \
  }

// Pour le debug
inline std::ostream& operator<<(std::ostream& nout, const State& s) 
{
  nout << "State : ";

  bool empty = true;
  
  PRINT_INFO(Real);
  PRINT_INFO(Integer);
  PRINT_INFO(Boolean);
  
  if(empty) nout << "empty!";
  
  return nout;
}

#undef SCALAR
#undef VECTORIAL
#undef PRINT_INFO

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_STATE_H */
