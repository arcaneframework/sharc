// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_VARIABLEEVALUATOR_H
#define ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_VARIABLEEVALUATOR_H
/* Author : desrozis at Wed Nov  7 08:33:33 2012
 * Generated by createNew
 */

/*
 * \ingroup Law
 * \brief Outils internes d'�valuation des lois pour les variables, variables partielles
 *        scalaires et tableaux
 *
 */

#include "ArcGeoSim/Physics/Law1/VariableManager.h"
#include "ArcGeoSim/Physics/Law1/Invoker.h"
#include "ArcGeoSim/Physics/Law1/Signature.h"
#include "ArcGeoSim/Physics/Law1/VariableResizer.h"
#include "ArcGeoSim/Physics/Law1/Enumerator.h"

#include <boost/type_traits/remove_reference.hpp>
#include <boost/type_traits/remove_pointer.hpp>

#include <numeric>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace details {

  // Permet de retrouver le I�me type sans reference ni pointeur d'un vecteur boost
  // ie 
  // typedef boost::vector<const double*,int*> V;
  // VariableTypeAt<V,0>::type == const double
  // VariableTypeAt<V,1>::type == int
  //
  template<typename ValuesT, Integer I>
  struct VariableTypeAt
  {
    typedef typename boost::fusion::result_of::at_c<ValuesT,I>::type VariablePtrRef;
    typedef typename boost::remove_reference<VariablePtrRef>::type VariablePtr;
    typedef typename boost::remove_pointer<VariablePtr>::type type;
  };
  
  // Allocation de r�f�rence et positionnement dans le vecteur
  
  // R�f�rence des valeurs des variables vers la partie in
  template<typename Signature>
  struct RefVariableToInValues
  {    
    template<Integer I, typename ValuesT>
    void apply(const typename Signature::InProperties& p, 
               const Accessor& a, 
               ValuesT& v) const
    { 
      typedef typename VariableTypeAt<ValuesT,I>::type Variable;
      boost::fusion::at_c<I>(v) = &(a.values<Variable>(boost::fusion::at_c<I>(p)));
    }
  };

  // R�f�rence des valeurs des variables vers la partie parameters
  template<typename Signature, Integer begin>
  struct RefVariableToParameters
  {    
    template<Integer I, typename ValuesT>
    void apply(const typename Signature::Parameters& p, 
               const Accessor& a, 
               ValuesT& v) const
    { 
      const Integer size = I+begin;

      typedef typename VariableTypeAt<ValuesT,size>::type Variable;
      boost::fusion::at_c<size>(v) = &(a.values<Variable>(boost::fusion::at_c<I>(p)));
    }
  };
  
  // R�f�rence des valeurs des variables vers la partie out sans d�riv�es
  template<typename Signature>
  struct RefVariableToOutValues
  {
    template<int I, typename ValuesT>
    void apply(const typename Signature::OutProperties& p, 
               const Accessor& a, 
               ValuesT& v) const
    {      
      const Integer size = I+Signature::nb_in_arguments;

      typedef typename VariableTypeAt<ValuesT,size>::type Variable;
      boost::fusion::at_c<size>(v) = &(a.values<Variable>(boost::fusion::at_c<I>(p)));
    }
  };
  
  // R�f�rence des valeurs des variables vers la partie out avec d�riv�es
  // NB : il faut avoir retailler les variables d�riv�es au pr�alable
  template<typename Signature>
  struct RefVariableToOutValuesWithDerivatives
  {
    template<int I, typename ValuesT>
    void apply(const typename Signature::OutProperties& p, 
               const Accessor& a,
               ValuesT& v) const
    { 
      const Integer size = 2*I+Signature::nb_in_arguments;
      
      typedef typename VariableTypeAt<ValuesT,size>::type Variable;
      boost::fusion::at_c<size>(v) = &(a.values<Variable>(boost::fusion::at_c<I>(p)));
    }
  };
   
  // Retaille les d�riv�es
  template<typename Signature, template<typename> class Resizer, typename E>
  struct RefVariableToOutDerivatives
  {
    template<int I, typename ValuesT>
    void apply(const typename Signature::OutProperties& p,
               const Accessor& a,
               ValuesT& v,
               Integer data_size,
               const E& enumerator) const
    {
      const Integer size = 2*I+Signature::nb_in_arguments+1;

      typedef typename Signature::OutProperties Properties;
      typedef typename boost::fusion::result_of::at_c<Properties,I>::type PropertyTypeRef;
      typedef typename boost::remove_reference<PropertyTypeRef>::type PropertyType;
      
      const PropertyType& property = boost::fusion::at_c<I>(p);

      typedef typename VariableTypeAt<ValuesT,size>::type Variable;
      
      Variable& var = a.derivatives<Variable>(property);

      Resizer<PropertyType>::resizeDerivatives(property, data_size, var, enumerator);
      
      boost::fusion::at_c<size>(v) = &var;
    }
  };
}
  
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Classe d'�valuation des variables
 *
 */
template<typename T>
class Evaluator
{ 
  typedef typename T::Signature Signature;

public:
  
  Evaluator(const T& algo, const Signature& signature)
    : m_algo(algo)
    , m_signature(signature) {}
  
  void operator()(const VariableAccessor& v, const GroupEnumerator& enumerator) const
  {
    _evaluate<typename Signature::Variables>(v,enumerator);
  } 

  void operator()(const PartialVariableAccessor& v, const GroupEnumerator& enumerator) const
  {
    _evaluate<typename Signature::PartialVariables>(v,enumerator);
  }  
  
  void operator()(const ArrayAccessor& v, const RangeEnumerator& enumerator) const
  { 
    _evaluate<typename Signature::Arrays>(v,enumerator);
  }

  void operator()(const ScalarAccessor& v) const
  {
    _evaluate<typename Signature::Scalars>(v, NoneEnumerator());
  }

private:

  template<typename V, typename E>
  void _evaluate(const Accessor& v, const E& enumerator) const
  {
    details::RefVariableToInValues<Signature> in_copy;
    details::RefVariableToOutValues<Signature> out_copy;
    details::RefVariableToParameters<Signature,Signature::nb_out_arguments+Signature::nb_in_arguments> param_copy;

    // Vecteur de donn�es (pointeurs)
    V values;

    // On r�f�rence les variables in dans le vecteur de donn�es
    mpl::static_for<0,Signature::nb_in_arguments >(in_copy, m_signature.in(), v, values);

    // On r�f�rence les variables out dans le vecteur de donn�es
    mpl::static_for<0,Signature::nb_out_arguments>(out_copy, m_signature.out(), v, values);
  
    // On r�f�rence les variables parameter dans le vecteur de donn�es
    mpl::static_for<0,Signature::nb_parameters>(param_copy, m_signature.param(), v, values);

    // Evaluateur
    Invoker<T,V> evaluator(m_algo, values);

    // On it�re et �value
    enumerator(evaluator);
  }

private:

  const T& m_algo;
  const Signature& m_signature;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Classe d'�valuation des variables avec d�riv�es
 *
 */
template<typename T, bool is_derivable = true>
class DerivativeEvaluator
{
  typedef typename T::Signature Signature;

public:
  
  DerivativeEvaluator(const T& algo, const typename T::Signature& signature)
    : m_algo(algo)
    , m_signature(signature) {} 
  
  void operator()(const VariableAccessor& v, const GroupEnumerator& enumerator, Arcane::Integer max_nb_unknowns=0) const
  {    
    _evaluate<typename Signature::VariablesAndDerivatives, VariableResizer>(v,enumerator,max_nb_unknowns);
  }
  
  void operator()(const PartialVariableAccessor& v, const GroupEnumerator& enumerator, Arcane::Integer max_nb_unknowns=0) const
  {    
    _evaluate<typename Signature::PartialVariablesAndDerivatives, VariableResizer>(v,enumerator,max_nb_unknowns);
  }
  
  void operator()(const ArrayAccessor& v, const RangeEnumerator& enumerator, Arcane::Integer max_nb_unknowns=0) const
  { 
    _evaluate<typename Signature::ArraysAndDerivatives, ArrayResizer>(v,enumerator,max_nb_unknowns);
  }

  void operator()(const ScalarAccessor& v, Arcane::Integer max_nb_unknowns=0) const
  {
    _evaluate<typename Signature::ScalarsAndDerivatives, ScalarResizer>(v,NoneEnumerator(),max_nb_unknowns);
  }

private:

  template<typename V, template<typename> class R, typename A, typename E>
  void _evaluate(const A& v, const E& enumerator, Arcane::Integer max_nb_unknowns=0) const
  { 
    details::RefVariableToInValues<Signature> in_copy;
    details::RefVariableToOutValuesWithDerivatives<Signature> out_copy;
    details::RefVariableToOutDerivatives<Signature,R,E> deriv_out_copy;
    details::RefVariableToParameters<Signature,2*Signature::nb_out_arguments+Signature::nb_in_arguments> param_copy;

  
    // Vecteur de donn�es (pointeurs)
    V values;
  
    // On r�f�rence les variables in dans le vecteur de donn�es
    mpl::static_for<0,Signature::nb_in_arguments >(in_copy, m_signature.in(), v, values);

    // On r�f�rence les variables out dans le vecteur de donn�es
    mpl::static_for<0,Signature::nb_out_arguments>(out_copy, m_signature.out(), v, values);

    const Integer data_size = (max_nb_unknowns==0?m_signature.inProperties().dataSize():max_nb_unknowns);
    
    // On r�f�rence les variables d�riv�es out dans le vecteur de donn�es
    // On retaille les d�riv�es au passage
    mpl::static_for<0,Signature::nb_out_arguments>(deriv_out_copy, m_signature.out(), v, values, data_size, enumerator);
    
    // On r�f�rence les variables parameter dans le vecteur de donn�es
    mpl::static_for<0,Signature::nb_parameters>(param_copy, m_signature.param(), v, values);

    // Evaluateur
    DerivativeInvoker<T,V> evaluator(m_algo, values);
    
    // On it�re et �value
    enumerator(evaluator);
  }

private:

  const T& m_algo;
  const Signature& m_signature;
};  

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

// Cas non d�rivable, on lance une exception
template<typename T>
struct DerivativeEvaluator<T,false> 
{
  DerivativeEvaluator(const T& algo, const typename T::Signature& signature) {}

  void operator()(const VariableAccessor&, const GroupEnumerator&, Arcane::Integer max_nb_unknowns=0) const
  {
    throw Arcane::FatalErrorException("Function is not derivable");
  }
  
  void operator()(const PartialVariableAccessor&, const GroupEnumerator&, Arcane::Integer max_nb_unknowns=0) const
  {
    throw Arcane::FatalErrorException("Function is not derivable");
  }
  
  void operator()(const ArrayAccessor&, const RangeEnumerator&, Arcane::Integer max_nb_unknowns=0) const
  {
    throw Arcane::FatalErrorException("Function is not derivable");
  }

  void operator()(const ScalarAccessor&, Arcane::Integer max_nb_unknowns=0) const
  {
    throw Arcane::FatalErrorException("Function is not derivable");
  }
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_VARIABLEEVALUATOR_H */
