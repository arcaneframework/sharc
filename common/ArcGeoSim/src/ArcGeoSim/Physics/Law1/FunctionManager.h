// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_PHYSICS_LAW_FUNCTIONMANAGER_H
#define ARCGEOSIM_PHYSICS_LAW_FUNCTIONMANAGER_H
/* Author : desrozis at Tue Oct 30 16:51:25 2012
 * Generated by createNew
 */

/*
 * \ingroup Law
 * \brief Base de donnees de fonctions
 *
 * Voir les fonctions de remplissage dans Function.h
 * Les algorithmes doivent etre retenus en memoire par l'application
 * 
 * \code
 *
 * FunctionManager function_mng;
 * 
 * ExampleAlgo algo();
 * ExampleAlgo::Signature signature;
 *
 * // Remplissage de la signature
 * ...
 *
 * function_mng << createFunction(0, algo, signature);
 *
 * info() << function_mng;
 *
 * const IFunction& f = function_mng[0]; 
 * 
 * info() << f;
 *
 * \endcode
 *
 */

#include "ArcGeoSim/Physics/Law1/Function.h"
#include "ArcGeoSim/Physics/Law1/EvalFunctionTraits.h"

#include <map>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Classe de stockage des fonctions
 *
 * Met e disposition les dependances par proprietes
 *
 */
class FunctionManager
{
private:

  typedef std::shared_ptr<IFunction> FunctionPtr;
  typedef Arcane::SharedArray<FunctionPtr> FunctionVector;
  typedef std::map< Integer,FunctionPtr> FunctionMap;
  typedef std::map<Property, PropertyVector> DependenciesMap;

public:

  //! Enumerateur de fonctions
  class Enumerator
  {
  public:
    Enumerator(const FunctionVector& f)
      : m_functions(f)
      , m_current(m_functions.begin())
      , m_end(m_functions.end())
      , m_count(0) {}
    Enumerator(const Enumerator& e)
      : m_functions(e.m_functions)
      , m_current(e.m_current)
      , m_end(e.m_end)
      , m_count(e.m_count) {}
    void reset() { m_current = m_functions.begin(); m_count = 0; }
    bool hasNext() const { return m_current != m_end; }
    void operator++() { m_current++; m_count++; }
    const IFunction& function() const { return **m_current; }
    Integer functionId() const { return (*m_current)->id(); }
    Integer count() const { return m_count; }
    Integer size() const { return m_functions.size(); }
  private:
    FunctionVector m_functions;
    FunctionVector::const_iterator m_current;
    FunctionVector::const_iterator m_end;
    Integer m_count;
  };

  FunctionManager(bool fatal_if_unregistered = false, bool verbose = true);

  virtual ~FunctionManager(){}

  //! Enclenche le mode verbose
  void enableVerbosity() { m_verbose = true; }

  //! Enclenche le mode silencieux
  void disableVerbosity() { m_verbose = false; }

  //! Enregistrement d'une fonction
  FunctionManager& operator<<(FunctionPtr f);

  //! Enregistrement d'une fonction
  void registerOrReplace(FunctionPtr f);

  //! Accession d'une fonction par son identifiant unique
  bool contains(const Property& p) const;

  //! Accession d'une fonction par son identifiant unique
  const IFunction& operator[](Integer i) const;

  //! Accession d'une fonction calculant une propriete
  const IFunction& operator[](const Property& p) const;

  //! Nombre de fonctions
  inline Integer size() const { return static_cast<Arcane::Integer>(m_all_functions.size()); }

  //! Enumerateur de fonction
  inline Enumerator functions() const { return m_functions; }

  //! Enumerateur de fonction parametres
  inline Enumerator parameters() const { return m_parameters; }

  //! Enumerateur de fonction
  Enumerator functions(Arcane::IntegerConstArrayView ids) const;

  //! Enumerateur de fonction // reflexion api pour function manager
  Enumerator functions(Arcane::IntegerConstArrayView idx_input,
                       Arcane::IntegerConstArrayView idx_ouput) const;

  //! Dependances d'une propriete
  const PropertyVector& dependencies(const Property& p) const { return m_dependencies[p]; }

  //! Recalcul des dependances des proprietes
  void recomputeDependencies();

private:

  //! Verbosity
  bool m_verbose;

  //! Manager de trace
  Arcane::ITraceMng* m_trace;

  //! Stragtegie si fonction absente mais demandee
  bool m_fatal_if_unregistered;

  //! Mapping de fonctions
  FunctionMap m_all_functions;
  FunctionMap m_functions_by_property;

  //! Dependances par proprietes
  mutable DependenciesMap m_dependencies;

  //! Fonctions
  FunctionVector m_functions;

  //! Fonctions parametres (evaluees en premier et sans derivees)
  FunctionVector m_parameters;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

std::ostream& operator<<(std::ostream& nout, const FunctionManager& f);

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

// !TODO deplacer la partie creation

//! Outil utilisateur pour la creation de fonction
template<typename T>
inline std::shared_ptr<IFunction> createFunction(Integer id, const T& algo, const typename T::Signature& signature)
{
  static_assert(EvalFunctionTraits<T>::is_valid, "Law is not valid - are eval methods const?");

  return std::shared_ptr<IFunction>(new FunctionT<T>(id,algo,signature,false));
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

//! Outil utilisateur pour la creation de fonction parametre
template<typename T>
inline std::shared_ptr<IFunction> createParameterFunction(Integer id, const T& algo, const typename T::Signature& signature)
{
  return std::shared_ptr<IFunction>(new FunctionT<T>(id,algo,signature,true));
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_PHYSICS_LAW_FUNCTIONMANAGER_H */
