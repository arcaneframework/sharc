// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_STATEEVALUATOR_H
#define ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_STATEEVALUATOR_H
/* Author : desrozis at Wed Nov  7 08:33:33 2012
 * Generated by createNew
 */

/*
 * \ingroup Law
 * \brief Outils internes d'�valuation des lois pour les states
 *
 */

#include "ArcGeoSim/Physics/Law1/State.h"
#include "ArcGeoSim/Physics/Law1/Invoker.h"
#include "ArcGeoSim/Physics/Law1/Signature.h"

#include <boost/fusion/include/for_each.hpp>

#include <numeric>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace details {
  
  // R�f�rence des valeurs d'un state vers la partie in 
  template<typename Signature>
  struct RefStateToInValues
  {    
    template<int I, typename ValuesT>
    void apply(const typename Signature::InProperties& p, 
               const State& s, 
               ValuesT& v) const
    { 
      // L'op�rateur [] pour un const array ne renvoit pas une r�f�rence !
      
      boost::fusion::at_c<I>(v) = &(const_cast<State*>(&s)->operator[](boost::fusion::at_c<I>(p)));
    }
  };
  
  // R�f�rence des valeurs d'un state vers la partie parameter 
  template<typename Signature, Integer begin>
  struct RefStateToParameters
  {    
    template<int I, typename ValuesT>
    void apply(const typename Signature::Parameters& p, 
               const State& s, 
               ValuesT& v) const
    { 
      // L'op�rateur [] pour un const array ne renvoit pas une r�f�rence !
      
      boost::fusion::at_c<I+begin>(v) = &(const_cast<State*>(&s)->operator[](boost::fusion::at_c<I>(p)));
    }
  };
  
  // Enregistre les propri�t�s dans le state/derivative
  template<typename Signature>
  struct RegisterProperty
  {
    template<int I, typename P>
    void apply(const P& p, State& s) const
    { 
      s << boost::fusion::at_c<I>(p);
    }

    template<int I, typename P>
    void apply(const P& p, const PropertyVector& in_properties, Derivative& d) const
    { 
      d << boost::fusion::at_c<I>(p);

      d.setFunctionDependencies(boost::fusion::at_c<I>(p), in_properties);
    }
  };

  // R�f�rence des valeurs d'un state vers la partie out
  template<typename Signature>
  struct RefStateToOutValues
  {
    template<int I>
    void apply(const typename Signature::OutProperties& p, 
               State& s, 
               typename Signature::Values& v) const
    {  
      boost::fusion::at_c<I+Signature::nb_in_arguments>(v) = &(s[boost::fusion::at_c<I>(p)]);
    }
    
    template<int I>
    void apply(const typename Signature::OutProperties& p, 
               State& s, 
               Derivative& d, 
               typename Signature::ValuesAndDerivatives& v) const
    {        
      boost::fusion::at_c<2*I+Signature::nb_in_arguments>(v) = &(s[boost::fusion::at_c<I>(p)]);
            
      boost::fusion::at_c<2*I+Signature::nb_in_arguments+1>(v) = &(d.values(boost::fusion::at_c<I>(p)));
    }
  };
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Classe d'�valuation des states sans d�riv�es
 *
 */
template<typename T>
class StateEvaluator
{
  typedef typename T::Signature Signature;

public:
  
  StateEvaluator(const T& algo, const Signature& signature)
    : m_algo(algo)
    , m_signature(signature) {}
  
  void operator()(const State& s, State& r) const
  { 
    // On enregistre les propri�t�s dans le state out
    mpl::static_for<0,Signature::nb_out_arguments>(details::RegisterProperty<Signature>(), 
                                                   m_signature.out(), 
                                                   r);
    
    // Vecteur de donn�es
    typename T::Signature::Values values;
    
    // On r�f�rence les valeurs du state in dans le vecteur de donn�es
    mpl::static_for<0,Signature::nb_in_arguments >(details::RefStateToInValues<Signature>(), 
                                                   m_signature.in(),
                                                   s,
                                                   values);
    
    // On r�f�rence les valeurs du state out dans le vecteur de donn�es
    mpl::static_for<0,Signature::nb_out_arguments>(details::RefStateToOutValues<Signature>(),
                                                   m_signature.out(),
                                                   r,
                                                   values);
   
    const Integer size = Signature::nb_out_arguments + Signature::nb_in_arguments;

    // On r�f�rence les valeurs du state parameter dans le vecteur de donn�es
    mpl::static_for<0,Signature::nb_parameters>(details::RefStateToParameters<Signature,size>(), 
                                                m_signature.param(),
                                                s,
                                                values);

    // On �value
    Invoker<T,typename Signature::Values>(m_algo, values)();
  }
  
private:
  
  const T& m_algo;
  const Signature& m_signature;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Classe d'�valuation des states avec d�riv�es
 *
 */
template<typename T, bool is_derivable = true>
class DerivativeStateEvaluator
{
  typedef typename T::Signature Signature;

public:
  
  DerivativeStateEvaluator(const T& algo, const Signature& signature)
    : m_algo(algo)
    , m_signature(signature) {}
  
  void operator()(const State& s, State& r, Derivative& d) const
  {
    // On enregistre les propri�t�s dans le state out
    mpl::static_for<0,Signature::nb_out_arguments>(details::RegisterProperty<Signature>(),
                                                   m_signature.out(),
                                                   r);
    
    // On enregistre les propri�t�s dans le derivative
    if(d.hasFunctionDependencies())
      mpl::static_for<0,Signature::nb_out_arguments>(details::RegisterProperty<Signature>(),
                                                     m_signature.out(),
                                                     d.getFunctionDependencies(),
                                                     d);
    else
      mpl::static_for<0,Signature::nb_out_arguments>(details::RegisterProperty<Signature>(),
                                                     m_signature.out(),
                                                     m_signature.inProperties(),
                                                     d);
    
    // Vecteur de donn�es (et d�riv�es)
    typename Signature::ValuesAndDerivatives values;
    
    // On r�f�rence les valeurs du state in dans le vecteur de donn�es
    mpl::static_for<0,Signature::nb_in_arguments >(details::RefStateToInValues<Signature>(), 
                                                   m_signature.in(),
                                                   s,
                                                   values);
    
    // On r�f�rence les valeurs du state out et derivative dans le vecteur de donn�es
    mpl::static_for<0,Signature::nb_out_arguments>(details::RefStateToOutValues<Signature>(),
                                                   m_signature.out(),
                                                   r, d,
                                                   values);
    
    const Integer size = 2*Signature::nb_out_arguments + Signature::nb_in_arguments;

    // On r�f�rence les valeurs du state parameter dans le vecteur de donn�es
    mpl::static_for<0,Signature::nb_parameters>(details::RefStateToParameters<Signature,size>(), 
                                                m_signature.param(),
                                                s,
                                                values);

    // On �value
    DerivativeInvoker<T, typename Signature::ValuesAndDerivatives>(m_algo,values)(); 
  }
  
private:
  
  const T& m_algo;
  const Signature& m_signature;
};

// Cas non d�rivable, on lance une exception
template<typename T>
struct DerivativeStateEvaluator<T,false>
{
  DerivativeStateEvaluator(const T& algo, const typename T::Signature& signature) {}
  
  void operator()(const State& s, State& r, Derivative& d) const
  {
    throw Arcane::FatalErrorException("Function is not derivable");
  }
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_STATEEVALUATOR_H */
