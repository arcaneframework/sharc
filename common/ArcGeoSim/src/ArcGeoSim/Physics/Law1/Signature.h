// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_SIGNATURE_H
#define ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_SIGNATURE_H
/* Author : desrozis at Mon Nov  5 16:17:08 2012
 * Generated by createNew
 */

/*
 * \ingroup Law
 * \brief Signature d'une fonction loi
 *
 * Les outils de programmation g�n�rique de boost (mpl,fusion) sont utilis�s
 *
 * La classe Signature est template des types SignatureTraits IN et OUT d�crivant
 * respectivement les entr�es et les sorties de la loi
 *
 */

#if !defined(FUSION_MAX_VECTOR_SIZE)
#define FUSION_MAX_VECTOR_SIZE 30
#endif

#include "ArcGeoSim/Physics/Law1/SignatureTraits.h"
#include "ArcGeoSim/Physics/Law1/PropertyVector.h"

#include <boost/mpl/joint_view.hpp>
#include <boost/fusion/include/vector.hpp>
#include <boost/fusion/include/at_c.hpp>
#include <boost/fusion/adapted/mpl.hpp>

#include <iostream>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#define AS_VECTOR(name,result)                                          \
  typedef typename boost::fusion::result_of::as_vector<name>::type result;

#define JOINT(in,out)                                                   \
  typedef typename boost::mpl::joint_view<                              \
          typename boost::mpl::joint_view<typename  IN::in,typename OUT::out>::type, \
          typename PARAM::in \
    >::type out;

template<typename IN, typename OUT, typename PARAM>
class Signature
{
public:

  struct PushBack
  {
    template<Integer I, typename P>
    void apply(const P& static_p, PropertyVector& dynamic_p) const
    {
      dynamic_p << boost::fusion::at_c<I>(static_p);
    }
  };

public:
  
  //! Nombres d'arguments de la signature
  static const Integer nb_in_arguments = IN::nb_arguments; 
  static const Integer nb_out_arguments = OUT::nb_arguments; 
  static const Integer nb_parameters = PARAM::nb_arguments;

  static const Integer nb_eval_arguments = IN::nb_arguments+OUT::nb_arguments+PARAM::nb_arguments;
  static const Integer nb_diff_eval_arguments = IN::nb_arguments+2*OUT::nb_arguments+PARAM::nb_arguments;

  // Jusqu'ici, on a des vecteurs de type (mpl)
  // Il nous faut des vecteur aggr�g�s (boost::fusion) contenant les types + valeurs.
  
  AS_VECTOR(typename    IN::PropertyTypes, InProperties); // Vecteur des propri�t�s IN
  AS_VECTOR(typename   OUT::PropertyTypes,OutProperties); // Vecteur des propri�t�s OUT
  AS_VECTOR(typename PARAM::PropertyTypes,   Parameters); // Vecteur des propri�t�s PARAM
  
  JOINT(ValueTypes,ValueTypes);
  JOINT(ValueTypes,ValueAndDerivativeTypes);
  AS_VECTOR(ValueTypes,Values);                            // Vecteur des valeurs pour states 
  AS_VECTOR(ValueAndDerivativeTypes,ValuesAndDerivatives); // Vecteur des valeurs + d�riv�es pour states
  AS_VECTOR(typename   IN::DerivativeValueTypes,InDerivativeValues); // Vecteur des d�riv�es out pour states
  AS_VECTOR(typename   OUT::DerivativeValueTypes,OutDerivativeValues); // Vecteur des d�riv�es in pour states

  JOINT(ArrayTypes,ArrayTypes);
  JOINT(ArrayTypes,ArrayAndDerivativeTypes);
  AS_VECTOR(ArrayTypes,Arrays);                            // Vecteur des valeurs pour tableaux 
  AS_VECTOR(ArrayAndDerivativeTypes,ArraysAndDerivatives); // Vecteur des valeurs + d�riv�es pour tableaux
  AS_VECTOR(typename   IN::DerivativeArrayTypes,InDerivativeArrays); // Vecteur des d�riv�es in pour tableaux
  AS_VECTOR(typename   OUT::DerivativeArrayTypes,OutDerivativeArrays); // Vecteur des d�riv�es out pour tableaux

  JOINT(ScalarTypes,ScalarTypes);
  JOINT(ScalarTypes,ScalarAndDerivativeTypes);
  AS_VECTOR(ScalarTypes,Scalars);                            // Vecteur des valeurs pour scalaires
  AS_VECTOR(ScalarAndDerivativeTypes,ScalarsAndDerivatives); // Vecteur des valeurs + d�riv�es pour scalaires
  AS_VECTOR(typename   IN::DerivativeScalarTypes,InDerivativeScalars); // Vecteur des d�riv�es in pour scalaires
  AS_VECTOR(typename   OUT::DerivativeScalarTypes,OutDerivativeScalars); // Vecteur des d�riv�es out pour scalaires

  JOINT(VariableTypes,VariableTypes);
  JOINT(VariableTypes,VariableAndDerivativeTypes);
  AS_VECTOR(VariableTypes,Variables);                            // Vecteur des valeurs pour variables
  AS_VECTOR(VariableAndDerivativeTypes,VariablesAndDerivatives); // Vecteur des valeurs + d�riv�es pour variables
  AS_VECTOR(typename   IN::DerivativeVariableTypes,InDerivativeVariables); // Vecteur des d�riv�es in pour variables
  AS_VECTOR(typename   OUT::DerivativeVariableTypes,OutDerivativeVariables); // Vecteur des d�riv�es out pour variables

  JOINT(PartialVariableTypes,PartialVariableTypes);
  JOINT(PartialVariableTypes,PartialVariableAndDerivativeTypes);
  AS_VECTOR(PartialVariableTypes,PartialVariables);                            // Vecteur des valeurs pour variables partielles
  AS_VECTOR(PartialVariableAndDerivativeTypes,PartialVariablesAndDerivatives); // Vecteur des valeurs + d�riv�es pour variables partielles
  AS_VECTOR(typename   IN::DerivativePartialVariableTypes,InDerivativePartialVariables); // Vecteur des in d�riv�es pour variables partielles
  AS_VECTOR(typename   OUT::DerivativePartialVariableTypes,OutDerivativePartialVariables); // Vecteur des d�riv�es out pour variables partielles

  JOINT(FuncSigTypes,FuncSigTypes);
  JOINT(FuncSigTypes,DerivFuncSigTypes);

public:
  
  Signature() 
    : m_is_up_to_date(false) {} 
  
  //! Accesseurs aux propri�t�s IN
  template<Integer I>
  typename boost::fusion::result_of::at_c<InProperties, I>::type in() 
  {
    BOOST_STATIC_ASSERT(I < IN::nb_arguments);
    m_is_up_to_date = false;
    return boost::fusion::at_c<I>(m_static_in);
  }
  
  //! Accesseurs aux propri�t�s OUT
  template<Integer I>
  typename boost::fusion::result_of::at_c<OutProperties, I>::type out() 
  {
    BOOST_STATIC_ASSERT(I < OUT::nb_arguments);
    m_is_up_to_date = false;
    return boost::fusion::at_c<I>(m_static_out);
  }
 
  //! Accesseurs aux propri�t�s PARAM
  template<Integer I>
  typename boost::fusion::result_of::at_c<Parameters, I>::type parameter() 
  {
    BOOST_STATIC_ASSERT(I < PARAM::nb_arguments);
    m_is_up_to_date = false;
    return boost::fusion::at_c<I>(m_static_param);
  }
  
  //! Liste statique des propri�t�s IN
  const InProperties& in() const { return m_static_in; }
    
  //! Liste statique des propri�t�s OUT
  const OutProperties& out() const { return m_static_out; }
  
  //! Liste statique des propri�t�s OUT
  const Parameters& param() const { return m_static_param; }
  
  //! Liste dynamique des propri�t�s IN
  const PropertyVector& inProperties() const { leazy_initialize(); return m_dynamic_in; }

  //! Liste dynamique des propri�t�s OUT
  const PropertyVector& outProperties() const { leazy_initialize(); return m_dynamic_out; }
 
  //! Liste dynamique des propri�t�s PARAM
  const PropertyVector& parameters() const { leazy_initialize(); return m_dynamic_param; }
  
  //! Initialisation pour l'utilisateur 
  // (par exemple si une propri�t� change de taille)
  void initialize() { _initialize(); }

private:
 
  void leazy_initialize() const
  {
    if(not m_is_up_to_date) _initialize();
  }
 
  void _initialize() const 
  {
    _initializeProperties<nb_in_arguments>(m_static_in,m_dynamic_in);
    _initializeProperties<nb_out_arguments>(m_static_out,m_dynamic_out);
    _initializeProperties<nb_parameters>(m_static_param,m_dynamic_param);
    m_is_up_to_date = true;
  }

  template<Integer SIZE, typename P>
  void _initializeProperties(const P& static_p, PropertyVector& dynamic_p) const
  {
    dynamic_p.reset();
    
    mpl::static_for<0,SIZE>(PushBack(), static_p, dynamic_p);
  }
  
private:

  mutable bool m_is_up_to_date;

  //! Description statique des propri�t�s
  InProperties  m_static_in;
  OutProperties m_static_out;
  Parameters m_static_param;
  
  //! Description dynamique des propri�t�s
  // (const par design avec leazy)
  mutable PropertyVector m_dynamic_in;
  mutable PropertyVector m_dynamic_out; 
  mutable PropertyVector m_dynamic_param;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
// Pour le debug

template<typename IN, typename OUT, typename PARAM>
inline std::ostream& operator<<(std::ostream& nout, const Signature<IN,OUT,PARAM>& s) 
{
  nout << "\nIn : ";
  ConstArrayView<Property> in = s.inProperties().properties();
  if(in.size() == 0)
    nout << "empty!";
  else 
    for(Integer i = 0; i < in.size(); ++i)
      nout << "\n" << in[i];
  nout << "\nOut : ";
  ConstArrayView<Property> out = s.outProperties().properties();
  if(out.size() == 0)
    nout << "empty!";
  else 
    for(Integer i = 0; i < out.size(); ++i)
      nout << "\n" << out[i];
  nout << "\nParameters : ";
  ConstArrayView<Property> param = s.parameters().properties();
  if(param.size() == 0)
    nout << "empty!";
  else 
    for(Integer i = 0; i < param.size(); ++i)
      nout << "\n" << param[i];
  return nout;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_SIGNATURE_H */
