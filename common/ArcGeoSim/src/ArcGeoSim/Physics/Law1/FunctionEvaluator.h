// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_FUNCTIONEVALUATOR_H
#define ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_FUNCTIONEVALUATOR_H
/* Author : desrozis at Tue Nov 13 08:40:09 2012
 * Generated by createNew
 */
         
/*
 * \ingroup Law
 * \brief Outils pour l'���valuation des fonctions
 *
 */

#include "ArcGeoSim/Physics/Law1/FunctionManager.h"
#include "ArcGeoSim/Physics/Law1/VariableManager.h"
#include "ArcGeoSim/Physics/Law1/Enumerator.h"
#include "ArcGeoSim/Physics/Law1/Property.h"
#include "ArcGeoSim/Physics/Law1/PropertyVector.h"
#include "ArcGeoSim/Physics/Law1/ContainerTraits.h"
#include "ArcGeoSim/Utils/Utils.h"
#include <arcane/IMesh.h>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Classe pour l'���valuation des fonctions associ���es ��� une base
 * de donn���es de variables
 *
 */

class FunctionEvaluator
{
public:
  
  using FunctionEnumerator = FunctionManager::Enumerator;

  FunctionEvaluator(const FunctionManager& f,Integer max_nb_unknowns=0);

  FunctionEvaluator(const FunctionManager& f, IntegerConstArrayView ids, Integer max_nb_unknowns=0);

  FunctionEvaluator(const FunctionManager& f, IntegerConstArrayView idi, IntegerConstArrayView ids, Integer max_nb_unknowns=0);

public:
  
  template<typename K, template<typename> class Accessor>
  void evaluate(const Accessor<K>& accessor, 
                Arcane::ItemGroupT<K> group, 
                EvaluationMode mode = eWithoutDerivative)
  {
    switch(mode) {
    case eWithoutDerivative:
      _evaluate(m_parameters, accessor, group);
      _evaluate(m_functions, accessor, group);
      break;
    case eWithDerivative:
      evaluateWithDerivatives(accessor, group);
      break;
    default:
      throw Arcane::FatalErrorException("Not implemented");
    }
  }
  
  template<typename Accessor>
  void evaluate(const Accessor& accessor,
                Arcane::ItemGroup group,
                EvaluationMode mode = eWithoutDerivative)
  {
    switch(mode) {
    case eWithoutDerivative:
      _evaluate(m_parameters, accessor, group);
      _evaluate(m_functions, accessor, group);
      break;
    case eWithDerivative:
      evaluateWithDerivatives(accessor, group);
      break;
    default:
      throw Arcane::FatalErrorException("Not implemented");
    }
  }

  template<typename K, template<typename> class Accessor>
  void evaluateWithDerivatives(const Accessor<K>& accessor, Arcane::ItemGroupT<K> group)
  {
    _evaluate(m_parameters, accessor, group);
    _evaluateWithDerivatives(m_functions, accessor, group);
  }
  
  template<typename Accessor>
  void evaluateWithDerivatives(const Accessor& accessor, Arcane::ItemGroup group)
  {
    _evaluate(m_parameters, accessor, group);
    _evaluateWithDerivatives(m_functions, accessor, group);
  }

  void evaluate(const ArrayAccessor& accessor, 
                Integer begin, Integer end, 
                EvaluationMode mode = eWithoutDerivative);
  
  void evaluateWithDerivatives(const ArrayAccessor& accessor, Integer begin, Integer end);

  void evaluate(const ScalarAccessor& accessor, 
                EvaluationMode mode = eWithoutDerivative);

  void evaluateWithDerivatives(const ScalarAccessor& accessor);

  void symbolic_evaluate(const Accessor& accessor, Arcane::ITraceMng* trace);

private:

  template<typename... T>
  void _evaluate(FunctionEnumerator& functions, const T&... args)
  {
    functions.reset();
    for( ; functions.hasNext(); ++functions) 
      functions.function().evaluate(args..., eWithoutDerivative);
  } 

  template<typename... T>
  void _evaluateWithDerivatives(FunctionEnumerator& functions, const T&... args)
                                
  {
    functions.reset();
    for( ; functions.hasNext(); ++functions)
      functions.function().evaluate(args..., eWithDerivative, m_max_nb_unknowns);
  }

  void _symbolic_evaluate(const Accessor& accessor, Arcane::ITraceMng* trace, FunctionEnumerator& functions);
  
  void _check(const PropertyVector& properties, const Accessor& accessor, Arcane::ITraceMng* trace);
  
private:
  
  const FunctionManager& m_function_mng;

  FunctionEnumerator m_functions;
  FunctionEnumerator m_parameters;

  Arcane::Integer m_max_nb_unknowns ;

  bool m_is_first_derivate_eval;
};


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_ARCGEOSIM_PHYSICS_LAW_EVALUATOR_H */
