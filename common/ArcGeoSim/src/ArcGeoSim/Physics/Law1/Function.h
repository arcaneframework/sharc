// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2025 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#ifndef ARCGEOSIM_PHYSICS_LAW_FUNCTIONINFO_H
#define ARCGEOSIM_PHYSICS_LAW_FUNCTIONINFO_H
/* Author : desrozis at Tue Nov  6 12:32:59 2012
 * Generated by createNew
 */

/*
 * \ingroup Law
 * \brief Fonction interne wrappant un algorithme utilisateur
 *
 */

#include "ArcGeoSim/Physics/Law1/IFunction.h"
#include "ArcGeoSim/Physics/Law1/EvalFunctionTraits.h"
#include "ArcGeoSim/Physics/Law1/StateEvaluator.h"
#include "ArcGeoSim/Physics/Law1/VariableEvaluator.h"
#include "ArcGeoSim/Physics/Law1/VariableManager.h"

#include <boost/shared_ptr.hpp>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

BEGIN_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*
 * \ingroup Law
 * \brief Fonction interne wrappant un algorithme utilisateur
 *
 */
template<typename T>
class FunctionT : public IFunction
{
private:

  static_assert(EvalFunctionTraits<T>::is_valid, "Law is not valid - are eval methods const?");

  typedef typename T::Signature Signature;

public:
  
  FunctionT(Integer id, const T& algo, const Signature& signature, bool is_parameter) 
    : m_id(id) 
    , m_is_parameter(is_parameter)
    , m_algo(algo)
    , m_signature(signature)
    , m_state_evaluator(m_algo,m_signature)
    , m_deriv_state_evaluator(m_algo,m_signature)
    , m_evaluator(m_algo,m_signature)
    , m_deriv_evaluator(m_algo,m_signature) 
  {
    if(id < 0) throw Arcane::FatalErrorException("Function construction error : id < 0");
  }

  Integer id() const { return m_id; }
  
  bool isParameter() const { return m_is_parameter; }

  //! Test si la fonction est d�rivable
  bool isDifferentiable() const { return EvalFunctionTraits<T>::is_differentiable; }
  
  //! Evaluation sans d�riv�e avec state
  void evaluate(const State& s, State& r) const
  {
    m_state_evaluator(s,r);
  }
  void eval(const State& s, State& r) const
  {
    m_state_evaluator(s,r);
  }
  
  //! Evaluation avec d�riv�e avec state
  void evaluate(const State& s, State& r, Derivative& d) const
  { 
    m_deriv_state_evaluator(s,r,d);
  }
  void eval(const State& s, State& r, Derivative& d) const
  {
    m_deriv_state_evaluator(s,r,d);
  }

  
  //! Evaluation pour variables sur le maillage
  void evaluate(const VariableAccessor& v, 
                const Arcane::ItemGroup& group,
                EvaluationMode mode, 
                Arcane::Integer max_nb_unknowns) const 
  {
    GroupEnumerator g(group);
    switch(mode) {
      case eWithoutDerivative:
        m_evaluator(v,g);
        break;
      case eWithDerivative:
        m_deriv_evaluator(v,g,max_nb_unknowns);
        break;
      default:
        throw Arcane::FatalErrorException("Not implemented");
    }
  }

  //! Evaluation sans d�riv�e pour variables partielles sur le maillage
  void evaluate(const PartialVariableAccessor& v, 
                const Arcane::ItemGroup& group,
                EvaluationMode mode, 
                Arcane::Integer max_nb_unknowns) const 
  {
    GroupEnumerator g(group);
    switch(mode) {
      case eWithoutDerivative:
        m_evaluator(v,g);
        break;
      case eWithDerivative:
        m_deriv_evaluator(v,g,max_nb_unknowns);
        break;
      default:
        throw Arcane::FatalErrorException("Not implemented");
    }
  }

  //! Evaluation sans d�riv�e pour tableaux
  void evaluate(const ArrayAccessor& v,
                const Arcane::Integer& begin,
                const Arcane::Integer& end,
                EvaluationMode mode, 
                Arcane::Integer max_nb_unknowns) const 
  {
    RangeEnumerator g(begin, end);
    switch(mode) {
      case eWithoutDerivative:
        m_evaluator(v,g);
        break;
      case eWithDerivative:
        m_deriv_evaluator(v,g,max_nb_unknowns);
        break;
      default:
        throw Arcane::FatalErrorException("Not implemented");
    }
  }
  
  //! Evaluation sans d�riv�e pour scalaires
  void evaluate(const ScalarAccessor& v,
                EvaluationMode mode, 
                Arcane::Integer max_nb_unknowns) const
  {
    switch(mode) {
      case eWithoutDerivative:
        m_evaluator(v);
        break;
      case eWithDerivative:
        m_deriv_evaluator(v,max_nb_unknowns);
        break;
      default:
        throw Arcane::FatalErrorException("Not implemented");
    }
  }

  //! Propri�t�s in
  PropertyVector in() const { return m_signature.inProperties(); }

  //! Propri�t�s out
  PropertyVector out() const { return m_signature.outProperties(); }

  //! Parameters
  PropertyVector parameters() const { return m_signature.parameters(); }
  
private:
  
  //! Identifiant de la fonction
  Integer m_id;

  //! Fonction param�tre
  bool m_is_parameter;

  //! Algorithme utilisateur
  const T& m_algo;
  
  //! Signature de la fonction fournie par l'utilisateur
  const Signature m_signature;

  //! Evaluateurs de states et scalaires
  const StateEvaluator<T> m_state_evaluator;
  // NB: envoie un FataErrorException � l'�valuation si la fonction n'est pas d�rivable
  const DerivativeStateEvaluator<T,EvalFunctionTraits<T>::is_differentiable> m_deriv_state_evaluator;
  
  //! Evaluateurs de variables, variables partielles, tableaux
  const Evaluator<T> m_evaluator;
  // NB: envoie un FataErrorException � l'�valuation si la fonction n'est pas d�rivable
  const DerivativeEvaluator<T,EvalFunctionTraits<T>::is_differentiable> m_deriv_evaluator;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

END_LAW_NAMESPACE

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_PHYSICS_LAW_FUNCTION_H */
