// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#ifndef ARCGEOSIM_PHYSICS_GUMP_ENUMERATOR_H
#define ARCGEOSIM_PHYSICS_GUMP_ENUMERATOR_H
/* Author : desrozis at Mon Jun 29 16:05:37 2015
 * Generated by createNew
 */

#include <arcane/ArcaneVersion.h>
#include <arcane/utils/Math.h>
#include "ArcGeoSim/Physics/Gump/Iterator.h"

#include <type_traits>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace Gump {
  
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

template<typename T>
class EnumeratorT
{
public:

  class Selection
  {
  public:

    Selection(const EntityVector& all_entities)
      : m_all_entities(all_entities) {}

    inline void add(Arcane::Integer position)
    {
      m_entities.add(m_all_entities[position]);
    }

    inline void add(const Arcane::IntegerArray& position)
    {
      auto size = position.size();
      for (Arcane::Integer i = 0 ; i < size; ++i) {
        m_entities.add(m_all_entities[position[i]]);
      }
    }

    inline void add(const T& entity)
    {
      for(auto e : m_all_entities) {
        if(e->uniqueId() == entity.uniqueId()) {
          m_entities.add(e);
          return;
        }
      }
    }

    inline EnumeratorT<T> enumerator() const { return m_entities; }

  private:

    const EntityVector& m_all_entities;

    EntityVector m_entities;
  };

private:

  template<typename> friend class EnumeratorT;

public:

  EnumeratorT(const EntityVector& entities)
    : m_entities(entities)
    , m_size(static_cast<Arcane::Integer>(m_entities.size()))
    , m_index(0) {}

  EnumeratorT(const EnumeratorT<T>& e)
    : m_entities(e.m_entities)
    , m_size(e.m_size)
    , m_index(e.m_index) {}

  template<typename U>
  EnumeratorT(const EnumeratorT<U>& e)
    : EnumeratorT(e.m_entities)
  {
    static_assert(std::is_base_of<T,U>::value, "error : enumerator conversion not allowed");
  }

  inline void reset() { m_index = 0; }

  inline bool hasNext() const { return m_index != m_size; }

  inline void operator++() { m_index ++; }

  inline T operator*() const { return T(m_entities[m_index]); }

  inline T operator->() const { return T(m_entities[m_index]); }

  inline Arcane::Integer size() const { return m_size; }
  inline Arcane::Integer index() const { return m_index; }

  inline bool isLast() const { return m_index == m_size - 1; }

  inline Arcane::Integer searchIndex(const T& t)
  {
    for(Arcane::Integer i = 0; i < m_size; i++) {
      if(t.uniqueId() == m_entities[i]->uniqueId())
        return i;
    }
    return -1;
  }

  inline Selection selection() const
  {
    return m_entities;
  }

#if (ARCANE_VERSION >= 22200)
  inline IteratorT<T> begin() { return m_entities.begin().base(); }
  inline IteratorT<T> end()   { return m_entities.end().base(); }
  inline IteratorT<T> begin() const { return m_entities.begin().base(); }
  inline IteratorT<T> end()   const { return m_entities.end().base(); }
#else
  inline IteratorT<T> begin() { return m_entities.begin(); }
  inline IteratorT<T> end()   { return m_entities.end(); }
  inline IteratorT<T> begin() const { return m_entities.begin(); }
  inline IteratorT<T> end()   const { return m_entities.end(); }
#endif
  inline std::pair<IteratorT<T>, IteratorT<T>> range()
  {
    return std::make_pair(begin(), end());
  }

  inline std::pair<IteratorT<T>, IteratorT<T>> range() const
  {
    return std::make_pair(begin(), end());
  }

  inline Arcane::Integer maxFamilyId() const
  {
    Arcane::Integer id = 0;
    for(Arcane::Integer i = 0; i < m_entities.size(); ++i) {
      id = Arcane::math::max(id, m_entities[i]->familyId());
    }
    return id;
  }

protected:
  const EntityVector& m_entities;
  const Arcane::Integer m_size;
  Arcane::Integer m_index;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_PHYSICS_GUMP_ENUMERATOR_H */
