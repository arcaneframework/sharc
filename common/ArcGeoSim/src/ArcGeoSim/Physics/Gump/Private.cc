// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
#include "Private.h"
/* Author : desrozis at Mon Jun 29 16:05:37 2015
 * Generated by createNew
 */

#include "ArcGeoSim/Utils/MakeDelegatedPtr.h"

#include <algorithm>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace Gump {

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace Private {

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

Entity::
Entity(const Arcane::String& name,
       const Arcane::Integer kind,
       const Arcane::Integer tag,
       const Arcane::Integer number_of_entities,
       const Arcane::Integer number_of_entity_tags,
       const Arcane::Integer number_of_properties,
       const Arcane::Integer entity_unique_id)
  : m_name(name)
  , m_kind(kind)
  , m_tag(tag)
  , m_parent(nullptr)
  , m_entities(number_of_entities)
  , m_sorted_entities(number_of_entities)
  , m_tagged_entities(number_of_entities, number_of_entity_tags)
  , m_properties(number_of_properties)
  , m_unique_id(entity_unique_id)
  , m_family_id(0) {}

/*---------------------------------------------------------------------------*/

void
Entity::
push(Property* property)
{
  m_properties[property->kind()] = property;
  m_sorted_properties[property->name()] = property;
  m_defined_properties.add(property);
}

/*---------------------------------------------------------------------------*/

void Entity::push(Entity* entity)
{
  if(entity->m_parent == nullptr) {
    entity->m_parent = this;
  }
  m_pushed_entities.add(entity);
  _insert(entity);
  for(Arcane::Integer i = 0; i < entity->m_entities.size(); ++i)
    for(Arcane::Integer j = 0; j < entity->m_entities[i].size(); ++j)
      _insert(entity->m_entities[i][j]);
  for(Arcane::Integer i = 0; i < m_entities.size(); ++i)
    for(Arcane::Integer j = 0; j < m_entities[i].size(); ++j)
      _updateFamilyId(m_entities[i][j]);
}

/*---------------------------------------------------------------------------*/

void
Entity::
_insert(Entity* entity)
{
  auto it = std::find(m_entities[entity->kind()].begin(),
                      m_entities[entity->kind()].end(),
                      entity);
  if(it == m_entities[entity->kind()].end()) {
    m_entities[entity->kind()].add(entity);
    m_sorted_entities[entity->kind()][entity->name()] = entity;
    if(entity->tag() != -1) {
      m_tagged_entities[entity->kind()][entity->tag()].add(entity);
    }
  }
  if(m_parent != NULL) m_parent->_insert(entity);
}
  
/*---------------------------------------------------------------------------*/

void
Entity::
_updateFamilyId(Entity* entity)
{
  auto* root = entity;
  while(root->m_parent != nullptr) {
    root = root->m_parent;
  }

  auto it = std::find(root->m_entities[entity->kind()].begin(),
                      root->m_entities[entity->kind()].end(),
                      entity);
  if(it == root->m_entities[entity->kind()].end())
    throw Arcane::FatalErrorException("ERROR ENTITY NOT IN ROOT");
  for(Arcane::Integer i = 0; i < root->m_entities[entity->kind()].size(); ++i)
    if(root->m_entities[entity->kind()][i] == entity) {
      entity->m_family_id = i;
    }
}

/*---------------------------------------------------------------------------*/

Entity*
Entity::
root() const
{
  if(m_parent != nullptr) {
    auto* root = m_parent;
    while(root->m_parent != nullptr) {
      root = root->m_parent;
    }
    return root;
  } else
    return m_parent;
}

/*---------------------------------------------------------------------------*/

void 
Entity::
kill()
{
  for(auto* e : m_pushed_entities) 
    delete e;
  for(auto* p : m_defined_properties)
    delete p;
}

/*---------------------------------------------------------------------------*/

Property::
Property()
  : m_kind(-1)
  , m_index(-1)
  , m_owner(nullptr)
  , m_name("Undefined")
  , m_full_name("Undefined")
  , m_dimension(eUndefined)
  , m_data_type(Arcane::DT_Unknown)
  , m_size(0) {}

/*---------------------------------------------------------------------------*/

Property::
Property(Arcane::String name,
         Arcane::Integer kind,
         Arcane::Integer property_unique_id,
         Entity* owner,
         Dimension dimension,
         Arcane::eDataType data_type,
         Arcane::Integer size)
  : m_kind(kind)
  , m_index(property_unique_id)
  , m_owner(owner)
  , m_name(name)
  , m_full_name(Arcane::String::format("{0}_{1}", m_name, m_owner->name()))
  , m_dimension(dimension)
  , m_data_type(data_type)
  , m_size(size)
{
  ARCANE_ASSERT((m_dimension != eUndefined),("Dimension is undefined"));
  ARCANE_ASSERT((m_data_type != Arcane::DT_Unknown),("Data type is unknown"));
  ARCANE_ASSERT((m_size > 0),("Size must be greater than one"));
}

/*---------------------------------------------------------------------------*/

Property::
Property(Arcane::String name,
         Arcane::Integer property_unique_id,
         Dimension dimension,
         Arcane::eDataType data_type,
         Arcane::Integer size)
  : m_kind(-1)
  , m_index(property_unique_id)
  , m_owner(nullptr)
  , m_name(name)
  , m_full_name(name)
  , m_dimension(dimension)
  , m_data_type(data_type)
  , m_size(size) {}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
