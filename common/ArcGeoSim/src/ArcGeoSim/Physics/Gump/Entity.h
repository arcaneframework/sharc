// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#ifndef ARCGEOSIM_PHYSICS_GUMP_ENTITY_H
#define ARCGEOSIM_PHYSICS_GUMP_ENTITY_H
/* Author : desrozis at Mon Jun 29 16:05:37 2015
 * Generated by createNew
 */

#include "ArcGeoSim/Physics/Gump/Enumerator.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace Gump {

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class Enumerator;

class Entity
{
public:

  class Coefficients
  {
  public:

    Coefficients(Private::Entity* entity)
      : m_entity(entity) {}

    Arcane::Real operator[](const Entity& e) const
    {
      return m_entity->values().find(e.m_private)->second;
    }

   private:

    Private::Entity* m_entity;
  };


public:

  Entity()
    : m_private(nullptr) {}

  Entity(const Entity& entity)
    : m_private(entity.m_private) {}

  Entity(Private::Entity* entity)
    : m_private(entity) {}

public:

  bool empty() const
  {
    return m_private == nullptr;
  }

  const Arcane::String& name() const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->name();
  }

  Arcane::Integer kind() const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->kind();
  }

  Arcane::Integer tag() const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->tag();
  }

  bool is(Arcane::Integer T) const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->is(T);
  }

  bool operator==(const Entity& entity) const
  {
    return m_private == entity.m_private;
  }
  bool operator!=(const Entity& entity) const
  {
    return m_private != entity.m_private;
  }
  bool operator<(const Entity& entity) const
  {
    return m_private < entity.m_private;
  }

  Entity entity(Arcane::String name, Arcane::Integer K) const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->entity(name,K);
  }

  bool contains(Arcane::String name, Arcane::Integer K) const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->contains(name,K);
  }

  Arcane::Integer numberOf(Arcane::Integer K) const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->numberOf(K);
  }

  Entity entity(Arcane::Integer i, Arcane::Integer K) const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->entity(i, K);
  }

  Arcane::Integer numberOfProperties() const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->numberOfProperties();
  }

  Private::Property* property(Arcane::Integer K) const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->property(K);
  }

  Arcane::Integer propertyKind(Arcane::Integer i) const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->propertyKind(i);
  }

  EnumeratorT<Entity> entities(Arcane::Integer K) const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->entities(K);
  }

  EnumeratorT<Entity> entities() const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->entities();
  }

  EnumeratorT<Entity> entities(Arcane::Integer K, Arcane::Integer T) const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->entities(K, T);
  }

  Arcane::Integer uniqueId() const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->uniqueId();
  }

  Arcane::Integer familyId() const
  {
    ARCANE_ASSERT((not empty()),("entity is empty"));
    return m_private->familyId();
  }

  Arcane::Real value(const Entity& entity) const
  {
    return m_private->values()[entity.m_private];
  }

  Coefficients coefficients() const
  {
    return m_private;
  }

  Gump::Entity root() const
  {
    auto* root = m_private->root();

    return root != nullptr ? root : m_private;
  }

  const Entity* operator->() const { return this; }

  // Detruit les entites et proprietes internes
  void kill()
  { 
    if(m_private != nullptr) {
      m_private->kill();
      delete m_private; 
    }
  }

protected:

  Private::Entity* m_private;

  friend class Factory;
};

// Classe utilisee par le modele de donnees genere
// Permet de faciliter l'utilisation de templates
// Pattern CRTP
template<typename T>
class EntityT
  : public Entity
{
public:

  EntityT() {}

  EntityT(const Entity& entity)
    : Entity(entity) {}

  EntityT(Private::Entity* entity)
    : Entity(entity) {}

  T& cast() { return static_cast<T&>(*this); }

  const T& cast() const { return static_cast<const T&>(*this); }
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#endif /* ARCGEOSIM_PHYSICS_GUMP_ENTITY_H */
