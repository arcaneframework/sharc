// -*- C++ -*-
/* Author : desrozis at Tue Mar  5 13:03:11 2013
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "ArcGeoSim/Utils/ArcGeoSim.h"
#include "ArcGeoSim/Tests/ServiceTesters/IServiceTester.h"

#ifdef USE_ALIEN_V1
#include <ALIEN/Alien-IFPEN.h>
#include <ArcGeoSim/Numerics/AlienTools/BasicIndexManager.h>
#include "ArcGeoSim/Numerics/AlienTools/BlockBuilder.h"
#endif

#ifdef USE_ALIEN_V2
#include <alien/ref/AlienRefSemantic.h>
#include <alien/arcane_tools/IIndexManager.h>
#include <alien/arcane_tools/indexManager/BasicIndexManager.h>
#include <alien/arcane_tools/data/Space.h>
#include <alien/expression/solver/ILinearSolver.h>
#include <alien/kernels/simple_csr/algebra/SimpleCSRLinearAlgebra.h>

#include <alien/arcane_tools/accessors/ItemVectorAccessor.h>

#include <alien/arcane_tools/indexManager/SimpleAbstractFamily.h>
#include <alien/arcane_tools/distribution/DistributionFabric.h>
#include <alien/arcane_tools/block/BlockBuilder.h>
#include <alien/arcane_tools/block/BlockSizes.h>

#include <alien/expression/normalization/NormalizeOpt.h>
#endif

#include "LinearAlgebra2VBlockTester_axl.h"

#include <arcane/ItemPairGroup.h>
#include <arcane/IMesh.h>
#include <arcane/IItemFamily.h>
#include <arcane/random/Uniform01.h>
#include <arcane/random/LinearCongruential.h>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace ArcGeoSim::Numerics;

/*---------------------------------------------------------------------------*/

class LinearAlgebra2VBlockTesterService 
    : public ArcaneLinearAlgebra2VBlockTesterObject
{
public:

  typedef Alien::VBlockMatrix MatrixType;
  typedef Alien::VBlockVector VectorType;

  LinearAlgebra2VBlockTesterService(const Arcane::ServiceBuildInfo & sbi) 
  : ArcaneLinearAlgebra2VBlockTesterObject(sbi)
  , m_uniform(m_generator) {}

  ~LinearAlgebra2VBlockTesterService() {}

public:

  void init();

  Integer test();

private:

  Real _compute_point_space_and_builder();
  Real _compute_block_space_and_builder();

private:

  Real m_diag_coeff = 0.;

  Arcane::CellGroup m_areaP;
  Arcane::CellGroup m_areaT;

  // G�n�rateur de nombres al�atoires
  Arcane::random::MinstdRand m_generator;
  mutable Arcane::random::Uniform01<Arcane::random::MinstdRand> m_uniform;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
LinearAlgebra2VBlockTesterService::
init()
{

  Alien::setTraceMng(traceMng());
  Alien::setVerbosityLevel(Alien::Verbosity::Debug);

  m_diag_coeff = options()->diagonalCoefficient();

  options()->linearSolver()->init();

  m_areaT = allCells();

  m_split.fill(0);

  ENUMERATE_CELL(icell, m_areaT.own()) {
    if(m_uniform() < 0.9) {
      m_split[icell] = 1;
    }
  }

  m_split.synchronize();

  {
    IntegerSharedArray areaP_lids;
    areaP_lids.reserve(m_areaT.size());

    ENUMERATE_CELL(icell, m_areaT) {
      if(m_split[icell] == 1) 
        areaP_lids.add(icell->localId()); 
    }

    m_areaP = mesh()->cellFamily()->createGroup("AreaP",areaP_lids);
  }

  m_P.fill(0);
  ENUMERATE_CELL(icell, m_areaP) m_P[icell] = 1.;

  m_T.fill(0);
  ENUMERATE_CELL(icell, m_areaT) m_T[icell] = 1.;

  m_split.fill(0);
  ENUMERATE_CELL(icell, m_areaP) m_split[icell] = 1;
}

/*---------------------------------------------------------------------------*/

Integer
LinearAlgebra2VBlockTesterService::
test()
{
  const Real v = _compute_point_space_and_builder();
  const Real u = _compute_block_space_and_builder();

  if(Arcane::math::abs(u - v) > 1.e-6) return 0;
  else return 1;
}
/*---------------------------------------------------------------------------*/

Real 
LinearAlgebra2VBlockTesterService::
_compute_point_space_and_builder()
{

#ifdef USE_ALIEN_V1
  Alien::BasicIndexManager index_manager(subDomain()->parallelMng());

  auto indexSetP  = index_manager.buildScalarIndexSet("P" , m_areaP);
  auto indexSetS1 = index_manager.buildScalarIndexSet("S1", m_areaP);
  auto indexSetS2 = index_manager.buildScalarIndexSet("S2", m_areaP);
  auto indexSetT  = index_manager.buildScalarIndexSet("T" , m_areaT);

  index_manager.prepare();
  auto global_size = index_manager.globalSize();
  auto local_size = index_manager.localSize();
  Alien::Space space(global_size, "TestSpace");

  Alien::MatrixDistribution mdist(space, space, local_size, subDomain()->parallelMng());
  Alien::VectorDistribution vdist(space, local_size, subDomain()->parallelMng());

  Alien::Matrix matrixA(mdist);
  Alien::Vector vectorB(vdist);
  Alien::Vector vectorX(vdist);
#endif

#ifdef USE_ALIEN_V2
    Alien::ArcaneTools::BasicIndexManager index_manager(subDomain()->parallelMng());

    auto indexSetP  = index_manager.buildScalarIndexSet("P" , m_areaP);
    auto indexSetS1 = index_manager.buildScalarIndexSet("S1", m_areaP);
    auto indexSetS2 = index_manager.buildScalarIndexSet("S2", m_areaP);
    auto indexSetT  = index_manager.buildScalarIndexSet("T" , m_areaT);


    index_manager.prepare();
    auto space = Alien::ArcaneTools::Space(&index_manager, "TestSpace");

    auto mdist = Alien::ArcaneTools::createMatrixDistribution(space);
    auto vdist = Alien::ArcaneTools::createVectorDistribution(space);
    auto matrixA = Alien::Matrix(mdist);
    auto vectorB = Alien::Vector(vdist);
    auto vectorX = Alien::Vector(vdist);
#endif

  IntegerSharedArray allPIndex  = index_manager.getIndexes(indexSetP);
  IntegerSharedArray allTIndex  = index_manager.getIndexes(indexSetT);
  IntegerSharedArray allS1Index = index_manager.getIndexes(indexSetS1);
  IntegerSharedArray allS2Index = index_manager.getIndexes(indexSetS2);

  {   
#if defined (USE_ALIEN_V1) || (USE_ALIEN_V2)
    Alien::VectorWriter b(vectorB);
    Alien::VectorWriter x(vectorX);
#endif
    ENUMERATE_CELL(icell, m_areaT.own()) {
      const Integer id = allTIndex[icell->localId()];
      b[id] = 1.;
      x[id] = 1.;
    }

    ENUMERATE_CELL(icell, m_areaP.own()) {
      const Integer id_p = allPIndex[icell->localId()];
      const Integer id_s1 = allS1Index[icell->localId()];
      const Integer id_s2 = allS2Index[icell->localId()];
      b[id_p] = 1.;
      b[id_s1] = 1.;
      b[id_s2] = 1.;
      x[id_p] = 1.;
      x[id_s1] = 1.;
      x[id_s2] = 1.;
    }
  }
  {
    Alien::StreamMatrixBuilder builder(matrixA);

    {
      Arcane::CellCellGroup T_connection(m_areaT.own(), m_areaT, Arcane::IK_Face);

      Alien::StreamMatrixBuilder::Profiler& inserter = builder.getNewInserter();

      ENUMERATE_ITEMPAIR(Cell, Cell, icell, T_connection) {
        const Cell cell = *icell;
        const Integer id_i = allTIndex[cell.localId()]; 
        inserter.addMatrixEntry(id_i,id_i);
        ENUMERATE_SUB_ITEM(Cell, isubcell, icell) {
          const Integer id_j = allTIndex[isubcell->localId()]; 
          inserter.addMatrixEntry(id_i,id_j);
        }
      }

      Arcane::CellCellGroup P_connection(m_areaP.own(), m_areaP, Arcane::IK_Face);

      ENUMERATE_ITEMPAIR(Cell, Cell, icell, P_connection) {
        const Cell cell = *icell;
        const Integer id_i = allPIndex[cell.localId()]; 
        inserter.addMatrixEntry(id_i,id_i);
        ENUMERATE_SUB_ITEM(Cell, isubcell, icell) {
          const Integer id_j = allPIndex[isubcell->localId()]; 
          inserter.addMatrixEntry(id_i,id_j);
        }
      }

      ENUMERATE_CELL(icell, m_areaP.own()) {
        const Integer id_i = allS1Index[icell->localId()];
        inserter.addMatrixEntry(id_i,id_i);
        const Integer id_j = allS2Index[icell->localId()];
        inserter.addMatrixEntry(id_j,id_i);
        inserter.addMatrixEntry(id_j,id_j);
      }

      builder.allocate();
    }

    builder.fillZero();
    {
      Arcane::CellCellGroup T_connection(m_areaT.own(), m_areaT, Arcane::IK_Face);

      Alien::StreamMatrixBuilder::Filler& inserter = builder.getInserter(0);

      inserter.start();

      ENUMERATE_ITEMPAIR(Cell, Cell, icell, T_connection) {
        inserter.addData(m_diag_coeff);
        ++inserter;
        ENUMERATE_SUB_ITEM(Cell, isubcell, icell) {
          inserter.addData(1.);
          ++inserter;
        }
      }

      Arcane::CellCellGroup P_connection(m_areaP.own(), m_areaP, Arcane::IK_Face);

      ENUMERATE_ITEMPAIR(Cell, Cell, icell, P_connection) {
        inserter.addData(m_diag_coeff);
        ++inserter;
        ENUMERATE_SUB_ITEM(Cell, isubcell, icell) {
          inserter.addData(1.);
          ++inserter;
        }
      }

      ENUMERATE_CELL(icell, m_areaP.own()) {
        inserter.addData(1.); 
        ++inserter;
        inserter.addData(1.);
        ++inserter;
        inserter.addData(1.);
        ++inserter;
      }
    }
    builder.finalize() ;
  }

  auto* solver = options()->linearSolver();
#if defined (USE_ALIEN_V1) || (USE_ALIEN_V2)
  std::shared_ptr<Alien::ILinearAlgebra> alg = solver->algebra();
#endif
  Real norm =0.;
  if(alg)
  {
#if defined (USE_ALIEN_V1) || (USE_ALIEN_V2)
    Alien::Vector vectorY(vdist);
    Alien::Vector vectorRes(vdist);
#else
    VectorType vectorY(space);
    VectorType vectorRes(space);
#endif
    alg->mult(matrixA, vectorX, vectorY);

    // res = b - A.x
    alg->copy(vectorB, vectorRes);
    alg->axpy(-1., vectorY, vectorRes);

    norm = alg->norm2(vectorRes);
    info() << "Residual norm2 by solver linear algebra : " << norm;
  }

  {
#if defined (USE_ALIEN_V1) || (USE_ALIEN_V2)
    Alien::SimpleCSRLinearAlgebra testAlg;
    Alien::Vector vectorY(vdist);
    Alien::Vector vectorRes(vdist);
#endif

    testAlg.mult(matrixA, vectorX, vectorY);
    // res = b - A.x
    testAlg.copy(vectorB, vectorRes);
    testAlg.axpy(-1., vectorY, vectorRes);
    norm = testAlg.norm2(vectorRes);
    info() << "Residual norm2 by SimpleCSR algebra : " << norm;
  }

  return norm;
}

/*---------------------------------------------------------------------------*/

Real 
LinearAlgebra2VBlockTesterService::
_compute_block_space_and_builder()
{

  info()<<" Block Space Builder";

#if defined (USE_ALIEN_V1)
  Alien::BasicIndexManager index_manager(subDomain()->parallelMng());

  auto indexSetX = index_manager.buildScalarIndexSet("X" , allCells());

  index_manager.prepare() ;

  auto global_size = index_manager.globalSize();
  auto local_size = index_manager.localSize();
  Alien::Space space(global_size, "TestSpace");

  Alien::MatrixDistribution mdist(space, space, local_size, subDomain()->parallelMng());
  Alien::VectorDistribution vdist(space, local_size, subDomain()->parallelMng());

  Alien::BlockBuilder block_builder(index_manager);
#endif


#if defined (USE_ALIEN_V2)
  Alien::ArcaneTools::BasicIndexManager index_manager(subDomain()->parallelMng());

  auto indexSetX = index_manager.buildScalarIndexSet("X" , allCells());

  index_manager.prepare() ;

  auto space = Alien::ArcaneTools::Space(&index_manager, "TestSpace");

  auto mdist = Alien::ArcaneTools::createMatrixDistribution(space);
  auto vdist = Alien::ArcaneTools::createVectorDistribution(space);

  //Alien::ArcaneTools::IndexManagerBlockBuilder block_builder(index_manager,vdist);
  Alien::ArcaneTools::BlockBuilder block_builder(index_manager);
#endif

  IntegerSharedArray allXIndex = index_manager.getIndexes(indexSetX);

  //block_builder[allXIndex.sample(m_areaT.own().view().localIds())]  = 1;
  //block_builder[allXIndex.sample(m_areaP.own().view().localIds())] += 3;

{
    auto areaT_lids = m_areaT.own().view().localIds();
    UniqueArray<Integer> sample_areaT_lids(areaT_lids.size());
    allXIndex.sample(areaT_lids, sample_areaT_lids);
    block_builder[sample_areaT_lids]  = 1;
  }
  {
    auto areaP_lids = m_areaP.own().view().localIds();
    UniqueArray<Integer> sample_areaP_lids(areaP_lids.size());
    allXIndex.sample(areaP_lids, sample_areaP_lids);
    block_builder[sample_areaP_lids] += 3;
  }

  Alien::VBlock block(block_builder.sizes());

  MatrixType matrixA(block,mdist);
  VectorType vectorB(block,vdist);
  VectorType vectorX(block,vdist);


  {
#if defined (USE_ALIEN_V1) || (USE_ALIEN_V2)
    Alien::VBlockVectorWriter b(vectorB);
    Alien::VBlockVectorWriter x(vectorX);
#endif
    ENUMERATE_CELL(icell, m_areaT.own()) {
      const Integer id = allXIndex[icell->localId()];
      b[id][0] = 1.;
      x[id][0] = 1.;
    }

    ENUMERATE_CELL(icell, m_areaP.own()) {
      const Integer id = allXIndex[icell->localId()];
      b[id][1] = 1.;
      b[id][2] = 1.;
      b[id][3] = 1.;
      x[id][1] = 1.;
      x[id][2] = 1.;
      x[id][3] = 1.;
    }
  }

#if defined (USE_ALIEN_V1) || (USE_ALIEN_V2)
  const Alien::VBlock& block_sizes = matrixA.vblock();
#else
  const Alien::BlockSizes& block_sizes = space.variableBlockSizes();
#endif
  {
#if defined (USE_ALIEN_V1) || (USE_ALIEN_V2)
    Alien::StreamVBlockMatrixBuilder builder(matrixA);
#endif
    {
      info()<<"DEFINE PROFILE MATRIX";

      Arcane::CellCellGroup T_connection(m_areaT.own(), m_areaT, Arcane::IK_Face);

#if defined (USE_ALIEN_V1) || (USE_ALIEN_V2)
      Alien::StreamVBlockMatrixBuilder::Profiler& inserter = builder.getNewInserter();
#endif
      ENUMERATE_ITEMPAIR(Cell, Cell, icell, T_connection) {
        const Cell cell = *icell;
        const Integer id_i = allXIndex[cell.localId()];
        inserter.addMatrixEntry(id_i,id_i);
        ENUMERATE_SUB_ITEM(Cell, isubcell, icell) {
          const Integer id_j = allXIndex[isubcell->localId()];
          inserter.addMatrixEntry(id_i,id_j);
        }
      }

      Arcane::CellCellGroup P_connection(m_areaP.own(), m_areaP, Arcane::IK_Face);

      ENUMERATE_ITEMPAIR(Cell, Cell, icell, P_connection) {
        const Cell cell = *icell;
        const Integer id_i = allXIndex[cell.localId()];
        inserter.addMatrixEntry(id_i,id_i);
        ENUMERATE_SUB_ITEM(Cell, isubcell, icell) {
          const Integer id_j = allXIndex[isubcell->localId()];
          inserter.addMatrixEntry(id_i,id_j);
        }
      }

      ENUMERATE_CELL(icell, m_areaP.own()) {
        const Integer id = allXIndex[icell->localId()];
        inserter.addMatrixEntry(id,id);
      }

      builder.allocate();
    }

    builder.fillZero();
    {
      info()<<"FILL MATRIX";

      Arcane::CellCellGroup T_connection(m_areaT.own(), m_areaT, Arcane::IK_Face);

#if defined (USE_ALIEN_V1) || (USE_ALIEN_V2)
     Alien::StreamVBlockMatrixBuilder::Filler& inserter = builder.getInserter(0);
#endif
      inserter.start();

      RealSharedArray2 diag(4,4);

      ENUMERATE_ITEMPAIR(Cell, Cell, icell, T_connection) {
        const Cell cell = *icell;
        const Integer id_i = allXIndex[cell.localId()];
        const Integer size_i = block_sizes.size(id_i);
        diag.resize(size_i,size_i);
        diag.fill(0.);
        diag[0][0] = m_diag_coeff;
        inserter.addBlockData(diag);
        ++inserter;
        ENUMERATE_SUB_ITEM(Cell, isubcell, icell) {
          const Integer id_j = allXIndex[isubcell->localId()];
          const Integer size_j = block_sizes.size(id_j);
          diag.resize(size_i,size_j);
          diag.fill(0.);
          diag[0][0] = 1.;
          inserter.addBlockData(diag);
          ++inserter;
        }
      }

      Arcane::CellCellGroup P_connection(m_areaP.own(), m_areaP, Arcane::IK_Face);

      ENUMERATE_ITEMPAIR(Cell, Cell, icell, P_connection) {
        diag.resize(4,4);
        diag.fill(0);
        diag[1][1] = m_diag_coeff;
        inserter.addBlockData(diag);
        ++inserter;
        ENUMERATE_SUB_ITEM(Cell, isubcell, icell) {
          const Integer id_j = allXIndex[isubcell->localId()];
          const Integer size_j = block_sizes.size(id_j);
          diag.resize(4,size_j);
          diag.fill(0.);
          diag[1][1] = 1.;
          inserter.addBlockData(diag);
          ++inserter;
        }
      }

      diag.fill(0);

      ENUMERATE_CELL(icell, m_areaP.own()) {
        diag[2][2] = 1.;
        diag[2][3] = 1.;
        diag[3][3] = 1.;
        inserter.addBlockData(diag);
        ++inserter;
      }
    }
#if defined (USE_ALIEN_V1) || (USE_ALIEN_V2)
    builder.finalize();
#endif
  }

//   {
//     Alien::StreamBlockMatrixBuilder builder(matrixA);

//     {
//       Arcane::CellCellGroup T_connection(m_areaT.own(), m_areaT, Arcane::IK_Face);

//       Alien::StreamBlockMatrixBuilder::Profiler& inserter = builder.getNewInserter();

//       ENUMERATE_ITEMPAIR(Cell, Cell, icell, T_connection) {
//         const Cell cell = *icell;
//         const Integer id_i = allXIndex[cell.localId()];
//         inserter.addMatrixEntry(id_i,id_i);
//         ENUMERATE_SUB_ITEM(Cell, isubcell, icell) {
//           const Integer id_j = allXIndex[isubcell->localId()];
//           inserter.addMatrixEntry(id_i,id_j);
//         }
//       }

//       Arcane::CellCellGroup P_connection(m_areaP.own(), m_areaP, Arcane::IK_Face);

//       ENUMERATE_ITEMPAIR(Cell, Cell, icell, P_connection) {
//         const Cell cell = *icell;
//         const Integer id_i = allXIndex[cell.localId()];
//         inserter.addMatrixEntry(id_i,id_i);
//         ENUMERATE_SUB_ITEM(Cell, isubcell, icell) {
//           const Integer id_j = allXIndex[isubcell->localId()];
//           inserter.addMatrixEntry(id_i,id_j);
//         }
//       }

//       ENUMERATE_CELL(icell, m_areaP.own()) {
//         const Integer id = allXIndex[icell->localId()];
//         inserter.addMatrixEntry(id,id);
//       }

//       builder.allocate();
//     }

//     builder.fillZero();
//     {
//       Arcane::CellCellGroup T_connection(m_areaT.own(), m_areaT, Arcane::IK_Face);

//       Alien::StreamBlockMatrixBuilder::Filler& inserter = builder.getInserter(0);

//       inserter.start();

//       RealArray2 diag(4,4);

//       ENUMERATE_ITEMPAIR(Cell, Cell, icell, T_connection) {
//         const Cell cell = *icell;
//         const Integer id_i = allXIndex[cell.localId()];
//         const Integer size_i = block_mng[id_i];
//         diag.resize(size_i,size_i);
//         diag.fill(0.);
//         diag[0][0] = m_diag_coeff;
//         inserter.addBlockData(diag);
//         ++inserter;
//         ENUMERATE_SUB_ITEM(Cell, isubcell, icell) {
//           const Integer id_j = allXIndex[isubcell->localId()];
//           const Integer size_j = block_mng[id_j];
//           diag.resize(size_i,size_j);
//           diag.fill(0.);
//           diag[0][0] = 1.;
//           inserter.addBlockData(diag);
//           ++inserter;
//         }
//       }

//       Arcane::CellCellGroup P_connection(m_areaP.own(), m_areaP, Arcane::IK_Face);

//       ENUMERATE_ITEMPAIR(Cell, Cell, icell, P_connection) {
//         diag.resize(4,4);
//         diag.fill(0);
//         diag[1][1] = m_diag_coeff;
//         inserter.addBlockData(diag);
//         ++inserter;
//         ENUMERATE_SUB_ITEM(Cell, isubcell, icell) {
//           const Integer id_j = allXIndex[isubcell->localId()];
//           const Integer size_j = block_mng[id_j];
//           diag.resize(4,size_j);
//           diag.fill(0.);
//           diag[1][1] = 1.;
//           inserter.addBlockData(diag);
//           ++inserter;
//         }
//       }

//       diag.fill(0);

//       ENUMERATE_CELL(icell, m_areaP.own()) {
//         diag[2][2] = 1.;
//         diag[2][3] = 1.;
//         diag[3][3] = 1.;
//         inserter.addBlockData(diag);
//         ++inserter;
//       }
//     }
//   }

  Real norm = 0.;
  {
#if defined (USE_ALIEN_V1) || (USE_ALIEN_V2)
    Alien::SimpleCSRLinearAlgebra testAlg;
    VectorType vectorY(block,vdist);
    VectorType vectorRes(block,vdist);
#endif
    testAlg.mult(matrixA, vectorX, vectorY);
    // res = b - A.x
    testAlg.copy(vectorB, vectorRes);
    testAlg.axpy(-1., vectorY, vectorRes);
    norm = testAlg.norm2(vectorRes);
    info() << "Residual norm2 by VBlockCSR algebra : " << norm;
  }

  return norm;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_LINEARALGEBRA2VBLOCKTESTER(LinearAlgebra2VBlockTester,LinearAlgebra2VBlockTesterService);
