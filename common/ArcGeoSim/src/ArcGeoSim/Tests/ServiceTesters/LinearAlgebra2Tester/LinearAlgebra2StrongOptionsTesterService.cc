/* Author : gratienj at Thu Aug  3 10:16:59 2008
 * Generated by createNew
 */

#include "ArcGeoSim/Tests/ServiceTesters/IServiceTester.h"

#include "ArcGeoSim/Tests/ServiceTesters/LinearAlgebra2Tester/LinearAlgebra2TestOptionTypes.h"

#include <ALIEN/Alien-IFPEN.h>

#include <ALIEN/Kernels/PETSc/LinearSolver/Arcane/PETScLinearSolverService.h>
// preconditionner
#include <ALIEN/Kernels/PETSc/LinearSolver/Arcane/PETScPrecConfigJacobiService.h>
#include <ALIEN/axl/PETScPrecConfigJacobi_StrongOptions.h>
// solver
#include <ALIEN/Kernels/PETSc/LinearSolver/Arcane/PETScSolverConfigBiCGStabService.h>
#include <ALIEN/axl/PETScSolverConfigBiCGStab_StrongOptions.h>
#include <ALIEN/Kernels/PETSc/LinearSolver/Arcane/PETScSolverConfigGMRESService.h>
#include <ALIEN/axl/PETScSolverConfigGMRES_StrongOptions.h>
// root linear solver instance
#include <ALIEN/axl/PETScLinearSolver_StrongOptions.h>
#ifdef USE_PETSC
#include <ALIEN/Kernels/PETSc/IO/AsciiDumper.h>
#include <ALIEN/Kernels/PETSc/Algebra/PETScLinearAlgebra.h>
#endif
#include "ArcGeoSim/Numerics/AlienTools/BasicIndexManager.h"

#include "LinearAlgebra2StrongOptionsTester_axl.h"

#include <arcane/ItemPairGroup.h>

#include <boost/shared_ptr.hpp>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/


class LinearAlgebra2StrongOptionsTesterService :
  public ArcaneLinearAlgebra2StrongOptionsTesterObject
{
public:
  typedef Alien::BlockMatrix MatrixType;
  typedef Alien::BlockVector VectorType;

  LinearAlgebra2StrongOptionsTesterService(const Arcane::ServiceBuildInfo & sbi)
    : ArcaneLinearAlgebra2StrongOptionsTesterObject(sbi)
    , m_diag_coeff(0.) {}

  ~LinearAlgebra2StrongOptionsTesterService() {
  }

public:

  //! Initialization

  void init();

  //! Run the test
  int test();

private:
  // Strong Options with alien part
  void _createStrongSolverPETScBiCGStabJacobi();
  void _switchFromBiCGStabToGMRES();
  void _switchToInitialBiCGStab();
  bool _test(MatrixType& matrixA, VectorType& vectorB, VectorType& vectorX);
  bool _testRelaxEpsilon(MatrixType& matrixA, VectorType& vectorB, VectorType& vectorX);
  bool _testIncreaseDT(MatrixType& matrixA, VectorType& vectorB, VectorType& vectorX);
  bool _testChangeSolver(MatrixType& matrixA, VectorType& vectorB, VectorType& vectorX);
  // End Strong Options with alien part
  //
  // alien classical part
  void _buildWithStream(Arcane::IntegerConstArrayView allUIndex,
                        Alien::Space& space,
                        MatrixType& matrixA,
                        VectorType& vectorB,
                        VectorType& vectorX);

  void _buildWithProfiled(Arcane::IntegerConstArrayView allUIndex,
                          Alien::Space& space,
                          MatrixType& matrixA,
                          VectorType& vectorB,
                          VectorType& vectorX);
  void _reinit(VectorType& vectorX);

  Arcane::Real fij(const Arcane::Cell & ci, const Arcane::Cell & cj)
  {
    if (ci == cj)
      return m_diag_coeff;
    else
      return -1;
  }
  // End Strong Options with alien part
private:

  Arcane::Real m_diag_coeff;
  IParallelMng* m_parallel_mng = subDomain()->parallelMng();
  std::unique_ptr<Alien::ILinearSolver> m_solver;
  // pour test changement de solveur (acces au setter)
  std::shared_ptr<StrongOptionsPETScLinearSolver> m_options_petsc_solver;
  // Pour test changement tolerance et nombre d'iteration (acces aux setter)
  std::shared_ptr<StrongOptionsPETScSolverConfigBiCGStab>  m_options_solver_bicgs;

};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void LinearAlgebra2StrongOptionsTesterService::init()
{
  m_diag_coeff = options()->diagonalCoefficient();
  // solver parameter numerical data from .arc file
  m_parallel_mng = subDomain()->parallelMng();
  // create PETSc strong options instance (solver BiCGStab, preconditionner Jacobi)
  _createStrongSolverPETScBiCGStabJacobi();
  m_solver->init();
}

void LinearAlgebra2StrongOptionsTesterService::
_createStrongSolverPETScBiCGStabJacobi()
{
  //
  // A - Preconditionner eq jacobi alias block-ilu0 alias ilu0
  // 1 - options
  auto  options_prec = std::make_shared<StrongOptionsPETScPrecConfigJacobi>();
  // 2 - service
  auto  service_prec = std::make_shared<Alien::PETScPrecConfigJacobiService>(m_parallel_mng, options_prec);
  // B - BiCGStab solver
  // 1 - options
  using namespace PETScSolverConfigBiCGStabOptionsNames;
  m_options_solver_bicgs = std::make_shared<StrongOptionsPETScSolverConfigBiCGStab>(
    _numIterationsMax = options()->solverParameters.numIterationsMax,
    _stopCriteriaValue = options()->solverParameters.stopCriteriaValue,
    _preconditioner =  service_prec
  );
  // 2 - service
  auto service_solver_bicgs = std::make_shared<Alien::PETScSolverConfigBiCGStabService>(m_parallel_mng, m_options_solver_bicgs);
  // C - PETSc root service
  Arcane::String verbose_str = options()->solverParameters.verbose;
  auto verbose_enum = OptionsPETScLinearSolverUtils::stringToVerboseEnum(verbose_str.localstr());
  // 1 - options
  using namespace PETScLinearSolverOptionsNames;
  m_options_petsc_solver =  std::make_shared<StrongOptionsPETScLinearSolver>(
    _verbose = verbose_enum,
    _solver = service_solver_bicgs
  );
  // 2 - service
  m_solver = std::unique_ptr<Alien::ILinearSolver>(new Alien::PETScLinearSolverService(m_parallel_mng, m_options_petsc_solver));
}

void
LinearAlgebra2StrongOptionsTesterService::
_switchFromBiCGStabToGMRES()
{
  using namespace PETScSolverConfigGMRESOptionsNames;
  auto options_solver_gmres = std::make_shared<StrongOptionsPETScSolverConfigGMRES>(
    _numIterationsMax = m_options_solver_bicgs->numIterationsMax(),
    _stopCriteriaValue = m_options_solver_bicgs->stopCriteriaValue(),
    _preconditioner = std::shared_ptr<Alien::IPETScPC>(m_options_solver_bicgs->preconditioner())
  );
  auto solver_gmres = std::make_shared<Alien::PETScSolverConfigGMRESService>(m_parallel_mng, options_solver_gmres);
  m_options_petsc_solver->solver(solver_gmres);
  m_solver->init();
}

void
LinearAlgebra2StrongOptionsTesterService::
_switchToInitialBiCGStab()
{
  m_options_petsc_solver->solver(std::make_shared<Alien::PETScSolverConfigBiCGStabService>(m_parallel_mng, m_options_solver_bicgs));
  m_solver->init();
}

bool
LinearAlgebra2StrongOptionsTesterService::
_testRelaxEpsilon(MatrixType& matrixA, VectorType& vectorB, VectorType& vectorX)
{
  double initial_tol = m_options_solver_bicgs->stopCriteriaValue();
  int nb_solve_max = 10;
  while(!m_solver->getStatus().succeeded && (nb_solve_max>0)){
    _reinit(vectorX);
    m_solver->solve(matrixA,vectorB,vectorX);
    double new_tol = m_options_solver_bicgs->stopCriteriaValue()*10;
    m_options_solver_bicgs->stopCriteriaValue(new_tol);
    nb_solve_max--;
  }
  return ((m_solver->getStatus().residual > initial_tol) && (m_solver->getStatus().succeeded));
}

bool
LinearAlgebra2StrongOptionsTesterService::
_testIncreaseDT(MatrixType& matrixA, VectorType& vectorB, VectorType& vectorX)
{
  int initial_iteration_max = m_options_solver_bicgs->numIterationsMax();
  int nb_solve_max = 10;
  while(!m_solver->getStatus().succeeded && (nb_solve_max>0)){
    _reinit(vectorX);
    m_solver->solve(matrixA,vectorB,vectorX);
    int new_iter_max = m_options_solver_bicgs->numIterationsMax()*2;
    m_options_solver_bicgs->numIterationsMax(new_iter_max);
    nb_solve_max--;
  }
  return ((m_solver->getStatus().iteration_count > initial_iteration_max) && (m_solver->getStatus().succeeded));
}

bool
LinearAlgebra2StrongOptionsTesterService::
_testChangeSolver(MatrixType& matrixA, VectorType& vectorB, VectorType& vectorX)
{
  // solve with BICGStab
  _reinit(vectorX);
  m_solver->solve(matrixA,vectorB,vectorX);
  // keep BICGStab results info
  double residual_bicgs = m_solver->getStatus().residual;
  int iteration_count_bicgs = m_solver->getStatus().iteration_count;
  // swith to GMRES and solve
  _switchFromBiCGStabToGMRES();
  _reinit(vectorX);
  m_solver->solve(matrixA,vectorB,vectorX);
  // choose your solver
  if((iteration_count_bicgs < m_solver->getStatus().iteration_count) || (residual_bicgs < m_solver->getStatus().residual))
    _switchToInitialBiCGStab();
  return true;
}

bool
LinearAlgebra2StrongOptionsTesterService::
_test(MatrixType& matrixA, VectorType& vectorB, VectorType& vectorX)
{
  bool status = _testRelaxEpsilon(matrixA,vectorB,vectorX);
  // reinit stopCriteriaValue
  m_options_solver_bicgs->stopCriteriaValue(options()->solverParameters.stopCriteriaValue);
  status = status || _testIncreaseDT(matrixA,vectorB,vectorX);
  status = status || _testChangeSolver(matrixA,vectorB,vectorX);
  return status;
}
/*---------------------------------------------------------------------------*/

void
LinearAlgebra2StrongOptionsTesterService::
_reinit(VectorType& vectorX)
{
  Alien::LocalBlockVectorWriter v(vectorX);
  for (Arcane::Integer i = 0; i < vectorX.distribution().localSize(); ++i)
  {
    ArrayView<Real> values = v[i];
    for(Integer j=0; j < vectorX.block().size();++j)
      values[j] = 0.;
  }
}

int
LinearAlgebra2StrongOptionsTesterService::
test()
{
  info() << "build with profiled builder";

  Alien::BasicIndexManager index_manager(subDomain()->parallelMng());

  auto indexSetU = index_manager.buildScalarIndexSet("U", allCells());
  index_manager.prepare();
  auto global_size = index_manager.globalSize();
  auto local_size = index_manager.localSize();
  Alien::Space space(global_size, "TestSpace");
  Alien::MatrixDistribution mdist(space, space, local_size, subDomain()->parallelMng());
  Alien::VectorDistribution vdist(space, local_size, subDomain()->parallelMng());
  Alien::Block block(options()->blockSize());
  MatrixType matrixA(block, mdist);
  VectorType vectorB(block,vdist);
  VectorType vectorX(block,vdist);

  info() << "Space size = " << vdist.globalSize()
         << ", local size= " << vdist.localSize();

  Arcane::IntegerSharedArray allUIndex = index_manager.getIndexes(indexSetU);

  _buildWithProfiled(allUIndex, space, matrixA, vectorB, vectorX);
  if(options()->normalise())
   {
     Alien::NormalizeOpt op;
     op.normalize(matrixA,vectorB);
   }
  bool testOK = _test(matrixA, vectorB, vectorX);
  return (testOK ? 1:0);
}

/*---------------------------------------------------------------------------*/

void
LinearAlgebra2StrongOptionsTesterService::
_buildWithProfiled(Arcane::IntegerConstArrayView allUIndex,
                   Alien::Space& space,
                   MatrixType& matrixA,
                   VectorType& vectorB,
                   VectorType& vectorX)
{
  CellCellGroup cell_cell_connection(ownCells(), allCells(), IK_Node);

  {
    Alien::LocalBlockVectorWriter v(vectorB);
    for (Arcane::Integer i = 0; i < vectorB.distribution().localSize(); ++i)
    {
      ArrayView<Real> values = v[i];
      for(Integer j=0; j < vectorB.block().size();++j)
        values[j] = 2.;
    }
  }
  {
    Alien::LocalBlockVectorWriter v(vectorX);
    for (Arcane::Integer i = 0; i < vectorX.distribution().localSize(); ++i)
    {
      ArrayView<Real> values = v[i];
      for(Integer j=0; j < vectorX.block().size();++j)
        values[j] = 0.;
    }
  }

  ///////////////////////////////////////////////////////////////////////////
  //
  // DEFINE PROFILE
  //
  {
    Alien::MatrixProfiler profiler(matrixA);

    ENUMERATE_ITEMPAIR(Cell, Cell, icell, cell_cell_connection)
    {
      const Arcane::Cell & cell = *icell;
      const Arcane::Integer iIndex = allUIndex[cell.localId()];
      profiler.addMatrixEntry(iIndex, allUIndex[cell.localId()]);
      ENUMERATE_SUB_ITEM(Cell, isubcell, icell)
      {
        const Arcane::Cell& subcell = *isubcell;
        profiler.addMatrixEntry(iIndex, allUIndex[subcell.localId()]);
      }
    }
  }
  const Arcane::Integer neq = matrixA.block().size();
  const Arcane::Integer nuk = neq;
  Alien::ProfiledBlockMatrixBuilder builder(matrixA, Alien::ProfiledBlockMatrixBuilder::ResetFlag::eResetValues);
  {
    Arcane::RealArray2 values(neq,nuk);
    ENUMERATE_ITEMPAIR(Cell, Cell, icell, cell_cell_connection)
    {
      const Arcane::Cell & cell = *icell;
      values.fill(0.) ;
      for(Arcane::Integer i=0; i<neq; ++i)
        values[i][i] = fij(cell,cell) ;

      const Arcane::Integer i = allUIndex[cell.localId()];
      builder(i,i) += values;
      ENUMERATE_SUB_ITEM(Cell, isubcell, icell)
      {
        const Arcane::Cell& subcell = *isubcell;
        for(Arcane::Integer k=0; k<neq; ++k)
          values[k][k] = fij(cell,subcell) ;
        const Arcane::Integer j = allUIndex[subcell.localId()];
        builder(i,j) += values;
      }
    }
  }
}

/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_LINEARALGEBRA2STRONGOPTIONSTESTER(LinearAlgebra2StrongOptionsTester,LinearAlgebra2StrongOptionsTesterService);
