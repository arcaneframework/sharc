/* Author : gratienj at Thu Aug  3 10:16:59 2008
 * Generated by createNew
 */
#include <arcane/ArcaneVersion.h>
#include "ArcGeoSim/Utils/Utils.h"
#include "ArcGeoSim/Utils/MemoryAllocationTracker.h"


#ifdef USE_ALIEN_V1
#include <ArcGeoSim/Numerics/AlienTools/Space.h>

#include <ALIEN/Alien-IFPEN.h>
//#include <ALIEN/Alien-ExternalPackages.h>

#ifdef USE_PETSC
#include <ALIEN/Kernels/PETSc/IO/AsciiDumper.h>
#include <ALIEN/Kernels/PETSc/Algebra/PETScLinearAlgebra.h>
#endif

#ifdef USE_MTL4
#include <ALIEN/Kernels/MTL/Algebra/MTLLinearAlgebra.h>
#endif

#include "ArcGeoSim/Numerics/AlienTools/CreateDistribution.h"
#include "ArcGeoSim/Numerics/AlienTools/VectorAccessor.h"
#include "ArcGeoSim/Numerics/AlienTools/SimpleAbstractFamily.h"
#include "ArcGeoSim/Numerics/AlienTools/DirectBuilderStats.h"
#endif

#ifdef USE_ALIEN_V2
#include <alien/ref/AlienRefSemantic.h>
#include <alien/kernels/simple_csr/algebra/SimpleCSRLinearAlgebra.h>
#ifdef USE_PETSC
#include <alien/kernels/petsc/io/AsciiDumper.h>
#include <alien/kernels/petsc/algebra/PETScLinearAlgebra.h>
#endif

#ifdef ALIEN_USE_MTL4
#include <alien/kernels/mtl/algebra/MTLLinearAlgebra.h>
#endif

#include <alien/arcane_tools/accessors/ItemVectorAccessor.h>

#include <alien/arcane_tools/IIndexManager.h>
#include <alien/arcane_tools/indexManager/BasicIndexManager.h>
#include <alien/arcane_tools/data/Space.h>
#include <alien/arcane_tools/indexManager/SimpleAbstractFamily.h>
#include <alien/arcane_tools/distribution/DistributionFabric.h>
#endif



#include <arcane/Timer.h>
#include <arcane/ItemPairGroup.h>
#include <arcane/mesh/ItemFamily.h>
#include <arcane/utils/PlatformUtils.h>
#include <arcane/utils/IMemoryInfo.h>
#include <arcane/utils/OStringStream.h>

#include <boost/shared_ptr.hpp>

#include "LinearAlgebra2TesterService.h"

using namespace Arcane;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void LinearAlgebra2TesterService::init() {

#ifdef USE_ALIEN_V1
  Alien::setTraceMng(traceMng());
  Alien::setVerbosityLevel(Alien::Verbosity::Debug);
#endif
#ifdef USE_ALIEN_V2
  Alien::setTraceMng(traceMng());
  Alien::setVerbosityLevel(Alien::Verbosity::Debug);
#endif

  m_diag_coeff = options()->diagonalCoefficient();
  switch (options()->stencilBy()) {
  case LinearAlgebra2TestOptionTypes::StencilByNode:
    m_stencil_kind = IK_Node;
    break;
  case LinearAlgebra2TestOptionTypes::StencilByFace:
    m_stencil_kind = IK_Face;
    break;
  }

  m_parallel_mng = subDomain()->parallelMng();

  if (m_parallel_mng->commRank() % 2 == 0)
    m_n_extra_indices = options()->extraEquationCount();
  else
    m_n_extra_indices = 0;

  for(int i=0;i<options()->linearSolver.size();++i)
  {
    auto* solver = options()->linearSolver[i];
    solver->init() ;
  }
}

/*---------------------------------------------------------------------------*/

int LinearAlgebra2TesterService::test() {
  Timer timer(subDomain(),"LinearAlgebra2TesterService",Timer::TimerVirtual);
  m_w.resize(2);

  if (options()->checkMemory()) 
    {
      m_memory_tracker = new MemoryAllocationTracker();
      m_memory_tracker->beginCollect();
    }

  using namespace ArcGeoSim::Numerics;

  ItemGroup areaU = allCells();
  // ItemGroup areaU = mesh()->cellFamily()->createGroup("AreaU");
  ItemGroup areaP = allNodes();
  // ItemGroup areaP = mesh()->nodeFamily()->createGroup("AreaP");
  CellCellGroup cell_cell_connection(areaU.own(),areaU,m_stencil_kind);

  BuildingStat index_manager_stat(this, timer);
  index_manager_stat.start();
#if defined(USE_ALIEN_V2)
  Alien::ArcaneTools::BasicIndexManager index_manager(m_parallel_mng);
#else
  Alien::BasicIndexManager index_manager(m_parallel_mng);
#endif
  index_manager.setTraceMng(traceMng());

  // index_manager->init() ; // facultatif apr�s une construction; principalement utilis� pour une r�utilisation de l'objet

  // Area doit r�pondre est une collection �num�rable o� chaque �l�ment doit r�pondre � 'localId', 'uniqueId' et 'owner'
  // 'localId' est pour l'acc�s au table 'cache' d'indexation et 'uniqueId' et 'owner' pour les algorthmiques d'indexation � proprement dit.
  // L'indexation s'occupe d'indexer des entit�s (le plus souvent des items) ind�pendamment des concepts de syst�me lin�aire.
  // Ainsi l'indexation est un objet qui forme une bijection entre des entit�s et un intervalle [O:N[ (par bloc en parall�le)
  auto indexSetU = index_manager.buildScalarIndexSet("U", areaU);
  // la variable U est taguee en "Elliptic" pour un traitement de type CprAMG:
  // NOTE: le tag "block-tag" et la valeur "Elliptic" sont pre-definis specifiquement pour le cas CprAMG de IFPSolver
  indexSetU.addTag("block-tag","Elliptic");
 
  // Idem en vectoriel
  auto indexSetP = index_manager.buildVectorIndexSet("P", areaP, 1);
  // Si l'on veut mettre des tags, on peut les mettre par composante ou pour tout l'entit� vectorielle
  indexSetP[0].addTag("block-tag","P");
  // indexSetP[1].addTag("block-tag","Q");

  Int64SharedArray xUids; // ajout de quelques indices extras pour les processeurs de rank pair
  const Integer max_n_extra_indices = m_parallel_mng->reduce(Arcane::Parallel::ReduceMax, m_n_extra_indices);
  for(Integer i=0;i<m_n_extra_indices;++i)
    xUids.add(m_parallel_mng->commRank()*max_n_extra_indices + i);

#if defined(USE_ALIEN_V2)
  auto indexSetX = index_manager.buildScalarIndexSet("X", Alien::ArcaneTools::SimpleAbstractFamily(xUids, &index_manager));
#else
  auto indexSetX = index_manager.buildScalarIndexSet("X", Alien::SimpleAbstractFamily(xUids, &index_manager));
#endif
  indexSetX.addTag("block-tag","P");
  
  // index_manager->prepare(); // associ� � un espce, l'appel sera facultatif car pris en charge dans l'espace

  ///////////////////////////////////////////////////////////////////////////
  //
  // CREATE Space FROM IndexManger
  // CREATE MATRIX ASSOCIATED TO Space
  // CREATE VECTORS ASSOCIATED TO Space
  //
#ifdef USE_ALIEN_V1
  Alien::ArcGeoSim::Space space(&index_manager);
  Alien::MatrixDistribution mdist = Alien::ArcGeoSim::createMatrixDistribution(space);
  Alien::VectorDistribution vdist = Alien::ArcGeoSim::createVectorDistribution(space);
  Alien::Vector vectorB(vdist);
  Alien::Vector vectorX(vdist);
#endif

#ifdef USE_ALIEN_V2
  index_manager.prepare() ;
  info() << "Create Space";
  auto space = Alien::ArcaneTools::Space(&index_manager);
  auto mdist = Alien::ArcaneTools::createMatrixDistribution(space);
  auto vdist = Alien::ArcaneTools::createVectorDistribution(space);

  auto vectorB = Alien::Vector(vdist);
  auto vectorX = Alien::Vector(vdist);
#endif
  // Acc�s � l'indexation
  IntegerSharedArray  allUIndex = index_manager.getIndexes(indexSetU);
  IntegerSharedArray2 allPIndex = index_manager.getIndexes(indexSetP);
  IntegerSharedArray  allXIndex = index_manager.getIndexes(indexSetX);

  index_manager_stat.stop();

  ///////////////////////////////////////////////////////////////////////////
  //
  // VECTOR BUILDING AND FILLING
  //
  info() << "Building & initializing vector b";
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
  info() << "Space size = " << vdist.globalSize() << ", local size= " << vdist.localSize();
#endif
  buildAndFillInVector(vectorB, 2.);

  // Testing linear algebra on vectors
  {

#if (defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)) && defined(ALIEN_USE_PETSC)
    Alien::PETScLinearAlgebra algebra2;
    algebra2.copy(vectorB,vectorX); // copy b in x using petsc

    info() << "Checking vector x data";
    checkVectorValues(vectorX, 2.);
#endif
  }


  // Dump an object
  // {
  //   Alien::AsciiDumper dumper(Alien::AsciiDumper::eMatlabStyle);

  //   dumper.dump("vectorX.txt", vectorX);
  // }

  ///////////////////////////////////////////////////////////////////////////
  //
  // SCALAR PRODUCT
  //
  info() << "Checking dot product using different linear algebra implementations";
  checkDotProductWithManyAlgebra(vectorB,vectorX,space);

  ///////////////////////////////////////////////////////////////////////////
  //
  // VECTOR / VARIABLE ASSOCIATION
  //
  vectorVariableUpdate(vectorB,indexSetU);
  info() << "Checking vector b data after a reverse commit";
  checkVectorValues(vectorB, 2.);

  Arcane::XmlNode rootXmlBuilderNode = options()->builder.rootElement();
  Arcane::XmlNodeList builderNodeList = rootXmlBuilderNode.children("builder");
  for(Integer ibuilder=0;ibuilder<options()->builder.size();++ibuilder)
    {
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
    Alien::Matrix matrixA(mdist);
#endif
      info() << "BUILDER #" << ibuilder << " : " << builderNodeList[ibuilder].value();

      BuildingStat profile_stat(this,timer);
      SharedArray<BuildingStat> inserter_stats;

      ///////////////////////////////////////////////////////////////////////////
      //
      // MATRIX BUILDING AND FILLING
      //
      {
        LinearAlgebra2TestOptionTypes::eBuilderType builder_type = options()->builder[ibuilder];
        switch(builder_type) {
        case LinearAlgebra2TestOptionTypes::DirectBuilder: {

          for(Integer loop = 0; loop<options()->repeatLoop();++loop)
            {
              info() << "Filling #" << loop;
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
              Alien::DirectMatrixBuilder builder(matrixA, Alien::DirectMatrixBuilder::ResetFlag::eResetValues);
#endif
              if (loop == 0)
                {
                  profile_stat.start();
                  builder.reserve(indexSetU.getOwnIndexes(),30);
                  builder.reserve(indexSetP[0].getOwnIndexes(),1);
                  builder.reserve(indexSetX.getOwnIndexes(),1);
                  builder.allocate(); // on force le placement de allocate ici pour les mesures de perfs (normalement seul l'autre suffit)
                  profile_stat.stop();
                }
              inserter_stats.add(BuildingStat(this,timer));
              if (loop != 0) builder.allocate();
              inserter_stats.back().start();
              fillInMatrix(cell_cell_connection,areaP, allPIndex, allUIndex, allXIndex, builder);
#if defined(USE_ALIEN_V1)
              info() << Alien::stats(builder, &index_manager);
              builder.finalize(); // process extra work after filling (squeeze, non-local...)
#else
              info() << builder.stats();
              builder.finalize(); // process extra work after filling (squeeze, non-local...)
#endif
              // optional if used with out-of-scope dtor
              inserter_stats.back().stop();
            }
        } break;

        case LinearAlgebra2TestOptionTypes::ProfiledBuilder: {
          profile_stat.start();
          {
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
            Alien::MatrixProfiler profiler(matrixA);
#endif
            profileMatrix(cell_cell_connection,areaP, allPIndex, allUIndex, allXIndex, profiler);
            profiler.allocate(); // optional if used with out-of-scope dtor
          }
          profile_stat.stop();
        
          for(Integer loop = 0; loop<options()->repeatLoop();++loop)
            {
              info() << "Filling #" << loop;
              inserter_stats.add(BuildingStat(this,timer));
              inserter_stats.back().start();
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
              Alien::ProfiledMatrixBuilder builder(matrixA, Alien::ProfiledMatrixBuilder::ResetFlag::eResetValues);
#endif
              fillInMatrix(cell_cell_connection, areaP, allPIndex, allUIndex, allXIndex, builder);
              builder.finalize(); // process extra work after filling (squeeze, non-local...) 
              // optional if used with out-of-scope dtor
              inserter_stats.back().stop();
            }
        } break;

        case LinearAlgebra2TestOptionTypes::StreamBuilder: {
          profile_stat.start();
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
          Alien::StreamMatrixBuilder stream_builder(matrixA);
#endif
          stream_builder.setOrderRowColsOpt(false) ;
#ifdef USE_ALIEN_V2
          stream_builder.setTraceMng(traceMng()) ;
#endif
          // stream_builder.init() ; // optional : already done by ctor (only used by multiple usage of MatrixBuilder)
          // stream_builder.start() ;
          streamProfileMatrix(cell_cell_connection, areaU, areaP, allPIndex, allUIndex, allXIndex, stream_builder);
      
          profile_stat.stop();

          for(Integer loop = 0; loop<options()->repeatLoop();++loop)
            {
              info() << "Filling #" << loop;
              stream_builder.fillZero();

              inserter_stats.add(BuildingStat(this,timer));
              inserter_stats.back().start();
          
              streamFillInMatrix(cell_cell_connection, areaP, allPIndex, allUIndex, allXIndex, stream_builder);
              stream_builder.finalize(); // process extra work after filling (squeeze, non-local...) 
              // NOT optional ! (since this object is usually used in a loop)
              inserter_stats.back().stop();
            }
    
          // stream_builder.end(); // optional : already done by dtor
        } break;
        default :
          fatal()<<"Builder type : "<<builder_type<<" Not yet available";
        }
      }
      ///////////////////////////////////////////////////////////////////////////
      //
      // RESOLUTION
      //
      Arcane::XmlNode rootXmlNode = options()->linearSolver.rootElement();
      Arcane::XmlNodeList linearSolverNodeList = rootXmlNode.children("linear-solver");

      SharedArray<SharedArray<Real> > solverData;

      if (!options()->buildingOnly())
        for(int i=0;i<options()->linearSolver.size();++i)
          {
            solverData.add(SharedArray<Real>());
            Array<Real> & currentSolverData = solverData[solverData.size()-1];
            Real memory_before_solve = getAllocatedMemory();
            resetMaxMemory();

            //info()<<"****** SOLVER #" << i << " : " << linearSolverNodeList[i].attrValue("name");
            info()<<"****** SOLVER #" << i << " : ";
            auto* solver = options()->linearSolver[i];

            if (not solver->hasParallelSupport() and m_parallel_mng->commSize() > 1)
              {
                info() << "Current solver has not a parallel support for solving linear system : skip it";
                currentSolverData.add(std::numeric_limits<Real>::quiet_NaN( ));
                currentSolverData.add(std::numeric_limits<Real>::quiet_NaN( ));
                currentSolverData.add(std::numeric_limits<Real>::quiet_NaN( ));
                currentSolverData.add(false);
                currentSolverData.add(0);
                currentSolverData.add(std::numeric_limits<Real>::quiet_NaN( ));
              }
            else
              {
                {
//                  // Dump an object
//                  {
//                    Alien::AsciiDumper dumper(Alien::AsciiDumper::eMatlabStyle);
//
//                    dumper.dump("vectorB.txt", vectorB);
//                    dumper.dump("matrixA.txt", matrixA);
//                  }

                  Timer::Sentry ts(&timer);
                  solve(solver, matrixA, vectorB, vectorX);

//                  {
//                    Alien::AsciiDumper dumper(Alien::AsciiDumper::eMatlabStyle);
//
//                    dumper.dump("vectorX.txt", vectorX);
//                  }

                  //fatal() << "OK";
                }
                auto status = solver->getStatus();
                currentSolverData.add(timer.lastActivationTime());
                currentSolverData.add(getAllocatedMemory() - memory_before_solve);
                currentSolverData.add(getMaxMemory() - memory_before_solve);
                currentSolverData.add(status.succeeded);
                currentSolverData.add(status.iteration_count);
                currentSolverData.add(status.residual);
                solver->end() ;
              }
          }

      if (subDomain()->parallelMng()->commRank() == 0)
        {
          info() << "========= LinearAlgebra2 Statistics Summary with " << builderNodeList[ibuilder].value() << " =============";
          printf("\tIndexManager time=%5.2f mem=%7.2f max_mem=%7.2f\n", index_manager_stat.time, index_manager_stat.memory, index_manager_stat.memory_max);
          printf("\tProfiler     time=%5.2f mem=%7.2f max_mem=%7.2f count=%d\n", profile_stat.time, profile_stat.memory, profile_stat.memory_max, profile_stat.allocation_count);
          for(Integer i=0;i<inserter_stats.size();++i)
            printf("\tFilling %2d   time=%5.2f mem=%7.2f max_mem=%7.2f count=%d\n", i, inserter_stats[i].time, inserter_stats[i].memory, inserter_stats[i].memory_max, inserter_stats[i].allocation_count);
      
          if (!options()->buildingOnly())
            {
              printf("\tSolver %2s : %6s %7s %7s %7s %6s %8s\n",
                     "id","time","dmem","mmem","success","#iter","residual");

              Integer iglobal = 0;
              // printf("Builder %s\n",options()->builder.enumValues()->nameOfValue(options()->builder[ibuilder],"").localstr());
      
              for(Integer isolver=0;isolver<options()->linearSolver.size();++isolver,++iglobal)
                {
                  const Array<Real> & c = solverData[iglobal];
            
                  printf("\tSolver %2d : %6.2f %7.2f %7.2f %7.0f %6.0f %8.3g",
                         isolver,c[0],c[1],c[2],c[3],c[4],c[5]);
                  printf("\n");
                }
            }
        }
    }

  delete m_memory_tracker, m_memory_tracker = NULL;

  return 1 ;
}

/*---------------------------------------------------------------------------*/

void
LinearAlgebra2TesterService::buildAndFillInVector(Alien::Vector& vectorB, const double& value)
{
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
  {
    Alien::LocalVectorWriter v(vectorB);
    info() << "Vector local size= " << vectorB.distribution().localSize();
    for(Integer i=0;i<vectorB.distribution().localSize();++i)
      v[i] = value;
  }
#endif
}

/*---------------------------------------------------------------------------*/

template<typename Profiler>
void
LinearAlgebra2TesterService::
profileMatrix(const CellCellGroup& cell_cell_connection,
              const ItemGroup areaP,
              const IntegerArray2& allPIndex,
              const IntegerArray& allUIndex,
              const IntegerArray& allXIndex,
              Profiler & profiler)
{
  ///////////////////////////////////////////////////////////////////////////
  //
  // DEFINE PROFILE
  //
  ENUMERATE_ITEMPAIR(Cell,Cell,icell,cell_cell_connection)
    {
      const Cell & cell = *icell;
      const Integer iIndex = allUIndex[cell.localId()];
      profiler.addMatrixEntry(iIndex, allUIndex[cell.localId()]);
      ENUMERATE_SUB_ITEM(Cell,isubcell,icell) 
        {
          const Cell& subcell = *isubcell;
          profiler.addMatrixEntry(iIndex,allUIndex[subcell.localId()]);
        }
    }

  ENUMERATE_NODE(inode, areaP.own())
    {
      const Node & node = *inode;
      ConstArrayView<Integer> indexes = allPIndex[node.localId()];
      for(Integer i=0;i<indexes.size();++i)
        {
          profiler.addMatrixEntry(indexes[i], indexes[i]);
        }
    }

  for(Integer localId=0;localId<m_n_extra_indices;++localId)
    {
      profiler.addMatrixEntry(allXIndex[localId],allXIndex[localId]);
    }
}

/*---------------------------------------------------------------------------*/

void
LinearAlgebra2TesterService::
streamProfileMatrix(const CellCellGroup& cell_cell_connection,
                    const ItemGroup areaU,
                    const ItemGroup areaP,
                    const IntegerArray2& allPIndex,
                    const IntegerArray& allUIndex,
                    const IntegerArray& allXIndex,
                    Alien::StreamMatrixBuilder & inserters)
{
  Alien::StreamMatrixBuilder::Profiler & uInserter = inserters.getNewInserter(); // id 0
  ARCANE_ASSERT((uInserter.getId() == 0),("Bad ID"));
  Alien::StreamMatrixBuilder::Profiler & pInserter = inserters.getNewInserter(); // id 1
  ARCANE_ASSERT((pInserter.getId() == 1),("Bad ID"));
  Alien::StreamMatrixBuilder::Profiler & xInserter = inserters.getNewInserter(); // id 2
  ARCANE_ASSERT((xInserter.getId() == 2),("Bad ID"));
  // uInserter.reserve(27*areaU.size()); // Pas plus rapide avec les r�serves ??
  // pInserter.reserve(1*areaP.size());
  // xInserter.reserve(m_n_extra_indices);
  
  ENUMERATE_ITEMPAIR(Cell,Cell,icell,cell_cell_connection)
    {
      const Cell & cell = *icell;
      const Integer iIndex = allUIndex[cell.localId()];
      uInserter.addMatrixEntry(iIndex, allUIndex[cell.localId()]);
      ENUMERATE_SUB_ITEM(Cell,isubcell,icell) 
        {
          const Cell& subcell = *isubcell;
          uInserter.addMatrixEntry(iIndex,allUIndex[subcell.localId()]);
        }
    }

  ENUMERATE_NODE(inode, areaP.own())
    {
      const Node & node = *inode;
      ConstArrayView<Integer> indexes = allPIndex[node.localId()];
      for(Integer i=0;i<indexes.size();++i)
        {
          pInserter.addMatrixEntry(indexes[i], indexes[i]);
        }
    }

  for(Integer localId=0;localId<m_n_extra_indices;++localId)
    {
      xInserter.addMatrixEntry(allXIndex[localId],allXIndex[localId]);
    }
  
  inserters.allocate(); // optional if used with out-of-scope dtor
}

/*---------------------------------------------------------------------------*/

void
LinearAlgebra2TesterService::
streamFillInMatrix(const CellCellGroup& cell_cell_connection,
                   const ItemGroup areaP,
                   const IntegerArray2& allPIndex,
                   const IntegerArray& allUIndex,
                   const IntegerArray& allXIndex,
                   Alien::StreamMatrixBuilder & inserters)
{
  Alien::StreamMatrixBuilder::Filler & uInserter = inserters.getInserter(0);
  uInserter.start();
  Alien::StreamMatrixBuilder::Filler & pInserter = inserters.getInserter(1);
  pInserter.start();
  Alien::StreamMatrixBuilder::Filler & xInserter = inserters.getInserter(2);
  xInserter.start();
  
  ENUMERATE_ITEMPAIR(Cell,Cell,icell,cell_cell_connection)
    {
      const Cell & cell = *icell;
      uInserter.addData(fij(cell,cell));
      ++uInserter;
      ENUMERATE_SUB_ITEM(Cell,isubcell,icell) 
        {
          const Cell& subcell = *isubcell;
          uInserter.addData(fij(cell,subcell)) ;
          ++uInserter;
        }
    }

  ENUMERATE_NODE(inode, areaP.own())
    {
      const Node & node = *inode;
      ConstArrayView<Integer> indexes = allPIndex[node.localId()];
      for(Integer i=0;i<indexes.size();++i)
        {
          pInserter.addData(2);
          ++pInserter;
        }
    }

  for(Integer localId=0;localId<m_n_extra_indices;++localId)
    {
      xInserter.addData(5);
      ++xInserter;
    }
}

/*---------------------------------------------------------------------------*/

template<typename Builder>
void
LinearAlgebra2TesterService::
fillInMatrix(const CellCellGroup& cell_cell_connection,
             const ItemGroup areaP,
             const IntegerArray2& allPIndex,
             const IntegerArray& allUIndex,
             const IntegerArray& allXIndex,
             Builder & builder)
{
  ///////////////////////////////////////////////////////////////////////////
  //
  // FILL MATRIX
  //
#if 1 // use point filling
  ENUMERATE_ITEMPAIR(Cell,Cell,icell,cell_cell_connection)
  {
    const Cell & cell = *icell;
    const Integer iIndex = allUIndex[cell.localId()];
    builder(iIndex,iIndex) += fij(cell,cell) ;
    ENUMERATE_SUB_ITEM(Cell,isubcell,icell)
      {
        const Cell& subcell = *isubcell;
        builder(iIndex,allUIndex[subcell.localId()]) += fij(cell,subcell) ;
      }
  }
#else /* use vector filling */
  SharedArray<Integer> jIndexes;
  SharedArray<Real> jValues;
  ENUMERATE_ITEMPAIR(Cell,Cell,icell,cell_cell_connection)
  {
    const Cell & cell = *icell;
    const Integer iIndex = allUIndex[cell.localId()];
    jIndexes.resize(0);
    jValues.resize(0);
    jIndexes.add(iIndex); jValues.add(fij(cell,cell));
    ENUMERATE_SUB_ITEM(Cell,isubcell,icell)
      {
        const Cell& subcell = *isubcell;
        jIndexes.add(allUIndex[subcell.localId()]); jValues.add(fij(cell,subcell));
      }
    builder.addData(iIndex, 1, jIndexes, jValues);
  }
#endif /* filling mode */
  ENUMERATE_NODE(inode, areaP.own())
  {
    const Node & node = *inode;
    ConstArrayView<Integer> indexes = allPIndex[node.localId()];
    for(Integer i=0;i<indexes.size();++i)
      {
        builder(indexes[i], indexes[i]) += 2;
      }
  }

  for(Integer localId=0;localId<m_n_extra_indices;++localId)
    {
      builder(allXIndex[localId], allXIndex[localId]) += 5;
    }
}

/*---------------------------------------------------------------------------*/

Alien::ILinearSolver::Status
LinearAlgebra2TesterService::solve(Alien::ILinearSolver * solver,
                                   Alien::Matrix& matrixA,
                                   Alien::Vector& vectorB,
                                   Alien::Vector& vectorX)
{
  { // R�initialisation de vectorX
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
    Alien::LocalVectorWriter v(vectorX);
#endif
    for(Integer i=0;i<v.size();++i) v[i] = 0;
  }

  solver->solve(matrixA,vectorB,vectorX) ;

  auto status = solver->getStatus();
  if (status.succeeded)
    {
      info() << "Solver succeeds with " << status.iteration_count << " iterations";

      ///////////////////////////////////////////////////////////////////////////
      //
      // OPERATIONS ALGEBRIQUES
      //
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
      Alien::Space space(vectorB.distribution().globalSize());
      std::shared_ptr<Alien::ILinearAlgebra> alg = solver->algebra();
#endif
      if (alg)
      {
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
        Alien::Vector vectorY(vectorB.distribution());
        Alien::Vector vectorRes(vectorB.distribution());
#endif
        alg->mult(matrixA,vectorX,vectorY) ;

        // res = b - A.x
        alg->copy(vectorB,vectorRes) ;
        alg->axpy(-1.,vectorY,vectorRes) ;

        Real norm = alg->norm2(vectorRes) ;
        info()<<"Residual norm2 by solver linear algebra : " << norm ;
      }

      {
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
        Alien::SimpleCSRLinearAlgebra testAlg;
        Alien::Vector vectorY(vectorB.distribution());
        Alien::Vector vectorRes(vectorB.distribution());
#endif
        testAlg.mult(matrixA,vectorX,vectorY);
        // res = b - A.x
        testAlg.copy(vectorB,vectorRes) ;
        testAlg.axpy(-1.,vectorY,vectorRes) ;
        Real norm = testAlg.norm2(vectorRes) ;
        info()<<"Residual norm2 by SimpleCSR algebra : " << norm ;
      }

      {
#if (defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2) ) && defined(ALIEN_USE_PETSC)
        Alien::PETScLinearAlgebra testAlg;
        Alien::Vector vectorY(vectorB.distribution());
        Alien::Vector vectorRes(vectorB.distribution());
        testAlg.mult(matrixA,vectorX,vectorY);
        // res = b - A.x
        testAlg.copy(vectorB,vectorRes) ;
        testAlg.axpy(-1.,vectorY,vectorRes) ;
        Real norm = testAlg.norm2(vectorRes) ;
        info()<<"Residual norm2 by PETSc algebra : " << norm ;
#endif
      }
    }
  else
    {
      fatal() << "Solver fails after " << status.iteration_count << " iterations";
    }
  
  return status;
}

/*---------------------------------------------------------------------------*/

void
LinearAlgebra2TesterService::
checkVectorValues(Alien::Vector& vectorX, const double& value)
{

#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
  const Alien::LocalVectorReader v(vectorX);
#endif
  for(Integer i=0;i<v.size();++i)
    if (v[i] != value)
      fatal() << "Incorrect value (" << v[i] << " vs expected 2.)";
  // auto-call for vB.end() in const context
}

/*---------------------------------------------------------------------------*/
void
LinearAlgebra2TesterService::
#if defined(USE_ALIEN_V2)
vectorVariableUpdate(Alien::Vector & vectorB, Alien::ArcaneTools::IIndexManager::ScalarIndexSet indexSetU)
#else
vectorVariableUpdate(Alien::Vector & vectorB, Alien::IIndexManager::ScalarIndexSet indexSetU)
#endif
{
  ///////////////////////////////////////////////////////////////////////////
  //
  // VECTOR / VARIABLE
  //
#if defined(USE_ALIEN_V2)
  Alien::ArcaneTools::ItemVectorAccessor v(vectorB); // remplissage algébrique de vectorB : accessor / view
  Alien::ArcaneTools::Variable(m_u)    = v(indexSetU);
  Alien::ArcaneTools::Variable(m_w)[1] = v(indexSetU);
  Alien::ArcaneTools::Variable(m_u)   += v(indexSetU);
  v(indexSetU)  = 0;
  v(indexSetU)  = Alien::ArcaneTools::Variable(m_u);
  v(indexSetU) -= Alien::ArcaneTools::Variable(m_w)[1];
#else
  Alien::ItemVectorAccessor v(vectorB); // remplissage algébrique de vectorB : accessor / view
  Alien::Variable(m_u)    = v(indexSetU);
  Alien::Variable(m_w)[1] = v(indexSetU);
  Alien::Variable(m_u)   += v(indexSetU);
  v(indexSetU)  = 0;
  v(indexSetU)  = Alien::Variable(m_u);
  v(indexSetU) -= Alien::Variable(m_w)[1];
#endif
}

/*---------------------------------------------------------------------------*/
void
LinearAlgebra2TesterService::
checkDotProductWithManyAlgebra(const Alien::Vector& vectorB,
                               Alien::Vector& vectorX,

#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
                               Alien::ISpace& space)
#else
                               Alien::Space& space)
#endif
{
  info() << "Checking dot product using two linear algebra implementations";

#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
  Alien::SimpleCSRLinearAlgebra alg1;
#endif
  alg1.copy(vectorB,vectorX); // copy b in x
  const Real dot1 = alg1.dot(vectorB,vectorX);
  info() << "SimpleCSR dot product : " << dot1;

#if (defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2) )&& defined(ALIEN_USE_PETSC)
  Alien::PETScLinearAlgebra alg2;
  alg2.copy(vectorB,vectorX); // copy b in x
  const Real dot2 = alg2.dot(vectorB,vectorX);
  info() << "PETSc dot product : " << dot2;
  if (dot1 != dot2)
    fatal() << "SimpleCSR vs PETSc : Not equal dot product";
#endif
#if (defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2) )&& defined(ALIEN_USE_MTL)
  if (m_parallel_mng->commSize() == 1) {
    Alien::MTLLinearAlgebra alg3;
    alg3.copy(vectorB,vectorX); // copy b in x
    const Real dot3 = alg3.dot(vectorB,vectorX);
    info() << "MTL dot product : " << dot3;
    if (dot1 != dot3)
      fatal() << "SimpleCSR vs MTL : Not equal dot product";
  }
#endif
}

/*---------------------------------------------------------------------------*/

Real
LinearAlgebra2TesterService::
fij(const Cell & ci, const Cell & cj)
{
  if (ci == cj)
    return m_diag_coeff;
  else
    return -1;
}

/*---------------------------------------------------------------------------*/

Real 
LinearAlgebra2TesterService::
getAllocatedMemory()
{
//   // Utilise IMemoryInfo, si ca marche ....
//   std::ostringstream oss;
//   subDomain()->memoryInfo()->printAllocatedMemory(oss,globalIteration());
//   long int current_allocated;
//   if (sscanf(oss.str().c_str()," INFO_ALLOCATION: current= %ld ",&current_allocated) != 1)
//     return -1;
//   return Real(current_allocated)/1048576;


  // Version a la mano
  if (options()->checkMemory())
    {
      ARCANE_ASSERT((m_memory_tracker!=NULL),("Invalid null memory tracker"));
      return Real(m_memory_tracker->getTotalAllocation())/1048576;
    }
  else
    {
      // Version tr�s approximative mais ne coutant rien
      return platform::getMemoryUsed()/1048576;
    }
}

/*---------------------------------------------------------------------------*/

Real 
LinearAlgebra2TesterService::
getMaxMemory()
{
  // Version a la mano
  if (options()->checkMemory())
    {
      ARCANE_ASSERT((m_memory_tracker!=NULL),("Invalid null memory tracker"));
      return Real(m_memory_tracker->getPeakAllocation())/1048576;
    }
  else
    {
      // Version tr�s approximative mais ne coutant rien
      return std::numeric_limits<Real>::quiet_NaN( );
    }
}

/*---------------------------------------------------------------------------*/

void
LinearAlgebra2TesterService::
resetMaxMemory()
{
  if (m_memory_tracker)
    m_memory_tracker->resetPeakAllocation();
}

/*---------------------------------------------------------------------------*/

Int64
LinearAlgebra2TesterService::
getAllocationCount()
{
  if (m_memory_tracker)
    return m_memory_tracker->getAllocationCount() + m_memory_tracker->getReallocationCount();
  else
    return -1;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_LINEARALGEBRA2TESTER(LinearAlgebra2Tester,LinearAlgebra2TesterService);
