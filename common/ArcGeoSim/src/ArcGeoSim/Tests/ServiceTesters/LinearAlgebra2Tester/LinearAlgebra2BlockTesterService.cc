/* Author : gratienj at Thu Aug  3 10:16:59 2008
 * Generated by createNew
 */

#include "ArcGeoSim/Tests/ServiceTesters/IServiceTester.h"

#include "ArcGeoSim/Tests/ServiceTesters/LinearAlgebra2Tester/LinearAlgebra2TestOptionTypes.h"


#ifdef USE_ALIEN_V1
#include <ALIEN/Alien-IFPEN.h>
#ifdef USE_PETSC
#include <ALIEN/Kernels/PETSc/IO/AsciiDumper.h>
#include <ALIEN/Kernels/PETSc/Algebra/PETScLinearAlgebra.h>
#endif
#include <ArcGeoSim/Numerics/AlienTools/BasicIndexManager.h>
#endif

#ifdef USE_ALIEN_V2
#include <alien/ref/AlienRefSemantic.h>
#include <alien/kernels/simple_csr/algebra/SimpleCSRLinearAlgebra.h>
#ifdef USE_PETSC
#include <alien/kernels/petsc/io/AsciiDumper.h>
#include <alien/kernels/petsc/algebra/PETScLinearAlgebra.h>
#endif
#include <alien/arcane_tools/IIndexManager.h>
#include <alien/arcane_tools/indexManager/BasicIndexManager.h>
#include <alien/arcane_tools/data/Space.h>

#include <alien/expression/solver/ILinearSolver.h>

#include <alien/arcane_tools/accessors/ItemVectorAccessor.h>

#include <alien/arcane_tools/indexManager/SimpleAbstractFamily.h>
#include <alien/arcane_tools/distribution/DistributionFabric.h>

#include <alien/expression/normalization/NormalizeOpt.h>
#endif

#include "LinearAlgebra2BlockTester_axl.h"

#include <arcane/ItemPairGroup.h>

#include <boost/shared_ptr.hpp>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class LinearAlgebra2BlockTesterService :
  public ArcaneLinearAlgebra2BlockTesterObject
{
public:
#if defined (USE_ALIEN_V1) || (USE_ALIEN_V2)
  typedef Alien::BlockMatrix MatrixType;
  typedef Alien::BlockVector VectorType;
#endif

  LinearAlgebra2BlockTesterService(const Arcane::ServiceBuildInfo & sbi)
    : ArcaneLinearAlgebra2BlockTesterObject(sbi)
    , m_stencil_kind(Arcane::IK_Unknown)
    , m_diag_coeff(0.) {}

  ~LinearAlgebra2BlockTesterService() {}

public:

  //! Initialization
  void init();

  //! Run the test
  int test();

private:

  void _buildWithStream(Arcane::IntegerConstArrayView allUIndex,
#ifdef USE_ALIEN_V1
                        Alien::Space& space,
#endif
#ifdef USE_ALIEN_V2
                        Alien::ArcaneTools::Space& space,
#endif
                        MatrixType& matrixA,
                        VectorType& vectorB,
                        VectorType& vectorX);

  void _buildWithProfiled(Arcane::IntegerConstArrayView allUIndex,
#ifdef USE_ALIEN_V1
                          Alien::Space& space,
#endif
#ifdef USE_ALIEN_V2
                          Alien::ArcaneTools::Space& space,
#endif
                          MatrixType& matrixA,
                          VectorType& vectorB,
                          VectorType& vectorX);

#ifdef USE_ALIEN_V1
  void _solve(Alien::Space& space,
#endif
#ifdef USE_ALIEN_V2
  void _solve(Alien::ArcaneTools::Space& space,
#endif
              MatrixType& matrixA,
              VectorType& vectorB,
              VectorType& vectorX,
              bool do_algebra_csr);

  Arcane::Real fij(const Arcane::Cell & ci, const Arcane::Cell & cj)
  {
    if (ci == cj)
      return m_diag_coeff;
    else
      return -1;
  }

private:

  Arcane::eItemKind m_stencil_kind;

  Arcane::Real m_diag_coeff;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void LinearAlgebra2BlockTesterService::init()
{
  m_diag_coeff = options()->diagonalCoefficient();
  switch (options()->stencilBy()) {
  case LinearAlgebra2TestOptionTypes::StencilByNode:
    m_stencil_kind = IK_Node;
    break;
  case LinearAlgebra2TestOptionTypes::StencilByFace:
    m_stencil_kind = IK_Face;
    break;
  }

  for (Arcane::Integer i = 0; i < options()->linearSolver.size(); ++i) {
    options()->linearSolver[i]->init();
  }
}

/*---------------------------------------------------------------------------*/

int
LinearAlgebra2BlockTesterService::
test()
{
  {
    info() << "build with stream builder";


#ifdef USE_ALIEN_V1
    Alien::BasicIndexManager index_manager(subDomain()->parallelMng());

    auto indexSetU = index_manager.buildScalarIndexSet("U", allCells());

    index_manager.prepare();
    auto global_size = index_manager.globalSize();
    auto local_size = index_manager.localSize();
    Alien::Space space(global_size, "TestSpace");
    Alien::MatrixDistribution mdist(space, space, local_size, subDomain()->parallelMng());
    Alien::VectorDistribution vdist(space, local_size, subDomain()->parallelMng());
    Alien::Block block(options()->blockSize());
    MatrixType matrixA(block, mdist);
    VectorType vectorB(block,vdist);
    VectorType vectorX(block,vdist);
#endif

#ifdef USE_ALIEN_V2
    Alien::ArcaneTools::BasicIndexManager index_manager(subDomain()->parallelMng());

    auto indexSetU = index_manager.buildScalarIndexSet("U", allCells());

    index_manager.prepare();
    auto global_size = index_manager.globalSize();
    auto local_size = index_manager.localSize();
    auto space = Alien::ArcaneTools::Space(&index_manager, "TestSpace");

    auto mdist = Alien::ArcaneTools::createMatrixDistribution(space);
    auto vdist = Alien::ArcaneTools::createVectorDistribution(space);
    auto block = Alien::Block(options()->blockSize());
    auto matrixA = MatrixType(block, mdist);
    auto vectorB = VectorType(block,vdist);
    auto vectorX = VectorType(block,vdist);
#endif
    Arcane::IntegerSharedArray allUIndex = index_manager.getIndexes(indexSetU);

#ifdef USE_ALIEN_V1
    info() << "Space size = " <<vdist.globalSize()
           << ", local size= " << vdist.localSize();
#endif

    _buildWithStream(allUIndex, space, matrixA, vectorB, vectorX);
    _solve(space, matrixA, vectorB, vectorX, true);
  }

  {
    info() << "build with profiled builder";

#ifdef USE_ALIEN_V1
    Alien::BasicIndexManager index_manager(subDomain()->parallelMng());

    auto indexSetU = index_manager.buildScalarIndexSet("U", allCells());
    index_manager.prepare();
    auto global_size = index_manager.globalSize();
    auto local_size = index_manager.localSize();
    Alien::Space space(global_size, "TestSpace");
    Alien::MatrixDistribution mdist(space, space, local_size, subDomain()->parallelMng());
    Alien::VectorDistribution vdist(space, local_size, subDomain()->parallelMng());
    Alien::Block block(options()->blockSize());
    MatrixType matrixA(block, mdist);
    VectorType vectorB(block,vdist);
    VectorType vectorX(block,vdist);

    info() << "Space size = " << vdist.globalSize()
           << ", local size= " << vdist.localSize();
#endif

#ifdef USE_ALIEN_V2
    Alien::ArcaneTools::BasicIndexManager index_manager(subDomain()->parallelMng());

    auto indexSetU = index_manager.buildScalarIndexSet("U", allCells());

    index_manager.prepare();
    auto global_size = index_manager.globalSize();
    auto local_size = index_manager.localSize();
    auto space = Alien::ArcaneTools::Space(&index_manager, "TestSpace");

    auto mdist = Alien::ArcaneTools::createMatrixDistribution(space);
    auto vdist = Alien::ArcaneTools::createVectorDistribution(space);

    auto block = Alien::Block(options()->blockSize());
    auto matrixA = MatrixType(block, mdist);
    auto vectorB = VectorType(block,vdist);
    auto vectorX = VectorType(block,vdist);
#endif
    Arcane::IntegerSharedArray allUIndex = index_manager.getIndexes(indexSetU);



    _buildWithProfiled(allUIndex, space, matrixA, vectorB, vectorX);
    _solve(space, matrixA, vectorB, vectorX, false);
  }

  return 1;
}

/*---------------------------------------------------------------------------*/

void
LinearAlgebra2BlockTesterService::
_buildWithStream(Arcane::IntegerConstArrayView allUIndex,
#ifdef USE_ALIEN_V1
                 Alien::Space& space,
#endif
#ifdef USE_ALIEN_V2
                 Alien::ArcaneTools::Space& space,
#endif
                 MatrixType& matrixA,
                 VectorType& vectorB,
                 VectorType& vectorX)
{
  CellCellGroup cell_cell_connection(ownCells(), allCells(), m_stencil_kind);

  {
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
    Alien::LocalBlockVectorWriter v(vectorB);
    for (Arcane::Integer i = 0; i < vectorB.distribution().localSize(); ++i)
    {
      ArrayView<Real> values = v[i];
      for(Integer j=0; j < vectorB.block().size();++j)
	values[j] = 2.;
    }
#endif
  }
  {
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
    Alien::LocalBlockVectorWriter v(vectorX);
    for (Arcane::Integer i = 0; i < vectorX.distribution().localSize(); ++i)
    {
      ArrayView<Real> values = v[i];
      for(Integer j=0; j < vectorX.block().size();++j)
	values[j] = 0.;
    }
#endif

    Alien::StreamMatrixBuilder stream_builder(matrixA);

    ///////////////////////////////////////////////////////////////////////////
    //
    // DEFINE PROFILE
    //
    {
      Alien::StreamMatrixBuilder::Profiler & uInserter = stream_builder.getNewInserter(); // id 0
      ARCANE_ASSERT((uInserter.getId() == 0), ("Bad ID"));

      ENUMERATE_ITEMPAIR(Cell, Cell, icell, cell_cell_connection)
      {
        const Arcane::Cell & cell = *icell;
        const Arcane::Integer iIndex = allUIndex[cell.localId()];
        uInserter.addMatrixEntry(iIndex, iIndex);
        ENUMERATE_SUB_ITEM(Cell, isubcell, icell)
        {
          const Arcane::Cell& subcell = *isubcell;
          uInserter.addMatrixEntry(iIndex, allUIndex[subcell.localId()]);
        }
      }
      stream_builder.allocate(); // optional if used with out-of-scope dtor
    }
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
    const Arcane::Integer neq = matrixA.block().size();
    const Arcane::Integer nuk = neq;
#endif
    stream_builder.fillZero();
    {
      Alien::StreamMatrixBuilder::Filler & uInserter = stream_builder.getInserter(0);
      uInserter.start();

      Arcane::RealSharedArray values(neq*nuk);
      ENUMERATE_ITEMPAIR(Cell, Cell, icell, cell_cell_connection)
      {
        const Arcane::Cell & cell = *icell;
        values.fill(0.) ;
        for(Arcane::Integer i=0; i<neq; ++i)
          values[i*neq+i] = fij(cell,cell) ;

        uInserter.addBlockData(values);
        ++uInserter;
        ENUMERATE_SUB_ITEM(Cell, isubcell, icell)
        {
          const Arcane::Cell& subcell = *isubcell;
          //values.fill(fij(cell,subcell));
          for(Arcane::Integer k=0; k<neq; ++k)
            values[k*neq+k] = fij(cell,subcell) ;
          uInserter.addBlockData(values);
          ++uInserter;
        }
      }
    }

    stream_builder.finalize(); // process extra work after filling (squeeze, non-local...)

    //  AsciiDumper dumper(AsciiDumper::eSequentialFixedBlockSizeStype);
    //  dumper.dump(matrixA);
    //  dumper.dump(vectorB);
    //Alien::AsciiDumper dumper;

    //dumper.dump("MATRIX_STREAM.txt", matrixA);
  }
}

/*---------------------------------------------------------------------------*/

void
LinearAlgebra2BlockTesterService::
_buildWithProfiled(Arcane::IntegerConstArrayView allUIndex,
#ifdef USE_ALIEN_V1
                   Alien::Space& space,
#endif
#ifdef USE_ALIEN_V2
                   Alien::ArcaneTools::Space& space,
#endif
                   MatrixType& matrixA,
                   VectorType& vectorB,
                   VectorType& vectorX)
{
  CellCellGroup cell_cell_connection(ownCells(), allCells(), m_stencil_kind);

  {
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
    Alien::LocalBlockVectorWriter v(vectorB);
    for (Arcane::Integer i = 0; i < vectorB.distribution().localSize(); ++i)
    {
      ArrayView<Real> values = v[i];
      for(Integer j=0; j < vectorB.block().size();++j)
	values[j] = 2.;
    }
#endif
  }
  {
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
    Alien::LocalBlockVectorWriter v(vectorX);
    for (Arcane::Integer i = 0; i < vectorX.distribution().localSize(); ++i)
    {
      ArrayView<Real> values = v[i];
      for(Integer j=0; j < vectorX.block().size();++j)
        values[j] = 0.;
    }
#endif
  }

  ///////////////////////////////////////////////////////////////////////////
  //
  // DEFINE PROFILE
  //
  {
    Alien::MatrixProfiler profiler(matrixA);

    ENUMERATE_ITEMPAIR(Cell, Cell, icell, cell_cell_connection)
    {
      const Arcane::Cell & cell = *icell;
      const Arcane::Integer iIndex = allUIndex[cell.localId()];
      profiler.addMatrixEntry(iIndex, allUIndex[cell.localId()]);
      ENUMERATE_SUB_ITEM(Cell, isubcell, icell)
      {
        const Arcane::Cell& subcell = *isubcell;
        profiler.addMatrixEntry(iIndex, allUIndex[subcell.localId()]);
      }
    }
  }
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
  const Arcane::Integer neq = matrixA.block().size();
  const Arcane::Integer nuk = neq;
  Alien::ProfiledBlockMatrixBuilder builder(matrixA, Alien::ProfiledBlockMatrixBuilder::ResetFlag::eResetValues);
#endif
  {

    Arcane::RealSharedArray2 values(neq,nuk);
    ENUMERATE_ITEMPAIR(Cell, Cell, icell, cell_cell_connection)
    {
      const Arcane::Cell & cell = *icell;
      values.fill(0.) ;
      for(Arcane::Integer i=0; i<neq; ++i)
        values[i][i] = fij(cell,cell) ;

      const Arcane::Integer i = allUIndex[cell.localId()];
      builder(i,i) += values;
      ENUMERATE_SUB_ITEM(Cell, isubcell, icell)
      {
        const Arcane::Cell& subcell = *isubcell;
        for(Arcane::Integer k=0; k<neq; ++k)
          values[k][k] = fij(cell,subcell) ;
        const Arcane::Integer j = allUIndex[subcell.localId()];
        builder(i,j) += values;
      }
    }
  }

  //  AsciiDumper dumper(AsciiDumper::eSequentialFixedBlockSizeStype);
  //  dumper.dump(matrixA);
  //  dumper.dump(vectorB);
}

/*---------------------------------------------------------------------------*/

void
LinearAlgebra2BlockTesterService::
#ifdef USE_ALIEN_V1
_solve(Alien::Space& space,
#endif
#ifdef USE_ALIEN_V2
_solve(Alien::ArcaneTools::Space& space,
#endif
       MatrixType& matrixA,
       VectorType& vectorB,
       VectorType& vectorX,
       bool do_algebra_csr)
{
  if(options()->normalise())
  {
    Alien::NormalizeOpt op;
    op.normalize(matrixA,vectorB);
  }

  ///////////////////////////////////////////////////////////////////////////
  //
  // RESOLUTION
  //
  for(Integer i=0;i<options()->linearSolver.size();++i)
  {
    auto* solver = options()->linearSolver[i];
    if (solver->hasParallelSupport() || subDomain()->parallelMng()->commSize() == 1)
    {
      {
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
        Alien::LocalBlockVectorWriter v(vectorX);
        for (Arcane::Integer i = 0; i < vectorX.distribution().localSize(); ++i)
        {
          ArrayView<Real> values = v[i];
          for(Integer j=0; j < vectorX.block().size();++j)
            values[j] = 0.;
        }
#endif
      }

      solver->solve(matrixA,vectorB,vectorX);
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
      std::shared_ptr<Alien::ILinearAlgebra> alg = solver->algebra();
#endif 
      if (alg)
      {
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
        VectorType vectorY(vectorB.block(),vectorB.distribution());
        VectorType vectorRes(vectorB.block(),vectorB.distribution());
#endif
        alg->mult(matrixA, vectorX, vectorY);

        // res = b - A.x
        alg->copy(vectorB, vectorRes);
        alg->axpy(-1., vectorY, vectorRes);

        const Arcane::Real norm = alg->norm2(vectorRes);
        info() << "Residual norm2 by solver linear algebra : " << norm;
      }
      if(do_algebra_csr) {
#if defined(USE_ALIEN_V1) || defined(USE_ALIEN_V2)
        Alien::SimpleCSRLinearAlgebra testAlg;
        VectorType vectorY(vectorB.block(),vectorB.distribution());
        VectorType vectorRes(vectorB.block(),vectorB.distribution());
#endif
        testAlg.mult(matrixA, vectorX, vectorY);
        // res = b - A.x
        testAlg.copy(vectorB, vectorRes);
        testAlg.axpy(-1., vectorY, vectorRes);
        const Arcane::Real norm = testAlg.norm2(vectorRes);
        info() << "Residual norm2 by SimpleCSR algebra : " << norm;
      }
    }
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_LINEARALGEBRA2BLOCKTESTER(LinearAlgebra2BlockTester,LinearAlgebra2BlockTesterService);
