// -*- C++ -*-
/* Author : havep at Wed Jun  5 15:55:12 2013
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "ArcGeoSim/Tests/ServiceTesters/IServiceTester.h"

#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"
#include "ArcGeoSim/Numerics/DiscreteOperator/IDivKGradDiscreteOperator.h"

#ifdef USE_ALIEN_V1
#include <ALIEN/Alien-IFPEN.h>
#include "ArcGeoSim/Numerics/AlienTools/BasicIndexManager.h"
#include "ArcGeoSim/Numerics/AlienTools/VectorAccessor.h"
#include "ArcGeoSim/Numerics/AlienTools/AnyItemAbstractFamily.h"
#endif

#ifdef USE_ALIEN_V2
#include <alien/ref/AlienRefSemantic.h>
#include <alien/arcane_tools/accessors/ItemVectorAccessor.h>
#include <alien/arcane_tools/indexManager/AnyItemAbstractFamily.h>
#include <alien/arcane_tools/IIndexManager.h>
#include <alien/arcane_tools/indexManager/BasicIndexManager.h>
#include <alien/arcane_tools/data/Space.h>
#include <alien/expression/solver/ILinearSolver.h>

#include <alien/arcane_tools/accessors/ItemVectorAccessor.h>

#include <alien/arcane_tools/distribution/DistributionFabric.h>
#endif

#include "AnyItemLinearAlgebra2Tester_axl.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "ArcGeoSim/Mesh/Geometry/ManualUpdateGeometryPolicy.h"

#include "ArcGeoSim/Appli/IAppServiceMng.h"

#include <arcane/anyitem/AnyItem.h>

#include <arcane/Timer.h>
#include <arcane/IMesh.h>
#include <arcane/IItemFamily.h>
#include <arcane/IMainFactory.h>
#include <arcane/Connectivity.h>
#include <arcane/MeshToMeshTransposer.h>

#include <map>
#include <limits>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class AnyItemLinearAlgebra2TesterService 
  : public ArcaneAnyItemLinearAlgebra2TesterObject
{
public:
  
  /** Constructeur de la classe */
  AnyItemLinearAlgebra2TesterService(const Arcane::ServiceBuildInfo & sbi);
 
  /** Destructeur de la classe */
  ~AnyItemLinearAlgebra2TesterService() {}
  
public:

  //! Initialisation
  void init();

  //! Test service function
  int test();

private:
  
  void _test1();
  void _test2();
  void _test3();

  void _prepare();
  void _prepareForSubMeshes();

  void _testSolver();
  void _testSolverWithSubMeshes();

private:
  Arcane::Timer m_timer;
  IGeometryMng * m_geometry_mng;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

AnyItemLinearAlgebra2TesterService::
AnyItemLinearAlgebra2TesterService(const Arcane::ServiceBuildInfo & sbi) 
  : ArcaneAnyItemLinearAlgebra2TesterObject(sbi)
  , m_timer(sbi.subDomain(),"AnyItemTestTimer",Arcane::Timer::TimerVirtual) 
  , m_geometry_mng(NULL)
{
  // Connectivit� des ar�tes
  Arcane::Connectivity c(mesh()->connectivity());
  c.enableConnectivity(Arcane::Connectivity::CT_HasEdge);
}

/*---------------------------------------------------------------------------*/

void 
AnyItemLinearAlgebra2TesterService::
init()
{
  // Ajoute un service en central pour que le sch�ma le trouve
  IAppServiceMng * app_service_mng = IAppServiceMng::instance(subDomain()->serviceMng());
  // app_service_mng->addService(dynamic_cast<IService*>( options()->geometryMng() ), "Geometry Manager");
  // m_geometry_mng = options()->geometryMng();
  m_geometry_mng = app_service_mng->find<IGeometryMng>(true);

  std::cout<<"INIT SOLVER"<<std::endl ;
  options()->linearSolver()->init();
  options()->submeshLinearSolver()->init();

  m_face_variable.fill(1.);
  m_cell_variable.fill(2.);
}

/*---------------------------------------------------------------------------*/

int
AnyItemLinearAlgebra2TesterService::
test()
{
  _test1();
  _test2();
  _test3();
  _testSolver();
  _testSolverWithSubMeshes(); 
  return 1;
}

/*---------------------------------------------------------------------------*/

void 
AnyItemLinearAlgebra2TesterService::
_test1()
{
  info() << "************************************** test 1 :";
 
  // Cr�ation d'une famille aggr�geant des groupes de maille et de face
  AnyItem::Family family;
  family << AnyItem::GroupBuilder( allFaces() ) 
         << AnyItem::GroupBuilder( allCells() );
  
  // Cr�ation d'une variable aggr�geant des variables de maille et de face
  AnyItem::Variable<Real> variable(family);
  variable[allFaces()] << m_face_variable;
  variable[allCells()] << m_cell_variable;
  
  Real value = 0;
  {
    // Enum�ration de la variable aggr�g�e via le groupe aggr�g�
    Arcane::Timer::Sentry t(&m_timer);
    ENUMERATE_ANY_ITEM(iitem, family.allItems()) {
      value += variable[iitem];
    }
  }
  info() << "Aggregate iteration : Value = " << value 
         << ", Time = " << m_timer.lastActivationTime();
  
  AnyItem::Array<Real> array(family.allItems());
  array.fill(0.);

  ENUMERATE_ANY_ITEM(iitem, family.allItems()) {
    array[iitem] += variable[iitem];
  }
 
  value = 0;
  {
    // Enum�ration de la variable aggr�g�e via le groupe aggr�g�
    Arcane::Timer::Sentry t(&m_timer);
    ENUMERATE_ANY_ITEM(iitem, family.allItems()) {
      value += array[iitem];
    }
  }
  info() << "Aggregate iteration trought array : Value = " << value 
         << ", Time = " << m_timer.lastActivationTime();
  
  // La suite sert simplement pour l'�tude de performance
  
  value = 0;
  {
    Arcane::Timer::Sentry t(&m_timer);
    ENUMERATE_FACE(iface, allFaces()) {
      value += m_face_variable[iface];
    }
    ENUMERATE_CELL(icell, allCells()) {
      value += m_cell_variable[icell];
    }
  }
  info() << "Arcane container : Value = " << value
         << ", Time = " << m_timer.lastActivationTime();

  value = 0;
  {
    Arcane::Timer::Sentry t(&m_timer);
    ENUMERATE_ITEM(iitem, allFaces()) {
      value += m_face_variable[iitem];
    }
    ENUMERATE_ITEM(iitem, allCells()) {
      value += m_cell_variable[iitem];
    }
  }
  info() << "Generic arcane container : Value = " << value
         << ", Time = " << m_timer.lastActivationTime();
}

/*---------------------------------------------------------------------------*/

void 
AnyItemLinearAlgebra2TesterService::
_test2()
{
  info() << "************************************** test 2 :";

  Arcane::FaceGroup xmin_faces = mesh()->faceFamily()->findGroup("XMIN");
  
  Arcane::IntegerSharedArray xmin_cell_lids(xmin_faces.size());
  
  ENUMERATE_FACE(iface, xmin_faces) {
    xmin_cell_lids[iface.index()] = iface->boundaryCell().localId();
  }
  
  Arcane::CellGroup xmin_cells = mesh()->cellFamily()->createGroup("XMIN_CELLS", xmin_cell_lids);

  // Cr�ation d'une famille aggr�geant le groupe de maille xmin_cells et de face xmin_faces
  AnyItem::Family family;
  family << AnyItem::GroupBuilder( xmin_faces ) 
         << AnyItem::GroupBuilder( xmin_cells );
  
  AnyItem::Variable<Real> variable(family);
  variable[xmin_faces] << m_face_variable;
  variable[xmin_cells] << m_cell_variable;
  
  //ENUMERATE_AGGREGATE_ITEM(iitem, group) {
  //  info() << variable[iitem];
  //}
  
  AnyItem::LinkFamily link_family(family);
  link_family.reserve(xmin_cells.size());
  
  AnyItem::LinkVariable<Real> link_variable(link_family);
  {
    Arcane::Timer::Sentry t(&m_timer);
    ENUMERATE_FACE(iface, xmin_faces) {
      AnyItem::LinkFamily::Link link = link_family.newLink();
      link(xmin_faces,xmin_cells) << AnyItem::Pair(iface,iface->boundaryCell());
      link_variable[link] = 3.;
    }
  }
  info() << "Add link items = " << m_timer.lastActivationTime();
  
  Real value = 0;
  {
    Arcane::Timer::Sentry t(&m_timer);
    ENUMERATE_ANY_ITEM_LINK(ilink, link_family) {
      if(ilink.index() < 10) {
        info() << "back item = [uid=" << family.item(ilink.back()).uniqueId() 
               << ",lid=" << family.item(ilink.back()).localId() << ",kind="
               << family.item(ilink.back()).kind() << "]";
        info() << "front item = [uid=" << family.item(ilink.front()).uniqueId() 
               << ",lid=" << family.item(ilink.front()).localId() << ",kind="
               << family.item(ilink.front()).kind() << "]";
      }
      value += link_variable[ilink] + variable[ilink.back()] + variable[ilink.front()];
    }
  }
  info() << "enumerate links = " << m_timer.lastActivationTime() << ", value = " << value;
} 

/*---------------------------------------------------------------------------*/

void 
AnyItemLinearAlgebra2TesterService::
_test3()
{
  info() << "************************************** test 3 :";
 
  Arcane::FaceGroup xmin_faces = mesh()->faceFamily()->findGroup("XMIN");
  
  Arcane::IMesh* sub_mesh = subDomain()->mainFactory()->createSubMesh(mesh(), xmin_faces, "XMINMesh");
  
  Arcane::VariableCellReal sub_cell_variable(Arcane::VariableBuildInfo(sub_mesh,"CellVariable"));
  
  sub_cell_variable.fill(3.);
  
  std::map<Int64,Arcane::Cell> uid_to_cell;

  {
    Arcane::Timer::Sentry t(&m_timer);
    ENUMERATE_FACE(iface, xmin_faces) {
      uid_to_cell[iface->uniqueId()] = iface->boundaryCell();
    }
  } 
  info() << "uid to cell time = " << m_timer.lastActivationTime();
  
  //   ENUMERATE_CELL(icell, sub_mesh->allCells()) {
  //     info() << "icell {" << icell->localId() << "," << icell->uniqueId() << "} = " << sub_cell_variable[icell];
  //   }
  //   ENUMERATE_CELL(icell, mesh()->allCells()) {
  //     info() << "icell {" << icell->localId() << "," << icell->uniqueId() << "} = " << m_cell_variable[icell];
  //   }

  Arcane::CellGroup all_cells = allCells();
  Arcane::CellGroup sub_mesh_all_cells = sub_mesh->allCells();
   
  AnyItem::Family family;
  family << AnyItem::GroupBuilder( all_cells )
         << AnyItem::GroupBuilder( sub_mesh_all_cells );

  AnyItem::LinkFamily link_family(family);
  {
    Arcane::Timer::Sentry t(&m_timer);
    const Integer size = xmin_faces.size() + all_cells.innerFaceGroup().size() + sub_mesh_all_cells.innerFaceGroup().size();
    link_family.reserve(size);
  }
  info() << "reserve time = " << m_timer.lastActivationTime();

  AnyItem::LinkVariable<Real> link_variable(link_family);
 
  {
    Arcane::Timer::Sentry t(&m_timer);
    ENUMERATE_CELL(icell, sub_mesh_all_cells) { 
      AnyItem::LinkFamily::Link link = link_family.newLink();
      link(sub_mesh_all_cells,all_cells) << AnyItem::Pair(icell,uid_to_cell[icell->uniqueId()]);
      link_variable[link] = 1.;
    } 
  }
  info() << "add link sub_mesh->allCells() time = " << m_timer.lastActivationTime();

  {
    Arcane::Timer::Sentry t(&m_timer);
    ENUMERATE_FACE(iface, sub_mesh_all_cells.innerFaceGroup()) {
      AnyItem::LinkFamily::Link link = link_family.newLink();
      link(sub_mesh_all_cells,sub_mesh_all_cells) << AnyItem::Pair(iface->backCell(),iface->frontCell());
      link_variable[link] = 2.;
    } 
  }
  info() << "add link sub_mesh->allCells().innerFaceGroup() time = " << m_timer.lastActivationTime();

  {
    Arcane::Timer::Sentry t(&m_timer);
    ENUMERATE_FACE(iface, all_cells.innerFaceGroup()) {
      AnyItem::LinkFamily::Link link = link_family.newLink();
      link(all_cells,all_cells) << AnyItem::Pair(iface->backCell(),iface->frontCell());
      link_variable[link] = 3.;
    } 
  }
  info() << "add link allCells().innerFaceGroup() time = " << m_timer.lastActivationTime();
 
  AnyItem::Variable<Real> variable(family);
  variable[all_cells] << m_cell_variable;
  variable[sub_mesh_all_cells] << sub_cell_variable;
 
  Real value = 0;
  {
    Arcane::Timer::Sentry t(&m_timer);
    ENUMERATE_ANY_ITEM_LINK(ilink, link_family) {
      value += link_variable[ilink] + variable[ilink.back()] + variable[ilink.front()];
    }
  }
  info() << "enumerate links = " << m_timer.lastActivationTime() << ", value = " << value;
}

/*---------------------------------------------------------------------------*/

void 
AnyItemLinearAlgebra2TesterService::
_prepare()
{
  IDivKGradDiscreteOperator* discrete_operator = options()->discreteOperator();
  discrete_operator->init();
  CoefficientArrayT<Cell> cell_coefficients(allFaces(), allCells());
  CoefficientArrayT<Face> face_coefficients(allFaces(), allCells().outerFaceGroup());
  // Pr�paration des sch�mas
  discrete_operator->prepare(mesh(),
                             &cell_coefficients,
                             &face_coefficients);

  IGeometryPolicy* geometry_policy = new ManualUpdateGeometryPolicy;
  m_geometry_mng->setPolicyTolerance(true);
  // Propri�t�s g�om�triques
  m_geometry_mng->addItemGroupProperty(discrete_operator->cells(),
                                     discrete_operator->getCellGeometricProperties(),
                                     IGeometryProperty::PVariable);
  m_geometry_mng->addItemGroupProperty(discrete_operator->faces(),
                                     discrete_operator->getFaceGeometricProperties(),
                                     IGeometryProperty::PVariable);
  m_geometry_mng->addItemGroupProperty(allCells(),
                                     IGeometryProperty::PMeasure,
                                     IGeometryProperty::PVariable);
  // Calcul de la g�om�tries
  m_geometry_mng->update(geometry_policy);
  delete geometry_policy;
  
  // Calcul des transmissivit�s
  {
    Arcane::VariableCellReal k(Arcane::VariableBuildInfo(mesh(),"One"));
    k.fill(1.);
    discrete_operator->formDiscreteOperator(k);
  }
  // Recopie des transmissivit�s (2 pts)
  ENUMERATE_FACE(iface,allFaces()) {
    m_t[iface] = cell_coefficients.coefficients(*iface)[0];
  }

  m_p.fill(0.);
}

/*---------------------------------------------------------------------------*/

void 
AnyItemLinearAlgebra2TesterService::
_testSolver()
{
  using namespace ArcGeoSim::Numerics;

  // Test Jacobi

  _prepare();

  // Construction d'un IIndexManager 


#ifdef USE_ALIEN_V1
  Alien::BasicIndexManager index_manager(subDomain()->parallelMng());
  index_manager.setTraceMng(traceMng());

  auto indexSetP = index_manager.buildScalarIndexSet("P", allCells());

  index_manager.prepare();
  auto global_size = index_manager.globalSize();
  auto local_size = index_manager.localSize();
  Alien::Space space(global_size, "TestSpace");
  Alien::MatrixDistribution mdist(space, space, local_size, subDomain()->parallelMng());
  Alien::VectorDistribution vdist(space, local_size, subDomain()->parallelMng());
  Alien::Vector vectorB(vdist);
  Alien::Matrix matrixA(mdist);
#endif

#ifdef USE_ALIEN_V2
  auto index_manager = Alien::ArcaneTools::BasicIndexManager(subDomain()->parallelMng());
  index_manager.setTraceMng(traceMng());

  auto indexSetP = index_manager.buildScalarIndexSet("P", allCells());

  index_manager.prepare();

  auto space      = Alien::ArcaneTools::Space(&index_manager, "TestSpace");

  auto mdist       = Alien::ArcaneTools::createMatrixDistribution(space);
  auto vdist       = Alien::ArcaneTools::createVectorDistribution(space);


  auto vectorB = Alien::Vector(vdist);
  auto matrixA = Alien::Matrix(mdist);
#endif
  IntegerSharedArray allPIndex = index_manager.getIndexes(indexSetP);
  {
    Alien::DirectMatrixBuilder builder(matrixA, Alien::DirectMatrixBuilder::ResetFlag::eResetValues);
    // builder.reserve(...); // todo: ajuster la r�servation
    builder.allocate(); 


    Alien::VectorWriter vB(vectorB);

    ENUMERATE_FACE(iface, allCells().innerFaceGroup()) {
      const Cell& back = iface->backCell();
      const Cell& front = iface->frontCell();
      const Integer indexBack = allPIndex[back.localId()];
      const Integer indexFront = allPIndex[front.localId()];
      if (back.isOwn()) {
        builder.addData(indexBack,indexBack,m_t[iface]);
        builder.addData(indexBack,indexFront,- m_t[iface]);
        vB[indexBack] = 0;
      }
      if (front.isOwn()) {
        builder.addData(indexFront,indexFront,m_t[iface]);
        builder.addData(indexFront,indexBack,- m_t[iface]);
        vB[indexFront] = 0;
      }
    }

    FaceGroup XMax = mesh()->faceFamily()->findGroup("XMAX");
    Arcane::PartialVariableFaceReal p_b_max(Arcane::VariableBuildInfo(mesh(),"XMAXPartial",String(),"XMAX"));
    p_b_max.fill(10.);
    ENUMERATE_FACE(iface, XMax) {
      const Cell& cell = iface->boundaryCell();
      if (cell.isOwn()) {
        const Integer index = allPIndex[cell.localId()];
        builder.addData(index, index, m_t[iface]);
        vB[index] += m_t[iface] * p_b_max[iface];
      }
    }
  
    FaceGroup XMin = mesh()->faceFamily()->findGroup("XMIN");
    Arcane::PartialVariableFaceReal p_b_min(Arcane::VariableBuildInfo(mesh(),"XMINPartial",String(),"XMIN"));
    p_b_min.fill(5.);
    ENUMERATE_FACE(iface, XMin) {
      const Cell& cell = iface->boundaryCell();
      if (cell.isOwn()) {
        const Integer index = allPIndex[cell.localId()];
        builder.addData(index, index, m_t[iface]);
        vB[index] += m_t[iface] * p_b_min[iface];
      }
    }
  }


  Alien::Vector vectorX(vdist);

  auto* solver = options()->linearSolver();
  solver->solve(matrixA, vectorB, vectorX);

  auto status = solver->getStatus();
  if (status.succeeded)
    {
      info() << "Solver succeeds with " << status.iteration_count << " iterations";
    }
  else
    {
      fatal() << "Error in linear solver";
    }

  {
#ifdef USE_ALIEN_V1
    Alien::ItemVectorAccessor v(vectorX);
    Alien::Variable(m_p)    = v(indexSetP);
#endif
#ifdef USE_ALIEN_V2
    Alien::ArcaneTools::ItemVectorAccessor v(vectorX);
    Alien::ArcaneTools::Variable(m_p)    = v(indexSetP);
#endif

    // m_p.synchronize(); // valeurs par d�faut non synchronis�es
  }

  //  ENUMERATE_CELL(icell,ownCells()) {
  //    info() << m_p[icell];
  //  }
  //#endif
}

/*---------------------------------------------------------------------------*/

void 
AnyItemLinearAlgebra2TesterService::
_prepareForSubMeshes()
{
  const IGeometryMng::Real3Variable & cell_center = 
    m_geometry_mng->getReal3VariableProperty(allCells(), IGeometryProperty::PCenter);

  Real x_min = std::numeric_limits<Real>::max();
  Real x_max = std::numeric_limits<Real>::min();
  ENUMERATE_CELL(icell,allCells()) {
    x_min = math::min(x_min, cell_center[icell].x);
    x_max = math::max(x_max, cell_center[icell].x);
  }
  
  Real mid = (x_max + x_min) * 0.5;

  Arcane::IntegerSharedArray left;
  left.reserve(allCells().size());
  Arcane::IntegerSharedArray right;
  left.reserve(allCells().size());

  Arcane::VariableCellInteger flags(Arcane::VariableBuildInfo(mesh(),"Flags"));
  
  ENUMERATE_CELL(icell,allCells()) {
    if(cell_center[icell].x < mid) {
      left.add(icell->localId());
      flags[icell] = 0;
    } else {
      right.add(icell->localId());
      flags[icell] = 1;
    }
  }
  
  Arcane::IntegerSharedArray lids;
  lids.reserve(allFaces().size());
  ENUMERATE_FACE(iface,allCells().innerFaceGroup()) {
    if(flags[iface->frontCell()] == 1 && flags[iface->backCell()] == 0) 
      lids.add(iface->localId());
    if(flags[iface->frontCell()] == 0 && flags[iface->backCell()] == 1) 
      lids.add(iface->localId());
  }

  mesh()->faceFamily()->createGroup("Interface", lids);

  Arcane::CellGroup left_cells = mesh()->cellFamily()->createGroup("LeftCells", left);
  
  Arcane::IMesh* left_mesh = subDomain()->mainFactory()->createSubMesh(mesh(), left_cells, "LeftMesh");
  
  Arcane::CellGroup right_cells = mesh()->cellFamily()->createGroup("RightCells", right);
  
  Arcane::IMesh* right_mesh = subDomain()->mainFactory()->createSubMesh(mesh(), right_cells, "RightMesh");

  FaceGroup XMax = mesh()->faceFamily()->findGroup("XMAX");
  
  ItemVector right_xmax = Arcane::MeshToMeshTransposer::transpose(mesh(), right_mesh, XMax.view());
  
  right_mesh->faceFamily()->createGroup("XMAX", right_xmax.view().localIds());

  FaceGroup XMin = mesh()->faceFamily()->findGroup("XMIN");
  
  ItemVector right_xmin = Arcane::MeshToMeshTransposer::transpose(mesh(), left_mesh, XMin.view());
  
  left_mesh->faceFamily()->createGroup("XMIN", right_xmin.view().localIds());
}

/*---------------------------------------------------------------------------*/

void 
AnyItemLinearAlgebra2TesterService::
_testSolverWithSubMeshes()
{
  using namespace ArcGeoSim::Numerics;

  // test solver with submeshes and any item tools
  
  _prepareForSubMeshes();
  
  Arcane::IMesh* left_mesh  = subDomain()->findMesh("LeftMesh");
  Arcane::IMesh* right_mesh = subDomain()->findMesh("RightMesh");

  Arcane::CellGroup  left_all_cells =  left_mesh->allCells();
  Arcane::CellGroup right_all_cells = right_mesh->allCells();

  Arcane::FaceGroup  left_xmin_faces =  left_mesh->faceFamily()->findGroup("XMIN");
  Arcane::FaceGroup right_xmax_faces = right_mesh->faceFamily()->findGroup("XMAX");
  
  AnyItem::Family family;
  family << AnyItem::GroupBuilder( left_all_cells )
         << AnyItem::GroupBuilder( right_all_cells )
         << AnyItem::PartialGroupBuilder( left_xmin_faces )
         << AnyItem::PartialGroupBuilder( right_xmax_faces );
    
  Arcane::SharedVariableFaceReal  left_t( left_mesh->faceFamily(), m_t);
  Arcane::SharedVariableFaceReal right_t(right_mesh->faceFamily(), m_t);
   
  FaceGroup interface = mesh()->faceFamily()->findGroup("Interface");
  
  std::map<Int64,Arcane::Cell> left_face_to_cell;
  FaceVector left_interface = Arcane::MeshToMeshTransposer::transpose(mesh(), left_mesh, interface.view());
  ENUMERATE_FACE(iface, left_interface) {
    left_face_to_cell[iface->uniqueId()] = iface->boundaryCell();
  }
  
  AnyItem::LinkFamily link_family(family);
  link_family.reserve( left_mesh->allCells().innerFaceGroup().size()  +
                       right_mesh->allCells().innerFaceGroup().size() +
                       interface.size() );
  AnyItem::LinkVariable<Real> t(link_family); 
  
  FaceVector right_interface = Arcane::MeshToMeshTransposer::transpose(mesh(), right_mesh, interface.view());
  ENUMERATE_FACE(iface, right_interface) {
    AnyItem::LinkFamily::Link link = link_family.newLink();
    link(left_all_cells,right_all_cells) << AnyItem::Pair(left_face_to_cell[iface->uniqueId()],iface->boundaryCell());
    t[link] = left_t[iface];
  }
  ENUMERATE_FACE(iface, left_mesh->allCells().innerFaceGroup()) {
    AnyItem::LinkFamily::Link link = link_family.newLink();
    link(left_all_cells,left_all_cells) << AnyItem::Pair(iface->frontCell(),iface->backCell());
    t[link] = left_t[iface];
  }
  ENUMERATE_FACE(iface, right_mesh->allCells().innerFaceGroup()) {
    AnyItem::LinkFamily::Link link = link_family.newLink();
    link(right_all_cells,right_all_cells) << AnyItem::Pair(iface->frontCell(),iface->backCell());
    t[link] = right_t[iface];
  }
 
  AnyItem::LinkFamily b_link_family(family);
  b_link_family.reserve( right_xmax_faces.size() + left_xmin_faces.size() );
  AnyItem::LinkVariable<Real> t_b(b_link_family); 
 
  ENUMERATE_FACE(iface, right_xmax_faces) {
    AnyItem::LinkFamily::Link link = b_link_family.newLink();
    link(right_all_cells,right_xmax_faces) << AnyItem::Pair(iface->boundaryCell(),iface);
    t_b[link] = right_t[iface];
  }
  ENUMERATE_FACE(iface, left_xmin_faces) {
    AnyItem::LinkFamily::Link link = b_link_family.newLink();
    link(left_all_cells,left_xmin_faces) << AnyItem::Pair(iface->boundaryCell(),iface);
    t_b[link] = left_t[iface];
  }
  
  Arcane::VariableCellReal p_left(Arcane::VariableBuildInfo(left_mesh,"LeftP"));
  Arcane::VariableCellReal p_right(Arcane::VariableBuildInfo(right_mesh,"RightP"));
  AnyItem::Variable<Real> p(family);
  p[ left_all_cells] << p_left;
  p[right_all_cells] << p_right;

  // Acces � l'IndexManager du builder

#ifdef USE_ALIEN_V1
  Alien::BasicIndexManager index_manager(subDomain()->parallelMng());
  index_manager.setTraceMng(traceMng());

  auto indexSetP = index_manager.buildScalarIndexSet("P", Alien::AnyItemAbstractFamily(family, &index_manager));
  index_manager.prepare();
  auto global_size = index_manager.globalSize();
  auto local_size = index_manager.localSize();
  Alien::Space space(global_size, "TestSpace");
  Alien::MatrixDistribution mdist(space, space, local_size, subDomain()->parallelMng());
  Alien::VectorDistribution vdist(space, local_size, subDomain()->parallelMng());
  Alien::Vector vectorB(vdist);
  Alien::Matrix matrixA(mdist);
#endif

#ifdef USE_ALIEN_V2
  Alien::ArcaneTools::BasicIndexManager index_manager(subDomain()->parallelMng());
  index_manager.setTraceMng(traceMng());

  auto indexSetP = index_manager.buildScalarIndexSet("P", Alien::ArcaneTools::AnyItemAbstractFamily(family, &index_manager));
  index_manager.prepare();

  auto space = Alien::ArcaneTools::Space(&index_manager, "TestSpace");

  auto mdist = Alien::ArcaneTools::createMatrixDistribution(space);
  auto vdist = Alien::ArcaneTools::createVectorDistribution(space);

  auto vectorB = Alien::Vector(vdist);
  auto matrixA = Alien::Matrix(mdist);
#endif
  IntegerSharedArray indexes = index_manager.getIndexes(indexSetP);
  {
    Alien::DirectMatrixBuilder builder(matrixA, Alien::DirectMatrixBuilder::ResetFlag::eResetValues);
    // builder.reserve(...); // todo: ajuster la r�servation
    builder.allocate(); 
    

    Alien::VectorWriter vB(vectorB);
    ENUMERATE_ANY_ITEM(iitem, family.allItems()) {
      if (family.item(iitem).isOwn()) {
        const Integer index = indexes[iitem.localId()];
        builder.addData(index,index,1); // HACK: add always a diagonal value
        vB[index] = 0;
      }
    }

    ENUMERATE_ANY_ITEM_LINK(ilink, link_family) {
      const Integer indexBack = indexes[ilink.back().localId()];
      const Integer indexFront = indexes[ilink.front().localId()];
      if (family.item(ilink.back()).isOwn()) {
        builder.addData(indexBack,indexBack,t[ilink]);
        builder.addData(indexBack,indexFront,-t[ilink]);
        vB[indexBack] += 0;
      }
      if (family.item(ilink.front()).isOwn()) {
        builder.addData(indexFront,indexFront,t[ilink]);
        builder.addData(indexFront,indexBack,-t[ilink]);
        vB[indexFront] += 0;
      }
    }
 
    FaceGroup XMax = mesh()->faceFamily()->findGroup("XMAX");
    Arcane::PartialVariableFaceReal p_b_max(Arcane::VariableBuildInfo(mesh(),"XMAXPartial",String(),"XMAX"));
    p_b_max.fill(10.);
    FaceGroup XMin = mesh()->faceFamily()->findGroup("XMIN");
    Arcane::PartialVariableFaceReal p_b_min(Arcane::VariableBuildInfo(mesh(),"XMINPartial",String(),"XMIN"));
    p_b_min.fill(5.);
  
    AnyItem::Variable<Real> p_b(family);
    p_b[left_xmin_faces] << p_b_min;
    p_b[right_xmax_faces] << p_b_max;

    ENUMERATE_ANY_ITEM_LINK(ilink, b_link_family) {
      if (family.item(ilink.back()).isOwn()) {
        const Integer index = indexes[ilink.back().localId()];
        builder.addData(index,index, t_b[ilink]);
        vB[index] += t_b[ilink] * p_b[ilink.front()];
      }
    }
  }

  Alien::Vector vectorX(vdist);
  auto* solver = options()->submeshLinearSolver();
  solver->solve(matrixA, vectorB, vectorX);

  auto status = solver->getStatus();
  if (status.succeeded)
    {
      info() << "Solver succeeds with " << status.iteration_count << " iterations";
    }
  else
    {
      fatal() << "Error in linear solver";
    }

  {
#ifdef USE_ALIEN_V1
    Alien::ItemVectorAccessor v(vectorX);
    Alien::Variable(p) = v(indexSetP);
    v(indexSetP)  = Alien::Variable(p);
#endif
#ifdef USE_ALIEN_V2
    Alien::ArcaneTools::ItemVectorAccessor v(vectorX);
    Alien::ArcaneTools::Variable(p) = v(indexSetP);
    v(indexSetP)  = Alien::ArcaneTools::Variable(p);
#endif

    // p_left.synchronize(); // valeurs par d�faut non synchronis�es
    // p_right.synchronize();
  }

  ENUMERATE_CELL(icell,left_mesh->allCells()) {
    info() << p_left[icell];
  }
  ENUMERATE_CELL(icell,right_mesh->allCells()) {
    info() << p_right[icell];
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_ANYITEMLINEARALGEBRA2TESTER(AnyItemLinearAlgebra2Tester,AnyItemLinearAlgebra2TesterService);
