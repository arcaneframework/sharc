// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
/* Author : desrozis at Mon Jun 29 15:42:33 2015
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "ArcGeoSim/Tests/ServiceTesters/IServiceTester.h"
#include "GumpTester_axl.h"

#include "ArcGeoSim/Physics/Gump/Factory.h"
#include "ArcGeoSim/Physics/Gump/Enumerator.h"
#include "ArcGeoSim/Physics/Gump/Property.h"
#include "ArcGeoSim/Physics/Gump/IO.h"
#include "ArcGeoSim/Physics/Gump/XPath.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class GumpTesterService
  : public ArcaneGumpTesterObject
{
public:
 
  GumpTesterService(const Arcane::ServiceBuildInfo& sbi)
    : ArcaneGumpTesterObject(sbi) {}
  
  ~GumpTesterService() {}
  
public:
  
  void init() {}

  Arcane::Integer test()
  {
    test_1();
    test_2();
    return 1;
  }
  
  void test_1();
  void test_2();
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
GumpTesterService::
test_1()
{
  info() << "test_1";

  Gump::Entity main;
  
  {
    Gump::Factory factory(3,4,3);
    
    Gump::Builder leaf_1_in_2 = factory.create("leaf_1_in_2", 2,  3);
    Gump::Builder leaf_2_in_2 = factory.create("leaf_2_in_2", 2,  3);
    Gump::Builder leaf_1_in_1 = factory.create("leaf_1_in_1", 2,  2);
    Gump::Builder leaf_2_in_1 = factory.create("leaf_2_in_1", 2,  2);
    Gump::Builder branch_2    = factory.create("branch_2",    1,  1);
    Gump::Builder branch_1    = factory.create("branch_1",    1,  0);
    Gump::Builder root        = factory.create("root",        0    );

    root.push<Gump::eScalar, Arcane::Real>("property_0", 0);
    root.push<Gump::eScalar, Arcane::Real>("property_1", 1);

    leaf_2_in_2.push<Gump::eVectorial, Arcane::Integer>("property_2", 2);

    root.push(branch_2);
    root.push(branch_1);
    
    branch_1.push(leaf_1_in_1);
    branch_1.push(leaf_2_in_1);
    
    branch_2.push(leaf_1_in_2);
    branch_2.push(leaf_2_in_2);
    
    main = root.entity();
  }
  
  info() << main;

  info() << " ";
  info() << "** enumerate entities with kind 1 and subentities with kind 2 from main";
  info() << " ";
  for(auto e = main.entities(1); e.hasNext(); ++e) {
    info() << "entity " << e->name()
           << " with kind " << e->kind()
           << " and tag " << e->tag();
    info() << " => uid = " << e->uniqueId()
           << ", fid = " << e->familyId();
    info() << *e;
    for(auto ee = e->entities(2); ee.hasNext(); ++ee) {
      info() << "  entity " << ee->name()
             << " with kind " << ee->kind()
             << " and tag " << ee->tag();
      info() << "   => uid = " << ee->uniqueId()
             << ", fid = " << ee->familyId();
      info() << "  " << *ee;
    }
  }

  info() << " ";
  info() << "** enumerate [c++11] entities with kind 1 and subentities with kind 2 from main";
  info() << " ";
  for(auto e : main.entities(1)) {
    info() << "entity " << e.name()
           << " with kind " << e.kind()
           << "  and tag " << e.tag();
    info() << "   => uid = " << e.uniqueId()
           << ", fid = " << e.familyId();
    info() << e;
    for(auto ee : e.entities(2)) {
      info() << "  entity " << ee.name()
             << " with kind " << ee.kind()
             << " and tag " << ee.tag();
      info() << "   => uid = " << ee.uniqueId()
             << ", fid = " << ee.familyId();
      info() << "  " << ee;
    }
  }
    
  info() << " ";
  info() << "** enumerate entities with kind 2 from main";
  info() << " ";
  for(auto e = main.entities(2); e.hasNext(); ++e) {
    info() << "entity " << e->name()
           << " with kind " << e->kind()
           << " and tag " << e->tag();
    info() << " => uid = " << e->uniqueId()
           << ", fid = " << e->familyId();
    info() << *e;
  }

  info() << " ";
  info() << "** enumerate entities with kind 2 and tag 3 from main";
  info() << " ";
  for(auto e = main.entities(2,3); e.hasNext(); ++e) {
    info() << "entity " << e->name()
           << " with kind " << e->kind()
           << " and tag " << e->tag();
    info() << " => uid = " << e->uniqueId()
           << ", fid = " << e->familyId();
    info() << *e;
  }

  info() << " ";
  info() << "** property xpath";
  info() << " ";
  {
    Gump::XPath<Gump::Entity> xpath;
    
    auto leaf_1_in_2 = xpath(main,"root.branch_2.leaf_1_in_2");
    
    info() << leaf_1_in_2;
  }

  Gump::Property p0(0, main);
  info() << "property " << p0.name()
         << ", uid = " << p0.uniqueId();
  info() << p0;
  
  Gump::Property p1(1, main);
  info() << "property " << p1.name()
         << ", uid = " << p1.uniqueId();
  info() << p1;
  
  {
    Gump::XPath<Gump::Property> xpath;
    
    auto p0 = xpath(main,"root.property_0");

    info() << p0;
    
    auto p2 = xpath(main,"root.branch_2.leaf_2_in_2.property_2");

    info() << p2;
  }

  main.kill();
}

/*---------------------------------------------------------------------------*/

void
GumpTesterService::
test_2()
{
  info() << "test_2";

  // Mode sans entites
  Law::ScalarRealProperty P(0,"P");
  Law::VectorialRealProperty S(1,"S",3);

  Law::VectorialRealProperty s;
  s = S;

  auto s2 = Law::VectorialRealProperty(1,"S",3);
  
  info() << s;
  info() << s2;
  info() << S;

  // Fonctionne pour Gump mais pas Law
  //info() << (s == s2) << "," << (s == S);
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_GUMPTESTER(GumpTester, GumpTesterService);
