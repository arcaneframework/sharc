#include "LUSolverTesterService.h"
/* Author : dipietrd at Thu Jan  3 10:16:59 2008
 * Generated by createNew
 */

#include <boost/version.hpp>
#if BOOST_VERSION >= 106400
#include <boost/serialization/array_wrapper.hpp>
#endif
#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/vector_proxy.hpp>
#include <boost/numeric/ublas/io.hpp>

#include "ArcGeoSim/Numerics/Utils/Algorithms/LUSolver.h"

using namespace Arcane;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void LUSolverTesterService::init() {
}

/*---------------------------------------------------------------------------*/

int LUSolverTesterService::test() {
    namespace ublas = boost::numeric::ublas;

    const int N = 10;

    ublas::matrix<Real> A(N, N);
    ublas::matrix<Real> B( ublas::scalar_matrix<Real>(N, 2, 1.) );
    ublas::vector<Real> x(N);
    ublas::matrix<Real> X( ublas::scalar_matrix<Real>(N, 2, 1.) );

    ublas::vector<Real> b1( ublas::scalar_vector<Real>(N, 1.) );
    ublas::vector<Real> b2( ublas::scalar_vector<Real>(2*N, 1.) );

    ublas::vector_range<ublas::vector<Real> > rb2(b2, ublas::range(0, N));

    // A is a perturbed (non symmetric) Hilbert matrix
    for(int i = 0; i < N; i++)
    for(int j = 0; j < N; j++)
    A(i, j) = 1. / (i + j + 1.);
    A(N-1, N-1) += 1;
    LUSolver<Real>::matrix_type A1(A);

    info() << "A   = " << A;
    info() << "b1  = " << b1;
    info() << "rb2 = " << rb2;

    // Supposed to work
    info() << "** Factorize and solve";
    LUSolver<Real> luA;
    try { 
    luA.factor(A); 
    x = luA.solve(b1);
    info() << "x   = " << x;
    x = luA.solve(rb2);
    info() << "x   = " << x;
    X = luA.solve(B);
    info() << "x   = " << X;
    }
    catch(LUSolver<Real>::Error e){ fatal() << e.msg; }
    catch(LUSolver<Real>::Warning w) { warning() << w.msg; }

    // Supposed to throw an error since B is not square
    info() << "** Test consistency check";
    LUSolver<Real> luB;
    try { luB.factor(B); }
    catch(LUSolver<Real>::Error e) { info() << "Expected error : " << e.msg; }
    catch(LUSolver<Real>::Warning w) { warning() << w.msg; }

    // Solve and overwrite the factorization
    info() << "** Solve and overwrite the factorization";
    info() << "A  = " << A;
    try {
    x = luA.solve(A, b1);
    info() << "x  = " << x;
    info() << "A  = " << A;
    }
    catch(LUSolver<Real>::Error e){ fatal() << e.msg; }
    catch(LUSolver<Real>::Warning w) { warning() << w.msg; }

    // Solve and overwrite both the factorization and the solution
    info() << "** Solve and overwrite both the factorization and the solution";
    LUSolver<Real> luA1;
    LUSolver<Real>::vector_type b3(b1);
    info() << "A1 = " << A1;
    try {
    luA1.overwrite_solve(A1, b3);
    info() << "b1 = " << b1;
    info() << "b3 = " << b3;
    info() << "A1 = " << A1;
    }
    // After factorization, it is correct that A1 = A^t, since the former
    // is stored column-wise, while the latter is stored row-wise (see the 
    // note in the help of LUSolver class for the details)
    catch(LUSolver<Real>::Error e){ fatal() << e.msg; }
    catch(LUSolver<Real>::Warning w) { warning() << w.msg; }

    return 1;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_LUSOLVERTESTER(LUSolverTester,LUSolverTesterService);
