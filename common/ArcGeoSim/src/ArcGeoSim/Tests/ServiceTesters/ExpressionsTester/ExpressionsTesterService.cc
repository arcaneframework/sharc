#include "ExpressionsTesterService.h"
/* Author : desrozis at Wed Mar 25 15:33:55 2009
 * Generated by createNew
 */

#include <arcane/ITimeLoopMng.h>
#include <arcane/utils/ValueConvert.h>
#include <arcane/utils/Math.h>
#include <arcane/Timer.h>

#include <arcane/ArcaneVersion.h>
#include <arcane/utils/Array.h>

#include "ArcGeoSim/Appli/IAppServiceMng.h"
#include "ArcGeoSim/Utils/IOBuffer.h"
#include "ArcGeoSim/Utils/Table.h"
#include "ArcGeoSim/Numerics/Expressions/Polynom/Polynom.h"
#include "ArcGeoSim/Numerics/Expressions/PieceWiseFunction/PieceWiseFunctionR1vR1.h"
#include "ArcGeoSim/Numerics/Expressions/PieceWiseFunction/PieceWiseFunctionR2vR1.h"
#include "ArcGeoSim/Numerics/Expressions/PieceWiseFunction/IPieceWiseFunction.h"
#include "ArcGeoSim/Numerics/Expressions/PieceWiseFunction/LinearPieceWiseFunction/LinearInterpolator.h"
#include "ArcGeoSim/Numerics/Expressions/PieceWiseFunction/BiLinearPieceWiseFunction/BiLinearInterpolator.h"
#include "ArcGeoSim/Numerics/Expressions/IFunctionR1vR1Transformer.h"
#include "ArcGeoSim/Numerics/Expressions/PieceWiseFunction/PieceWiseFunctionR1vR1Transformer.h"
#include "ArcGeoSim/Numerics/Expressions/UnsteadyRegularGridData/UnsteadyRegularGridData.h"
#include "ArcGeoSim/Numerics/Expressions/UnsteadyRegularGridData/OnePointInterpGridDataFunction/OnePointGridDataInterpolator.h"
#include "ArcGeoSim/Numerics/Expressions/UnsteadyRegularGridData/LinearInterpGridDataFunction/LinearInterpGridDataInterpolator.h"
#include "ArcGeoSim/Numerics/Expressions/UnsteadyRegularGridData/IUnsteadyRegularGridData.h"
#include "ArcGeoSim/Numerics/Expressions/KozenyCarmannFunction/KozenyCarmannFunction.h"
#include "ArcGeoSim/Numerics/Expressions/ExpressionBuilder/ExpressionBuilderR1vR1Core.h"
#include "ArcGeoSim/Numerics/Expressions/FunctionParser/FunctionParser.h"

using ArcGeoSim::Numerics::Expressions::Polynom;

using namespace Arcane;


/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
ExpressionsTesterService::
init()
{
  ;
}

/*---------------------------------------------------------------------------*/

int
ExpressionsTesterService::
test()
{
  _functionalTest();
  _performanceTest();

  return 1;
}


/*---------------------------------------------------------------------------*/

void
ExpressionsTesterService::_functionalTest()
{
      {
        info() << "Fonction f4";
        IFunctionR3vR1 * f4 = options()->f4();
        f4->init();

        Integer n = 6;

        SharedArray<Real> x, y, z, r;
        x.resize(n);
        x.fill(1.);
        y.resize(n);
        y.fill(1.);
        z.resize(n);
        z.fill(1.);
        r.resize(n);

        f4->setParameter("t", 0.5);

        f4->eval(x, y, z, r);

        for (Integer i = 0; i < n; ++i)
          {
            info() << " result " << i << " = " << r[i];
          }
      }

      {
        info() << "Fonction f5";
        IFunctionR1vR1 * f5 = options()->f5();
        f5->init();

        Integer n = 6;

        SharedArray<Real> x, r;
        x.resize(n);
        x.fill(1.);
        r.resize(n);

        f5->eval(x, r);

        for (Integer i = 0; i < n; ++i)
          {
            info() << " result " << i << " = " << r[i];
          }
        info() << " point result = " << f5->eval(0.3);
      }

      {
        info() << "Fonction f6";
        IFunctionR1vR1 * f6 = options()->f6();
        f6->init();

        Integer n = 6;

        SharedArray<Real> x, r;
        x.resize(n);
        x[0] = 0.9;
        x[1] = 0.01;
        x[2] = 0.8;
        x[3] = 0.04;
        x[4] = 0.5;
        x[5] = 0.08;
        r.resize(n);

        f6->eval(x, r);

        for (Integer i = 0; i < n; ++i)
          {
            info() << " result " << i << " = " << r[i];
          }
        info() << " point result( 0.3) = " << f6->eval(0.3);
        info() << " point result(0.01) = " << f6->eval(0.01);
        info() << " point result(  0.) = " << f6->eval(0.);
      }

      {
        info() << "Fonction f7";
        IFunctionR1vR1 * f7 = options()->f7();
        f7->init();

        Integer n = 6;

        SharedArray<Real> x, r;
        x.resize(n);
        x[0] = -100.;
        x[1] = -2;
        x[2] = 0.;
        x[3] = 1.;
        x[4] = 2.;
        x[5] = 10.;
        r.resize(n);

        f7->eval(x, r);

        for (Integer i = 0; i < n; ++i)
          {
            info() << " result " << i << " = " << r[i];
          }
      }

        // COMPARE IFUNCTION BASED AND IPHYSICALLAW BASED TABLES
        // detailed performance comparison between these two elements
        // (already synthetically assessed in _perfomanceTest() method
        // can be included using cpuTest option (use release compilation)
        // In this case nb_points = 2000000; and nloop = 500;

        // Choose if cpu_test or validation
        m_table_impl_cpu_comparison = options()->tableImplCpuComparison();
        if (!m_table_impl_cpu_comparison)
          {
            m_nb_points = 10; //
          }
        else
          {
            m_nb_points = 2000000; // 2000000 for tests in report
            m_total_loop = 500; // 500 for tests in report: used to increase number of eval without inscreasing array size
            m_xmax_table = 19.5; // max table value for cpu test
            m_xmin_table = 0.; // max table value
          }

        //! Declare enumeration for table access choice (random, first elements or last elements)
        EvalTableTypes::eChoice choice;

        //! Random access for validation test
        choice = EvalTableTypes::Random;

        /* IFUNCTION LINEAR INTERPOLATOR */

        //! Get IFunction
        pinfo()
            << "-------Start New Linear IFunction Evaluation-----------------";
        pinfo() << "Test fonction f9 : Linear Interpolator";
        IFunctionR1vR1 * ifunc_linear_interp = options()->f9();
        ifunc_linear_interp->init();

        if (!m_table_impl_cpu_comparison)
          {
            m_xmax_table = 9.5; // max table value
            m_xmin_table = 0.; // min table value
            // Test out of bound behavior
            pinfo() << " TEST BORNES : INFINITE LINEAR PROLONGATION";
            pinfo() << "Test bornes f(-2)="  << ifunc_linear_interp->eval(-2);
            pinfo() << "Test bornes f'(-2)=" << ifunc_linear_interp->diffEval(-2);
            pinfo() << "Test bornes f(-3)="  << ifunc_linear_interp->eval(-3);
            pinfo() << "Test bornes f'(-3)=" << ifunc_linear_interp->diffEval(-3);
            pinfo() << "Test bornes f(40)="  << ifunc_linear_interp->eval(40);
            pinfo() << "Test bornes f'(40)=" << ifunc_linear_interp->diffEval(40);
            pinfo() << "Test bornes f(50)="  << ifunc_linear_interp->eval(50);
            pinfo() << "Test bornes f'(50)="  << ifunc_linear_interp->diffEval(50);
            pinfo() << "Test bornes f(xmax)=" << ifunc_linear_interp->eval(
                m_xmax_table);
            pinfo() << " FIN TEST BORNES";

            //! Test Linear IFunction
            evalTable<IFunctionR1vR1*> (ifunc_linear_interp, choice);
            //! Eval derivative
            diffEvalTable(ifunc_linear_interp);

          }
        else
          {
            //! Test IFunction for random access
            choice = EvalTableTypes::Random;
            evalTable<IFunctionR1vR1*> (ifunc_linear_interp, choice);
            //        evalTable<PieceWiseFunction*> (fPWF, choice); // to avoid inheritance cost

            //! Test IFunction for first element access
            choice = EvalTableTypes::FirstElements;
            evalTable<IFunctionR1vR1*> (ifunc_linear_interp, choice);
            //        evalTable<PieceWiseFunction*> (fPWF, choice); // to avoid inheritance cost

            //! Test IFunction for first element access
            choice = EvalTableTypes::LastElements;
            evalTable<IFunctionR1vR1*> (ifunc_linear_interp, choice);
            //        evalTable<PieceWiseFunction*> (fPWF, choice); // to avoid inheritance cost

            //! Test IFunction for derivative (only for random access)
            diffEvalTable(ifunc_linear_interp);
          }

        pinfo() << "-------Stop New Linear IFunction Evaluation-----------------";

        if (!m_table_impl_cpu_comparison)
          {
            /* IFUNCTION CONSTANT INTERPOLATOR */
            m_xmax_table = 9.5; // max table value
            m_xmin_table = 0.; // max table value
            pinfo()
                << "-------Start Constant IFunction Evaluation-----------------";
            pinfo() << "Test fonction f10 : constant interpolator";
            IFunctionR1vR1 * ifunc_const_interp = options()->f10();
            ifunc_const_interp->init();
            // Test out of bound behavior
            pinfo() << " TEST BORNES : FINITE CONSTANT PROLONGATION [-3,15]";
            pinfo() << "Test bornes f(-3)=" << ifunc_const_interp->eval(-3);
            pinfo() << "Test bornes f'(-3)=" << ifunc_const_interp->diffEval(-3);
            pinfo() << "Test bornes f(-5)=" << ifunc_const_interp->eval(-5);
            pinfo() << "Test bornes f'(-5)=" << ifunc_const_interp->diffEval(-5);
            pinfo() << "Test bornes f(10)=" << ifunc_const_interp->eval(10);
            pinfo() << "Test bornes f'(10)=" << ifunc_const_interp->diffEval(10);
            pinfo() << "Test bornes f(39.5)=" << ifunc_const_interp->eval(39.5);
            pinfo() << "Test bornes f'(39.5)=" << ifunc_const_interp->diffEval(39.5);
            pinfo() << " FIN TEST BORNES";

            //! Test Constant IFunction
            evalTable<IFunctionR1vR1*> (ifunc_const_interp, choice);
            //! Eval derivative
            diffEvalTable(ifunc_const_interp);

            pinfo()
                << "-------Stop Constant IFunction Evaluation-----------------";

            /* IFUNCTION ANDRADE INTERPOLATOR */
            m_xmax_table = 9.5; // max table value
            m_xmin_table = 0.; // max table value
            pinfo()
                << "-------Start Andrade IFunction Evaluation-----------------";
            pinfo() << "Test fonction fAndrade : Andrade interpolator";
            IFunctionR1vR1 * ifunc_andrade_interp = options()->fandrade();
            ifunc_andrade_interp->init();
            // Test out of bound behavior
            pinfo() << " TEST BORNES : NO PROLONGATION; DEFINED ON [1 , 7]";
            pinfo() << "Test bornes f(-3)=" << ifunc_andrade_interp->eval(-3);
            pinfo() << "Test bornes f'(-3)=" << ifunc_andrade_interp->diffEval(-3);
            pinfo() << "Test bornes f(1)=" << ifunc_andrade_interp->eval(1);
            pinfo() << "Test bornes f'(1)=" << ifunc_andrade_interp->diffEval(1);
            pinfo() << "Test bornes f(5)=" << ifunc_andrade_interp->eval(5);
            pinfo() << "Test bornes f'(5)=" << ifunc_andrade_interp->diffEval(5);
            pinfo() << "Test bornes f(30)=" << ifunc_andrade_interp->eval(30);
            pinfo() << "Test bornes f'(30)=" << ifunc_andrade_interp->diffEval(30);
            pinfo() << " FIN TEST BORNES";

            // Construct expected results
            RealSharedArray expected_results;
            RealSharedArray expected_derivative;
            String values = "1.5874010519682 2.64813016773336 3.53602086097445 6.41860235092075";
            String dvalues = "0.978046723190799 0.953009808944819 0.996489609323619 1.01455421067582";
            builtInGetValue(expected_results,values);
            builtInGetValue(expected_derivative,dvalues);

            // Scalar eval
            info() << "Scalar eval test";
            RealSharedArray scalar_results;
            scalar_results.add(ifunc_andrade_interp->eval(1.5));
            scalar_results.add(ifunc_andrade_interp->eval(2.6));
            scalar_results.add(ifunc_andrade_interp->eval(3.5));
            scalar_results.add(ifunc_andrade_interp->eval(6.4));
            info() << "Expected results : r_expected = " << expected_results;
            info() << "Scalar results r = " << scalar_results;
            if (!_checkValues(scalar_results,expected_results)) fatal() << "Error in Andrade interpolation";
            scalar_results.clear();
            scalar_results.add(ifunc_andrade_interp->diffEval(1.5));
            scalar_results.add(ifunc_andrade_interp->diffEval(2.6));
            scalar_results.add(ifunc_andrade_interp->diffEval(3.5));
            scalar_results.add(ifunc_andrade_interp->diffEval(6.4));
            info() << "Expected derivative : r_expected = " << expected_derivative;
            info() << "Scalar derivative r = " << scalar_results;
            if (!_checkValues(scalar_results,expected_derivative)) fatal() << "Error in Andrade derivative interpolation";

            //! Test Constant IFunction
            evalTable<IFunctionR1vR1*> (ifunc_andrade_interp, choice);
            //! Eval derivative
            diffEvalTable(ifunc_andrade_interp);

            pinfo()
                << "-------Stop Andrade IFunction Evaluation-----------------";

            /* IFUNCTION LINEAR LOG INTERPOLATOR */
            /*  Test Log10 linear interpolator : ORDINATE GIVEN in .arc */
            m_xmax_table = 6.0; // max table value
            m_xmin_table = 0.; // max table value
            pinfo()
                << "-------Start New Log10 Linear IFunction Evaluation with ordinate given in .arc-----------------";
            pinfo() << "Test fonction : log10 linear interpolator";
            IFunctionR1vR1 * ifunc_loglinear_interp = options()->flog();
            ifunc_loglinear_interp->init();
            // Test out of bound behavior
            pinfo() << " TEST BORNES : NO PROLONGATION; DEFINED ON [0 , 6]";
            pinfo() << "Test bornes f(-3)=" << ifunc_loglinear_interp->eval(-3);
            pinfo() << "Test bornes f'(-3)=" << ifunc_const_interp->diffEval(-3);
            pinfo() << "Test bornes f(-5)=" << ifunc_loglinear_interp->eval(-5);
            pinfo() << "Test bornes f'(-5)=" << ifunc_const_interp->diffEval(-5);
            pinfo() << "Test bornes f(10)=" << ifunc_loglinear_interp->eval(10);
            pinfo() << "Test bornes f'(10)=" << ifunc_const_interp->diffEval(10);
            pinfo() << "Test bornes f(30)=" << ifunc_loglinear_interp->eval(30);
            pinfo() << "Test bornes f'(30)=" << ifunc_const_interp->diffEval(30);
            pinfo() << " FIN TEST BORNES";

            //! Test IFunction for random access
            evalTable<IFunctionR1vR1*> (ifunc_loglinear_interp, choice);
            //! Eval derivative
            diffEvalTable(ifunc_loglinear_interp);

            pinfo()
                << "-------Stop New Log Linear IFunction Evaluation with ordinate given in .arc-----------------";

            /* IFUNCTION LINEAR LOG INTERPOLATOR */
            /* Test Log10 linear interpolator : LOG(ORDINATE) given in .arc */
            m_xmax_table = 6.0; // max table value
            m_xmin_table = 0.; // max table value
            pinfo()
                << "-------Start New Log10 Linear IFunction Evaluation with Log(ordinate) given in .arc-----------------";
            pinfo() << "Test fonction : log10 linear interpolator";
            IFunctionR1vR1 * ifunc_loglinearbis_interp = options()->flogbis();
            ifunc_loglinearbis_interp->init();

            //! Test IFunction for random access
            evalTable<IFunctionR1vR1*> (ifunc_loglinearbis_interp, choice);
            //! Eval derivative
            diffEvalTable(ifunc_loglinearbis_interp);
            pinfo()
                << "-------Stop New Log Linear IFunction Evaluation with Log(ordinate) given in .arc-----------------";

            /* IFUNCTION TRANSFORMATION */
            m_xmax_table = 3.0; // max table value
            m_xmin_table = 0.; // max table value
            pinfo()
                << "---------Test IFunction transformation for table------------";
            pinfo() << "--get f--";
            IFunctionR1vR1 * f = options()->fclone();
            f->init();
            pinfo() << "clone it into g";
            //! Create Transformer for clone operation
            IFunctionR1vR1Transformer* pwf_transformer =
                new PieceWiseFunctionR1vR1Transformer(traceMng());
            //! Create cloned IFunction
            IFunctionR1vR1* g = pwf_transformer->createTransformedIFunction(f);

            //! Test both IFunction (random access)
            pinfo() << "eval f";
            evalTable<IFunctionR1vR1*> (f, choice);
            pinfo() << "eval g";
            evalTable<IFunctionR1vR1*> (g, choice);

            //! Test boundary
            pinfo() << " TEST BORNES : g must clone f behavior (FINITE CONSTANT PROLONGATION [-5, 5]) ";
            pinfo() << "Test bornes f(-6)=" << f->eval(-6);
            pinfo() << "Test bornes g(-6)=" << g->eval(-6);
            pinfo() << "Test bornes f(-4)=" << f->eval(-4);
            pinfo() << "Test bornes g(-4)=" << g->eval(-4);
            pinfo() << "Test bornes f(4)=" << f->eval(4);
            pinfo() << "Test bornes g(4)=" << g->eval(4);
            pinfo() << "Test bornes f(6)=" << f->eval(6);
            pinfo() << "Test bornes g(6)=" << g->eval(6);

            //! Clean memory
            delete g;
            delete pwf_transformer;

            //! Test shift rescale transformation
            pinfo() << "Clone it into g2 and shift rescale";
            //! Create Transformer for clone operation
            pwf_transformer = new PieceWiseFunctionR1vR1Transformer(traceMng(), 1, 7,
                0, 4);
            //! Create cloned shift-rescaled IFunction
            IFunctionR1vR1* g2 = pwf_transformer->createTransformedIFunction(f);

            //! Print both IFunction
            pinfo() << "print f points";
            dynamic_cast<IPieceWiseFunction*> (f)->printPoints();
            pinfo() << "print g2 points";
            dynamic_cast<IPieceWiseFunction*> (g2)->printPoints();

            //! Clean memory
            delete g2;
            delete pwf_transformer;

            /* IFUNCTION DERIVATION */
            pinfo()
                << "---------Test PieceWiseFunction derivation strategy------------";
            m_xmax_table = 5; // max table value
            m_xmin_table = 0.; // max table value
            m_nb_points = 6;
            //! Get IFunction
            IFunctionR1vR1* fderivative = options()->fderivative();
            fderivative->init();

            //! Default behavior for limit points: right derivative
            pinfo() << "Default behavior for limit points: right derivative";
            diffEvalLimitPoints(fderivative);
            //! Change derivation strategy (default right derivative)
            IPieceWiseFunction * my_IPWF =
                dynamic_cast<IPieceWiseFunction*> (fderivative);
            //! Left derivative
            pinfo()
                << "Change derivation strategy : left derivative for limit points";
            my_IPWF->setLimitDerivationStrategy(
                LimitDerivationStrategy::LeftDerivative);
            diffEvalLimitPoints(fderivative);
            //! Mean derivative
            pinfo()
                << "Change derivation strategy : left-right mean derivative for limit points";
            my_IPWF->setLimitDerivationStrategy(
                LimitDerivationStrategy::MeanDerivative);
            diffEvalLimitPoints(fderivative);
          }

        {
        	info() << "---------Test UnsteadyRegularGridData ------------";
        	info() << "Test UnsteadyRegularGridData created from LinearInterGridDataFunction Service";
        	info() << "---------Test Vertical Data ------------";

        	IFunctionR4vR1* f_vertical_data = options()->fverticalData();
        	f_vertical_data->init();

        	// Get grid infos need to cast in concrete service type LinearInterpGridDataFunctionService
        	static_cast<IUnsteadyRegularGridData*>(f_vertical_data)->printGrid();

        	// Construct expected results
        	RealSharedArray expected_results;
        	String  values = " 1 2 1.5";
        	builtInGetValue(expected_results,values);

        	info() << "Scalar eval test";
        	RealSharedArray scalar_results;
        	scalar_results.add(f_vertical_data->eval(0, 0, -100, 0));
        	scalar_results.add(f_vertical_data->eval(0, 0, 100, 0));
        	scalar_results.add(f_vertical_data->eval(0, 0, 0, 0));

        	info() << "Expected results : r_expected = " << expected_results;
        	info() << "Scalar results r = " << scalar_results;
        	if (!_checkValues(scalar_results,expected_results)) fatal() << "Error in UnsteadyRegularGridData interpolation";

        }

        {
        	info() << "---------Test UnsteadyRegularGridData ------------";
        	info() << "Test UnsteadyRegularGridData created from LinearInterGridDataFunction Service";
        	info() << "---------Test Vertical Data Time ------------";

        	IFunctionR4vR1* f_vertical_data_time = options()->fverticalDataTime();
        	f_vertical_data_time->init();

        	// Get grid infos need to cast in concrete service type LinearInterpGridDataFunctionService
        	static_cast<IUnsteadyRegularGridData*>(f_vertical_data_time)->printGrid();

        	// Construct expected results
        	RealSharedArray expected_results;
        	String  values = " 1 2 1.5 3 4 3.5";
        	builtInGetValue(expected_results,values);

        	info() << "Scalar eval test";
        	RealSharedArray scalar_results;
        	scalar_results.add(f_vertical_data_time->eval(0, 0, -100, 0));
        	scalar_results.add(f_vertical_data_time->eval(0, 0, 100, 0));
        	scalar_results.add(f_vertical_data_time->eval(0, 0, 0, 0));
        	scalar_results.add(f_vertical_data_time->eval(0, 0, -100, 1));
        	scalar_results.add(f_vertical_data_time->eval(0, 0, 100, 1));
        	scalar_results.add(f_vertical_data_time->eval(0, 0, 0, 1));

        	info() << "Expected results : r_expected = " << expected_results;
        	info() << "Scalar results r = " << scalar_results;
        	if (!_checkValues(scalar_results,expected_results)) fatal() << "Error in UnsteadyRegularGridData interpolation";

        }


      {
        // IFUNCTIONR4vR1 for unsteady regular cartesian grid data. Needs from ArcTem
        // Test initialization by service

    	info() << "---------Test UnsteadyRegularGridData ------------";
    	info() << "Test UnsteadyRegularGridData created from LinearInterGridDataFunction Service";

        IFunctionR4vR1* f_regular_grid_data = options()->fregularGridData();
        f_regular_grid_data->init();

        // Get grid infos need to cast in concrete service type LinearInterpGridDataFunctionService
        static_cast<IUnsteadyRegularGridData*>(f_regular_grid_data)->printGrid();

        String filename = static_cast<IUnsteadyRegularGridData*>(f_regular_grid_data)->getFileName();

        RegularGridType::eRegularGridType gridtype = static_cast<IUnsteadyRegularGridData*>(f_regular_grid_data)->getGridType();

        // Construct expected results
        RealSharedArray expected_results;
        String  values = " 1 4 7 8 9 5.5 7 7.5 9";
        builtInGetValue(expected_results,values);

        // Scalar eval
        info() << "Scalar eval test";
        RealSharedArray scalar_results;
        scalar_results.add(f_regular_grid_data->eval(0, 0, 100, 200));
        scalar_results.add(f_regular_grid_data->eval(0, 1, 100, 200));
        scalar_results.add(f_regular_grid_data->eval(0, 2, 100, 200));
        scalar_results.add(f_regular_grid_data->eval(1, 2, 100, 200));
        scalar_results.add(f_regular_grid_data->eval(2, 2, 100, 200));
        scalar_results.add(f_regular_grid_data->eval(-0.5, 1.5, 100, 200));
        scalar_results.add(f_regular_grid_data->eval(-0.5, 2.5, 100, 200));
        scalar_results.add(f_regular_grid_data->eval(2.5, 1.5, 100, 200));
        scalar_results.add(f_regular_grid_data->eval(2.5, 2.5, 100, 200));
        info() << "Expected results : r_expected = " << expected_results;
        info() << "Scalar results r = " << scalar_results;
        if (!_checkValues(scalar_results,expected_results)) fatal() << "Error in UnsteadyRegularGridData interpolation";

        //values = " 1 4 7 8 9";
        //expected_results.clear();
        //builtInGetValue(expected_results,values);

        // Vector eval
        SharedArray<Real> x1;
        SharedArray<Real> y1;
        SharedArray<Real> z1(9, 100);
        SharedArray<Real> t1(9, 200);
        SharedArray<Real> res1(9);
        x1.add(0);
        x1.add(0);
        x1.add(0);
        x1.add(1);
        x1.add(2);
        x1.add(-0.5);
        x1.add(-0.5);
        x1.add(2.5);
        x1.add(2.5);

        y1.add(0);
        y1.add(1);
        y1.add(2);
        y1.add(2);
        y1.add(2);
        y1.add(1.5);
        y1.add(2.5);
        y1.add(1.5);
        y1.add(2.5);

        // Vector test 1
        f_regular_grid_data->eval(x1, y1, z1, t1, res1);
        info() << "Vector evaltest1: f_regular_grid = " << res1;
        if (!_checkValues(res1,expected_results)) fatal() << "Error in UnsteadyRegularGridData interpolation";

        // Vector test 2
        SharedArray<Real> x2(9);
        SharedArray<Real> y2(9);
        SharedArray<Real> z2(9);
        SharedArray<Real> t2(9);
        SharedArray<Real> res2(9);
        for (Integer i = 0; i < 9; ++i)
          {
            x2[i] = 0;
            y2[i] = 2;
            z2[i] = 100;
            t2[i] = 200;
          }
        x2[3] = 1;
        x2[4] = 2;
        x2[5] = -0.5;
        x2[6] = -0.5;
        x2[7] = 2.5;
        x2[8] = 2.5;

        y2[0] = 0;
        y2[1] = 1;
        y2[5] = 1.5;
        y2[6] = 2.5;
        y2[7] = 1.5;
        y2[8] = 2.5;

        // Set variable by name
        f_regular_grid_data->setVariable("x", x2);
        f_regular_grid_data->setVariable("y", y2);
        f_regular_grid_data->setVariable("z", z2);
        f_regular_grid_data->setVariable("t", t2);
        f_regular_grid_data->setEvaluationResult(res2);
        f_regular_grid_data->eval();
        f_regular_grid_data->cleanup();
        info() << "Vector eval test2: f_regular_grid = ";
        for (Integer i = 0; i < res2.size(); ++i)
          {
            info() << res2[i];
          }
        if (!_checkValues(res2,expected_results)) fatal() << "Error in UnsteadyRegularGridData interpolation";

        // Set variable by index
        f_regular_grid_data->setVariable(0, x2);
        f_regular_grid_data->setVariable(1, y2);
        f_regular_grid_data->setVariable(2, z2);
        f_regular_grid_data->setVariable(3, t2);
        f_regular_grid_data->setEvaluationResult(res2);
        f_regular_grid_data->eval();
        f_regular_grid_data->cleanup();
        info() << "Vector eval test3: f_regular_grid = ";
        for (Integer i = 0; i < res2.size(); ++i)
          {
            info() << res2[i];
          }
        if (!_checkValues(res2,expected_results)) fatal() << "Error in UnsteadyRegularGridData interpolation";

        // Test initialization from scratch
        info() << "Test UnsteadyRegularGridData created from scratch";
        IUnsteadyRegularGridData* f_scratch_regular_grid =
            new UnsteadyRegularGridDataT<LinearInterpGridDataInterpolator>(traceMng(),subDomain()->ioMng()) ;
        // set grid type
        f_scratch_regular_grid->setRegularGridType(gridtype);

        // set grid points (read xml or xmf file given)

        f_scratch_regular_grid->setPoints(filename);
        // init
        f_scratch_regular_grid->init();
        // Test Vector eval
        SharedArray<Real> res3(9);
        //f_scratch_regular_grid->eval(x1, y1, z1, t1, res3);
        f_scratch_regular_grid->eval(x2, y2, z2, t2, res3);
        // Print info
        info() << "Vector evaltest: f_regular_grid = " << res3;
        if (!_checkValues(res3,expected_results)) fatal() << "Error in UnsteadyRegularGridData interpolation";

        delete f_scratch_regular_grid;
      }


      {
             // IFUNCTIONR4vR1 for unsteady regular cartesian grid data. Needs from ArcTem
             // Test initialization by service

         	info() << "---------Test UnsteadyRegularGridData ------------";
         	info() << "Test UnsteadyRegularGridData created from LinearInterGridDataFunction Service";

             IFunctionR4vR1* f_regular_grid_data_time = options()->fregularGridDataTime();
             f_regular_grid_data_time->init();

             // Get grid infos need to cast in concrete service type LinearInterpGridDataFunctionService
             static_cast<IUnsteadyRegularGridData*>(f_regular_grid_data_time)->printGrid();

             // Construct expected results
             RealSharedArray expected_results;
             String  values = " 1 4 7 8 9 5.5 7 7.5 9 10 13 16 17 18 14.5 16 16.5 18";
             builtInGetValue(expected_results,values);

             // Scalar eval
             info() << "Scalar eval test";
             RealSharedArray scalar_results;
             scalar_results.add(f_regular_grid_data_time->eval(0, 0, 100, 0));
             scalar_results.add(f_regular_grid_data_time->eval(0, 1, 100, 0));
             scalar_results.add(f_regular_grid_data_time->eval(0, 2, 100, 0));
             scalar_results.add(f_regular_grid_data_time->eval(1, 2, 100, 0));
             scalar_results.add(f_regular_grid_data_time->eval(2, 2, 100, 0));
             scalar_results.add(f_regular_grid_data_time->eval(-0.5, 1.5, 100, 0));
             scalar_results.add(f_regular_grid_data_time->eval(-0.5, 2.5, 100, 0));
             scalar_results.add(f_regular_grid_data_time->eval(2.5, 1.5, 100, 0));
             scalar_results.add(f_regular_grid_data_time->eval(2.5, 2.5, 100, 0));
             scalar_results.add(f_regular_grid_data_time->eval(0, 0, 100, 1));
             scalar_results.add(f_regular_grid_data_time->eval(0, 1, 100, 1));
             scalar_results.add(f_regular_grid_data_time->eval(0, 2, 100, 1));
             scalar_results.add(f_regular_grid_data_time->eval(1, 2, 100, 1));
             scalar_results.add(f_regular_grid_data_time->eval(2, 2, 100, 1));
             scalar_results.add(f_regular_grid_data_time->eval(-0.5, 1.5, 100, 1));
             scalar_results.add(f_regular_grid_data_time->eval(-0.5, 2.5, 100, 1));
             scalar_results.add(f_regular_grid_data_time->eval(2.5, 1.5, 100, 1));
             scalar_results.add(f_regular_grid_data_time->eval(2.5, 2.5, 100, 1));
             info() << "Expected results : r_expected = " << expected_results;
             info() << "Scalar results r = " << scalar_results;
             if (!_checkValues(scalar_results,expected_results)) fatal() << "Error in UnsteadyRegularGridData interpolation";

      }

      {
        // IFUNCTIONR4vR1 for unsteady regular Cartesian grid data. Needs from ArcTem
        // Test initialization by service
        IFunctionR4vR1* f_regular_grid_data_linear = options()->fregularGridDataLinear();
        f_regular_grid_data_linear->init();


        // Test only new linear interpolator with point evaluation
        pinfo() << "---------Test UnsteadyRegularGridData ------------";
        info() << "Test UnsteadyRegularGridData created from LinearInterGridDataFunction Service";
        RealSharedArray point_results;
        point_results.add(f_regular_grid_data_linear->eval(0,0, 0, 0));
        point_results.add(f_regular_grid_data_linear->eval(1,2, 0, 0));
        point_results.add(f_regular_grid_data_linear->eval(1,2, 1, 0));
        point_results.add(f_regular_grid_data_linear->eval(1,2, 1, 1));
        point_results.add(f_regular_grid_data_linear->eval(0,2, 0, 0));
        point_results.add(f_regular_grid_data_linear->eval(0,2, 1, 0));
        point_results.add(f_regular_grid_data_linear->eval(0,2, 1, 1));
        point_results.add(f_regular_grid_data_linear->eval(0,1, 0, 2));
        point_results.add(f_regular_grid_data_linear->eval(1,0, 1, 2));
        point_results.add(f_regular_grid_data_linear->eval(1,1, 0, 2));
        point_results.add(f_regular_grid_data_linear->eval(1,1, 1, 2));
        info() << "Point evaluation results r = " << point_results;
        RealSharedArray expected_results;
        String  values = " 1 8 17 35 7 16 34 40 47 41 50 ";
        builtInGetValue(expected_results,values);
        info() << "Expected results : r_expected = " << expected_results;
        if (!_checkValues(point_results,expected_results)) fatal() << "Error in UnsteadyRegularGridData linear interpolation";

        RealSharedArray interpolation_results;
        interpolation_results.add(f_regular_grid_data_linear->eval(0.3,0.7, 0, 0)); // x y interp
        interpolation_results.add(f_regular_grid_data_linear->eval(0.3,0.7, 1, 0)); // x y interp
        interpolation_results.add(f_regular_grid_data_linear->eval(0.3,0.7, 0.2, 0)); // x y z interp
        interpolation_results.add(f_regular_grid_data_linear->eval(0.3,0.7, 0, 1)); // x y interp
        interpolation_results.add(f_regular_grid_data_linear->eval(0.3,0.7, 1, 1)); // x y interp
        interpolation_results.add(f_regular_grid_data_linear->eval(0.3,0.7, 0.2, 1)); // x y z interp
        interpolation_results.add(f_regular_grid_data_linear->eval(0.3,0.7, 0.2, 0.6)); // x y z t interp
        interpolation_results.add(f_regular_grid_data_linear->eval(1.6,1.4, 1, 2)); // x y interp
        interpolation_results.add(f_regular_grid_data_linear->eval(1,1, 0.2, 0)); // z interp
        interpolation_results.add(f_regular_grid_data_linear->eval(2,2, 1, 1.6));// t interp
        info() << "interpolation computation results r = " << interpolation_results;
        RealSharedArray expected_interp_results;
        String  interp_values = " 3.4 12.4 5.2 21.4 30.4 23.2 16 51.8 6.8 46.8 ";
        builtInGetValue(expected_interp_results,interp_values);
        info() << "Expected interpolation results : r_expected = " << expected_interp_results;
        if (!_checkValues(interpolation_results,expected_interp_results)) fatal() << "Error in UnsteadyRegularGridData linear interpolation";

      }
      {
        //! BilinearPiece wise function from .arc : row definition

        //! Init
        IFunctionR2vR1 * bi_piece_wise_function1 = options()->biRowLinearWiseFunction();
        bi_piece_wise_function1->init();

        // Construct expected results fxy = x + y
        RealSharedArray expected_results;
        String  values = " 0.5 0.9 5 80 150";
        builtInGetValue(expected_results,values);

        // Scalar eval
        info() << "Scalar eval test";
        RealSharedArray scalar_results;
        scalar_results.add(bi_piece_wise_function1->eval(0.05,0.45));
        scalar_results.add(bi_piece_wise_function1->eval(0.4,0.5));
        scalar_results.add(bi_piece_wise_function1->eval(4.8,0.2));
        scalar_results.add(bi_piece_wise_function1->eval(40,40));
        scalar_results.add(bi_piece_wise_function1->eval(140,10));
        info() << "Expected results : r_expected = " << expected_results;
        info() << "Scalar results r = " << scalar_results;
        // SDC
//        if (!_checkValues(scalar_results,expected_results)) fatal() << "Error in BiLinearPieceWiseFunction interpolation";


        //! Start vect evaluation
        SharedArray<Real> x0;
        SharedArray<Real> x1;
        SharedArray<Real> fxy(5);
        x0.add(0.05);
        x0.add(0.4);
        x0.add(4.8);
        x0.add(40);
        x0.add(140);
        x1.add(0.45);
        x1.add(0.5);
        x1.add(0.2);
        x1.add(40);
        x1.add(10);

        info() << "Vector eval test";
        bi_piece_wise_function1->eval(x0,x1,fxy);
        info() << "Vector results r = " << fxy;
        // SDC
//        if (!_checkValues(fxy,expected_results)) fatal() << "Error in BiLinearPieceWiseFunction interpolation";

        //! Coupled values and Derivative scalar evaluation
        Real f, dfdx, dfdy;
        bi_piece_wise_function1->eval(0.05, 0.45, f, dfdx, dfdy);
        info() << "Vector derivative results wrt x = " << dfdx;
        info() << "Vector derivative results wrt y = " << dfdy;
      }
      {

        //! BilinearPiece wise function from .arc : col definition

        //! Init
        IFunctionR2vR1 * bi_piece_wise_function2 = options()->biColLinearWiseFunction();
        bi_piece_wise_function2->init();

        //! Coupled values and Derivative scalar evaluation
        // Construct expected results f(x,y)=2x+3y+4
        RealSharedArray expected_results;
        String values = " 44.2 2 3 ";
        builtInGetValue(expected_results,values);
        info() << "Expected results : r_expected = " << expected_results;
        RealSharedArray scalar_results(3);
        bi_piece_wise_function2->eval(12, 5.4, scalar_results[0],
          scalar_results[1], scalar_results[2]);
        info() << "Scalar results f, dfdx, dfdy = " << scalar_results;
        // SDC
//        if (!_checkValues(scalar_results,expected_results)) fatal() << "Error in BiLinearPieceWiseFunction interpolation";
      }

      // Check tool
      _checkArray2Tools();
  }

/*---------------------------------------------------------------------------*/

void
ExpressionsTesterService::
_performanceTest()
{
  m_performance_test = options()->performanceTest();

  if (!m_performance_test) return;
  info() << "=== Expression implementation performance evaluation ===";

  // Vector for random access
  Integer size = 5000000;
  m_x.resize(size);
  srand(1);
  for (Integer i = 0; i < size; ++i)
    {
    m_x[i] = rand() / Real(RAND_MAX);
    //        info() << "xk[" << i << "]= " << xk[i];
    }

  info() << "Test function computation time";
  info() << size << " calls";

  Real dump = 0.;

  // Analytical Function
  IFunctionR1vR1 * analytical_function = options()->analyticalFunction();
  analytical_function->init();

  m_timer.start();

  for (Integer i = 0; i < size; ++i)
    {
    Real result;

    Real x = Real(i) / Real(size);

    result = analytical_function->eval(x);

    dump += result;
    }

  m_timer.stop();

  if (options()->dump())
    {
    info() << dump;
    }

  info() << "-------------------------------------------";
  info() << "Analytical service function ";
  info() << " global time = " << m_timer.totalTime();
  info() << "   call time = " << m_timer.totalTime() / Real(size);
  info() << "-------------------------------------------";

  m_timer.reset();
  dump = 0.;

  // Analytical Function cast in ExpressionBluiderR1vR1Core
  ExpressionBuilderR1vR1Core * analytical_function_core =
      dynamic_cast<ExpressionBuilderR1vR1Core*> (analytical_function);

  m_timer.start();

  for (Integer i = 0; i < size; ++i)
    {
    Real result;

    Real x = Real(i) / Real(size);

    result = analytical_function_core->eval(x);

    dump += result;
    }

  m_timer.stop();

  if (options()->dump())
    {
    info() << dump;
    }

  info() << "-------------------------------------------";
  info() << "Analytical service function cast in ExpressionBuilderR1vR1Core";
  info() << " global time = " << m_timer.totalTime();
  info() << "   call time = " << m_timer.totalTime() / Real(size);
  info() << "-------------------------------------------";

  m_timer.reset();
  dump = 0.;

  // ExpressionBluiderR1vR1Core created
  FunctionParser function_parser;
  function_parser.init(NULL, NULL, traceMng());
  function_parser.parseString("(x)->x");
  ExpressionBuilderR1vR1Core expression_builder(&function_parser);

  m_timer.start();

  for (Integer i = 0; i < size; ++i)
    {
    Real result;

    Real x = Real(i) / Real(size);

    result = expression_builder.eval(x);

    dump += result;
    }

  m_timer.stop();

  if (options()->dump())
    {
    info() << dump;
    }

  info() << "-------------------------------------------";
  info() << "Analytical function from scratch";
  info() << " global time = " << m_timer.totalTime();
  info() << "   call time = " << m_timer.totalTime() / Real(size);
  info() << "-------------------------------------------";

  m_timer.reset();
  dump = 0.;

  // ---TABLES CPU COST ANALYSIS---
  pinfo() << "CPU cost comparison only valid with compilation in RELEASE mode";





  //! Optimized tables from scratch
  Real x[11] =
  { 0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. };
  Real y[11] =
  { 0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. };
  //   Real x[2] = {0., 1.};
  //   Real y[2] = {0., 1.};

  Table table("table", 11, x, y);

  //! Start test
  m_timer.start();
  for (Integer i = 0; i < size; ++i)
    {
    table.eval(m_x[i]);
    }
  m_timer.stop();

  info() << "-------------------------------------------";
  info() << "Optimized table function from scratch";
  info() << " global time = " << m_timer.totalTime();
  info() << "   call time = " << m_timer.totalTime() / Real(size);
  info() << "-------------------------------------------";

  m_timer.reset();

  // Piece wise function from IFunction
  //! Init
  IFunctionR1vR1 * piece_wise_function = options()->pieceWiseFunction();
  piece_wise_function->init();
  //    dynamic_cast<IPieceWiseFunction*> (new_piece_wise_function)->printPoints();

  m_timer.start();
  for (Integer i = 0; i < size; ++i)
    {
    piece_wise_function->eval(m_x[i]);
    }
  m_timer.stop();

  info() << "-------------------------------------------";
  info() << "New implementation for Piece wise service function";
  info() << " global time = " << m_timer.totalTime();
  info() << "   call time = " << m_timer.totalTime() / Real(size);
  info() << "-------------------------------------------";

  m_timer.reset();

  //! New Piece wise function from scratch

  //! Create object
  PieceWiseFunctionR1vR1T<LinearInterpolator> piece_wise_function_from_scratch(
      traceMng());

  //! Init default boundary condition
  piece_wise_function_from_scratch.initBorderCondition();

  //! Fill
  piece_wise_function_from_scratch.setPoint(0.0, 0.0);
  piece_wise_function_from_scratch.setPoint(0.2, 0.2);
  piece_wise_function_from_scratch.setPoint(0.4, 0.4);
  piece_wise_function_from_scratch.setPoint(0.6, 0.6);
  piece_wise_function_from_scratch.setPoint(0.8, 0.8);
  piece_wise_function_from_scratch.setPoint(0.1, 0.1);
  piece_wise_function_from_scratch.setPoint(0.3, 0.3);
  piece_wise_function_from_scratch.setPoint(0.5, 0.5);
  piece_wise_function_from_scratch.setPoint(0.7, 0.7);
  piece_wise_function_from_scratch.setPoint(0.9, 0.9);
  piece_wise_function_from_scratch.setPoint(1.0, 1.0);

  //! Init
  piece_wise_function_from_scratch.init();

  //    new_piece_wise_function.printPoints();

  //! Start CPU tests
  m_timer.start();
  for (Integer i = 0; i < size; ++i)
    {
    piece_wise_function_from_scratch.eval(m_x[i]);
    }
  m_timer.stop();

  info() << "-------------------------------------------";
  info() << "Optimized implementation for Piece wise service function from scratch";
  info() << " global time = " << m_timer.totalTime();
  info() << "   call time = " << m_timer.totalTime() / Real(size);
  info() << "-------------------------------------------";

  m_timer.reset();


  //! BilinearPiece wise function from .arc : row definition


  //! Init
  IFunctionR2vR1 * bi_piece_wise_function1 = options()->biRowLinearWiseFunction();
  bi_piece_wise_function1->init();

  //! Start CPU test scalar evaluation
  dump = 0;

  m_timer.start();
  for (Integer i = 0; i < size; ++i)
    {
       dump += bi_piece_wise_function1->eval(m_x[i],1.-m_x[i]);
    }
  m_timer.stop();

  if (options()->dump())
    {
      info() << dump;
    }

  info() << "----------------------------------------------------";
  info() << "BilinearPiece wise service function point evaluation";
  info() << "BilinearPiece wise service function define by rows";
  info() << " global time = " << m_timer.totalTime();
  info() << "   call time = " << m_timer.totalTime() / Real(size);
  info() << "----------------------------------------------------";

  m_timer.reset();

  //! New BilinearPiece wise function from scratch

  //! Create object
  PieceWiseFunctionR2vR1T<BiLinearInterpolator> new_biLinearPieceWiseFunction_from_scratch(
      traceMng());

  //! Init default boundary condition
  new_biLinearPieceWiseFunction_from_scratch.initBorderCondition();

  //! Fill
  // X0n = N
  // X1n = 0,5*(1,6**N) - 0,5
  // f(X0,X1) = (X0/3)**2-X0*X1
  const Integer N = 15;
  RealSharedArray x0(N), x1(N), fxy(N);
  for (Integer i = 0; i < N; i++)
    {
      x0[i] = i;
      x1[i] = 0.5 * pow(1.6, i) - 0.5;
    }
  for (Integer j = 0; j < N; j++)
    {
      for (Integer i = 0; i < N; i++)
        {
          // Fill table row by row
          fxy[i] = (x0[i] / 3.) * (x0[i] / 3.) - x1[j]*x0[i];
          //fxy[i] = 3*x0[i] + 5.*x1[j]-30.;
        }
      new_biLinearPieceWiseFunction_from_scratch.addTableVector(x0, x1[j], fxy,
          VectorType::row);
    }


  //! Init
  new_biLinearPieceWiseFunction_from_scratch.init();

  //! Debug Print
  new_biLinearPieceWiseFunction_from_scratch.printPoints();

  //! Compute exact solution
  dump = 0;
  for (Integer i = 0; i < size; ++i)
    {
       dump += (14.*m_x[i] / 3.) * (14.*m_x[i] / 3.) - 350.*14*m_x[i]*m_x[i];
       //dump += 3*14.*m_x[i] + 5.*350.*m_x[i]-30.;
    }

  //! Start CPU test
  m_timer.start();
  for (Integer i = 0; i < size; ++i)
    {
       dump -= new_biLinearPieceWiseFunction_from_scratch.eval(14.*m_x[i],350.*m_x[i]);
    }
  m_timer.stop();

  if (options()->dump())
    {
      //! Print error
      info() << "Evaluation of error = "<< dump;
    }

  info() << "----------------------------------------";
  info() << "BilinearPiece wise function from scratch";
  info() << " global time = " << m_timer.totalTime();
  info() << "   call time = " << m_timer.totalTime() / Real(size);
  info() << "----------------------------------------";

  m_timer.reset();


#ifdef TEST
  // Analytical Function
  // ExpressionBluiderR1vR1Core created
  FunctionParser parser;
  parser.init(NULL, NULL, traceMng());
  parser.parseString("(x)->x");
  ExpressionBuilderR1vR1Core polynom_function(&parser);
  dump = 0;
  m_timer.start();

  for (Integer i = 0; i < size; ++i)
    {
    Real result;

    Real x = Real(i) / Real(size);

    result = polynom_function.eval(x);

    dump += result;
    }

  m_timer.stop();

  if (options()->dump())
    {
    info() << dump;
    }

  info() << "-------------------------------------------";
  info() << "Analytical polynom function                ";
  info() << " global time = " << m_timer.totalTime();
  info() << "   call time = " << m_timer.totalTime() / Real(size);
  info() << "-------------------------------------------";

  m_timer.reset();
#endif

  Real* coef = new Real[5];
  coef[0] = 1;
  coef[1] = 1;
  coef[2] = 1;
  coef[3] = 1;
  coef[4] = 1;
  Polynom<4> p4(coef);

  dump = 0;
  m_timer.start();

  for (Integer i = 0; i < size; ++i)
    {
    Real result;

    Real x = Real(i) / Real(size);

    result = p4.eval(x);

    dump += result;
    }

  m_timer.stop();

  if (options()->dump())
    {
    info() << dump;
    }

  info() << "-------------------------------------------";
  info() << "template Polynom ";
  info() << " global time = " << m_timer.totalTime();
  info() << "   call time = " << m_timer.totalTime() / Real(size);
  info() << "-------------------------------------------";

  m_timer.reset();

  {

    // KozenyCarmanFunction Function
    KozenyCarmannFunction kozeny_func(traceMng());
    kozeny_func.setParameter(0, 1.);

    dump = 0;
    m_timer.start();

    for (Integer i = 0; i < size; ++i)
      {
      Real result;

      Real x = Real(i) / Real(size);

      result = kozeny_func.eval(x);

      dump += result;
      //info() <<i<<" "<<result<<" "<<dump;
      }

    m_timer.stop();

    if (options()->dump())
      {
      info() << dump;
      }

    info() << "-------------------------------------------";
    info() << " function KozenyCarmannFunction            ";
    info() << " global time = " << m_timer.totalTime();
    info() << "   call time = " << m_timer.totalTime() / Real(size);
    info() << "-------------------------------------------";

    m_timer.reset();

    Real* coef = new Real[6];
    coef[0] = 0;
    coef[1] = 0;
    coef[2] = 0;
    coef[3] = 0;
    coef[4] = 0;
    coef[5] = 20.;
    Polynom<5> p5(coef);
    coef[3] = 0.2;
    Polynom<3> p3(coef);
    coef[0] = 1.;
    coef[1] = -2.;
    coef[2] = 1.;
    Polynom<2> p2(coef);

    dump = 0;
    m_timer.start();

    for (Integer i = 0; i < size; ++i)
      {
      Real result;

      Real x = Real(i) / Real(size);
      if (x > 0.1)
        result = p3.eval(x) / p2.eval(x);
      else
        result = p5.eval(x) / p2.eval(x);
      dump += result;
      //info() <<i<<" "<<result<<" "<<dump;
      }

    m_timer.stop();

    if (options()->dump())
      {
      info() << dump;
      }

    info() << "-------------------------------------------";
    info() << "Polynom Kozeny ";
    info() << " global time = " << m_timer.totalTime();
    info() << "   call time = " << m_timer.totalTime() / Real(size);
    info() << "-------------------------------------------";

    m_timer.reset();
  }



}

/*---------------------------------------------------------------------------*/

template<typename T>
void
ExpressionsTesterService::evalTable(T t,
                                 const EvalTableTypes::eChoice& choice_eval)
{

  // Generate vector for table evaluation depending of choice
  SharedArray<Real>
  xk(m_nb_points);
  String eval_type;
  Real dx_access = 2.0;
  Real x_start_point_last = m_xmax_table - dx_access;
  switch (choice_eval)
  {
  case EvalTableTypes::Random://! Random access
    {
      //! Random generation initialization
      srand(1);
      //          srand(time(NULL));

      for (Integer i = 0; i < m_nb_points; ++i)
        {
        xk[i] = rand() / (RAND_MAX / m_xmax_table + 1.0);
        ;
        //              info() << "xk[" << i << "]= " << xk[i];
        }
      eval_type = "random access";
      break;
    }

  case EvalTableTypes::FirstElements:
    {
      Real dx_table = dx_access / m_nb_points;
      for (Integer i = 0; i < m_nb_points; ++i)
        {
        xk[i] = m_xmin_table + dx_table * i;
        }
      eval_type = "first element access";
      break;
    }

  case EvalTableTypes::LastElements:
    {
      Real dx_table = dx_access / m_nb_points;
      for (Integer i = 0; i < m_nb_points; ++i)
        {
        xk[i] = x_start_point_last + dx_table * i;
        }
      eval_type = "last element access";
      break;
    }

  case EvalTableTypes::AllElements:
    {
      Real dx_table = m_xmax_table / m_nb_points;
      for (Integer i = 0; i < m_nb_points; ++i)
        {
        xk[i] = m_xmin_table + dx_table * i;
        }
      eval_type = "all element access";
      break;
    }

  }
  if (!m_table_impl_cpu_comparison)
    {
    //! Point to Point eval
    for (Integer i = 0; i < m_nb_points; ++i)
      {
      Real r = t->eval(xk[i]);
      pinfo() << "xk[i]=" << xk[i] << " f(xk[i]) = " << r;
      }
    }
  else
    {
    //! CPU time measure initialization
    Timer timer(subDomain(), "EvalTableTimer", Timer::TimerVirtual);
    //            Timer timer(subDomain(), "EvalTableTimer", Timer::TimerReal);

    //! Evaluate table points
    //! Preparation for vectorized evaluation
    //      Array<Real>
    //      res(m_nb_points);
    //      RealArrayView res_view(m_nb_points, &res[0]);

    //! Start outside loop timer
    timer.start();
    //! Preparation only for inside loop timer
    //      Real time = 0;
    //      Real time1 = 0;

    //! Prepare while loop
    Integer nloop = 0;

    while (nloop < m_total_loop)
      {
      //! Vectorized evaluation with IFunction only
      //          t->eval(xk.constView(), res.view());

      //! Point to Point eval
      for (Integer i = 0; i < m_nb_points; ++i)
        {
        //! Eval for cpu analysis
        t->eval(xk[i]);

        //! Eval with timer inside the loop
        //              Real var = xk[i];
        //              timer.start();
        //              t->eval(var);
        //              timer.stop();
        //              time1 = timer.stop();
        //              time+=time1;
        //              time1 = 0;

        }

      //! Validation Print for vectorized evaluation
      //          for (Integer i = 0; i < m_nb_points; ++i)
      //            {
      //              pinfo() << "xk[i]=" << xk[i] << " f(xk[i]) = " << res[i];
      //              //                  << "   10^(f(xk[i]) = " << math::pow(10., res[i]);
      //                  }
      ++nloop;
      }

    //! Stop outside loop timer
    timer.stop();

    //! Get and print consumed time
    Real time2 = timer.totalTime();
    pinfo() << "CPU time consumed to evaluate Table with " << eval_type
        << " t= " << time2;

    }
}

/*---------------------------------------------------------------------------*/

void
ExpressionsTesterService::diffEvalTable(IFunctionR1vR1* i_func)
{
  // Generate vector for table evaluation depending of choice
  SharedArray<Real> xk(m_nb_points);
  for (Integer i = 0; i < m_nb_points; ++i)
    {
    xk[i] = rand() / (RAND_MAX / m_xmax_table + 1.0);
    //              info() << "xk[" << i << "]= " << xk[i];
    }

  /*--- IFunction---*/
  if (!m_table_impl_cpu_comparison)
    {
    for (Integer i = 0; i < m_nb_points; ++i)
      {
      //! Eval for validation purpose (print result)
      Real r, der;
      i_func->eval(xk[i], r, der);
      pinfo() << "xk[i]=" << xk[i] << " f(xk[i]) = " << r
          << " f'(xk[i]) = " << der;
      }
    }
  else
    {
    //! CPU time measure initialization
    Timer timer(subDomain(), "EvalTableTimer", Timer::TimerVirtual);
    //! Start outside loop timer
    timer.start();

    //! Prepare while loop
    Integer nloop = 0;

    while (nloop < m_total_loop)
      {
      //! Point to Point eval and diffEval
      for (Integer i = 0; i < m_nb_points; ++i)
        {
        //! Eval for cpu analysis
        //              i_func->eval(xk[i]);
        i_func->diffEval(xk[i]);
        }
      ++nloop;
      }
    //! Stop outside loop timer
    timer.stop();

    //! Get and print consumed time
    Real time2 = timer.totalTime();
    pinfo()
    << "CPU time consumed to evaluate and differentiate Table with random access t= "
    << time2;
    }


}

/*---------------------------------------------------------------------------*/



/*---------------------------------------------------------------------------*/

void
ExpressionsTesterService::
diffEvalLimitPoints(IFunctionR1vR1* i_func)
{
  // Generate vector of the tabulated points
  SharedArray<Real> xk(m_nb_points);
  Real dx_table = (m_xmax_table - m_xmin_table) / (m_nb_points - 1);
  for (Integer i = 0; i < m_nb_points; ++i)
    {
      xk[i] = m_xmin_table + dx_table * i;
    }

  /*--- IFunction---*/
  if (!m_table_impl_cpu_comparison)
    {
      for (Integer i = 0; i < m_nb_points; ++i)
        {
          //! Eval for validation purpose (print result)
          Real r, der;
          i_func->eval(xk[i], r, der);
          pinfo() << "xk[i]=" << xk[i] << " f(xk[i]) = " << r
              << " f'(xk[i]) = " << der;
        }
    }
}

/*---------------------------------------------------------------------------*/


bool
ExpressionsTesterService::
_checkValues(const ConstArrayView<Real>& a , const ConstArrayView<Real>& b)
{
  bool is_nearly_equal = true;
  if (a.size() != b.size()) fatal() << "input arrays have different sizes";
  Integer size = a.size();
  for (Integer i = 0; i < size && is_nearly_equal; ++i)
    {
      is_nearly_equal = math::isNearlyEqual(a[i],b[i]);
    }
  return is_nearly_equal;
}

/*---------------------------------------------------------------------------*/

void
ExpressionsTesterService::
_checkArray2Tools()
{
  PWFDataTools::PWFArray2 array2;
  PWFDataTools pwf_tools;
  Arcane::Integer dim1_size = 4;
  Arcane::Integer dim2_size = 5;
  pwf_tools.resize(array2,dim1_size,dim2_size);
  for (Arcane::Integer i = 0; i < dim1_size; ++i)
    {
      for (Arcane::Integer j = 0; j < dim2_size; ++j)
        {
          array2[i][j] = 0;
        }
    }
  pwf_tools.fillDim1(array2,1,-1);
  std::ostringstream oss;
  pwf_tools.print(array2,oss);
  // Fill DIM1
  info() << "Test PWFArray::fillDim1(1,-1): " << oss.str();
  // Fill DIM2
  pwf_tools.fillDim2(array2,1,100);
  std::ostringstream oss2;
  pwf_tools.print(array2,oss2);
  info() << "Test PWFArray::fillDim2(1,100) : " << oss2.str();
  Arcane::Integer view_dim1_size = 2;
  Arcane::Integer view_dim2_size = 3;

  PWFDataTools::PWFArray2View view = pwf_tools.view(array2,1,3,2,5);
  // Print view
  info() << "Test view ";
  for (Arcane::Integer i = 0; i < view_dim1_size; ++i)
    {
      for (Arcane::Integer j = 0; j < view_dim2_size; ++j)
        {
          info() << Arcane::String::format("view [{0}][{1}] = {2}",i,j,view[i][j]);
      }
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_EXPRESSIONSTESTER(ExpressionsTester,ExpressionsTesterService);
