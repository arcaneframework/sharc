#include "InterpolatorTesterService.h"
/* Author : dipietrd at Fri May 30 14:10:44 2008
 * Generated by createNew
 */

#include <arcane/IItemFamily.h>

#include "ArcGeoSim/Appli/IAppServiceMng.h"
#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"
#include <arcane/IParallelMng.h>

using namespace Arcane;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void InterpolatorTesterService::init() {
}

/*---------------------------------------------------------------------------*/

int InterpolatorTesterService::test() {
  IInterpolator* interpolator = options()->interpolator();
  interpolator->init();

  // Source field
  info() << "Creating source and target fields";
  VariableBuildInfo vb_source(mesh(),
			      "Source",
			      allFaces().itemFamily()->name(),
			      IVariable::PPrivate | IVariable::PTemporary | IVariable::PNoRestore);
  VariableFaceReal source(vb_source);

  // Target field
  VariableBuildInfo vb_target(mesh(),
			      "Target",
			      allCells().itemFamily()->name(),
			      IVariable::PPrivate | IVariable::PTemporary | IVariable::PNoRestore);
  VariableCellReal3 target(vb_target);

  // (Interpolated) exact field
  VariableBuildInfo vb_exact(mesh(),
			     "Exact",
			     allCells().itemFamily()->name(),
			     IVariable::PPrivate | IVariable::PTemporary | IVariable::PNoRestore);
  VariableCellReal3 exact(vb_exact);


  // Retrieve analytical field from configuration file
  info() << "Parsing analytical field";
  IAppServiceMng* app_service_mng = IAppServiceMng::instance(subDomain()->serviceMng());


  AnalyticalVectorField v;
  // x
  v(0) = options()->continuousField().x();
  v(0)->init() ;
  // y
  v(1) = options()->continuousField().y();
  v(1)->init() ;
  // z
  v(2) = options()->continuousField().z();
  v(2)->init() ;

  // Compute relevant geometrical properties
  info() << "Compute relevant geometrical properties";
  IGeometryMng* geometry_service = app_service_mng->find<IGeometryMng>(true);
  geometry_service->addItemGroupProperty(ownCells(), interpolator->getCellGeometricProperties(), IGeometryProperty::PVariable);
  geometry_service->addItemGroupProperty(allFaces(), interpolator->getFaceGeometricProperties(), IGeometryProperty::PVariable);
  geometry_service->update(IGeometryPolicy::nullPolicy());

  const IGeometryMng::Real3Variable& cell_centers =
    geometry_service->getReal3VariableProperty(ownCells(), IGeometryProperty::PCenter);
  const IGeometryMng::Real3Variable& face_centers = 
    geometry_service->getReal3VariableProperty(allFaces(), IGeometryProperty::PCenter);

  const IGeometryMng::Real3Variable& face_normals =
    geometry_service->getReal3VariableProperty(allFaces(), IGeometryProperty::PNormal);

  const IGeometryMng::RealVariable& cell_measures =
    geometry_service->getRealVariableProperty(ownCells(), IGeometryProperty::PMeasure);
  
  // Evaluate analytical field
  ENUMERATE_FACE(iface, allFaces()) {
    const Face F = *iface;

    const Real3& xF = face_centers[F];
    const Real3& nF = face_normals[F];

    Real vn_xF = 0;
    for(Integer i = 0; i < mesh()->dimension(); i++) 
      vn_xF += v(i)->eval(xF.x,xF.y,xF.z) * nF[i];

    // WARNING: the Euclidean norm of the normal coincides with the
    // measure of the face
    // source[F] = face_measures[F] * vn_xF;
    source[F] = vn_xF;
  }
  source.synchronize();

  ENUMERATE_CELL(icell, ownCells()) {
    const Cell T = *icell;
    Real3& exact_T = exact[T];
    const Real3 xT = cell_centers[T];

    for(Integer i = 0; i < mesh()->dimension(); i++)
      exact_T[i] = v(i)->eval(xT.x,xT.y,xT.z);
  }

  // Interpolate fields
  info() << "Interpolating fields";
  interpolator->setSourceField(&source);
  interpolator->setTargetField(&target);

  interpolator->interpolate();
  target.synchronize();

  // Compute error
  Real erl2 = 0;
  ENUMERATE_CELL(icell, ownCells()) {
    const Cell T = *icell;
    Real3 diff_T = exact[T] - target[T];
    erl2 += cell_measures[T] * pow(diff_T.abs(), 2);
  }
  erl2 = ownCells().mesh()->parallelMng()->reduce(Parallel::ReduceSum, erl2);
  erl2 = sqrt(erl2);
  info() << "erl2   : " << erl2;

  // Compute number of cells
  Integer nunkw = ownCells().size();
  nunkw = mesh()->parallelMng()->reduce(Parallel::ReduceSum, nunkw);
  info() << "nunkw  : " << nunkw;

  return 1 ;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_INTERPOLATORTESTER(InterpolatorTester,InterpolatorTesterService);
