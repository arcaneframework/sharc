// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
/* Author : desrozis at Tue Dec 19 12:37:25 2017
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
//#define SPARSE_AUDI

#include "ArcGeoSim/Tests/ServiceTesters/IServiceTester.h"

#include "LawContributionTester_axl.h"

#include "Law1_law.h"
#include "Law2_law.h"

// Gump model generated from file ContributionModel.gump
#include "ContributionModel/Entities.h"
#include "ContributionModel/Properties.h"
#include "ContributionModel/Builders/Factory.h"
#include "ContributionModel/XPath.h"

#include "ArcGeoSim/Physics/Law2/VariableManager.h"
#include "ArcGeoSim/Physics/Law2/FunctionManager.h"
#include "ArcGeoSim/Physics/Law2/FunctionEvaluator.h"
#include "ArcGeoSim/Physics/Law2/EvaluationResults.h"

#include "ArcGeoSim/Physics/Law2/Contribution/ContributionAccessor.h"

#include <arcane/random/Uniform01.h>
#include <arcane/random/LinearCongruential.h>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class LawContributionTesterService
    : public ArcaneLawContributionTesterObject
{
private:
  // law algorithms definition
  struct AlgoLaw1
  {
    void compute(Arcane::Real in, Arcane::Real& out, Arcane::Real& dout) const
    {
      out = 3*in;
      dout = 2*in;
    }
  };

  struct AlgoLaw2
  {
    void compute(Arcane::Real in, Arcane::Real& out, Arcane::Real& dout) const
    {
      out = 4*in;
      dout = 5*in;
    }
  };

  struct AlgoLaw3
  {
    void compute(Arcane::Real in1, Arcane::RealConstArrayView in2,
        Arcane::RealArrayView out, Arcane::RealArrayView dout_in1,
        Arcane::RealArray2View dout_in2) const
    {
      auto size1 = out.size();
      auto size2 = in2.size();
      for(auto k = 0; k < size1; ++k) {
        out[k] = in1 ;
        dout_in1[k] = in1 + k;
        for(auto i = 0; i < size2; ++i)
          dout_in2[k][i] = in2[i] + k*i + k;
      }
    }
  };

  // Contribution operators tested
  struct ContributionOperator
  {
    enum eOperator
    {
      add, mult, div
    };
  };

public:

  LawContributionTesterService(const Arcane::ServiceBuildInfo & sbi):
    ArcaneLawContributionTesterObject(sbi),
    m_domain("mesh_cell_domain", mesh()),
    m_uniform(m_generator){}

  ~LawContributionTesterService() {}

public:

  // test initialization
  void init();

  // test processing
  Arcane::Integer test();

private:

  // tests
  // some operators contribution without stencil tests  multi unknown
  bool _common_tests();
  // "law1*law2" contribution on stencil test (flux-style) 1 unknowns
  bool _stencil_test();

  // test checkers
  // check test (law1 * law2) contribution results with reference
  bool _check_law1_op_law2(const ContributionOperator::eOperator opertor,
      const audi::scalar<Arcane::Real>& contrib_law1_op_law2,
      const VariableCellReal& in_1, const Arcane::ItemEnumeratorT<Arcane::Cell>& icell);
  // check test (law1 * law2 * law3) contribution results with reference results
  bool _check_law1_op_law2_mult_law3(
      const audi::scalar<Arcane::Real>& contrib_law1_mult_law2,
      const audi::scalar<Arcane::Real>& contrib_law1_law2_mult_law3,
      const VariableCellReal& in_1, const VariableCellReal& in_2a,
      const VariableCellReal& in_2b, const VariableCellReal& in_2c,
      const Arcane::ItemEnumeratorT<Arcane::Cell>& icell,
      const Arcane::Integer& idx_species_out);
  // check "law1*law2" contribution on stencil test (flux-style) results with reference results
  bool _check_law1_mult_law2_test_stencil(const audi::scalar<Arcane::Real>& contrib_law1_law2_flux_kl,
      const VariableCellReal& in_1, const Arcane::ItemEnumeratorT<Arcane::Face>& iface);

  inline bool _check(const Arcane::Real& a, const Arcane::Real& b){
	  return (Arcane::math::abs(a-b) < 1.e-12);
  }
  // to mask audi sparse and audi dense
  inline audi::scalar<Arcane::Real>
  unpack(const Integer nb_deviv, const audi::scalar<Arcane::Real>& contrib) const
  { return contrib; }

#ifdef SPARSE_AUDI
  inline audi::scalar<Arcane::Real>
  unpack(const Integer nb_deviv, const audi::sparse_expression<Arcane::Real>& contrib) const
  { return audi::unpack(nb_deviv, contrib); }
#endif
  
private:

  // laws algorithms
  AlgoLaw1 m_example1;
  AlgoLaw2 m_example2;
  AlgoLaw3 m_example3;

  // Gump  system from ContributionModel.gump
  ContributionModel::System m_gump_system;

  // laws input properties
  // 1 scalar
  Gump::ScalarRealProperty in1;
  // 1 multi scalar
  Gump::ScalarRealProperty in2a;
  Gump::ScalarRealProperty in2b;
  Gump::ScalarRealProperty in2c;

  // laws computed properties
  // 2 scalar
  Gump::ScalarRealProperty out1;
  Gump::ScalarRealProperty out2;
  // 1 multi scalar
  Gump::ScalarRealProperty out3a;
  Gump::ScalarRealProperty out3b;
  Gump::ScalarRealProperty out3c;

  // law function manager
  Law::FunctionManager m_funcs;

  // domain for contributions
  Law::VariableCellFolder  m_domain;

  // random values generator for properties initialization
  Arcane::random::MinstdRand m_generator;
  mutable Arcane::random::Uniform01<Arcane::random::MinstdRand> m_uniform;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
LawContributionTesterService::
init()
{
  //  Gump model initialization
  {
    ContributionModel::Factory factory;
    //
    auto species_a = factory.newSpecies("speciesA");
    auto species_b = factory.newSpecies("speciesB");
    auto species_c = factory.newSpecies("speciesC");
    //
    auto root = factory.newSystem("system");
    root<<species_a<<species_b<<species_c;
    auto system_builder = root.entity();
    m_gump_system = ContributionModel::System(system_builder);
  }
  //
  // properties mapping from Gump model
  {
    ContributionModel::XPath xpath(m_gump_system);
    //
    in1 = xpath.property("[System]system::In1");
    //
    in2a = xpath.property("[Species]speciesA::In2");
    in2b = xpath.property("[Species]speciesB::In2");
    in2c = xpath.property("[Species]speciesC::In2");
    //
    out1 = xpath.property("[System]system::Out1");
    out2 = xpath.property("[System]system::Out2");
    //
    out3a = xpath.property("[Species]speciesA::Out3");
    out3b = xpath.property("[Species]speciesB::Out3");
    out3c = xpath.property("[Species]speciesC::Out3");
  }
  //
  // create my variable cell folder
  {
    m_domain.setSupport(allCells());
    //
    m_domain.addVariable(in1);
    m_domain.addVariable(in2a);
    m_domain.addVariable(in2b);
    m_domain.addVariable(in2c);
    //
    m_domain.addVariable(out1, Law::WithDerivative);
    m_domain.addVariable(out2, Law::WithDerivative);
    m_domain.addVariable(out3a, Law::WithDerivative);
    m_domain.addVariable(out3b, Law::WithDerivative);
    m_domain.addVariable(out3c, Law::WithDerivative);
  }
  //
  // inputs initialization
  {
    auto accessor =  m_domain.lawVariableAccessor();
    VariableCellReal in_1(accessor.values(in1.cast()));
    VariableCellReal in_2a(accessor.values(in2a.cast()));
    VariableCellReal in_2b(accessor.values(in2b.cast()));
    VariableCellReal in_2c(accessor.values(in2c.cast()));
    ENUMERATE_CELL(icell, allCells()) {
      in_1[icell] = m_uniform();
      in_2a[icell] = m_uniform();
      in_2b[icell] = m_uniform();
      in_2c[icell] = m_uniform();
    }
  }
  //
  // laws part
  {
    // law 1
    Law1::Signature s1;
    s1.in = in1;
    s1.out = out1;
    auto f1 = std::make_shared<Law1::Function>(s1, m_example1, &AlgoLaw1::compute);
    m_funcs << f1;
    // law 2
    Law1::Signature s2;
    s2.in = in1;
    s2.out = out2;
    auto f2 = std::make_shared<Law1::Function>(s2, m_example2, &AlgoLaw2::compute);
    m_funcs << f2;
    // law 3 (with multi scalar)
    Law2::Signature s3;
    s3.in_1 = in1;
    s3.in_2.add(in2a);
    s3.in_2.add(in2b);
    s3.in_2.add(in2c);
    s3.out.add(out3a);
    s3.out.add(out3b);
    s3.out.add(out3c);
    auto f3 = std::make_shared<Law2::Function>(s3, m_example3, &AlgoLaw3::compute);
    m_funcs << f3;
  }
  //
}
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
Arcane::Integer
LawContributionTesterService::
test()
{
  // Evaluate laws
  {
    auto accessor =  m_domain.lawVariableAccessor();
    Law::FunctionEvaluator e(m_funcs);
    e.evaluate(accessor, allCells(), Law::eWithDerivative);
  }
  //
  // common tests without stencil
  bool common_tests_status = _common_tests();
  //
  // simple test with stencil
  bool stencil_test_status = _stencil_test();
  //
  return (common_tests_status && stencil_test_status) ? 1 : 0 ;
}

bool
LawContributionTesterService::
_common_tests()
{
  // my unknowns
  Law::PropertyVector um_properties;
  um_properties<<in1;
  um_properties<<in2a;
  um_properties<<in2b;
  um_properties<<in2c;
  const Arcane::Integer um_size = um_properties.size();
  //
  // Law contributions
  auto out1_contrib = Law::contribution<ContributionModel::Out1>(m_domain, m_funcs, um_properties, m_gump_system);
  auto out2_contrib = Law::contribution<ContributionModel::Out2>(m_domain, m_funcs, um_properties, m_gump_system);
  auto out3_contrib = Law::contribution<ContributionModel::Out3>(m_domain, m_funcs, um_properties, m_gump_system.species());
  //
  // Input properties used to evaluate reference results
  auto accessor =  m_domain.lawVariableAccessor();
  VariableCellReal in_1(accessor.values(in1.cast()));
  VariableCellReal in_2a(accessor.values(in2a.cast()));
  VariableCellReal in_2b(accessor.values(in2b.cast()));
  VariableCellReal in_2c(accessor.values(in2c.cast()));
  //
  // Tests results variables
  bool check_law1_mult_law2 = true;
  bool check_law1_add_law2 = true;
  bool check_law1_div_law2 = true;
  bool check_law1_mult_law2_mult_law3 = true;
  bool check_law1_add_law2_mult_law3 = true;
  //
  ENUMERATE_CELL(icell, allCells()) {
    //
    // test A: (law1*law2)
    const Law::Contribution contrib_law1_mult_law2 = out1_contrib[icell] * out2_contrib[icell];
    // check results
    check_law1_mult_law2 &= _check_law1_op_law2(ContributionOperator::mult, unpack(um_size, contrib_law1_mult_law2), in_1, icell);
    //
    // test B: (law1+law2)
    const Law::Contribution contrib_law1_add_law2 = out1_contrib[icell] + out2_contrib[icell];
    // check results
    check_law1_add_law2 &= _check_law1_op_law2(ContributionOperator::add, unpack(um_size,contrib_law1_add_law2), in_1, icell);
    //
    // test C: (law1/law2)
    const Law::Contribution contrib_law1_div_law2 = out1_contrib[icell] / out2_contrib[icell];
    // check results
    check_law1_div_law2 &= _check_law1_op_law2(ContributionOperator::div, unpack(um_size,contrib_law1_div_law2), in_1, icell);
    //
    // Begin D: (law1*law2*law3)
    ENUMERATE_SPECIES(ispecies_out, m_gump_system.species()) {
      auto idx_species_out = ispecies_out.index();
      // contribution
      const Law::Contribution contrib_law1_mult_law2_mult_law3 =
          contrib_law1_mult_law2 * out3_contrib[ispecies_out][icell];
      // check results
      check_law1_mult_law2_mult_law3 &= _check_law1_op_law2_mult_law3(
    		  unpack(um_size,contrib_law1_mult_law2), unpack(um_size,contrib_law1_mult_law2_mult_law3),
          in_1, in_2a, in_2b,in_2c, icell, idx_species_out);
    }
    //
    // Begin E: (law1+law2)*law3
    ENUMERATE_SPECIES(ispecies_out, m_gump_system.species()) {
      auto idx_species_out = ispecies_out.index();
      // contribution
      const Law::Contribution contrib_law1_add_law2_mult_law3 =
          contrib_law1_add_law2 * out3_contrib[ispecies_out][icell];
      // check results
      check_law1_add_law2_mult_law3 &= _check_law1_op_law2_mult_law3(
    		  unpack(um_size,contrib_law1_add_law2), unpack(um_size,contrib_law1_add_law2_mult_law3),
          in_1, in_2a, in_2b,in_2c, icell, idx_species_out);
    }
  }
  // print results of tests
  if(check_law1_mult_law2)
    std::cout << "law1*law2 contribution test OK...\n";
  if(check_law1_add_law2)
    std::cout << "law1+law2 contribution test OK...\n";
  if(check_law1_div_law2)
    std::cout << "law1/law2 contribution test OK...\n";
  if(check_law1_mult_law2_mult_law3)
    std::cout << "law1*law2*law3 contribution test OK...\n";
  if(check_law1_add_law2_mult_law3)
    std::cout << "(law1+law2)*law3 contribution test OK...\n";
  //
  return (check_law1_mult_law2 && check_law1_add_law2 && check_law1_div_law2 &&
      check_law1_mult_law2_mult_law3 && check_law1_add_law2_mult_law3) ? 1 : 0 ;
}



bool
LawContributionTesterService::
_check_law1_op_law2(const ContributionOperator::eOperator opertor,
    const audi::scalar<Arcane::Real>& contrib_deriv,
    const VariableCellReal& in_1, const Arcane::ItemEnumeratorT<Arcane::Cell>& icell)
{
  bool check_result = true;
  //
  // compute reference laws results
  Arcane::Real out_law_1_ref, dout_law_1_ref;
  Arcane::Real out_law_2_ref, dout_law_2_ref;
  m_example1.compute(in_1[icell],out_law_1_ref,dout_law_1_ref);
  m_example2.compute(in_1[icell],out_law_2_ref,dout_law_2_ref);
  //
  // compute reference factor laws result value
  Arcane::Real laws_value_ref, laws_derivative_ref;
  switch (opertor)
  {
    case ContributionOperator::mult:
      laws_value_ref = out_law_1_ref * out_law_2_ref;
      laws_derivative_ref = dout_law_1_ref*out_law_2_ref + dout_law_2_ref*out_law_1_ref;
      break;
    case ContributionOperator::add:
      laws_value_ref = out_law_1_ref + out_law_2_ref;
      laws_derivative_ref = dout_law_1_ref + dout_law_2_ref;
      break;
    case ContributionOperator::div:
      laws_value_ref = out_law_1_ref / out_law_2_ref;
      laws_derivative_ref = (dout_law_1_ref*out_law_2_ref - dout_law_2_ref*out_law_1_ref) / (out_law_2_ref*out_law_2_ref);
      break;
    default:
      throw Arcane::FatalErrorException(A_FUNCINFO,
          Arcane::String::format("Unmanaged ContributionOperator::eOperator value: {0}", opertor));
  }
  //
  // check value
  check_result &= _check(contrib_deriv.value(), laws_value_ref);
  //
  // check derivative
  check_result &= _check(contrib_deriv[0], laws_derivative_ref);
  //
  // law2 law1 no depends of in2 so null contribution from species
  ENUMERATE_SPECIES(ispecies, m_gump_system.species()) {
    auto id = ispecies.index();
    check_result &= (contrib_deriv[id+1]==0);
  }
  //
  return check_result;
}

bool
LawContributionTesterService::
_check_law1_op_law2_mult_law3(
    const audi::scalar<Arcane::Real>& contrib_law1_mult_law2,
    const audi::scalar<Arcane::Real>& contrib_law1_law2_mult_law3,
    const VariableCellReal& in_1, const VariableCellReal& in_2a,
    const VariableCellReal& in_2b, const VariableCellReal& in_2c,
    const Arcane::ItemEnumeratorT<Arcane::Cell>& icell, const Arcane::Integer& idx_species_out)
{
  bool check_result = true;
  //
  // law 3 ref results var in 1 scalar and 1 3 scalar real out 1 3 scalar
  Arcane::RealUniqueArray out_law_3_array(3);
  out_law_3_array.fill(0.);
  Arcane::RealArrayView out_law_3_ref = out_law_3_array.view();
  //
  Arcane::RealUniqueArray dout_in1_law_3_array(4);
  dout_in1_law_3_array.fill(0.);
  Arcane::RealArrayView dout_in1_law_3_ref = dout_in1_law_3_array.view();
  //
  Arcane::RealUniqueArray2 dout_in2_law_3_array2(3,4);
  dout_in2_law_3_array2.fill(0.);
  Arcane::RealArray2View dout_in2_law_3_ref = dout_in2_law_3_array2.view();
  //
  // compute reference law3 results
  Arcane::RealUniqueArray in2_values(3);
  in2_values[0]=in_2a[icell];
  in2_values[1]=in_2b[icell];
  in2_values[2]=in_2c[icell];
  Arcane::RealConstArrayView in2_view = in2_values.view();
  m_example3.compute(in_1[icell], in2_view, out_law_3_ref, dout_in1_law_3_ref, dout_in2_law_3_ref);
  //
  // compute reference factor laws results
  //
  // against in1
  auto deriv_in1_ref = contrib_law1_mult_law2.value() * dout_in1_law_3_ref[idx_species_out] +
      contrib_law1_mult_law2[0] * out_law_3_ref[idx_species_out];
  check_result &= _check(contrib_law1_law2_mult_law3[0],deriv_in1_ref);
  //
  // against  in2
  ENUMERATE_SPECIES(ispecies_in, m_gump_system.species()) {
    auto idx_species_in = ispecies_in.index();
    auto deriv_in2_ref = contrib_law1_mult_law2.value() * dout_in2_law_3_ref[idx_species_out][idx_species_in]+
        contrib_law1_mult_law2[1+idx_species_in]* out_law_3_ref[idx_species_out];
    check_result &= _check(contrib_law1_law2_mult_law3[1+idx_species_in], deriv_in2_ref);
  }
  //
  return check_result;
}

bool
LawContributionTesterService::
_stencil_test()
{
  bool check_result = true;
  // my unknowns just 1
  Law::PropertyVector um_properties;
  um_properties<<in1;
  //
  // Law contributions with stencil so 2 unknowns properties
  // (um_properties could be different on specific domain interfacing between different physical problems)
  auto out1_contrib = Law::contribution<ContributionModel::Out1>(m_domain, m_funcs, um_properties, um_properties, m_gump_system);
  auto out2_contrib = Law::contribution<ContributionModel::Out2>(m_domain, m_funcs, um_properties, um_properties, m_gump_system);
  //
  // Input properties used to evaluate reference results
  auto accessor = m_domain.lawVariableAccessor();
  VariableCellReal in_1(accessor.values(in1.cast()));
  //
  // Loop on inner faces
  Arcane::FaceGroup inner_faces = allCells().innerFaceGroup();
  ENUMERATE_FACE(iface,inner_faces) {
    //
    // test: kind of gradient law1 on stencil (2 points) * mult Law2 with kind of off-center
	//
    // mimick stencil 2 point Geoxim
    const Law::Cell back_cell(iface->backCell() , 2, 0);
    const Law::Cell front_cell(iface->frontCell(), 2, 1);
    //
    // kind of gradient
    const Law::Contribution contrib_law1_grad_kl = out1_contrib[back_cell] * out1_contrib[front_cell];
    //
    // kind of off-center mult
#ifdef SPARSE_AUDI
    const Law::Contribution contrib_law1_law2_flux_kl = (audi::value(contrib_law1_grad_kl)>0) ?
        		out2_contrib[back_cell]*contrib_law1_grad_kl :
    			out2_contrib[front_cell]*contrib_law1_grad_kl;
#else
    const audi::scalar<Arcane::Real> contrib_law1_law2_flux_kl = (audi::one( contrib_law1_grad_kl>= 0) * out2_contrib[back_cell]
            + audi::one(contrib_law1_grad_kl <  0) * out2_contrib[front_cell]) * contrib_law1_grad_kl;
#endif
    //
    // check results
    check_result&=_check_law1_mult_law2_test_stencil(unpack(2,contrib_law1_law2_flux_kl), in_1, iface);
  }
  //
  if(check_result)
    std::cout << "\"law1*law2\" contribution on stencil test (flux-style) OK ...\n";
  //
  return check_result;
}

bool
LawContributionTesterService::
_check_law1_mult_law2_test_stencil(
    const audi::scalar<Arcane::Real>& contrib_law1_law2_flux_kl,
    const VariableCellReal& in_1, const Arcane::ItemEnumeratorT<Arcane::Face>& iface)
{
  const Arcane::Cell& icell_k = iface->backCell();
  const Arcane::Cell& icell_l = iface->frontCell();
  //
  // compute reference laws results
  Arcane::Real out_law_1_ref_k, dout_law_1_ref_k;
  Arcane::Real out_law_1_ref_l, dout_law_1_ref_l;
  // kind of gradient on law1
  m_example1.compute(in_1[icell_k],out_law_1_ref_k,dout_law_1_ref_k);
  m_example1.compute(in_1[icell_l],out_law_1_ref_l,dout_law_1_ref_l);
  // kind of gradient
  Arcane::Real out_law_1_ref_k_l = out_law_1_ref_k*out_law_1_ref_l;
  Arcane::Real dout_law_1_ref_k_l = (dout_law_1_ref_k*out_law_1_ref_l+out_law_1_ref_k*dout_law_1_ref_l) / 2;
  //
  // kind of off-center mult law2
  Arcane::Real law1_law2_flux_kl_ref = 0;
  if(out_law_1_ref_k_l>=0){
    Arcane::Real out_law_2_ref_k, dout_law_2_ref_k;
    m_example2.compute(in_1[icell_k],out_law_2_ref_k,dout_law_2_ref_k);
    law1_law2_flux_kl_ref = dout_law_1_ref_k_l*out_law_2_ref_k + out_law_1_ref_k_l*dout_law_2_ref_k;
  }
  else{
    Arcane::Real out_law_2_ref_l, dout_law_2_ref_l;
    m_example2.compute(in_1[icell_l],out_law_2_ref_l,dout_law_2_ref_l);
    law1_law2_flux_kl_ref = dout_law_1_ref_k_l*out_law_2_ref_l + out_law_1_ref_k_l*dout_law_2_ref_l;
  }
  //
  return _check(contrib_law1_law2_flux_kl[0], law1_law2_flux_kl_ref);
}
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_LAWCONTRIBUTIONTESTER(LawContributionTester,LawContributionTesterService);
