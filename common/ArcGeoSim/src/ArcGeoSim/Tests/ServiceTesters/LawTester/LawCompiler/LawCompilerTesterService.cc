// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
/* Author : desrozis at Tue Dec 19 12:37:25 2017
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "ArcGeoSim/Tests/ServiceTesters/IServiceTester.h"

#include "LawCompilerTester_axl.h"

#include "Example1_law.h"
#include "Example2_law.h"
#include "Example3_law.h"
#include "Example4_law.h"
#include "Example5_law.h"

#include "ArcGeoSim/Physics/Law2/VariableManager.h"
#include "ArcGeoSim/Physics/Law2/FunctionManager.h"
#include "ArcGeoSim/Physics/Law2/FunctionEvaluator.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class LawCompilerTesterService
  : public ArcaneLawCompilerTesterObject
{
private:

  struct AlgoExample1
  {
    void compute(
        Arcane::Real in1,
        Arcane::Real in2,
        Arcane::Real in3,
        Arcane::Real in4,
        Arcane::Real& out1,
        Arcane::Real& dout1_in1,
        Arcane::Real& dout1_in2,
        Arcane::Real& dout1_in3,
        Arcane::Real& dout1_in4,
        Arcane::Real& out2,
        Arcane::Real& dout2_in1,
        Arcane::Real& dout2_in2,
        Arcane::Real& dout2_in3,
        Arcane::Real& dout2_in4,
        Arcane::Real param1,
        Arcane::Real param2) const
    {
      std::cout << "evaluate AlgoExample1...\n";
      std::cout << "in1 = " << in1 << "\n";
      std::cout << "in2 = " << in2 << "\n";
      std::cout << "in3 = " << in3 << "\n";
      std::cout << "in4 = " << in4 << "\n";
      std::cout << "param1 = " << param1 << "\n";
      std::cout << "param2 = " << param2 << "\n";
      out1 = 1;
      dout1_in1 = 11;
      dout1_in2 = 12;
      dout1_in3 = 13;
      dout1_in4 = 14;
      out2 = 2;
      dout2_in1 = 21;
      dout2_in2 = 22;
      dout2_in3 = 23;
      dout2_in4 = 24;
    }
  };

  struct AlgoExample2
  {
    void compute(
        Arcane::Real in1,
        Arcane::RealConstArrayView in2,
        Arcane::Real in3,
        Arcane::RealConstArrayView in4,
        Arcane::Real in5,
        Arcane::Real& out,
        Arcane::Real& dout_in1,
        Arcane::RealArrayView dout_in2,
        Arcane::Real& dout_in3,
        Arcane::RealArrayView dout_in4,
        Arcane::Real& dout_in5) const
    {
      std::cout << "evaluate AlgoExample2...\n";
      std::cout << "in1 = " << in1 << "\n";
      auto size2 = in2.size();
      for(auto i = 0; i < size2; ++i)
        std::cout << "in2[" << i << "] = " << in2[i] << "\n";
      std::cout << "in3 = " << in3 << "\n";
      auto size4 = in4.size();
      for(auto i = 0; i < size4; ++i)
        std::cout << "in4[" << i << "] = " << in4[i] << "\n";
      std::cout << "in5 = " << in5 << "\n";
      out = 1;
      dout_in1 = 11;
      for(auto i = 0; i < size2; ++i)
        dout_in2[i] = 121 + i;
      dout_in3 = 13;
      for(auto i = 0; i < size4; ++i)
        dout_in4[i] = 140 + i;
      dout_in5 = 15;
    }
  };

  struct AlgoExample3
  {
    void compute(
        Arcane::Real in1,
        Arcane::RealConstArrayView in2,
        Arcane::RealConstArrayView in3,
        Arcane::Real in4,
        Arcane::Real& out1,
        Arcane::Real& dout1_in1,
        Arcane::RealArrayView dout1_in2,
        Arcane::RealArrayView dout1_in3,
        Arcane::Real& dout1_in4,
        Arcane::Real& out2,
        Arcane::Real& dout2_in1,
        Arcane::RealArrayView dout2_in2,
        Arcane::RealArrayView dout2_in3,
        Arcane::Real& dout2_in4,
        Arcane::Real param1,
        Arcane::Integer param2) const
    {
      std::cout << "evaluate AlgoExample3...\n";
      std::cout << "in1 = " << in1 << "\n";
      auto size2 = in2.size();
      for(auto i = 0; i < size2; ++i)
        std::cout << "in2[" << i << "] = " << in2[i] << "\n";
      auto size3 = in3.size();
      for(auto i = 0; i < size3; ++i)
        std::cout << "in3[" << i << "] = " << in3[i] << "\n";
      std::cout << "in4 = " << in4 << "\n";
      std::cout << "param1 = " << param1 << "\n";
      std::cout << "param2 = " << param2 << "\n";
      out1 = 1;
      dout1_in1 = 11;
      for(auto i = 0; i < size2; ++i)
        dout1_in2[i] = 121 + i;
      for(auto i = 0; i < size3; ++i)
        dout1_in3[i] = 131 + i;
      dout1_in4 = 14;
      out2 = 2;
      dout2_in1 = 21;
      for(auto i = 0; i < size2; ++i)
        dout2_in2[i] = 221 + i;
      for(auto i = 0; i < size3; ++i)
        dout2_in3[i] = 231 + i;
      dout2_in4 = 24;
    }
  };

  struct AlgoExample4
  {
    void compute(
        Arcane::Real in1,
        Arcane::RealConstArrayView in2,
        Arcane::RealConstArrayView in3,
        Arcane::Real in4,
        Arcane::RealArrayView out1,
        Arcane::RealArrayView dout1_in1,
        Arcane::RealArray2View dout1_in2,
        Arcane::RealArray2View dout1_in3,
        Arcane::RealArrayView dout1_in4,
        Arcane::Real& out2,
        Arcane::Real& dout2_in1,
        Arcane::RealArrayView dout2_in2,
        Arcane::RealArrayView dout2_in3,
        Arcane::Real& dout2_in4,
        Arcane::Real param1,
        Arcane::Integer param2) const
    {
      std::cout << "evaluate AlgoExample4...\n";
      std::cout << "in1 = " << in1 << "\n";
      auto size2 = in2.size();
      for(auto i = 0; i < size2; ++i)
        std::cout << "in2[" << i << "] = " << in2[i] << "\n";
      auto size3 = in3.size();
      for(auto i = 0; i < size3; ++i)
        std::cout << "in3[" << i << "] = " << in3[i] << "\n";
      std::cout << "in4 = " << in4 << "\n";
      std::cout << "param1 = " << param1 << "\n";
      std::cout << "param2 = " << param2 << "\n";
      auto sizeo1 = out1.size();
      for(auto k = 0; k < sizeo1; ++k) {
        out1[k] = 11 + k;
        dout1_in1[k] = 111 + k;
        for(auto i = 0; i < size2; ++i)
          dout1_in2[k][i] = 1211 + 10*i + k;
        for(auto i = 0; i < size3; ++i)
          dout1_in3[k][i] = 1311 + 10*i + k;
        dout1_in4[k] = 141 + k;
      }
      out2 = 2;
      dout2_in1 = 21;
      for(auto i = 0; i < size2; ++i)
        dout2_in2[i] = 221 + i;
      for(auto i = 0; i < size3; ++i)
        dout2_in3[i] = 231 + i;
      dout2_in4 = 24;
    }
  };

  struct AlgoExample5
  {
    void compute(
        Arcane::Real in1,
        Arcane::RealConstArrayView in2,
        Arcane::RealConstArrayView in3,
        Arcane::Real in4,
        Arcane::RealArrayView out1,
        Arcane::RealArrayView dout1_in1,
        Arcane::RealArray2View dout1_in2,
        Arcane::RealArray2View dout1_in3,
        Arcane::RealArrayView dout1_in4,
        Arcane::RealArrayView out2,
        Arcane::RealArrayView dout2_in1,
        Arcane::RealArray2View dout2_in2,
        Arcane::RealArray2View dout2_in3,
        Arcane::RealArrayView dout2_in4,
        Arcane::Real param1,
        Arcane::Integer param2) const
    {
      std::cout << "evaluate AlgoExample5...\n";
      std::cout << "in1 = " << in1 << "\n";
      auto size2 = in2.size();
      for(auto i = 0; i < size2; ++i)
        std::cout << "in2[" << i << "] = " << in2[i] << "\n";
      auto size3 = in3.size();
      for(auto i = 0; i < size3; ++i)
        std::cout << "in3[" << i << "] = " << in3[i] << "\n";
      std::cout << "in4 = " << in4 << "\n";
      std::cout << "param1 = " << param1 << "\n";
      std::cout << "param2 = " << param2 << "\n";
      auto sizeo1 = out1.size();
      for(auto k = 0; k < sizeo1; ++k) {
        out1[k] = 11 + k;
        dout1_in1[k] = 111 + k;
        for(auto i = 0; i < size2; ++i)
          dout1_in2[k][i] = 1211 + 10*i + k;
        for(auto i = 0; i < size3; ++i)
          dout1_in3[k][i] = 1311 + 10*i + k;
        dout1_in4[k] = 141 + k;
      }
      auto sizeo2 = out2.size();
      for(auto k = 0; k < sizeo2; ++k) {
        out2[k] = 21 + k;
        dout2_in1[k] = 211 + k;
        for(auto i = 0; i < size2; ++i)
          dout2_in2[k][i] = 2211 + 10*i + k;
        for(auto i = 0; i < size3; ++i)
          dout2_in3[k][i] = 2311 + 10*i + k;
        dout2_in4[k] = 241 + k;
      }
    }
  };


public:
  
  LawCompilerTesterService(const Arcane::ServiceBuildInfo & sbi)
    : ArcaneLawCompilerTesterObject(sbi) {}
  
  ~LawCompilerTesterService() {}
  
private:

  void _unitaryTestExample1();
  void _unitaryTestExample2();
  void _unitaryTestExample3();
  void _unitaryTestExample4();
  void _unitaryTestExample5();

public:

  void init();

  Arcane::Integer test() { return 1; }

  AlgoExample1 m_example1;
  AlgoExample2 m_example2;
  AlgoExample3 m_example3;
  AlgoExample4 m_example4;
  AlgoExample5 m_example5;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
LawCompilerTesterService::
init()
{
  _unitaryTestExample1();
  _unitaryTestExample2();
  _unitaryTestExample3();
  _unitaryTestExample4();
  _unitaryTestExample5();
}

/*---------------------------------------------------------------------------*/

void
LawCompilerTesterService::
_unitaryTestExample1()
{
  Law::ScalarRealProperty in1(0,"I1");
  Law::ScalarRealProperty in2(1,"I2");
  Law::ScalarRealProperty in3(2,"I3");
  Law::ScalarRealProperty in4(3,"I4");
  Law::ScalarRealProperty out1(4,"O1");
  Law::ScalarRealProperty out2(5,"O2");
  Law::ScalarRealProperty pa1(6,"P1");
  Law::ScalarRealProperty pa2(7,"P2");

  Law::VariableManager vars(mesh());

  vars << Law::variable<Arcane::Cell>(in1);
  vars << Law::variable<Arcane::Cell>(in2);
  vars << Law::variable<Arcane::Cell>(in3);
  vars << Law::variable<Arcane::Cell>(in4);
  vars << Law::variableWithDerivative<Arcane::Cell>(out1);
  vars << Law::variableWithDerivative<Arcane::Cell>(out2);
  vars << Law::variable<Arcane::Cell>(pa1);
  vars << Law::variable<Arcane::Cell>(pa2);

  auto accessor = vars.variables<Arcane::Cell>();

  accessor.values(in1).fill(1.);
  accessor.values(in2).fill(2.);
  accessor.values(in3).fill(3.);
  accessor.values(in4).fill(4.);

  accessor.values(pa1).fill(5.);
  accessor.values(pa2).fill(6.);

  Law::FunctionManager funcs;

  Example1::Signature s;
  s.in_1 = in1;
  s.in_2 = in2;
  s.in_3 = in3;
  s.in_4 = in4;
  s.out_1 = out1;
  s.out_2 = out2;
  s.param_1 = pa1;
  s.param_2 = pa2;

  auto f = std::make_shared<Example1::Function>(s, m_example1, &AlgoExample1::compute);

  funcs << f;

  Law::FunctionEvaluator e(funcs);

  e.evaluate(accessor, allCells(), Law::eWithDerivative);

  auto vout1 = accessor.values(out1);
  auto dout1 = accessor.derivatives(out1);
  auto vout2 = accessor.values(out2);
  auto dout2 = accessor.derivatives(out2);

  ENUMERATE_CELL(icell, allCells()) {
    std::cout << "verify AlgoExample1 on cell " << icell->localId() << "...\n";
    std::cout << "out1 = " << vout1[icell] << "\n";
    std::cout << "dout1_in1 = " << dout1[icell][0] << "\n";
    std::cout << "dout1_in2 = " << dout1[icell][1] << "\n";
    std::cout << "dout1_in3 = " << dout1[icell][2] << "\n";
    std::cout << "dout1_in4 = " << dout1[icell][3] << "\n";
    std::cout << "out2 = " << vout2[icell] << "\n";
    std::cout << "dout2_in1 = " << dout2[icell][0] << "\n";
    std::cout << "dout2_in2 = " << dout2[icell][1] << "\n";
    std::cout << "dout2_in3 = " << dout2[icell][2] << "\n";
    std::cout << "dout2_in4 = " << dout2[icell][3] << "\n";
  }
}

/*---------------------------------------------------------------------------*/

void
LawCompilerTesterService::
_unitaryTestExample2()
{
  Law::ScalarRealProperty in1(0,"I1");
  Law::ScalarRealProperty in2a(1,"I2a");
  Law::ScalarRealProperty in2b(2,"I2b");
  Law::ScalarRealProperty in2c(3,"I2c");
  Law::ScalarRealProperty in3(4,"I3");
  Law::ScalarRealProperty in4a(5,"I4a");
  Law::ScalarRealProperty in4b(6,"I4b");
  Law::ScalarRealProperty in5(7,"I5");
  Law::ScalarRealProperty out(8,"O");

  Law::VariableManager vars(mesh());

  vars << Law::variable<Arcane::Cell>(in1);
  vars << Law::variable<Arcane::Cell>(in2a);
  vars << Law::variable<Arcane::Cell>(in2b);
  vars << Law::variable<Arcane::Cell>(in2c);
  vars << Law::variable<Arcane::Cell>(in3);
  vars << Law::variable<Arcane::Cell>(in4a);
  vars << Law::variable<Arcane::Cell>(in4b);
  vars << Law::variable<Arcane::Cell>(in5);
  vars << Law::variableWithDerivative<Arcane::Cell>(out);

  auto accessor = vars.variables<Arcane::Cell>();

  accessor.values(in1).fill(1.);
  accessor.values(in2a).fill(2.);
  accessor.values(in2b).fill(3.);
  accessor.values(in2c).fill(4.);
  accessor.values(in3).fill(5.);
  accessor.values(in4a).fill(6.);
  accessor.values(in4b).fill(7.);
  accessor.values(in5).fill(8.);

  Law::FunctionManager funcs;

  Example2::Signature s;
  s.in_1 = in1;
  s.in_2.add(in2a);
  s.in_2.add(in2b);
  s.in_2.add(in2c);
  s.in_3 = in3;
  s.in_4.add(in4a);
  s.in_4.add(in4b);
  s.in_5 = in5;
  s.out = out;

  auto f = std::make_shared<Example2::Function>(s, m_example2, &AlgoExample2::compute);

  funcs << f;

  Law::FunctionEvaluator e(funcs);

  e.evaluate(accessor, allCells(), Law::eWithDerivative);

  auto vout = accessor.values(out);
  auto dout = accessor.derivatives(out);

  ENUMERATE_CELL(icell, allCells()) {
    std::cout << "verify AlgoExample2 on cell " << icell->localId() << "...\n";
    std::cout << "out = " << vout[icell] << "\n";
    std::cout << "dout_in1 = " << dout[icell][0] << "\n";
    std::cout << "dout_in2a = " << dout[icell][1] << "\n";
    std::cout << "dout_in2b = " << dout[icell][2] << "\n";
    std::cout << "dout_in2c = " << dout[icell][3] << "\n";
    std::cout << "dout_in3 = " << dout[icell][4] << "\n";
    std::cout << "dout_in4a = " << dout[icell][5] << "\n";
    std::cout << "dout_in4b = " << dout[icell][6] << "\n";
    std::cout << "dout_in5 = " << dout[icell][7] << "\n";
  }
}

/*---------------------------------------------------------------------------*/

void
LawCompilerTesterService::
_unitaryTestExample3()
{
  Law::ScalarRealProperty in1(0,"I1");
  Law::VectorialRealProperty in2(1,"I2",3);
  Law::ScalarRealProperty in3a(2,"I3a");
  Law::ScalarRealProperty in3b(3,"I3b");
  Law::ScalarRealProperty in4(4,"I4");
  Law::ScalarRealProperty out1(5,"O1");
  Law::ScalarRealProperty out2(6,"O2");
  Law::ScalarRealProperty pa1(7,"P1");
  Law::ScalarIntegerProperty pa2(8,"P2");

  Law::VariableManager vars(mesh());

  vars << Law::variable<Arcane::Cell>(in1);
  vars << Law::variable<Arcane::Cell>(in2);
  vars << Law::variable<Arcane::Cell>(in3a);
  vars << Law::variable<Arcane::Cell>(in3b);
  vars << Law::variable<Arcane::Cell>(in4);
  vars << Law::variableWithDerivative<Arcane::Cell>(out1);
  vars << Law::variableWithDerivative<Arcane::Cell>(out2);
  vars << Law::variable<Arcane::Cell>(pa1);
  vars << Law::variable<Arcane::Cell>(pa2);

  auto accessor = vars.variables<Arcane::Cell>();

  accessor.values(in1).fill(1.);
  {
    auto v = accessor.values(in2);
    ENUMERATE_CELL(icell,allCells()) {
      v[icell][0] = 2.;
      v[icell][1] = 3.;
      v[icell][2] = 4.;
    }
  }
  accessor.values(in3a).fill(5.);
  accessor.values(in3b).fill(6.);
  accessor.values(in4).fill(7.);

  accessor.values(pa1).fill(8.);
  accessor.values(pa2).fill(9);

  Law::FunctionManager funcs;

  Example3::Signature s;
  s.in_1 = in1;
  s.in_2 = in2;
  s.in_3.add(in3a);
  s.in_3.add(in3b);
  s.in_4 = in4;
  s.out_1 = out1;
  s.out_2 = out2;
  s.param_1 = pa1;
  s.param_2 = pa2;

  auto f = std::make_shared<Example3::Function>(s, m_example3, &AlgoExample3::compute);

  funcs << f;

  Law::FunctionEvaluator e(funcs);

  e.evaluate(accessor, allCells(), Law::eWithDerivative);

  auto vout1 = accessor.values(out1);
  auto dout1 = accessor.derivatives(out1);
  auto vout2 = accessor.values(out2);
  auto dout2 = accessor.derivatives(out2);

  ENUMERATE_CELL(icell, allCells()) {
    std::cout << "verify AlgoExample3 on cell " << icell->localId() << "...\n";
    std::cout << "out1 = " << vout1[icell] << "\n";
    std::cout << "dout1_in1    = " << dout1[icell][0] << "\n";
    std::cout << "dout1_in2[0] = " << dout1[icell][1] << "\n";
    std::cout << "dout1_in2[1] = " << dout1[icell][2] << "\n";
    std::cout << "dout1_in2[2] = " << dout1[icell][3] << "\n";
    std::cout << "dout1_in3a   = " << dout1[icell][4] << "\n";
    std::cout << "dout1_in3b   = " << dout1[icell][5] << "\n";
    std::cout << "dout1_in4    = " << dout1[icell][6] << "\n";
    std::cout << "out2 = " << vout2[icell] << "\n";
    std::cout << "dout2_in1 = " << dout2[icell][0] << "\n";
    std::cout << "dout2_in2[0] = " << dout2[icell][1] << "\n";
    std::cout << "dout2_in2[1] = " << dout2[icell][2] << "\n";
    std::cout << "dout2_in2[2] = " << dout2[icell][3] << "\n";
    std::cout << "dout2_in3a   = " << dout2[icell][4] << "\n";
    std::cout << "dout2_in3b   = " << dout2[icell][5] << "\n";
    std::cout << "dout2_in4    = " << dout2[icell][6] << "\n";
  }
}

/*---------------------------------------------------------------------------*/

void
LawCompilerTesterService::
_unitaryTestExample4()
{
  Law::ScalarRealProperty in1(0,"I1");
  Law::VectorialRealProperty in2(1,"I2",3);
  Law::ScalarRealProperty in3a(2,"I3a");
  Law::ScalarRealProperty in3b(3,"I3b");
  Law::ScalarRealProperty in4(4,"I4");
  Law::VectorialRealProperty out1(5,"O1",2);
  Law::ScalarRealProperty out2(6,"O2");
  Law::ScalarRealProperty pa1(7,"P1");
  Law::ScalarIntegerProperty pa2(8,"P2");

  Law::VariableManager vars(mesh());

  vars << Law::variable<Arcane::Cell>(in1);
  vars << Law::variable<Arcane::Cell>(in2);
  vars << Law::variable<Arcane::Cell>(in3a);
  vars << Law::variable<Arcane::Cell>(in3b);
  vars << Law::variable<Arcane::Cell>(in4);
  vars << Law::variableWithDerivative<Arcane::Cell>(out1);
  vars << Law::variableWithDerivative<Arcane::Cell>(out2);
  vars << Law::variable<Arcane::Cell>(pa1);
  vars << Law::variable<Arcane::Cell>(pa2);

  auto accessor = vars.variables<Arcane::Cell>();

  accessor.values(in1).fill(1.);
  {
    auto v = accessor.values(in2);
    ENUMERATE_CELL(icell,allCells()) {
      v[icell][0] = 2.;
      v[icell][1] = 3.;
      v[icell][2] = 4.;
    }
  }
  accessor.values(in3a).fill(5.);
  accessor.values(in3b).fill(6.);
  accessor.values(in4).fill(7.);

  accessor.values(pa1).fill(8.);
  accessor.values(pa2).fill(9);

  Law::FunctionManager funcs;

  Example4::Signature s;
  s.in_1 = in1;
  s.in_2 = in2;
  s.in_3.add(in3a);
  s.in_3.add(in3b);
  s.in_4 = in4;
  s.out_1 = out1;
  s.out_2 = out2;
  s.param_1 = pa1;
  s.param_2 = pa2;

  auto f = std::make_shared<Example4::Function>(s, m_example4, &AlgoExample4::compute);

  funcs << f;

  Law::FunctionEvaluator e(funcs);

  e.evaluate(accessor, allCells(), Law::eWithDerivative);

  auto vout1 = accessor.values(out1);
  auto dout1 = accessor.derivatives(out1);
  auto vout2 = accessor.values(out2);
  auto dout2 = accessor.derivatives(out2);

  ENUMERATE_CELL(icell, allCells()) {
    std::cout << "verify AlgoExample4 on cell " << icell->localId() << "...\n";
    for(auto i = 0; i < out1.size(); ++i) {
      std::cout << "out1 = " << vout1[icell][i] << "\n";
      std::cout << "dout1_in1    = " << dout1[icell][i][0] << "\n";
      std::cout << "dout1_in2[0] = " << dout1[icell][i][1] << "\n";
      std::cout << "dout1_in2[1] = " << dout1[icell][i][2] << "\n";
      std::cout << "dout1_in2[2] = " << dout1[icell][i][3] << "\n";
      std::cout << "dout1_in3a   = " << dout1[icell][i][4] << "\n";
      std::cout << "dout1_in3b   = " << dout1[icell][i][5] << "\n";
      std::cout << "dout1_in4    = " << dout1[icell][i][6] << "\n";
    }
    std::cout << "out2 = " << vout2[icell] << "\n";
    std::cout << "dout2_in1 = " << dout2[icell][0] << "\n";
    std::cout << "dout2_in2[0] = " << dout2[icell][1] << "\n";
    std::cout << "dout2_in2[1] = " << dout2[icell][2] << "\n";
    std::cout << "dout2_in2[2] = " << dout2[icell][3] << "\n";
    std::cout << "dout2_in3a   = " << dout2[icell][4] << "\n";
    std::cout << "dout2_in3b   = " << dout2[icell][5] << "\n";
    std::cout << "dout2_in4    = " << dout2[icell][6] << "\n";
  }
}

/*---------------------------------------------------------------------------*/

void
LawCompilerTesterService::
_unitaryTestExample5()
{
  Law::ScalarRealProperty in1(0,"I1");
  Law::VectorialRealProperty in2(1,"I2",3);
  Law::ScalarRealProperty in3a(2,"I3a");
  Law::ScalarRealProperty in3b(3,"I3b");
  Law::ScalarRealProperty in4(4,"I4");
  Law::VectorialRealProperty out1(5,"O1",2);
  Law::ScalarRealProperty out2a(6,"O2a");
  Law::ScalarRealProperty out2b(7,"O2b");
  Law::ScalarRealProperty out2c(8,"O2c");
  Law::ScalarRealProperty pa1(9,"P1");
  Law::ScalarIntegerProperty pa2(10,"P2");

  Law::VariableManager vars(mesh());

  vars << Law::variable<Arcane::Cell>(in1);
  vars << Law::variable<Arcane::Cell>(in2);
  vars << Law::variable<Arcane::Cell>(in3a);
  vars << Law::variable<Arcane::Cell>(in3b);
  vars << Law::variable<Arcane::Cell>(in4);
  vars << Law::variableWithDerivative<Arcane::Cell>(out1);
  vars << Law::variableWithDerivative<Arcane::Cell>(out2a);
  vars << Law::variableWithDerivative<Arcane::Cell>(out2b);
  vars << Law::variableWithDerivative<Arcane::Cell>(out2c);
  vars << Law::variable<Arcane::Cell>(pa1);
  vars << Law::variable<Arcane::Cell>(pa2);

  auto accessor = vars.variables<Arcane::Cell>();

  accessor.values(in1).fill(1.);
  {
    auto v = accessor.values(in2);
    ENUMERATE_CELL(icell,allCells()) {
      v[icell][0] = 2.;
      v[icell][1] = 3.;
      v[icell][2] = 4.;
    }
  }
  accessor.values(in3a).fill(5.);
  accessor.values(in3b).fill(6.);
  accessor.values(in4).fill(7.);

  accessor.values(pa1).fill(8.);
  accessor.values(pa2).fill(9);

  Law::FunctionManager funcs;

  Example5::Signature s;
  s.in_1 = in1;
  s.in_2 = in2;
  s.in_3.add(in3a);
  s.in_3.add(in3b);
  s.in_4 = in4;
  s.out_1 = out1;
  s.out_2.add(out2a);
  s.out_2.add(out2b);
  s.out_2.add(out2c);
  s.param_1 = pa1;
  s.param_2 = pa2;

  auto f = std::make_shared<Example5::Function>(s, m_example5, &AlgoExample5::compute);

  funcs << f;

  Law::FunctionEvaluator e(funcs);

  e.evaluate(accessor, allCells(), Law::eWithDerivative);

  auto vout1 = accessor.values(out1);
  auto dout1 = accessor.derivatives(out1);
  auto vout2a = accessor.values(out2a);
  auto dout2a = accessor.derivatives(out2a);
  auto vout2b = accessor.values(out2b);
  auto dout2b = accessor.derivatives(out2b);
  auto vout2c = accessor.values(out2c);
  auto dout2c = accessor.derivatives(out2c);

  ENUMERATE_CELL(icell, allCells()) {
    std::cout << "verify AlgoExample5 on cell " << icell->localId() << "...\n";
    for(auto i = 0; i < out1.size(); ++i) {
      std::cout << "out1 = " << vout1[icell][i] << "\n";
      std::cout << "dout1_in1    = " << dout1[icell][i][0] << "\n";
      std::cout << "dout1_in2[0] = " << dout1[icell][i][1] << "\n";
      std::cout << "dout1_in2[1] = " << dout1[icell][i][2] << "\n";
      std::cout << "dout1_in2[2] = " << dout1[icell][i][3] << "\n";
      std::cout << "dout1_in3a   = " << dout1[icell][i][4] << "\n";
      std::cout << "dout1_in3b   = " << dout1[icell][i][5] << "\n";
      std::cout << "dout1_in4    = " << dout1[icell][i][6] << "\n";
    }
    std::cout << "out2a = " << vout2a[icell] << "\n";
    std::cout << "dout2a_in1 = " << dout2a[icell][0] << "\n";
    std::cout << "dout2a_in2[0] = " << dout2a[icell][1] << "\n";
    std::cout << "dout2a_in2[1] = " << dout2a[icell][2] << "\n";
    std::cout << "dout2a_in2[2] = " << dout2a[icell][3] << "\n";
    std::cout << "dout2a_in3a   = " << dout2a[icell][4] << "\n";
    std::cout << "dout2a_in3b   = " << dout2a[icell][5] << "\n";
    std::cout << "dout2a_in4    = " << dout2a[icell][6] << "\n";
    std::cout << "out2b = " << vout2a[icell] << "\n";
    std::cout << "dout2b_in1 = " << dout2b[icell][0] << "\n";
    std::cout << "dout2b_in2[0] = " << dout2b[icell][1] << "\n";
    std::cout << "dout2b_in2[1] = " << dout2b[icell][2] << "\n";
    std::cout << "dout2b_in2[2] = " << dout2b[icell][3] << "\n";
    std::cout << "dout2b_in3a   = " << dout2b[icell][4] << "\n";
    std::cout << "dout2b_in3b   = " << dout2b[icell][5] << "\n";
    std::cout << "dout2b_in4    = " << dout2b[icell][6] << "\n";
    std::cout << "out2c = " << vout2c[icell] << "\n";
    std::cout << "dout2c_in1 = " << dout2c[icell][0] << "\n";
    std::cout << "dout2c_in2[0] = " << dout2c[icell][1] << "\n";
    std::cout << "dout2c_in2[1] = " << dout2c[icell][2] << "\n";
    std::cout << "dout2c_in2[2] = " << dout2c[icell][3] << "\n";
    std::cout << "dout2c_in3a   = " << dout2c[icell][4] << "\n";
    std::cout << "dout2c_in3b   = " << dout2c[icell][5] << "\n";
    std::cout << "dout2c_in4    = " << dout2c[icell][6] << "\n";
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_LAWCOMPILERTESTER(LawCompilerTester,LawCompilerTesterService);
