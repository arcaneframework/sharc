// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
// -*- C++ -*-
/* Author : desrozis at Wed Aug 26 11:22:48 2015
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "ArcGeoSim/Tests/ServiceTesters/IServiceTester.h"

#include "AuDiTester_axl.h"

#include "ArcGeoSim/Numerics/AuDi/audi.h"

#include <arcane/ITimeLoopMng.h>
#include <arcane/random/Uniform01.h>
#include <arcane/random/LinearCongruential.h>
#include <arcane/Timer.h>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class AuDiTesterService
  : public ArcaneAuDiTesterObject
{
private:
  
  struct Info
  {
    Info() { std::cout << "** create a new Info\n"; }
    ~Info() { std::cout << "** delete Info(" << name << ")\n"; }
    Arcane::String name;
  };
  
public:
 
  AuDiTesterService(const Arcane::ServiceBuildInfo& sbi)
    : ArcaneAuDiTesterObject(sbi)
    , m_timer(subDomain(),"AuDiTimer",Arcane::Timer::TimerReal) {}

  ~AuDiTesterService() {}
  
public:
  
  void init();

  Arcane::Integer test();

private:

  Arcane::Timer m_timer;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
AuDiTesterService::
init()
{

  info() << "Memory collector tester";
  {
	info() << "Pool memory test ...";

	auto check = [&](const auto& p, int size) {
		if(p.current() != size)
			fatal() << "pool error, size is not equal to " << size <<" ...";
	};

    {
      auto &pool_int = audi::pool<int>::get();
      std::cout << &pool_int << std::endl;
      pool_int();
      std::cout << pool_int.current() << std::endl;
      check(pool_int, 1);
      pool_int();
      pool_int();
      std::cout << pool_int.current() << std::endl;
      check(pool_int, 3);
    }
    {
      auto &pool_int = audi::pool<int>::get();
      std::cout << &pool_int << std::endl;
      pool_int();
      std::cout << pool_int.current() << std::endl;
      check(pool_int, 4);
      pool_int();
      pool_int();
      std::cout << pool_int.current() << std::endl;
      check(pool_int, 6);
    }
    {
      auto &pool_int = audi::pool<int>::get();
      pool_int.reset();
      std::cout << &pool_int << std::endl;
      std::cout << pool_int.current() << std::endl;
      check(pool_int, 0);
      pool_int();
      pool_int();
      std::cout << pool_int.current() << std::endl;
      check(pool_int, 2);
    }
  }
  {
    info() << "Stack memory test ...";

    auto display = [](const auto& v) {
      for(auto i : v) {
        std::cout << i << " ";
      }
      std::cout << std::endl;
    };

    auto check = [&](const auto& v, int size, int value) {
      int index = 0;
      for(auto i : v) {
        if(i != value)
          fatal() << "stack error, value is not equal to " << value <<" ...";
        index++;
      }
      if(index != size)
        fatal() << "stack error, size is not equal to " << size <<" ...";
    };

    std::vector<int, std::allocator<int>> u(3, 0);
    std::vector<int, audi::allocator<int>> v(4, 1);
    display(u);
    check(u,3,0);
    display(v);
    check(v,4,1);
    {
      std::vector<int, audi::allocator<int>> v(3, 2);
      display(v);
      check(v,3,2);
    }
    {
      std::vector<int, audi::allocator<int>> v(3, 3);
      display(v);
      check(v,3,3);
    }
  }
}

/*---------------------------------------------------------------------------*/

Arcane::Integer
AuDiTesterService::
test()
{
  Arcane::Integer repeat = 1000000;

  {
    using ADoubleDense = audi::scalar<Arcane::Real, audi::allocator>;

    ADoubleDense a(2);
    a.value() = 1.;
    a.gradient(0) = 10.;
    a.gradient(1) = 20.;

    ADoubleDense b(2);
    b.value() = 2.;
    b.gradient(0) = 2.;
    b.gradient(1) = 3.;

    ADoubleDense c = a * b;

    info() << c;

    Arcane::Real r = 0.;
    {
      Arcane::Timer::SimplePrinter sp(traceMng(),"AD allocator");
      for(auto i = 0; i < repeat; ++i) {
        ADoubleDense c = a * b;
        r += c.value() + c.gradient(0) + c.gradient(1);
      }
    }
    info() << "r = " << r;
  }

  const Arcane::Integer nb_test = 100000;
  const Arcane::Integer size = 10 - 1;
  const Arcane::Integer size_wout_zero = 6;

  Arcane::Real time_exp_tmp_sparse = 0;
  Arcane::Real time_sparse = 0;
  Arcane::Real time_exp_tmp_dense = 0;
  Arcane::Real time_dense = 0;

  using ADoubleDense = audi::scalar<Arcane::Real>;
  using ADoubleSparse = audi::scalar_wrapper<Arcane::Real>;
  for(Arcane::Integer k = 0; k < nb_test; ++k) {

    { // 1ere expression sparse

      Arcane::RealSharedArray aa(size+1), bb(size+1);

      double a_value, b_value;
      Arcane::IntegerSharedArray redir_sparse(size_wout_zero);

      using RandomGenerator = Arcane::random::MinstdRand0;
      using UniformRandomGenerator = Arcane::random::Uniform01<RandomGenerator>;

      RandomGenerator generator;
      UniformRandomGenerator uniform_generator(generator);

      aa[0] = a_value = uniform_generator();
      bb[0] = b_value = uniform_generator();

      for(auto i = 0; i < size; ++i) {
        if(i<size_wout_zero){
          aa[i+1] = uniform_generator();
          bb[i+1] = uniform_generator();
          redir_sparse[i]=i;
        }
        else{
          aa[i+1] = 0;
          bb[i+1] = 0;
        }
      }

      Arcane::ConstArrayView<Arcane::Real> a_grad = aa.subConstView(1, size_wout_zero + 1);
      Arcane::ConstArrayView<Arcane::Real> b_grad = bb.subConstView(1, size_wout_zero + 1);
      Arcane::ConstArrayView<Arcane::Integer> grad_index = redir_sparse.constView();

      ADoubleSparse a {
        a_value,
		size_wout_zero,
        a_grad.unguardedBasePointer(),
		grad_index.unguardedBasePointer()
	  };

      ADoubleSparse b {
        b_value,
		size_wout_zero,
		b_grad.unguardedBasePointer(),
		grad_index.unguardedBasePointer()
      };

      // NB : on aurait pu utiliser aa et bb dans a et b
      // Mais pas une bonne id�e quand on compare des perfs
      // meme si c'est tres grossier

      Arcane::Timer timer(subDomain(),"Test sparse",Arcane::Timer::TimerVirtual);

      timer.start();

      // Evaluation via expression template
      auto r_sparse = 3. * (a * b + a);

      time_exp_tmp_sparse += timer.stop();

      ADoubleDense r = audi::unpack(size, r_sparse);
      audi::pool_reset<Arcane::Real>();

      timer.start();

      // Evaluation sans expression template
      Arcane::RealSharedArray rr(size+1);
      rr[0] = 3. * (aa[0] * bb[0] + aa[0]);
      for(auto i = 1; i < size+1; ++i) {
        rr[i] = 3. * (aa[i] * (bb[0] + 1) + aa[0] * bb[i]);
      }

      time_sparse += timer.stop();

      if(Arcane::math::abs(rr[0] - r.value()) > 1.e-12)
        fatal() << "Numeric error [" << 0 << "] : " << rr[0] << " != " << r.value();
      for(auto i = 0; i < size; ++i) {
        if(Arcane::math::abs(rr[i+1] - r.gradient(i)) > 1.e-12)
          fatal() << "Numeric error [" << i << "] : " << rr[i+1] << " != " << r.gradient(i);
      }
    }

    { // 2eme expression dense
      ADoubleDense a(size), b(size);

      Arcane::RealSharedArray aa(size+1), bb(size+1);

      typedef Arcane::random::MinstdRand0 RandomGenerator;
      typedef Arcane::random::Uniform01<RandomGenerator> UniformRandomGenerator;

      RandomGenerator generator;
      UniformRandomGenerator uniform_generator(generator);

      aa[0] = a.value() = uniform_generator();
      bb[0] = b.value() = uniform_generator();

      for(auto i = 0; i < size; ++i) {
        aa[i+1] = a.gradient(i) = uniform_generator();
        bb[i+1] = b.gradient(i) = uniform_generator();
      }

      // NB : on aurait pu utiliser aa et bb dans a et b
      // Mais pas une bonne id�e quand on compare des perfs
      // m�me si c'est tr�s grossier

      Arcane::Timer timer(subDomain(),"Test dense",Arcane::Timer::TimerVirtual);

      timer.start();

      // Evaluation via expression template
      ADoubleDense r = 3. / (a * 5. + (b / a));

      time_exp_tmp_dense += timer.stop();

      timer.start();

      // Evaluation sans expression template
      Arcane::RealSharedArray rr(size+1);
      rr[0] = 3. / (aa[0] * 5. + (bb[0] / aa[0]));
      for(auto i = 1; i < size+1; ++i) {
        rr[i] = - 3. * ( aa[i] * 5. + (bb[i] * aa[0] - bb[0] * aa[i]) / (aa[0] * aa[0]) )
          / ( (aa[0] * 5. + (bb[0] / aa[0])) * (aa[0] * 5. + (bb[0] / aa[0])) );
      }

      time_dense += timer.stop();

      if(Arcane::math::abs(rr[0] - r.value()) > 1.e-12)
        fatal() << "Numeric error [" << 0 << "] : " << rr[0] << " != " << r.value();
      for(auto i = 0; i < size; ++i) {
        if(Arcane::math::abs(rr[i+1] - r.gradient(i)) > 1.e-12)
          fatal() << "Numeric error [" << i << "] : " << rr[i+1] << " != " << r.gradient(i);
      }
    }

  }

  info() << "= Evaluation times =";
  info() << "[without expression template (sparse)] = " << time_sparse;
  info() << "[with    expression template (sparse)] = " << time_exp_tmp_sparse;
  info() << "[without expression template (dense)] = " << time_dense;
  info() << "[with    expression template (dense)] = " << time_exp_tmp_dense;

  ADoubleDense a(1), b(1), c(1);
  a = 1.;
  a.gradient(0) = 1.;
  b = 2.;
  b.gradient(0) = 1.;
  c = 2.;
  c.gradient(0) = 1.;

  // utilisation de auto pour stocker arbre partiellement
  auto tmp1 = a + b + c;
  auto tmp2 = a + b + tmp1;
  auto tmp3 = a + b + tmp2 + tmp1;

  info() << "tmp[1].value() = " << tmp1.value();
  info() << "tmp[2].value() = " << tmp2.value();
  info() << "tmp[3].value() = " << tmp3.value();
  info() << "tmp[1].gradient() = " << tmp1.gradient(0);
  info() << "tmp[2].gradient() = " << tmp2.gradient(0);
  info() << "tmp[3].gradient() = " << tmp3.gradient(0);

  ADoubleDense d(1);
  d = 9.;
  d.gradient(0) = 9.;

  info() << "sqrt: " << audi::sqrt(d).value() << ", " << audi::sqrt(d).gradient(0);

  ADoubleDense e(1);
  for(auto i = 0; i < 3; ++i)
    e += tmp1;
  info() << "e.value() = " << e.value();
  info() << "e.gradient() = " << e.gradient(0);

  info() << "Basics";
  
  info() << "d : " << d;
  
  if((-d).value() != (-9)) {
    fatal() << "(- d) : error, expected -9, get " << (-d).value();
  }
  if((-d).gradient(0) != (-9)) {
    fatal() << "(- d) : error, expected -9, get " << e.gradient(0);
  }
  info() << "(- d) : " << (- d);

  if((d-1).value() != 8) {
    fatal() << "(d - 1) : error, expected 8, get " << (d-1).value();
  }
  if((d-1).gradient(0) != 9) {
    fatal() << "(d - 1) : error, expected 9, get " << (d-1).gradient(0);
  }
  info() << (d - 1);

  if((1-d).value() != (-8)) {
    fatal() << "(1 - d) : error, expected -8, get " << (1-d).value();
  }
  if((1-d).gradient(0) != (-9)) {
    fatal() << "(1 - d) : error, expected -9, get " << (1-d).gradient(0);
  }
  info() << "(1 - d) : " << (1 - d);

  if((d*2).value() != 18) {
    fatal() << "(d * 2) : error, expected 18, get " << (d*2).value();
  }
  if((d*2).gradient(0) != 18) {
    fatal() << "(d * 2) : error, expected 18, get " << (d*2).gradient(0);
  }
  info() << "(d * 2) : " << (d * 2);
  
  if((2*d).value() != 18) {
    fatal() << "(2 * d) : error, expected 18, get " << (2*d).value();
  }
  if((2*d).gradient(0) != 18) {
    fatal() << "(2 * d) : error, expected 18, get " << (2*d).gradient(0);
  }
  info() << "(2 * d) : " << (2 * d);
  
  if((d+1).value() != 10) {
    fatal() << "(d + 1) : error, expected 10, get " << (d+1).value();
  }
  if((d+1).gradient(0) != 9) {
    fatal() << "(d + 1) : error, expected 9, get " << (d+1).gradient(0);
  }
  info() << "(d + 1) : " << (d + 1);
  
  if((1+d).value() != 10) {
    fatal() << "(1 + d) : error, expected 10, get " << (1+d).value();
  }
  if((1+d).gradient(0) != 9) {
    fatal() << "(1 + d) : error, expected 9, get " << (1+d).gradient(0);
  }
  info() << "(1 + d) : " << (1 + d);

  if((d/2).value() != 4.5) {
    fatal() << "a (d / 2) : error, expected 4.5, get " << (d/2).value();
  }
  if((d/2).gradient(0) != 4.5) {
    fatal() << "b (d / 2) : error, expected 4.5, get " << (d/2).gradient(0);
  }
  info() << "(d / 2) : " << (d/2);
  
  if((1/d).value() != (1./9.)) {
    fatal() << "(1 / d) : error, expected " << (1./9.) << ", get " << (1/d).value();
  }
  if((1/d).gradient(0) != (-1./9.)) {
    fatal() << "(1 / d) : error, expected "<< (-1./9.) << ", get " << (1/d).gradient(0);
  }
  info() << "(1 / d) : " << (1 / d);

  return 1;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

using namespace Arcane;
ARCANE_REGISTER_SERVICE_AUDITESTER(AuDiTester,AuDiTesterService);
