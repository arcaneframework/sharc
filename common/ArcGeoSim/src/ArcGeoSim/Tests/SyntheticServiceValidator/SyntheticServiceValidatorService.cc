// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
/* Author : havep at Tue Apr  7 15:29:24 2009
 * Generated by createNew
 */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "ArcGeoSim/Tests/IServiceValidator.h"

struct SyntheticServiceValidatorTypes
{
  enum eReduction
    {
      Min, Max, Mean, L1Mean, L2Mean
    };
  enum eComparator
    {
      Absolute, Relative, LowerValue, UpperValue
    };
  enum eTargetplatform
    {
      Linux, Windows
    };
};

#include "ArcGeoSim/Tests/Utils/IDataAccessor.h"
#include "ArcGeoSim/Appli/IAppServiceMng.h"
#include "ArcGeoSim/Mesh/Geometry/IGeometryMng.h"
#include "ArcGeoSim/Mesh/Geometry/ManualUpdateGeometryPolicy.h"
#include "SyntheticServiceValidator_axl.h"

#include <arcane/IMesh.h>
#include <arcane/IVariable.h>
#include <arcane/IVariableMng.h>
#include <arcane/datatype/DataTypes.h>
#include <arcane/utils/Limits.h>
#include <arcane/utils/Math.h>
#include <arcane/IParallelMng.h>

#include <arcane/ArcaneTypes.h>
#include <arcane/utils/Collection.h>

#include <limits>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class SyntheticServiceValidatorService 
  : public ArcaneSyntheticServiceValidatorObject
{
public:
  
  SyntheticServiceValidatorService(const Arcane::ServiceBuildInfo & sbi) 
    : ArcaneSyntheticServiceValidatorObject(sbi), m_mesh_group()
    , m_initialized(false)
    , m_flag_validator(true)
    , m_geometry_mng(NULL)
  {
    ;
  }

  virtual ~SyntheticServiceValidatorService() {}

public:

  //! Initialisation
  void init();

  //! Apply service function
  int validate();

private:

  //! Compute reduction
  template<typename T>
  Arcane::Real computeReduction(const T& var);

private:

  //! Item group
  Arcane::ItemGroup m_mesh_group;
  
  bool m_initialized;
  bool m_flag_validator;
  //! Geometry manager
  IGeometryMng* m_geometry_mng;

};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void SyntheticServiceValidatorService::init() {
  if (m_initialized)
    return;
  //! Get validation group and check existence
  m_mesh_group = mesh()->findGroup(options()->groupName());
  if (m_mesh_group.null()) {
    if (options()->verbose()) {
      info() << "Available groups are :";
      ItemGroupCollection coll = mesh()->groups();
      for (ItemGroupCollection::Iterator i = coll.begin(); i
	     != coll.end(); ++i) {
	ItemGroup g = *i;
	info() << "\tGroup : " << g.name() << " size=" << g.size();
      }
    }
    fatal() << "Cannot check on undefined group '"
	    << options()->groupName() << "'";
  }
  //! Initialize DataAccessor
  options()->variableField()->init(m_mesh_group);

  if (options()->targetPlatform.isPresent()) {
    switch (options() -> targetPlatform()) {
    case SyntheticServiceValidatorTypes::Linux:
#ifdef WIN32
      m_flag_validator=false;
#endif
      break;
    case SyntheticServiceValidatorTypes::Windows:
#ifndef WIN32
      m_flag_validator=false;
#endif
      break;
    default:
      error() << "Undefined platform type ["
	      << options()->targetPlatform() << "]";
      break;
    }
  }

  if(options()->reduction() == SyntheticServiceValidatorTypes::L1Mean ||
     options()->reduction() == SyntheticServiceValidatorTypes::L2Mean) {
    //! Find IAppServiceMng
    IServiceMng * service_mng = subDomain()->serviceMng();
    IAppServiceMng * app_service_mng = IAppServiceMng::instance(service_mng);
    
    //! Look for a suitable geometric service
    m_geometry_mng = app_service_mng->find<IGeometryMng> (true);

    //! Property computed for the whole variable
    m_geometry_mng->addItemGroupProperty(m_mesh_group, 
					 IGeometryProperty::PMeasure, 
					 IGeometryProperty::PVariable);

    if(options() -> geometryUpdate()) {
      IGeometryPolicy* geometry_policy = new ManualUpdateGeometryPolicy();
      m_geometry_mng->update(mesh(), geometry_policy);
      delete geometry_policy;
    }
  }

  m_initialized = true;
}

/*---------------------------------------------------------------------------*/

template<typename T>
Arcane::Real 
SyntheticServiceValidatorService::
computeReduction(const T& var)
{
  Real value = 0;
  switch (options()->reduction())
  {
  case SyntheticServiceValidatorTypes::Min:
    {
      value = +FloatInfo<Real>::maxValue();
      ENUMERATE_ITEM(iitem,m_mesh_group.own())
	value = math::min(value,(Real) var[*iitem]);
      value = subDomain()->parallelMng()->reduce(Parallel::ReduceMin, value);
    }
    break;
  case SyntheticServiceValidatorTypes::Max:
    {
      value = -FloatInfo<Real>::maxValue();
      ENUMERATE_ITEM(iitem,m_mesh_group.own())
	value = math::max(value,(Real) var[*iitem]);
      value = subDomain()->parallelMng()->reduce(Parallel::ReduceMax, value);
    }
    break;
  case SyntheticServiceValidatorTypes::Mean:
    {
      ENUMERATE_ITEM(iitem,m_mesh_group.own())
	value += (Real) var[*iitem];
      value = subDomain()->parallelMng()->reduce(Parallel::ReduceSum, value);
      const Integer fullSize = 
	subDomain()->parallelMng()->reduce(Parallel::ReduceSum, m_mesh_group.own().size());
      if (fullSize == 0)
      {
	error() << "Reduction group '" << m_mesh_group.name() << "' is empty";
	value = std::numeric_limits<Real>::quiet_NaN( );
      }
      else
      {
	value /= fullSize;
      }
    }
    break;
  case SyntheticServiceValidatorTypes::L1Mean:
    {
      const IGeometryMng::RealVariable& measure =
	m_geometry_mng->getRealVariableProperty(m_mesh_group,
						IGeometryProperty::PMeasure);

      Arcane::Real domain_measure = 0. ;
      ENUMERATE_ITEM(iitem,m_mesh_group.own()) {
	value += measure[*iitem] * math::abs(var[*iitem]) ;
	domain_measure += measure[*iitem] ;
      }
      value = subDomain()->parallelMng()->reduce(Parallel::ReduceSum, value);
      domain_measure = subDomain()->parallelMng()->reduce(Parallel::ReduceSum, domain_measure);

      if(math::isNearlyZero(domain_measure))
	value = 0. ;
      else
	value /= domain_measure ;
    }
    break;
  case SyntheticServiceValidatorTypes::L2Mean:
    {
      const IGeometryMng::RealVariable& measure =
	m_geometry_mng->getRealVariableProperty(m_mesh_group,
						IGeometryProperty::PMeasure);	
      Arcane::Real domain_measure = 0. ;
      ENUMERATE_ITEM(iitem,m_mesh_group.own()) {
	value += measure[*iitem] * var[*iitem] * var[*iitem] ;
	domain_measure += measure[*iitem] ;
      }
      value = subDomain()->parallelMng()->reduce(Parallel::ReduceSum, value);
      domain_measure = subDomain()->parallelMng()->reduce(Parallel::ReduceSum, domain_measure);

      if(math::isNearlyZero(domain_measure))
	value = 0. ;
      else
	value /= domain_measure ;

      value = math::sqrt(value) ;
    }
    break;
  default:
    error() << "Undefined reduction type [" << options()->reduction() << "]";
  }
  return value;
}

/*---------------------------------------------------------------------------*/

int
SyntheticServiceValidatorService::
validate()
{
  if (!m_initialized) fatal() << "Service not initialized";

  if(!m_flag_validator)
  {
    info() << "Target platform and current platform are different. Validator not activated";
    return 0;
  }

  //! Get checked variable IVariable
  IVariable* ivar = options()->variableField()->variable(m_mesh_group);

  Arcane::Real value = 0.;
  
  if(ivar->isPartial()) {
    if ( ivar->dataType() == DT_Real  )
    {
      //! Construct mesh variable
      ItemPartialVariableScalarRefT<Real> var(ivar);
      //! Computing reduction
      value = computeReduction(var);
    }
    else if ( ivar->dataType() == DT_Int32  )
    {
      //! Construct mesh variable
      ItemPartialVariableScalarRefT<Int32> var(ivar);
      //! Computing reduction
      value = computeReduction(var);
    }
    else
    {
      fatal() << "Only Real or Int32 variables can be validated" ;
    }
  } else {
    if ( ivar->dataType() == DT_Real  )
    {
      //! Construct mesh variable
      ItemVariableScalarRefT<Real> var(ivar);
      //! Computing reduction
      value = computeReduction(var);
    }
    else if ( ivar->dataType() == DT_Int32  )
    {
      //! Construct mesh variable
      ItemVariableScalarRefT<Int32> var(ivar);
      //! Computing reduction
      value = computeReduction(var);
    }
    else
    {
      fatal() << "Only Real or Int32 variables can be validated" ;
    }
  }
  
  const Real reference = options()->referenceValue();
  const Real tolerance = options()->tolerance();

  Real diffError = 0;

  bool isOk = false;

  switch (options()->comparator())
  {
  case SyntheticServiceValidatorTypes::Absolute:
    diffError = math::abs(reference - value);
    isOk = (diffError <= tolerance); // cet ordre permet de gï¿½rer les nans
    // http://msdn.microsoft.com/en-us/library/w22adx1s%28v=vs.80%29.aspx
    break;
  case SyntheticServiceValidatorTypes::Relative:
    diffError = math::abs(reference - value) / math::abs(reference);
    isOk = (diffError <= tolerance);
    break;
  case SyntheticServiceValidatorTypes::LowerValue:
    diffError = value - reference;
    isOk = (diffError >= -tolerance);
    break;
  case SyntheticServiceValidatorTypes::UpperValue:
    diffError = value - reference;
    isOk = (diffError <= tolerance);
    break;
  default:
    error() << "Undefined comparator type [" << options()->comparator() << "]";
  }

  if (options()->verbose() || not isOk)
  {
    info() << "Reduction of variable " << ivar->name() << " on group "
	   << m_mesh_group.name() << " is " << std::fixed << std::setprecision(10)
	   << value;

    switch (options()->comparator())
    {
    case SyntheticServiceValidatorTypes::Absolute:
    case SyntheticServiceValidatorTypes::Relative:
      info() << "Error to reference value " << reference << " is "
	     << std::fixed << std::setprecision(10) << diffError;
      break;
    case SyntheticServiceValidatorTypes::LowerValue:
      if (isOk)
	info() << "Value + Tolerance " << value+tolerance << " is greater than lower Value " << reference;
      else
	info() << "Value + Tolerance " << value+tolerance << " is lower than lower Value " << reference;
      break;
    case SyntheticServiceValidatorTypes::UpperValue:
      if (isOk)
	info() << "Value - Tolerance " << value-tolerance << " is lower than upper Value " << reference;
      else
	info() << "Value - Tolerance " << value-tolerance << " is greater than upper Value " << reference;
      break;
      break;
    default:
      error() << "Undefined comparator type [" << options()->comparator() << "]";
    }
  }

  if (isOk)
    return 0;
  else
    return 1;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_SYNTHETICSERVICEVALIDATOR(SyntheticServiceValidator,SyntheticServiceValidatorService);
