// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2022 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
#include "FieldServiceValidatorService.h"
/* Author : dechaiss at Tue Jul  7 09:51:28 2009
 * Generated by createNew
 */

#include "ArcGeoSim/Appli/IAppServiceMng.h"
#include <arcane/IVariable.h>
#include <arcane/IVariableMng.h>
#include <arcane/ArcaneTypes.h>
#include <arcane/utils/Collection.h>
#include <arcane/IMesh.h>
#include <arcane/utils/Math.h>
#include <arcane/utils/NotSupportedException.h>
#include <arcane/IParallelMng.h>

using namespace Arcane;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
FieldServiceValidatorService::init()
{
  try
    {
      //! Test initialization
      if (m_initialized)
        return;

      //! Get mesh group and check existence
      m_mesh_group = mesh()->findGroup(options()->groupName());

      info() << "Looking for Group : " << options()->groupName();

      if (m_mesh_group.null())
        {
          if (options()->verbose())
            {
              pinfo() << "Available groups are :";
              ItemGroupCollection coll = mesh()->groups();
              for (ItemGroupCollection::Iterator i = coll.begin(); i
                  != coll.end(); ++i)
                {
                  ItemGroup g = *i;
                  pinfo() << "\tGroup : " << g.name() << " size=" << g.size();
                }
            }
          fatal() << "Cannot check on undefined group '"
              << options()->groupName() << "'";
        }

      //! Initialize reference solution access using IDataAccessor
      IDataAccessor * reference_solution = options()->referenceField();
      reference_solution->init(m_mesh_group);

      //! Find IAppServiceMng
      IServiceMng * service_mng = subDomain()->serviceMng();
      IAppServiceMng * app_service_mng = IAppServiceMng::instance(service_mng);

      //! Initialize checked variable accessor
      IDataAccessor* variable = options()->variableField();
      variable->init(m_mesh_group);

      //! Look for a suitable geometric service
      m_geometry_mng = app_service_mng->find<IGeometryMng> (true);

      //! Property computed for the whole variable
      m_geometry_mng->addItemGroupProperty(m_mesh_group,
          IGeometryProperty::PMeasure, IGeometryProperty::PVariable);

//#ifndef NO_USER_WARNING
//#ifndef WIN32
//#warning "TODO: g�rer correctement la d�pendance � la g�om�trie"
//#endif
//#endif /* NO_USER_WARNING */
      // Should have an update done : not the case (+ error if done manually)
      //      m_geometry_mng->update();

    }

  //! Catch exception
  catch (const NotSupportedException& not_supported_exception)
    {
      not_supported_exception.explain(cout);
    }
  m_initialized = true;
}

/*---------------------------------------------------------------------------*/

int
FieldServiceValidatorService::validate()
{
	try
	{
		if (!m_initialized)
			fatal() << "Service not initialized";

		//! Get reference solution (to do first : throw parallel exception)
		IVariable * isol = options()->referenceField()->variable(m_mesh_group);
		//! Construct mesh variable for reference solution

		//! Get checked variable IVariable
		IVariable* ichecked = options()->variableField()->variable(m_mesh_group);

		// some properties about groups are checked first

		ItemGroup groupVar = ichecked->itemGroup();
		ItemGroup groupSol = isol->itemGroup();

		// are groupVar and groupSol identical ?

		ItemVector intersection = BinaryGroupOperations::And(groupSol,groupVar);

		if ( intersection.size() != groupSol.size() || intersection.size() != groupVar.size())
			warning() << "Checked and reference variables are not defined on the same group";

		// if m_mesh_group belongs to groupVar, the substraction of groupVar to m_mesh_group  must be void
		ItemVector substraction = BinaryGroupOperations::Substract(m_mesh_group,groupVar);
		if ( substraction.size() > 0)
			fatal() << "Variable must be checked on a group which belongs to variable's group";

		// if m_mesh_group belongs to groupSol, the substraction of groupSol to m_mesh_group  must be void
		substraction.clear();
		substraction = BinaryGroupOperations::Substract(m_mesh_group,groupSol);
		if ( substraction.size() > 0)
			fatal() << "Variable must be checked on a group which belongs to solution's group";

		if ( ichecked->dataType() == DT_Real && isol->dataType() == DT_Real )
		{
			if ( ichecked->isPartial() && isol->isPartial() )
			{


				//! Construct mesh variable for reference one
				ItemPartialVariableScalarRefT<Real> sol(isol);
				//! Construct mesh variable for checked one
				ItemPartialVariableScalarRefT<Real> var(ichecked);
				return validateVariable(sol,var);
			}
			else if ( !ichecked->isPartial() && !isol->isPartial() )
			{
				//! Construct mesh variable for reference one
				ItemVariableScalarRefT<Real> sol(isol);
				//! Construct mesh variable for checked one
				ItemVariableScalarRefT<Real> var(ichecked);
				return validateVariable(sol,var);
			}
			else if ( ichecked->isPartial() && !isol->isPartial() )
			{
				//! Construct mesh variable for reference one
				ItemVariableScalarRefT<Real> sol(isol);
				//! Construct mesh variable for checked one
				ItemPartialVariableScalarRefT<Real> var(ichecked);
				return validateVariable(sol,var);
			}
			else
			{
				//! Construct mesh variable for reference one
				ItemPartialVariableScalarRefT<Real> sol(isol);
				//! Construct mesh variable for checked one
				ItemVariableScalarRefT<Real> var(ichecked);
				return validateVariable(sol,var);
			}
		}
		else
			if ( isol->dataType() == DT_Int32 && ichecked->dataType() == DT_Int32)
			{
				if ( ichecked->isPartial() && isol->isPartial() )
				{
					//! Construct mesh variable for reference one
					ItemPartialVariableScalarRefT<Int32> sol(isol);
					//! Construct mesh variable for checked one
					ItemPartialVariableScalarRefT<Int32> var(ichecked);
					return validateVariable(sol,var);

				}
				else if ( !ichecked->isPartial() && !isol->isPartial() )
				{
					//! Construct mesh variable for reference one
					ItemVariableScalarRefT<Int32> sol(isol);
					//! Construct mesh variable for checked one
					ItemVariableScalarRefT<Int32> var(ichecked);
					return validateVariable(sol,var);
				}
				else if ( ichecked->isPartial() && !isol->isPartial() )
				{
					//! Construct mesh variable for reference one
					ItemVariableScalarRefT<Int32> sol(isol);
					//! Construct mesh variable for checked one
					ItemPartialVariableScalarRefT<Int32> var(ichecked);
					return validateVariable(sol,var);
				}
				else
				{
					//! Construct mesh variable for reference one
					ItemPartialVariableScalarRefT<Int32> sol(isol);
					//! Construct mesh variable for checked one
					ItemVariableScalarRefT<Int32> var(ichecked);
					return validateVariable(sol,var);
				}
			}
			else
			{
				if ( isol->dataType() != ichecked->dataType())
					fatal() << "Checked and reference variables must be of same type";
				else
					fatal() << "Only Real or Int32 variables can be validated" ;
			}

	}

	catch (const NotSupportedException& not_supported_exception)
	{
		throw ;
	}
  return 1;
}


/*---------------------------------------------------------------------------*/
template<typename VarT>
VarT FieldServiceValidatorService::relativeError(VarT a, VarT b)
{
  VarT relative_error = 0;
  if (!(math::isNearlyZero(a) && math::isNearlyZero(b)))
    //! Note relativeError(a,b)= (a-b)/(|a|+|b|) cf doc namespace math
    relative_error = math::relativeError(a, b);
  return relative_error;
}


/*---------------------------------------------------------------------------*/

template<typename VarT1,typename VarT2>
int
FieldServiceValidatorService::validateVariable(VarT1 & sol, VarT2 & var)
{
      //! Define Error
      Real error = 0;
      String error_type;
      switch (options()->comparator)
        {
      case FieldServiceValidatorTypes::MaxRelativeError:
        {
          ENUMERATE_ITEM(iitem,m_mesh_group.own())
            {
              error = math::max(error,(Real)math::abs(relativeError(var[*iitem],sol[*iitem])));
            }
          error
              = subDomain()->parallelMng()->reduce(Parallel::ReduceMax, error);
          error_type = "Maximum relative error";

          break;
        }
      case FieldServiceValidatorTypes::L2:
        {
          const IGeometryMng::RealVariable & cell_measure =
              m_geometry_mng->getRealVariableProperty(m_mesh_group,
                  IGeometryProperty::PMeasure);
          ENUMERATE_ITEM(iitem,m_mesh_group.own())
            {
              error += ((var[*iitem]-sol[*iitem])*(var[*iitem]-sol[*iitem]))
              *cell_measure[*iitem];
            }
          error
              = subDomain()->parallelMng()->reduce(Parallel::ReduceSum, error);
          error = math::sqrt(error);
          error_type = "Error L2 norm";
          break;
        }
      case FieldServiceValidatorTypes::L2Relative:
        {
          Real field = 0;
          const IGeometryMng::RealVariable & cell_measure =
              m_geometry_mng->getRealVariableProperty(m_mesh_group,
                  IGeometryProperty::PMeasure);
          ENUMERATE_ITEM(iitem,m_mesh_group.own())
            {
              error += ((var[*iitem]-sol[*iitem])*(var[*iitem]-sol[*iitem]))
              *cell_measure[*iitem];
              field += sol[*iitem]*sol[*iitem]*cell_measure[*iitem];
            }
          error
              = subDomain()->parallelMng()->reduce(Parallel::ReduceSum, error);
          error = math::sqrt(error);
          field
              = subDomain()->parallelMng()->reduce(Parallel::ReduceSum, field);
          field = math::sqrt(field);

	  if(field == 0. && error == 0.)
	    error = 0.;
	  else if(field == 0. && error != 0.)
	    error = std::numeric_limits<Real>::max();
	  else
	    error = error / field;
          error_type = "Error Relative L2 norm";
          break;
        }
      case FieldServiceValidatorTypes::Linf:
        {
          ENUMERATE_ITEM(iitem,m_mesh_group.own())
            {
              error = math::max(error,(Real)math::abs(var[*iitem]-sol[*iitem]));
            }
          error
              = subDomain()->parallelMng()->reduce(Parallel::ReduceMax, error);
          error_type = "Error Linf norm";
          break;
        }
      default:
        {
          fatal() << "Error type " << options()->comparator()
              << " not implemented. See in file FieldServiceValidator.axl available implementations";
        }
        }

      const bool isOk = (error <= options()->tolerance()); // cet ordre permet de g�rer les nans

      if (options()->verbose() or !isOk)
          {
            pinfo() << "Comparison of variable " << var.name() << " with " << sol.name() << " on group "
                   << m_mesh_group.name() ;
            if (isOk)
            	pinfo() << error_type << " value " << error
                          << " is lower than tolerance " << options()->tolerance();
            else
            	pinfo() << error_type << " value " << error
            	                          << " is greater than tolerance " << options()->tolerance();
          }


      if (!isOk)
        {
          return 1;
        }
      else
        return 0;

}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_FIELDSERVICEVALIDATOR(FieldServiceValidator,FieldServiceValidatorService);
