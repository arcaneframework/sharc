/* Author : dechaiss at Tue Jul 21 07:54:29 2009
 * Generated by createNew
 */
#include <arcane/IParallelMng.h>
#include <arcane/IIOMng.h>
#include <arcane/IXmlDocumentHolder.h>
#include <arcane/utils/ValueConvert.h>
#include <arcane/IMesh.h>
#include <arcane/IItemFamily.h>

using namespace Arcane;

struct FileAccessorTypes
{
  enum eFileFormat
  {
    Undef = 0,
    Auto,
    IXM
  };
};

#include <arcane/IVariable.h>
#include <arcane/utils/NotSupportedException.h>
#include "ArcGeoSim/Tests/Utils/IDataAccessor.h"
#include "FileAccessor_axl.h"

//#ifndef NO_USER_WARNING
//#ifndef WIN32
//#warning "TODO: (HP) ne g�re pas la fin de vie des variables"
//#endif
//// pour utiliser un setUsed(false), il faut une fin de port��e d'utilisation telle que relase/dispose...
//#endif /* NO_USER_WARNING */

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class FileAccessorService : public ArcaneFileAccessorObject
{
public:
  /** Constructeur de la classe */
  FileAccessorService(const Arcane::ServiceBuildInfo & sbi);

  /** Destructeur de la classe */
  virtual ~FileAccessorService();

public:
  //! Initialization
  void init(const Arcane::ItemGroup& group);

  //! Apply service function
  IVariable * variable(const Arcane::ItemGroup& group);

private:
  //! Create Variable 
  void createVariable(const Arcane::ItemGroup& group);

  //! IXM methods
  void checkVariableFromIXMData(Arcane::eItemKind); //!< V��rification pr��alable
  void loadVariableFromIXMData(const ItemGroup& group);  //!< Chargement effectif des donn��es

  //! Init test
  bool m_initialized;

  //! Groupe associ�� �� la construction
  Arcane::ItemGroup m_group;

  //! Data format
  FileAccessorTypes::eFileFormat m_format;

  //! Mesh variable
  ItemVariableScalarRefT<Real> * m_mesh_variable;

  //! Returned IVariable
  IVariable * m_ivariable;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

FileAccessorService::
FileAccessorService(const Arcane::ServiceBuildInfo & sbi) 
  : ArcaneFileAccessorObject(sbi)
  , m_initialized(false)
  , m_format(FileAccessorTypes::Undef)
  , m_mesh_variable(NULL)
  , m_ivariable(NULL)
{
  ;
}

/*---------------------------------------------------------------------------*/

FileAccessorService::
~FileAccessorService()
{
  delete m_mesh_variable;
}

/*---------------------------------------------------------------------------*/

void
FileAccessorService::init(const Arcane::ItemGroup& group)
{
  m_group = group;
  m_format = options()->fileFormat();
  
  if (m_format == FileAccessorTypes::Auto) {
    if (options()->fileName().endsWith(".ixm"))
      m_format = FileAccessorTypes::IXM;
    else 
      fatal() << "Cannot auto-detect format for file " << options()->fileName();
  }

  //! Choose specialized init with file format
  switch (options()->fileFormat()) {
  case FileAccessorTypes::IXM: {
    checkVariableFromIXMData(group.itemKind());
  } break;
  case FileAccessorTypes::Auto:
  default:
    {
      fatal() << "Format " << options()->fileFormat()
              << " not implemented. See in file FileAccessorService.axl implemented format.";
    }
  }
}

/*---------------------------------------------------------------------------*/

// void
// FileAccessorService::initVtsFormat(const ItemGroup& group)
// {
//   //! Check parameters

//   //! File access cannot proceed if parallel computation
//   if (subDomain()->parallelMng()->isParallel())
//     {
//       const String message =
//           "File Access with FileAccessorService not supported in parallel computation";
//       throw NotSupportedException(A_FUNCINFO, message);
//     }

//   //! Open file if exists else throw fatal
//   IIOMng * ioMng = subDomain()->ioMng();
//   IXmlDocumentHolder * xmlDoc = ioMng->parseXmlFile(options()->fileName());
//   if (xmlDoc == NULL)
//     fatal() << "Cannot open file: " << options()->fileName();

//   //! Read XML file
//   XmlNode rootNode = xmlDoc->documentNode().child("VTKFile");

//   //! Check structured grid
//   if (rootNode.attr("type", true).value() != "StructuredGrid")
//     {
//       fatal()
//           << "Cannot proceed Field validation with reference read from file for unstructured grid";
//     }

//   //! Go to cell Data node
//   XmlNode gridNode = rootNode.child("StructuredGrid");
//   XmlNode pieceNode = gridNode.child("Piece");
//   XmlNode cellDataNode = pieceNode.child("CellData");

//   //! Get structured grid definition
//   Array<Integer> grid_extent;
//   bool hasErrorGrid = builtInGetValue(grid_extent, gridNode.attrValue(
//       "WholeExtent", true));
//   if (hasErrorGrid)
//     {
//       fatal()
//           << "Cannot convert grid node value, of attribute WholeExtent. File "
//           << options()->fileName();
//     }
//   m_x_nb_point = grid_extent[1] - grid_extent[0];
//   m_y_nb_point = grid_extent[3] - grid_extent[2];
//   m_z_nb_point = grid_extent[5] - grid_extent[4];

//   //! Find variable
//   XmlNode varNode = cellDataNode.childWithAttr("DataArray", "Name",
//       options()->fileVariableName());
//   if (!varNode)
//     {
//       fatal() << "Trying to access to variable "
//           << options()->fileVariableName() << " not existing in file "
//           << options()->fileName();
//     }

//   //! Check format (ASCII)
//   if (varNode.attr("format", true).value() != "ascii")
//     {
//       fatal() << " Variable " << options()->fileVariableName()
//           << " is not in ASCII format. Validation from file cannot proceed";
//     }

//   //! convert node value to RealArray
//   bool hasErrorVar = builtInGetValue(m_variable_array, varNode.value());
//   if (hasErrorVar)
//     {
//       fatal() << "Cannot convert variable node value, variable "
//           << options()->fileVariableName() << " file " << options()->fileName();
//     }

//   //! Check variable size and kind
//   if (m_variable_array.size() != group.own().size())
//     {
//       fatal() << "Read variable size different from considered item group size";
//     }

//   //! Declare service initialized
//   m_initialized = true;
// }

/*---------------------------------------------------------------------------*/

void
FileAccessorService::
createVariable(const ItemGroup& group)
{
  if (m_mesh_variable == NULL)
    {
//#ifndef NO_USER_WARNING
//#ifndef WIN32
//#warning "BUG: Probl�me de nommage globale de la variable: risque de collision !!"
//#endif
//#endif /* NO_USER_WARNING */
      // Create a real scalar variable on the group of the mesh
      m_mesh_variable = new ItemVariableScalarRefT<Real> (VariableBuildInfo(group.mesh(), 
                                                                            "FileAccessorVariable",
                                                                            group.itemFamily()->name(),
                                                                            IVariable::PNoRestore|IVariable::PPrivate),
                                                          group.itemKind());
      // Create a IVariable *
      m_ivariable = m_mesh_variable->variable();
    }
}

/*---------------------------------------------------------------------------*/

void
FileAccessorService::
checkVariableFromIXMData(Arcane::eItemKind kind)
{
  // V�rifie que la variable file-variable-name
  // - existe dans le fichier
  // - est de type real
  // - est scalaire (non array)
  // - est port�e par un item du maillage du m�me genre que eItemKind
  // - et si port�e par face ou edge, qu'un bloc <faces> ou <edges> a bien �t� d�fini

  // On ne peut pas faire de contr�le de valeurs, car � cet instant le maillage
  // n'a peut-�tre pas encore atteint l'instant o� il sera utilis� pour porter des donn�es

}

/*---------------------------------------------------------------------------*/

void
FileAccessorService::
loadVariableFromIXMData(const Arcane::ItemGroup & group)
{
  //   ENUMERATE_ITEM(iitem, group.own())
      //     {
      //       (*m_mesh_variable)[iitem] = ...
      //     }
  m_mesh_variable->synchronize();
}

/*---------------------------------------------------------------------------*/

IVariable *
FileAccessorService::
variable(const Arcane::ItemGroup& group)
{
  if (m_mesh_variable == NULL)
    fatal() << "Not initialized service";

  //! Choose specialized init with file format
  switch (m_format) {
  case FileAccessorTypes::IXM:
    {
      loadVariableFromIXMData(group);
      break;
    }
  case FileAccessorTypes::Auto:
  default:
    throw Arcane::NotImplementedException(A_FUNCINFO, 
                                          String::format("Format case [{0}] not implemented in switch", m_format));
  }

  return m_ivariable;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_FILEACCESSOR(FileAccessor, FileAccessorService);
