<#@ template language="C#" #>
<#@ import namespace="System.Linq" #>
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool. 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#ifndef ARCGEOSIM_GENERATED_<#= Model.name.ToUpper() #>_LAW_H
#define ARCGEOSIM_GENERATED_<#= Model.name.ToUpper() #>_LAW_H

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

<# if(MultiThread == MultiThreadMode.ArcaneTBB){ #>
#include <arcane/Concurrency.h>
#include <arcane/utils/PlatformUtils.h>
<# }
   if(MultiThread == MultiThreadMode.Kokkos){ #>
#include <Kokkos_Core.hpp>
<# } #>
#include "ArcGeoSim/Physics/Law2/IFunction.h"
<# if(Debug) { #>
#include <arcane/utils/ITraceMng.h>
<# } #>
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace <#= Model.name #> {

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

struct SignatureDescription
{
  struct ArgDescription {
    Arcane::String name;
    Arcane::String type;
    Arcane::String dim;
  };
  Arcane::UniqueArray<ArgDescription> inputs;
  Arcane::UniqueArray<ArgDescription> outputs;
  Arcane::UniqueArray<ArgDescription> parameters;
  SignatureDescription()
  {
<# foreach(var p in Inputs) { #>
    inputs.add({"<#= p.name #>","<#= p.type #>","<#= p.dim #>"});
<# } 
   foreach(var p in Outputs) { #>
    outputs.add({"<#= p.name #>","<#= p.type #>","<#= p.dim #>"});
<# } 
   foreach(var p in Parameters) { #>
    parameters.add({"<#= p.name #>","<#= p.type #>","<#= p.dim #>"});
<# } #>
  }
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

struct Signature
{
<# foreach(var p in AllProperties) { #>
  <#= p.Type #> <#= p.name #>;
<# } #>  
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class Function
  : public Law::IFunction
{
public:

  template<typename UserAlgo, typename Method>
  Function(const Signature& s,
           UserAlgo& kernel,
           Method method)
    : m_signature(s)
  {
    _ckeck_signature();
    
    typedef void (UserAlgo::*requiredSignature)(
      <#= Signature #>
    );

    typedef void (UserAlgo::*requiredConstSignature)(
      <#= Signature #>
    ) const;

    static_assert(
        std::is_same<Method,requiredSignature>::value ||
        std::is_same<Method,requiredConstSignature>::value,
        "Required signature and method given mismatch !!");

    m_invoker = [&,method](
      <#= CallSignature #>
    ) { (kernel.*method)(<#= ArgSignature #>); };
  }

  ~Function() {}

public:

  Arcane::Integer id() const { return out()[0].id(); }
  
  Arcane::String name() const { return "<#= Model.name #>"; }

  Law::PropertyVector in() const
  {
    Law::PropertyVector v;
<# foreach(var p in Inputs) { #>
    v << m_signature.<#= p.name #>;
<# } #>
    return v;
  }

  Law::PropertyVector out() const
  {
    Law::PropertyVector v;
<# foreach(var p in Outputs) { #>
    v << m_signature.<#= p.name #>;
<# } #>
    return v;
  }

  Law::PropertyVector parameters() const
  {
    Law::PropertyVector v;
<# foreach(var p in Parameters) { #>
    v << m_signature.<#= p.name #>;
<# } #>
    return v;
  }

  bool isDifferentiable() const { return true; }

  bool isParameter() const { return false; }

  const Signature& signature() { return m_signature; }
  
private:

  void _ckeck_signature()
  {
    Law::PropertyVector v;
<# foreach(var p in InOutputs) { #>
<#   if(p.dim == PropertyDim.multiscalar) { #>
    for(auto i = 0; i < m_signature.<#= p.name #>.size(); ++i)
      _check_prop_uniq(v, m_signature.<#= p.name #>[i], "<#= p.name #>["+std::to_string(i)+"]");
<# } else { #>
    _check_prop_uniq(v, m_signature.<#= p.name #>, "<#= p.name #>");
<#   } #>
<# } #>
  }
  
  void _check_prop_uniq(Law::PropertyVector& v, const Law::Property& p, const std::string& p_name)
  {
    if(v.contains(p)) _error_signature(p_name);
    v << p;
  }
  
  void _error_signature(const std::string& prop_name)
  {
    throw Arcane::FatalErrorException(
       "<#= Model.name #>::Signature property uniqueness error, check " + prop_name + " property signature assignment"
    );
  }

public:

  void evaluate(const Law::VariableAccessor& accessor,
                const Arcane::ItemGroup& group,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    _evaluate(mode, static_size, accessor, group);
  }

  void evaluate(const Law::PartialVariableAccessor& accessor,
                const Arcane::ItemGroup& group,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    _evaluate(mode, static_size, accessor, group);
  }

  void evaluate(const Law::ArrayAccessor& accessor,
                const Arcane::Integer& begin,
                const Arcane::Integer& end,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    _evaluate(mode, static_size, accessor, begin, end);
  }

  void evaluate(const Law::ScalarAccessor& accessor,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    _evaluate(mode, static_size, accessor);
  }

private:

  void _evaluateOnlyValues(const Law::VariableAccessor& accessor,
                           const Arcane::ItemGroup& group) const
  {
<# AccessGlobalValues (); #>
<# String groupName = "group"; #>
<# AllocateLocalData (); #>
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, <#=groupName#>) {
<# CopyGlobalValuesToLocalValues ("[iitem]"); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      );
<# CopyLocalOutputsValuesToGlobalValues ("[iitem]"); #>
    }
  }

  void _evaluateOnlyValues(const Law::PartialVariableAccessor& accessor,
                           const Arcane::ItemGroup& group) const
  {
<# AccessGlobalValues (); #>
<# groupName = "group"; #>
<# AllocateLocalData (); #>
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, <#=groupName#>) {
<# CopyGlobalValuesToLocalValues ("[iitem]"); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      );
<# CopyLocalOutputsValuesToGlobalValues ("[iitem]"); #>
    }
  }

  void _evaluateOnlyValues(const Law::ArrayAccessor& accessor,
                           const Arcane::Integer& begin,
                           const Arcane::Integer& end) const
  {
<# AccessGlobalValues (); #>
<# AllocateLocalData (); #>
    // Evaluation loop
    for(Arcane::Integer index = begin; index < end; ++index) {
<# CopyGlobalValuesToLocalValues ("[index]"); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      ); 
<# CopyLocalOutputsValuesToGlobalValues ("[index]"); #>
    }
  }

  void _evaluateOnlyValues(const Law::ScalarAccessor& accessor) const
  {
<# AccessGlobalValues (); #>
<# AllocateLocalData (); #>
    {
<# CopyGlobalValuesToLocalValues ("()", true); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      ); 
<# CopyLocalOutputsValuesToGlobalValues (""); #>
    }
  }

protected:
  void _evaluate(Arcane::Integer size,
                 const Law::VariableAccessor& accessor,
                 const Arcane::ItemGroup& group) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# ResizeGlobalDerivatives (); #>
<# groupName = "group"; #>
<# 
  
   if(MultiThread == MultiThreadMode.ArcaneTBB) { 
     groupName = "items"; #>
    auto partialEvaluateItem = [&](Arcane::ItemVectorView items) {
<# }
   else if(MultiThread == MultiThreadMode.Kokkos) {
#>
     auto group_view = group.view();
     auto partialEvaluateItem = [&](const int i) {
     auto iitem = group_view[i];
<# } #>
<# AllocateLocalData (); #>
<# CreateDerivativesOffsets (); #>
<# if(MultiThread != MultiThreadMode.Kokkos) { #>
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, <#=groupName#>) {
<# } #>
<# CopyGlobalValuesToLocalValues ("[iitem]"); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      );
<# CopyLocalOutputsValuesToGlobalValues ("[iitem]"); #>
<# CopyLocalOutputsDerivativesToGlobalDerivatives ("[iitem]"); #>
<# if(MultiThread != MultiThreadMode.Kokkos){ #>
    }
<# } #>
<# if(MultiThread == MultiThreadMode.ArcaneTBB){ #>
    };
<# parallelEnumerate("group","partialEvaluateItem");  
  } #>
<# if(MultiThread == MultiThreadMode.Kokkos){ #>
    };
<# parallelEnumerate(Model.name, "partialEvaluateItem");  
  } #>
  }

  void _evaluate(Arcane::Integer size,
                 const Law::PartialVariableAccessor& accessor,
                 const Arcane::ItemGroup& group) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# ResizeGlobalDerivatives (); #>
<# groupName = "group"; #>
<# 
  
   if(MultiThread == MultiThreadMode.ArcaneTBB) { 
     groupName = "items"; #>
    auto partialEvaluateItem = [&](Arcane::ItemVectorView items) {
<# }
   else if(MultiThread == MultiThreadMode.Kokkos) {
#>
     auto group_view = group.view();
     auto partialEvaluateItem = [&](const int i) {
     auto iitem = group_view[i];
<# } #>
<# AllocateLocalData (); #>
<# CreateDerivativesOffsets (); #>
<# if(MultiThread != MultiThreadMode.Kokkos) { #>
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, <#=groupName#>) {
<# } #>
<# CopyGlobalValuesToLocalValues ("[iitem]"); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      );
<# CopyLocalOutputsValuesToGlobalValues ("[iitem]"); #>
<# CopyLocalOutputsDerivativesToGlobalDerivatives ("[iitem]"); #>
<# if(MultiThread != MultiThreadMode.Kokkos){ #>
    }
<# } #>
<# if(MultiThread == MultiThreadMode.ArcaneTBB){ #>
    };
<# parallelEnumerate("group","partialEvaluateItem");  
  } #>
<# if(MultiThread == MultiThreadMode.Kokkos){ #>
    };
<# parallelEnumerate(Model.name, "partialEvaluateItem");  
  } #>
  }

  void _evaluate(Arcane::Integer size,
                 const Law::ArrayAccessor& accessor,
                 const Arcane::Integer& begin,
                 const Arcane::Integer& end) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# ResizeGlobalDerivatives (true); #>
<# AllocateLocalData (); #>
<# CreateDerivativesOffsets (); #>
    // Evaluation loop
    for(Arcane::Integer index = begin; index < end; ++index) {
<# CopyGlobalValuesToLocalValues ("[index]"); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      );
<# CopyLocalOutputsValuesToGlobalValues ("[index]"); #>
<# CopyLocalOutputsDerivativesToGlobalDerivatives ("[index]"); #>
    }
  }

  void _evaluate(Arcane::Integer size,
                 const Law::ScalarAccessor& accessor) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# ResizeGlobalDerivatives (); #>
<# AllocateLocalData (); #>
<# CreateDerivativesOffsets (); #>
    {
<# CopyGlobalValuesToLocalValues ("()", true); #>
      // Invoke user kernel
      m_invoker(
        <#= InvokerCallSignature #>
      );
<# CopyLocalOutputsValuesToGlobalValues (""); #>
<# CopyLocalOutputsDerivativesToGlobalDerivatives (""); #>
    }
  }

//
// split and pass private

public:

  void derivativesCorrection(const Law::VariableAccessor& accessor,
                             const Arcane::ItemGroup& group,
                             Law::PropertyVector graph_dependencies,
                             std::map<Law::Property, Law::PropertyVector> in_composed_derivative_ofs,
                             Arcane::Integer nb_unknown_resize) const
<# if(! AllPropertiesScalarReal()) {  #>
  {
    throw Arcane::FatalErrorException("Graph composed derivatives correction only available with scalar real properties error");
  }
<# } else {  #>
  {
<# StaticGlobalDependenciesSize (); #>
<# AccessGlobalDerivatives (); #>
    // Re order derivatives and nullify before correction
    // Could be done directly in _evaluate method with offset as argument
    {
<# ComputeDerivativesReorderOffset (); #>
      //
      // Evaluation loop over items
      ENUMERATE_ITEM(iitem, group) {
<# ReorderDerivativesAndNullify ("[iitem]"); #>
      }
    }
    //
    // Derivatives correction
    Arcane::Integer direct_composed_index = nb_graph_prop - 1;
    for(auto iter_composed : in_composed_derivative_ofs)
    {
<# ComputeDerivativesCorrectionOffset (); #>
      //
      // Evaluation loop over items
      ENUMERATE_ITEM(iitem, group) {
<#  ApplyDerivativesCorrection("[iitem]"); #>
      }
    }
    //
    // Resize to root prop 
    const Arcane::Integer size = nb_unknown_resize;
<# ResizeGlobalDerivatives (); #>
  }
<# } #> 

  void derivativesCorrection(const Law::PartialVariableAccessor& accessor,
                             const Arcane::ItemGroup& group,
                             Law::PropertyVector graph_dependencies,
                             std::map<Law::Property, Law::PropertyVector> in_composed_derivative_ofs,
                             Arcane::Integer nb_unknown_resize) const
<# if(! AllPropertiesScalarReal()) {  #>
  {
    throw Arcane::FatalErrorException("Graph composed derivatives correction only available with scalar real properties error");
  }
<# } else {  #>
  {
<# StaticGlobalDependenciesSize (); #>
<# AccessGlobalDerivatives (); #>
    // Re order derivatives and nullify before correction
    // Could be done directly in _evaluate method with offset as argument
    {
<# ComputeDerivativesReorderOffset (); #>
      //
      // Evaluation loop over items
      ENUMERATE_ITEM(iitem, group) {
<# ReorderDerivativesAndNullify ("[iitem]"); #>
      }
    }
    //
    // Derivatives correction
    Arcane::Integer direct_composed_index = nb_graph_prop - 1;
    for(auto iter_composed : in_composed_derivative_ofs)
    {
<# ComputeDerivativesCorrectionOffset (); #>
      //
      // Evaluation loop over items
      ENUMERATE_ITEM(iitem, group) {
<#  ApplyDerivativesCorrection("[iitem]"); #>
      }
    }
    //
    // Resize to root prop 
    const Arcane::Integer size = nb_unknown_resize;
<# ResizeGlobalDerivatives (); #>
  }
<# } #> 

  void derivativesCorrection(const Law::ArrayAccessor& accessor,
                             const Arcane::Integer& begin,
                             const Arcane::Integer& end,
                             Law::PropertyVector graph_dependencies,
                             std::map<Law::Property, Law::PropertyVector> in_composed_derivative_ofs,
                             Arcane::Integer nb_unknown_resize) const
 <# if(! AllPropertiesScalarReal()) {  #>
  {
    throw Arcane::FatalErrorException("Graph composed derivatives correction only available with scalar real properties error");
  }
<# } else {  #>
  {
<# StaticGlobalDependenciesSize (); #>
<# AccessGlobalDerivatives (); #>
    // Re order derivatives and nullify before correction
    // Could be done directly in _evaluate method with offset as argument
    {
<# ComputeDerivativesReorderOffset (); #>
      //
      // Evaluation loop
      for(Arcane::Integer i = begin; i < end; ++i) {
<# ReorderDerivativesAndNullify ("[i]"); #>
      }
    }
    //
    // Derivatives correction
    Arcane::Integer direct_composed_index = nb_graph_prop - 1;
    for(auto iter_composed : in_composed_derivative_ofs)
    {
<# ComputeDerivativesCorrectionOffset (); #>
      //
      // Evaluation loop
      for(Arcane::Integer i = begin; i < end; ++i) {
<#  ApplyDerivativesCorrection("[i]"); #>
      }
    }  
    //
    // Resize to root prop 
    const Arcane::Integer size = nb_unknown_resize;
<# ResizeGlobalDerivatives (true); #>
  }
<# } #> 

  void derivativesCorrection(const Law::ScalarAccessor& accessor,
                             Law::PropertyVector graph_dependencies,
                             std::map<Law::Property, Law::PropertyVector> in_composed_derivative_ofs,
                             Arcane::Integer nb_unknown_resize) const
<# if(! AllPropertiesScalarReal()) {  #>
  {
    throw Arcane::FatalErrorException("Graph composed derivatives correction only available with scalar real properties error");
  }
<# } else {  #>
  {
<# StaticGlobalDependenciesSize (); #>
<# AccessGlobalDerivatives (); #>
    // Re order derivatives and nullify before correction
    // Could be done directly in _evaluate method with offset as argument
    {
<# ComputeDerivativesReorderOffset (); #>
      //
      //
      {
<# ReorderDerivativesAndNullify (""); #>
      }
    }
    //
    // Derivatives correction
    Arcane::Integer direct_composed_index = nb_graph_prop - 1;
    for(auto iter_composed : in_composed_derivative_ofs)
    {
<# ComputeDerivativesCorrectionOffset (); #>
      //
      // 
      {
<#  ApplyDerivativesCorrection(""); #>
      }
    }
    //
    // Resize to root prop 
    const Arcane::Integer size = nb_unknown_resize;
<# ResizeGlobalDerivatives (); #>
  }
<# } #> 

protected:

  template<typename... T>
  void _evaluate(const Law::EvaluationMode mode, Arcane::Integer static_size, const T&... args) const
  {
    switch(mode)
    {
    case Law::eWithoutDerivative :
      _evaluateOnlyValues(args...);
      break;
    case Law::eWithDerivative :
      if(static_size != 0) {
        _evaluate(static_size, args...);
      } else {
        _evaluate(in().dataSize(), args...);
      }
      break;
    default:
      throw Arcane::FatalErrorException("evaluation case default error");
    }
  }

protected:

  Signature m_signature;

  std::function<
    void(<#= Signature #>)
  > m_invoker;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
<# if(Debug) { #>
struct EpsilonDerivatives
{
<# foreach(var i in Inputs) { #>
  Arcane::Real <#= i.name #> = 1.e-6;
<# } #>
};

class DebugFunction
  : public Function
{
public:

  template<typename UserAlgo, typename Method>
  DebugFunction(const Signature& s,
                UserAlgo& kernel,
                Method method,
                const EpsilonDerivatives& epsilon,
                Arcane::ITraceMng* trace_mng):
                Function(s,kernel,method),
                m_epsilon(epsilon),
                m_trace_mng(trace_mng)
                {};

protected:
  
  void evaluate(const Law::VariableAccessor& accessor,
                const Arcane::ItemGroup& group,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    Function::evaluate(accessor, group, mode, static_size);
<# if(Inputs.Count()>0)
   { #>
    if(mode==Law::eWithDerivative) 
      _check_derivatives(accessor, group);
<# } #>
  }
  
  void evaluate(const Law::PartialVariableAccessor& accessor,
                const Arcane::ItemGroup& group,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    Function::evaluate(accessor, group, mode, static_size);
<# if(Inputs.Count()>0)
   { #>
    if(mode==Law::eWithDerivative) 
      _check_derivatives(accessor, group);
<# } #>
  }
  
  void evaluate(const Law::ArrayAccessor& accessor,
                const Arcane::Integer& begin,
                const Arcane::Integer& end,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    Function::evaluate(accessor, begin, end, mode, static_size);
<# if(Inputs.Count()>0)
   { #>
    if(mode==Law::eWithDerivative) 
      _check_derivatives(accessor,  begin, end);
<# } #>
  }
  
  void evaluate(const Law::ScalarAccessor& accessor,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    Function::evaluate(accessor, mode, static_size);
<# if(Inputs.Count()>0)
   { #>
    if(mode==Law::eWithDerivative) 
      _check_derivatives(accessor);
<# } #>
  }

<# if(Inputs.Count()>0)
   { #>
private:

  void _check_derivatives(const Law::VariableAccessor& accessor,
                          const Arcane::ItemGroup& group) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# AllocateLocalData (); #>
<# AllocateLocalDataFiniteDiff (); #>
<# CreateDerivativesOffsets (); #>
    m_trace_mng->info()<<"<#= Model.name #>"<< " debug evaluation";
    m_trace_mng->info()<<"Check consistency between law derivatives and finite difference ones";
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, group) {
<# CopyGlobalValuesToLocalValues ("[iitem]"); #>
<# CopyGlobalValuesOutputToLocalValues ("[iitem]"); #>
<# ComputeDifferenceFiniteDerivatives(); #>
<# PrintDebugValuesInfos ("[iitem]"); #>
<# PrintDebugDerivativesInfos ("[iitem]"); #>
<# CopyLocalOutputsDerivativesDiffToGlobalDerivatives ("[iitem]"); #>
    }
  }
  
  void _check_derivatives(const Law::PartialVariableAccessor& accessor,
                          const Arcane::ItemGroup& group) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# AllocateLocalData (); #>
<# AllocateLocalDataFiniteDiff (); #>
<# CreateDerivativesOffsets (); #>
    m_trace_mng->info()<<"<#= Model.name #>"<< " debug evaluation";
    m_trace_mng->info()<<"Check consistency between law derivatives and finite difference ones";
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, group) {
<# CopyGlobalValuesToLocalValues ("[iitem]"); #>
<# CopyGlobalValuesOutputToLocalValues ("[iitem]"); #>
<# ComputeDifferenceFiniteDerivatives(); #>
<# PrintDebugValuesInfos ("[iitem]"); #>
<# PrintDebugDerivativesInfos ("[iitem]"); #>
<# CopyLocalOutputsDerivativesDiffToGlobalDerivatives ("[iitem]"); #>
    }
  }
  
  void _check_derivatives(const Law::ArrayAccessor& accessor,
                          const Arcane::Integer& begin,
                          const Arcane::Integer& end) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# AllocateLocalData (); #>
<# AllocateLocalDataFiniteDiff (); #>
<# CreateDerivativesOffsets (); #>
    m_trace_mng->info()<<"<#= Model.name #>"<< " debug evaluation";
    m_trace_mng->info()<<"Check consistency between law derivatives and finite difference ones";
    // Evaluation loop
    for(Arcane::Integer index = begin; index < end; ++index) {
<# CopyGlobalValuesToLocalValues ("[index]"); #>
<# CopyGlobalValuesOutputToLocalValues ("[index]"); #>
<# ComputeDifferenceFiniteDerivatives(); #>
<# PrintDebugValuesInfos ("[index]"); #>
<# PrintDebugDerivativesInfos ("[index]"); #>
<# CopyLocalOutputsDerivativesDiffToGlobalDerivatives ("[index]"); #>
    }
  }
  
  void _check_derivatives(const Law::ScalarAccessor& accessor) const
  {
<# AccessGlobalValues (); #>
<# AccessGlobalDerivatives (); #>
<# AllocateLocalData (); #>
<# AllocateLocalDataFiniteDiff (); #>
<# CreateDerivativesOffsets (); #>
    m_trace_mng->info()<<"<#= Model.name #>"<< " debug evaluation";
    m_trace_mng->info()<<"Check consistency between law derivatives and finite difference ones";
    // Evaluation
    {
<# CopyGlobalValuesToLocalValues ("()", true); #>
<# CopyGlobalValuesOutputToLocalValues ("()", true); #>
<# ComputeDifferenceFiniteDerivatives(); #>
<# PrintDebugValuesInfos ("()"); #>
<# PrintDebugDerivativesInfos (""); #>
<# CopyLocalOutputsDerivativesDiffToGlobalDerivatives (""); #>
    }
  }
<# } #>
private:

<# if(Inputs.Count()>0)
   { #>
  void _print_value(const Arcane::String value_name, const Arcane::Real& value) const
  {
    m_trace_mng->info() << value_name <<" value   = "<< value ;
  }

  void _print_derivatives(const Arcane::String deriv_name, const Arcane::Real& deriv_ref, const Arcane::Real& deriv_test) const
  {
    m_trace_mng->info() << deriv_name <<" ref   = "<< deriv_ref ;
    m_trace_mng->info() << deriv_name <<" test  = "<< deriv_test ;
    m_trace_mng->info() << deriv_name <<" error = "<< (deriv_ref - deriv_test) / (fabs(deriv_ref) + 1.e-20);
  }
<# } #>

private:

  //! Epsilon values to compute derivatives
  EpsilonDerivatives m_epsilon;
  
  //! Manager de trace
  Arcane::ITraceMng* m_trace_mng;

};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
<#  } #>

}

#endif

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
<#+
private bool AllPropertiesScalarReal () 
{
  foreach(var p in AllProperties) { 
  	if(p.dim != PropertyDim.scalar || p.type!= PropertyType.real)
  	  return false;
  }
  return true;
}
private void StaticGlobalDependenciesSize () 
{ #>
   
    // Derivatives dependencies sizes
    const Arcane::Integer nb_graph_prop = graph_dependencies.size();
    const Arcane::Integer nb_direct_prop = in().size();
<#+ 
}

private void ComputeDerivativesReorderOffset () 
{ #>
      Arcane::IntegerUniqueArray static_ofs(nb_direct_prop);
      Arcane::Integer graph_composed_ofs = nb_graph_prop;
      auto in_prop = in();
      Arcane::Integer nb_root_prop = 0;
      for(Arcane::Integer static_index = 0; static_index<nb_direct_prop;++static_index)
      {
        auto prop = in_prop[static_index];
        // Move composed derivatives to the end
        if(in_composed_derivative_ofs.find(prop) != in_composed_derivative_ofs.end())
          static_ofs[static_index] = graph_composed_ofs++;
        // Move root properties to the consistent graph index
        else
        {
          static_ofs[static_index]=graph_dependencies[prop];
          nb_root_prop++;
        }
      }
      // Non root graph derivatives equals zero before correction
      const Arcane::Integer nb_inherited_prop = nb_graph_prop - nb_root_prop;
      Arcane::IntegerUniqueArray inherited_deriv_ofs(nb_inherited_prop);
      Arcane::Integer inherited_index = 0;
      for(Arcane::Integer graph_index = 0; graph_index<nb_graph_prop;++graph_index)
      {
        if(!in_prop.contains(graph_dependencies[graph_index]))
          inherited_deriv_ofs[inherited_index++]=graph_index;
      }
<#+ 
}
private void ReorderDerivativesAndNullify (string op) 
{ #>
<#+ 
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
        Arcane::<#= o.type.Name() #>UniqueArray var_deriv_<#= o.name #>_ini(var_deriv_<#= o.name #><#= op #>.constView());
<#+ 
    break;
    } 
  } #>
        for(Arcane::Integer static_index=0;static_index<nb_direct_prop;++static_index)
        {
<#+ 
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
          var_deriv_<#= o.name #><#= op #>[static_ofs[static_index]] = var_deriv_<#= o.name #>_ini[static_index];
<#+ 
    break;
    } 
  } #>
        }
        for(Arcane::Integer inherited_index=0;inherited_index<nb_inherited_prop;++inherited_index)
        {
<#+ 
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
          var_deriv_<#= o.name #><#= op #>[inherited_deriv_ofs[inherited_index]]=0;
<#+ 
    break;
    } 
  } #>
       }
<#+
}
private void ComputeDerivativesCorrectionOffset () 
{#>
      direct_composed_index++;
      // Derivatives correction through in derivatives properties
      Law::PropertyVector composed_prop_deriv = iter_composed.second;
      Arcane::Integer nb_composed_prop_deriv = composed_prop_deriv.size();
      Arcane::IntegerUniqueArray composed_prop_deriv_ofs(nb_composed_prop_deriv);
      for(Arcane::Integer composed_deriv_index=0;composed_deriv_index<nb_composed_prop_deriv;++composed_deriv_index){
        auto current_in_derived_prop = composed_prop_deriv[composed_deriv_index];
        composed_prop_deriv_ofs[composed_deriv_index] = graph_dependencies[current_in_derived_prop];
      }
      // Only real scalar avalaible in this vesrion (external check)
      Law::Property composed_prop = iter_composed.first;
      Law::ScalarRealProperty& scalar_composed_prop = static_cast<Law::ScalarRealProperty&>(composed_prop);
      // In proproperties has derivatives (external check)
      auto deriv_composed = accessor.derivatives(scalar_composed_prop);
<#+
}
private void parallelEnumerate(string groupName, string lambdaName) 
{
    if(MultiThread == MultiThreadMode.ArcaneTBB) {
#>
      int nb_thread = Arcane::TaskFactory::nbAllowedThread();
      Arcane::ParallelLoopOptions para_options;
      para_options.setMaxThread(nb_thread);
      int grain_size = group.size()/nb_thread + 1;
      para_options.setGrainSize(grain_size);
      Arcane::Parallel::Foreach(<#= groupName #>, para_options, <#= lambdaName #>);
<#+
    }
    else if(MultiThread == MultiThreadMode.Kokkos) {
#>
      Kokkos::parallel_for("<#= groupName #>", group.size(), <#= lambdaName #>);
<#+
    }
}
private void ApplyDerivativesCorrection(string op) 
{
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
        auto direct_derivative_<#= o.name #> = var_deriv_<#= o.name #><#= op #>[direct_composed_index];
<#+ 
    break;
    } 
  } #>
        for(auto derived_index = 0; derived_index < nb_composed_prop_deriv; ++derived_index)
        {
<#+ 
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
          var_deriv_<#= o.name #><#= op #>[composed_prop_deriv_ofs[derived_index]] += direct_derivative_<#= o.name #>*deriv_composed<#= op #>[derived_index];
<#+ 
    break;
    } 
  } #>
        }
<#+
}
private void AccessGlobalValues () 
{ #>
    // Access to global values container
<#+
  foreach(var p in AllProperties) { #>
    auto var_<#= p.name #> = accessor.values(m_signature.<#= p.name #>);
<#+
  }
}

private void AccessGlobalDerivatives () 
{ #>
    // Access to global derivatives container
<#+
  foreach(var o in Outputs) { #>
    auto var_deriv_<#= o.name #> = accessor.derivatives(m_signature.<#= o.name #>);
<#+
  }
}

private void ResizeGlobalDerivatives (bool need_resize_array = false) 
{ #>
    // Resize global outputs
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
    var_deriv_<#= o.name #>.resize(size);
<#+ 
    break;
    case PropertyDim.multiscalar : #>
    for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
      var_deriv_<#= o.name #>[i].resize(size);
    }
<#+ 
    break;
    case PropertyDim.vectorial : 
    if(need_resize_array) { #>
    var_deriv_<#= o.name #>.resize(var_deriv_<#= o.name #>.dim1Size(), m_signature.<#= o.name #>.size(),size);
<#+ 
    } else { #>
    var_deriv_<#= o.name #>.resize(m_signature.<#= o.name #>.size(),size);
<#+ 
    }
    break;
    } 
  }
}

private void CreateDerivativesOffsets () 
{ #>
    // Create derivatives offsets
<#+
  Property prev = null;
  foreach(var p in Inputs) {
    if(prev == null) { #>
    auto ofs_<#= p.name #> = 0;
<#+ 
    } else if (prev.dim != PropertyDim.scalar) { #>
    auto ofs_<#= p.name #> = ofs_<#= prev.name #> + m_signature.<#= prev.name #>.size();
<#+ 
    } else { #>
    auto ofs_<#= p.name #> = ofs_<#= prev.name #> + 1;
<#+
    }
    prev = p;
  }
}

private void AllocateLocalData ()
{ #>
    // Allocate local inputs
<#+
  foreach(var i in Inputs) { 
    switch(i.dim) {
    case PropertyDim.scalar : #>
    Arcane::<#= i.type.Name() #> <#= i.name #>;
<#+ 
    break;
    case PropertyDim.multiscalar : #>
    Arcane::<#= i.type.Name() #>UniqueArray <#= i.name #>(m_signature.<#= i.name #>.size());
<#+ 
    break;
    case PropertyDim.vectorial : #>
    Arcane::<#= i.type.Name() #>ConstArrayView <#= i.name #>;
<#+ 
    break;
    } 
  } #>
    // Allocate local outputs
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #> <#= o.name #>;
<#+ 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #> <#= o.name #>_wrt_<#= i.name #>;
<#+
      break;
      case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= i.name #>.size());
<#+
      break;
      case PropertyDim.vectorial : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= i.name #>.size());
<#+
      break;
      }
    }
    break;
    case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>(m_signature.<#= o.name #>.size());
<#+ 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= o.name #>.size());
<#+
      break;
      case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray2 <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= o.name #>.size(),m_signature.<#= i.name #>.size());
<#+
      break;
      case PropertyDim.vectorial : #>
    Arcane::<#= o.type.Name() #>UniqueArray2 <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= o.name #>.size(),m_signature.<#= i.name #>.size());
<#+
      break;
      }
    }
    break;
    case PropertyDim.vectorial : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>(m_signature.<#= o.name #>.size());
<#+ 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= o.name #>.size());
<#+
      break;
      case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray2 <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= o.name #>.size(),m_signature.<#= i.name #>.size());
<#+
      break;
      case PropertyDim.vectorial : #>
    Arcane::<#= o.type.Name() #>UniqueArray2 <#= o.name #>_wrt_<#= i.name #>(m_signature.<#= o.name #>.size(),m_signature.<#= i.name #>.size());
<#+
      break;
      }
    }
    break;
    }
  } #>
    // Allocate local parameters
<#+
  foreach(var p in Parameters) { 
    switch(p.dim) {
    case PropertyDim.scalar : #>
    Arcane::<#= p.type.Name() #> <#= p.name #>;
<#+ 
    break;
    case PropertyDim.multiscalar : #>
    Arcane::<#= p.type.Name() #>UniqueArray <#= p.name #>(m_signature.<#= p.name #>.size());
<#+ 
    break;
    case PropertyDim.vectorial : #>
    Arcane::<#= p.type.Name() #>ConstArrayView <#= p.name #>;
<#+ 
    break;
    }
  }
}

private void CopyGlobalValuesToLocalValues (string op, bool vectorial_no_op = false)
{ #>
      // Copy global inputs values to local values
<#+
  foreach(var i in Inputs) { 
    switch(i.dim) {
    case PropertyDim.scalar : #>
      <#= i.name #> = var_<#= i.name #><#= op #>;
<#+ 
    break;
    case PropertyDim.multiscalar : #>
      for(auto i = 0; i < m_signature.<#= i.name #>.size(); ++i) {
        <#= i.name #>[i] = var_<#= i.name #>[i]<#= op #>;
      }
<#+ 
    break;
    case PropertyDim.vectorial : 
    if(vectorial_no_op) { #>
      <#= i.name #> = var_<#= i.name #>;
<#+ 
    } else { #>
      <#= i.name #> = var_<#= i.name #><#= op #>;
<#+ 
    }
    break;
    }
  } #>
      // Copy global parameters values to local values
<#+
  foreach(var p in Parameters) { 
    switch(p.dim) {
    case PropertyDim.scalar : #>
      <#= p.name #> = var_<#= p.name #><#= op #>;
<#+ 
    break;
    case PropertyDim.multiscalar : #>
      for(auto i = 0; i < m_signature.<#= p.name #>.size(); ++i) {
        <#= p.name #>[i] = var_<#= p.name #>[i]<#= op #>;
      }
<#+ 
    break;
    case PropertyDim.vectorial : 
    if(vectorial_no_op) { #>
      <#= p.name #> = var_<#= p.name #>;
<#+ 
    } else { #>
      <#= p.name #> = var_<#= p.name #><#= op #>;
<#+
    }
    break;
    }
  }
} 

private void CopyLocalOutputsValuesToGlobalValues (string op)
{ #>
      // Copy local outputs values to global values
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
      var_<#= o.name #><#= op #> = <#= o.name #>;
<#+ 
    break;
    case PropertyDim.multiscalar : #>
      for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
        var_<#= o.name #>[i]<#= op #> = <#= o.name #>[i];
      }
<#+ 
    break;
    case PropertyDim.vectorial : #>
      for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
        var_<#= o.name #><#= op #>[i] = <#= o.name #>[i];
      }
<#+ 
    break;
    }
  }
} 
private void CopyLocalOutputsDerivativesToGlobalDerivatives (string op)
{ #>
      // Copy local outputs derivatives to global derivatives
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
      var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>] = <#= o.name #>_wrt_<#= i.name #>;
<#+
      break;
      case PropertyDim.multiscalar : #>
      for(auto i = 0; i < m_signature.<#= i.name #>.size(); ++i) {
        var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>+i] = <#= o.name #>_wrt_<#= i.name #>[i];
      }
<#+
      break;
      case PropertyDim.vectorial : #>
      for(auto i = 0; i < m_signature.<#= i.name #>.size(); ++i) {
        var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>+i] = <#= o.name #>_wrt_<#= i.name #>[i];
      }
<#+
      break;
      }
    }
    break;
    case PropertyDim.multiscalar : #>
      for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
<#+
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
        var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>] = <#= o.name #>_wrt_<#= i.name #>[i];
<#+
      break;
      case PropertyDim.multiscalar : #>
        for(auto j = 0; j < m_signature.<#= i.name #>.size(); ++j) {
          var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>+j] = <#= o.name #>_wrt_<#= i.name #>[i][j];
        }
<#+
      break;
      case PropertyDim.vectorial : #>
        for(auto j = 0; j < m_signature.<#= i.name #>.size(); ++j) {
          var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>+j] = <#= o.name #>_wrt_<#= i.name #>[i][j];
        }
<#+
      break;
      } 
    } #>
      }
<#+
    break;
    case PropertyDim.vectorial : #>
      for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
<#+
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
        var_deriv_<#= o.name #><#= op #>[i][ofs_<#= i.name #>] = <#= o.name #>_wrt_<#= i.name #>[i];
<#+
      break;
      case PropertyDim.multiscalar : #>
        for(auto j = 0; j < m_signature.<#= i.name #>.size(); ++j) {
          var_deriv_<#= o.name #><#= op #>[i][ofs_<#= i.name #>+j] = <#= o.name #>_wrt_<#= i.name #>[i][j];
        }
<#+
      break;
      case PropertyDim.vectorial : #>
        for(auto j = 0; j < m_signature.<#= i.name #>.size(); ++j) {
          var_deriv_<#= o.name #><#= op #>[i][ofs_<#= i.name #>+j] = <#= o.name #>_wrt_<#= i.name #>[i][j];
        }
<#+
      break;
      }
    } #>
      }
<#+
    break;
    }
  }
} 
private void AllocateLocalDataFiniteDiff ()
{ #>
    // Allocate local outputs values to compute difference finite derivatives
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #> <#= o.name #>_ref;
<#+ 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #> <#= o.name #>_wrt_<#= i.name #>_diff;
<#+
      break;
      case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_wrt_<#= i.name #>_diff(m_signature.<#= i.name #>.size());
<#+
      break;
      }
    }
    break;
    case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_ref(m_signature.<#= o.name #>.size());
<#+
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray <#= o.name #>_wrt_<#= i.name #>_diff(m_signature.<#= o.name #>.size());
<#+
      break;
      case PropertyDim.multiscalar : #>
    Arcane::<#= o.type.Name() #>UniqueArray2 <#= o.name #>_wrt_<#= i.name #>_diff(m_signature.<#= o.name #>.size(),m_signature.<#= i.name #>.size());
<#+
      break;
      }
    }
    break;
    }
  }
}
private void CopyGlobalValuesOutputToLocalValues (string op, bool vectorial_no_op = false)
{ #>
      // Copy global inputs values to local values
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
      <#= o.name #>_ref = var_<#= o.name #><#= op #>;
<#+ 
    break;
    case PropertyDim.multiscalar : #>
      for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
        <#= o.name #>_ref[i] = var_<#= o.name #>[i]<#= op #>;
      }
<#+ 
    break;
    }
  }
}
private void ComputeDifferenceFiniteDerivatives ()
{
  foreach(var i in Inputs) { #>
      // compute difference finite derivatives through <#= i.name #>
<#+ 
    switch(i.dim) {
    case PropertyDim.scalar : #>
      {
        <#= i.name #> += m_epsilon.<#= i.name #>;
        // Invoke user kernel
        m_invoker(
          <#= InvokerCallSignature #>
        );
        <#= i.name #> -= m_epsilon.<#= i.name #>;
<#+ 
    foreach(var o in Outputs) {
      switch(o.dim) {
      case PropertyDim.scalar : #>
        <#= o.name #>_wrt_<#= i.name #>_diff = (<#= o.name #> - <#= o.name #>_ref) / m_epsilon.<#= i.name #>;
<#+
      break;
      case PropertyDim.multiscalar : #>
        for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i)
          <#= o.name #>_wrt_<#= i.name #>_diff[i] = (<#= o.name #>[i] - <#= o.name #>_ref[i]) / m_epsilon.<#= i.name #>;
<#+
      break;
      }
    } #>
      }
<#+
    break;
    case PropertyDim.multiscalar : #>
      for(int i = 0; i < m_signature.<#= i.name #>.size(); ++i) {
        <#= i.name #>[i] += m_epsilon.<#= i.name #>;
        // Invoke user kernel
        m_invoker(
          <#= InvokerCallSignature #>
        );
        <#= i.name #>[i] -= m_epsilon.<#= i.name #>;
<#+
    foreach(var o in Outputs) {
      switch(o.dim) {
      case PropertyDim.scalar : #>
        <#= o.name #>_wrt_<#= i.name #>_diff[i] = (<#= o.name #> - <#= o.name #>_ref) / m_epsilon.<#= i.name #>;
<#+
      break;
      case PropertyDim.multiscalar : #>
        for(int j = 0; j < m_signature.<#= o.name #>.size(); ++j)
          <#= o.name #>_wrt_<#= i.name #>_diff[j][i] = (<#= o.name #>[j] - <#= o.name #>_ref[j]) / m_epsilon.<#= i.name #>;
<#+
      break;
      }
    } #>
      }
<#+           
    break;
    } 
  }
}
private void CopyLocalOutputsDerivativesDiffToGlobalDerivatives (string op)
{ #>
      // Overwrite global derivatives by difference finite ones
      {
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
        var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>] = <#= o.name #>_wrt_<#= i.name #>_diff;
<#+
      break;
      case PropertyDim.multiscalar : #>
        for(auto i = 0; i < m_signature.<#= i.name #>.size(); ++i)
          var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>+i] = <#= o.name #>_wrt_<#= i.name #>_diff[i];
<#+
      break;
      }
    }
    break;
    case PropertyDim.multiscalar : #>
        for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
<#+
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
          var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>] = <#= o.name #>_wrt_<#= i.name #>_diff[i];
<#+
      break;
      case PropertyDim.multiscalar : #>
          for(auto j = 0; j < m_signature.<#= i.name #>.size(); ++j)
            var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>+j] = <#= o.name #>_wrt_<#= i.name #>_diff[i][j];
<#+
      break;
      } 
    } #>
        }
<#+
    break;
    }
  } #>
      }
<#+
}
private void PrintDebugValuesInfos (string op)
{ #>
      // Print debug values
      {
<#+
  foreach(var o in InOutputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : #>
        _print_value("<#= o.name #>", var_<#= o.name #><#= op #>);
<#+
    break;
    case PropertyDim.multiscalar : #>
        for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i)
          _print_value(Arcane::String::format("<#= o.name #>[{0}]",i), var_<#= o.name #>[i]<#= op #>);
<#+
    break;
    }
  } #>
      }
<#+    
}
private void PrintDebugDerivativesInfos (string op)
{ #>
      // Print derivatives debug informations
      {
<#+
  foreach(var o in Outputs) { 
    switch(o.dim) {
    case PropertyDim.scalar : 
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
        _print_derivatives("d<#= o.name #>_d<#= i.name #>", var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>], <#= o.name #>_wrt_<#= i.name #>_diff);
<#+
      break;
      case PropertyDim.multiscalar : #>
        for(auto i = 0; i < m_signature.<#= i.name #>.size(); ++i)
          _print_derivatives(Arcane::String::format("d<#= o.name #>_d<#= i.name #>[{0}]",i), var_deriv_<#= o.name #><#= op #>[ofs_<#= i.name #>+i], <#= o.name #>_wrt_<#= i.name #>_diff[i]);
<#+
      break;
      }
    }
    break;
    case PropertyDim.multiscalar : #>
        for(auto i = 0; i < m_signature.<#= o.name #>.size(); ++i) {
<#+
    foreach(var i in Inputs) {
      switch(i.dim) {
      case PropertyDim.scalar : #>
          _print_derivatives(Arcane::String::format("d<#= o.name #>[{0}]_d<#= i.name #>",i), var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>], <#= o.name #>_wrt_<#= i.name #>_diff[i]);
<#+
      break;
      case PropertyDim.multiscalar : #>
          for(auto j = 0; j < m_signature.<#= i.name #>.size(); ++j)
            _print_derivatives(Arcane::String::format("d<#= o.name #>[{0}]_d<#= i.name #>[{1}]",i,j), var_deriv_<#= o.name #>[i]<#= op #>[ofs_<#= i.name #>+j], <#= o.name #>_wrt_<#= i.name #>_diff[i][j]);
<#+
      break;
      } 
    } #>
        }
<#+
    break;
    }
  } #>
      }
<#+    
}
#>