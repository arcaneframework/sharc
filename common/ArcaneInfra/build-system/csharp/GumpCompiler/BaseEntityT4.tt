<#@ template language="C#" #>
<#@ import namespace="System.Linq" #>
<# 
var gump = this.Session["gump"] as gump;
var path = this.Session["path"] as string; 
var entity = this.Session["entity"] as Entity; 
var all_uniques = entity.UniqueEntities(gump);
var uniques_by_kind = entity.UniqueEntitiesByKind(gump);
var multiples = entity.MultipleEntities(gump);
var nested = entity.NestedBaseEntities(gump).Except(all_uniques).Except(multiples);
#>
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by tool <#= GumpCompiler.Version.Name #> v<#= GumpCompiler.Version.Number #>.
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
#ifndef <#= gump.model.@namespace.ToUpper()  #>_GENERATED_BY_GUMP_<#= entity.name.ToUpper() #>_H
#define <#= gump.model.@namespace.ToUpper()  #>_GENERATED_BY_GUMP_<#= entity.name.ToUpper() #>_H

#include "ArcGeoSim/Physics/Gump/Entity.h"
#include "ArcGeoSim/Physics/Gump/Enumerator.h"
<#  
foreach(var e in entity.AllEntities(gump)) { 
#>
#include "<#= path #>/Entities/<#= e.name #>.h"
<#  
  foreach(var ee in e.ChildEntities(gump)) { 
#>
#include "<#= path #>/Entities/<#= ee.name #>.h"
<#
  } 
}
#>
#include "<#= path #>/Entities/EntityKind.h"
#include "<#= path #>/Entities/EntityTag.h"

namespace <#= gump.model.@namespace #> {

  class <#= entity.name #> : public Gump::EntityT<<#= entity.name #>>
  {
  public:
    
    <#= entity.name #>() {}
    
    <#= entity.name #>(<#= entity.name #>&& e)
      : Gump::EntityT<<#= entity.name #>>(e) {}
    
    <#= entity.name #>(const <#= entity.name #>& e)
      : Gump::EntityT<<#= entity.name #>>(e) {}
    
    <#= entity.name #>(Gump::Private::Entity* e)
      : Gump::EntityT<<#= entity.name #>>(e)
    {
      ARCANE_ASSERT((e->kind() == <#= entity.Kind () #>), ("entity kind error"));
    }
    
    <#= entity.name #>(const Gump::Entity& e)
      : Gump::EntityT<<#= entity.name #>>(e)
    {
      ARCANE_ASSERT((e.kind() == <#= entity.Kind () #>), ("entity kind error"));
    }
   
    <#= entity.name #>& operator=(const <#= entity.name #>& e)
    {
      m_private = e.m_private;
      return *this;
    }

<#  
foreach (var uniques in uniques_by_kind) {
  int i = 0;
  foreach (var e in uniques) {  
#>
    <#= e.name  #> <#= e.Object()  #>() const {
      return <#= e.name  #>(m_private->entity(<#= i++ #>, <#= e.Kind ()  #>)); 
    }

<#  
  }
}
foreach (var e in multiples.Where(ee => ee.@base == null)) { 
#>
    Gump::EnumeratorT<<#= e.name #>> <#= e.Enumerator() #>() const { 
      return m_private->entities(<#= e.Kind () #>); 
    }
    Arcane::Integer numberOf<#= e.Multiple() #>() const { 
      return m_private->numberOf(<#= e.Kind () #>); 
    }
    <#= e.name #> <#= e.Object() #>(Arcane::Integer i) const { 
     return <#= e.name #>(m_private->entity(i, <#= e.Kind () #>)); 
    }
    <#= e.name #> <#= e.Object() #>(Arcane::String name) const { 
     return <#= e.name #>(m_private->entity(name, <#= e.Kind () #>)); 
    }

<# 
}
foreach (var e in multiples.Where(ee => ee.@base != null)) {
#>
    Gump::EnumeratorT<<#= e.name #>> <#= e.Enumerator () #>() const { 
      return m_private->entities(<#= e.Kind () #>, <#= e.Tag () #>); 
    }
    Arcane::Integer numberOf<#= e.Multiple () #>() const { 
      return m_private->numberOf(<#= e.Kind () #>, <#= e.Tag () #>); 
    }
    
<#
}
foreach (var e in nested.Where(ee => ee.@base == null)) { 
#>
    Gump::EnumeratorT<<#= e.name #>> <#= e.Enumerator() #>() const { 
      return m_private->entities(<#= e.Kind () #>); 
    }
    Arcane::Integer numberOf<#= e.Multiple() #>() const { 
      return m_private->numberOf(<#= e.Kind () #>); 
    }
    <#= e.name #> <#= e.Object() #>(Arcane::Integer i) const { 
      return <#= e.name #>(m_private->entity(i, <#= e.Kind () #>)); 
    }
    <#= e.name #> <#= e.Object() #>(Arcane::String name) const { 
      return <#= e.name #>(m_private->entity(name, <#= e.Kind () #>)); 
    }

<# 
}
foreach (var e in nested.Where(ee => ee.@base != null)) {
#>
    Gump::EnumeratorT<<#= e.name #>> <#= e.Enumerator () #>() const { 
      return m_private->entities(<#= e.Kind () #>, <#= e.Tag () #>); 
    }
    Arcane::Integer numberOf<#= e.Multiple () #>() const { 
      return m_private->numberOf(<#= e.Kind () #>, <#= e.Tag () #>); 
    }
    
<#
}
#>    const <#= entity.name #>* operator->() const { return this; }
    <#= entity.name #>* operator->() { return this; }
  };

}

#define ENUMERATE_<#= entity.name.ToUpper() #>(e,enumerator) \
  for(auto e = enumerator; e.hasNext(); ++e)

#define ENUMERATE_SOME_<#= entity.name.ToUpper() #>(e,enumerator,predicat) \
  for(auto e = enumerator; e.hasNext(); ++e) if(not predicat) continue; else 
 
#endif /* <#= gump.model.@namespace.ToUpper()  #>_GENERATED_BY_GUMP_<#= entity.name.ToUpper() #>_H */
