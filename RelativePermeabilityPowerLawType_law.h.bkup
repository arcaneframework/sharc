// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool. 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#ifndef ARCGEOSIM_GENERATED_RELATIVEPERMEABILITYPOWERLAWTYPE_LAW_H
#define ARCGEOSIM_GENERATED_RELATIVEPERMEABILITYPOWERLAWTYPE_LAW_H

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "ArcGeoSim/Physics/Law2/IFunction.h"
#include <mipp.h>
#include <vector>
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace RelativePermeabilityPowerLawType {

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

struct SignatureDescription
{
  struct ArgDescription {
    Arcane::String name;
    Arcane::String type;
    Arcane::String dim;
  };
  Arcane::UniqueArray<ArgDescription> inputs;
  Arcane::UniqueArray<ArgDescription> outputs;
  Arcane::UniqueArray<ArgDescription> parameters;
  SignatureDescription()
  {
    inputs.add({"saturation","real","scalar"});
    outputs.add({"relativePermeability","real","scalar"});
  }
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

struct Signature
{
  Law::ScalarRealProperty saturation;
  Law::ScalarRealProperty relativePermeability;
  
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

class Function
  : public Law::IFunction
{
public:

  template<typename UserAlgo, typename Method>
  Function(const Signature& s,
           UserAlgo& kernel,
           Method method)
    : m_signature(s)
  {
    _ckeck_signature();

    typedef void (UserAlgo::*requiredSignature)(
      mipp::Reg<Arcane::Real>,mipp::Reg<Arcane::Real>&,mipp::Reg<Arcane::Real>&
    );

    typedef void (UserAlgo::*requiredConstSignature)(
            mipp::Reg<Arcane::Real>,mipp::Reg<Arcane::Real>&,mipp::Reg<Arcane::Real>&
    ) const;


    static_assert(
        std::is_same<Method,requiredSignature>::value ||
        std::is_same<Method,requiredConstSignature>::value,
        "Required signature and method given mismatch !!");

    m_invoker = [&,method](
      mipp::Reg<Arcane::Real> a0,mipp::Reg<Arcane::Real>& a1,mipp::Reg<Arcane::Real>& a2
    ) { (kernel.*method)(a0,a1,a2); };
  }

  ~Function() {}

public:

  Arcane::Integer id() const { return out()[0].id(); }
  
  Arcane::String name() const { return "RelativePermeabilityPowerLawType"; }

  Law::PropertyVector in() const
  {
    Law::PropertyVector v;
    v << m_signature.saturation;
    return v;
  }

  Law::PropertyVector out() const
  {
    Law::PropertyVector v;
    v << m_signature.relativePermeability;
    return v;
  }

  Law::PropertyVector parameters() const
  {
    Law::PropertyVector v;
    return v;
  }

  bool isDifferentiable() const { return true; }

  bool isParameter() const { return false; }

  const Signature& signature() { return m_signature; }
  
private:

  void _ckeck_signature()
  {
    Law::PropertyVector v;
    _check_prop_uniq(v, m_signature.saturation, "saturation");
    _check_prop_uniq(v, m_signature.relativePermeability, "relativePermeability");
  }
  
  void _check_prop_uniq(Law::PropertyVector& v, const Law::Property& p, const std::string& p_name)
  {
    if(v.contains(p)) _error_signature(p_name);
    v << p;
  }
  
  void _error_signature(const std::string& prop_name)
  {
    throw Arcane::FatalErrorException(
       "RelativePermeabilityPowerLawType::Signature property uniqueness error, check " + prop_name + " property signature assignment"
    );
  }

public:

  void evaluate(const Law::VariableAccessor& accessor,
                const Arcane::ItemGroup& group,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    _evaluate(mode, static_size, accessor, group);
  }

  void evaluate(const Law::PartialVariableAccessor& accessor,
                const Arcane::ItemGroup& group,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    _evaluate(mode, static_size, accessor, group);
  }

  void evaluate(const Law::ArrayAccessor& accessor,
                const Arcane::Integer& begin,
                const Arcane::Integer& end,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    _evaluate(mode, static_size, accessor, begin, end);
  }

  void evaluate(const Law::ScalarAccessor& accessor,
                const Law::EvaluationMode mode,
                Arcane::Integer static_size = 0) const
  {
    _evaluate(mode, static_size, accessor);
  }

private:

  void _evaluateOnlyValues(const Law::VariableAccessor& accessor,
                           const Arcane::ItemGroup& group) const
  {
    // Access to global values container
    auto var_saturation = accessor.values(m_signature.saturation);
    auto var_relativePermeability = accessor.values(m_signature.relativePermeability);
    // Allocate local inputs
    Arcane::Real saturation;
    // Allocate local outputs
    Arcane::Real relativePermeability;
    Arcane::Real relativePermeability_wrt_saturation;
    // Allocate local parameters
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, group) {
      // Copy global inputs values to local values
      saturation = var_saturation[iitem];
      // Copy global parameters values to local values
      // Invoke user kernel
      /*
      m_invoker(
        saturation,relativePermeability,relativePermeability_wrt_saturation
      );
       */
      // Copy local outputs values to global values
      var_relativePermeability[iitem] = relativePermeability;
    }
  }

  void _evaluateOnlyValues(const Law::PartialVariableAccessor& accessor,
                           const Arcane::ItemGroup& group) const
  {
    // Access to global values container
    auto var_saturation = accessor.values(m_signature.saturation);
    auto var_relativePermeability = accessor.values(m_signature.relativePermeability);
    // Allocate local inputs
    Arcane::Real saturation;
    // Allocate local outputs
    Arcane::Real relativePermeability;
    Arcane::Real relativePermeability_wrt_saturation;
    // Allocate local parameters
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, group) {
      // Copy global inputs values to local values
      saturation = var_saturation[iitem];
      // Copy global parameters values to local values
      // Invoke user kernel
          /*
          m_invoker(
            saturation,relativePermeability,relativePermeability_wrt_saturation
          );
           */
      // Copy local outputs values to global values
      var_relativePermeability[iitem] = relativePermeability;
    }
  }

  void _evaluateOnlyValues(const Law::ArrayAccessor& accessor,
                           const Arcane::Integer& begin,
                           const Arcane::Integer& end) const
  {
    // Access to global values container
    auto var_saturation = accessor.values(m_signature.saturation);
    auto var_relativePermeability = accessor.values(m_signature.relativePermeability);
    // Allocate local inputs
    Arcane::Real saturation;
    // Allocate local outputs
    Arcane::Real relativePermeability;
    Arcane::Real relativePermeability_wrt_saturation;
    // Allocate local parameters
    // Evaluation loop
    for(Arcane::Integer index = begin; index < end; ++index) {
      // Copy global inputs values to local values
      saturation = var_saturation[index];
      // Copy global parameters values to local values
      // Invoke user kernel
        /*
        m_invoker(
          saturation,relativePermeability,relativePermeability_wrt_saturation
        );
         */
      // Copy local outputs values to global values
      var_relativePermeability[index] = relativePermeability;
    }
  }

  void _evaluateOnlyValues(const Law::ScalarAccessor& accessor) const
  {
    // Access to global values container
    auto var_saturation = accessor.values(m_signature.saturation);
    auto var_relativePermeability = accessor.values(m_signature.relativePermeability);
    // Allocate local inputs
    Arcane::Real saturation;
    // Allocate local outputs
    Arcane::Real relativePermeability;
    Arcane::Real relativePermeability_wrt_saturation;
    // Allocate local parameters
    {
      // Copy global inputs values to local values
      saturation = var_saturation();
      // Copy global parameters values to local values
      // Invoke user kernel
        /*
        m_invoker(
          saturation,relativePermeability,relativePermeability_wrt_saturation
        );
         */
      // Copy local outputs values to global values
      var_relativePermeability = relativePermeability;
    }
  }

protected:
  void _evaluate(Arcane::Integer size,
                 const Law::VariableAccessor& accessor,
                 const Arcane::ItemGroup& group) const
  {
    // Access to global values container
    auto var_saturation = accessor.values(m_signature.saturation);
    auto var_relativePermeability = accessor.values(m_signature.relativePermeability);
    // Access to global derivatives container
    auto var_deriv_relativePermeability = accessor.derivatives(m_signature.relativePermeability);
    // Resize global outputs
    var_deriv_relativePermeability.resize(size);
    // Allocate local inputs
    mipp::Reg<Arcane::Real> saturation;
    // Allocate local outputs
    mipp::Reg<Arcane::Real> relativePermeability;
    mipp::Reg<Arcane::Real> relativePermeability_wrt_saturation;
    // Allocate local parameters
    // Create derivatives offsets
    auto ofs_saturation = 0;
    // Evaluation loop over items
    std::vector<Arcane::Real> std_saturation(group.size());
    std::vector<Arcane::Real> std_relativePermeability(group.size());
    std::vector<Arcane::Real> std_deriv_relativePermeability(group.size());
    int i = 0;
    ENUMERATE_ITEM(iitem, group){
        std_saturation[i] = var_saturation[iitem];
        i++;
      }
      for (int k = 0; k<group.size(); k+=mipp::N<Real>()) {
          // Copy global inputs values to local values
          saturation.load(&std_saturation[k]);
          // Copy global parameters values to local values
          // Invoke user kernel
          m_invoker(
            saturation,relativePermeability,relativePermeability_wrt_saturation
          );
          // Copy local outputs values to global values
          relativePermeability.store(&std_relativePermeability[k]);
          relativePermeability_wrt_saturation.store(&std_deriv_relativePermeability[k]);
      }
      i = 0;
      ENUMERATE_ITEM(iitem, group){
          var_relativePermeability[iitem] = std_relativePermeability[i];
          var_deriv_relativePermeability[iitem][ofs_saturation] = std_deriv_relativePermeability[i];
          i++;
      }
  }

  void _evaluate(Arcane::Integer size,
                 const Law::PartialVariableAccessor& accessor,
                 const Arcane::ItemGroup& group) const
  {
    // Access to global values container
    auto var_saturation = accessor.values(m_signature.saturation);
    auto var_relativePermeability = accessor.values(m_signature.relativePermeability);
    // Access to global derivatives container
    auto var_deriv_relativePermeability = accessor.derivatives(m_signature.relativePermeability);
    // Resize global outputs
    var_deriv_relativePermeability.resize(size);
    // Allocate local inputs
    Arcane::Real saturation;
    // Allocate local outputs
    Arcane::Real relativePermeability;
    Arcane::Real relativePermeability_wrt_saturation;
    // Allocate local parameters
    // Create derivatives offsets
    auto ofs_saturation = 0;
    // Evaluation loop over items
    ENUMERATE_ITEM(iitem, group) {
      // Copy global inputs values to local values
      saturation = var_saturation[iitem];
      // Copy global parameters values to local values
      // Invoke user kernel
          /*
          m_invoker(
            saturation,relativePermeability,relativePermeability_wrt_saturation
          );
           */
      // Copy local outputs values to global values
      var_relativePermeability[iitem] = relativePermeability;
      // Copy local outputs derivatives to global derivatives
      var_deriv_relativePermeability[iitem][ofs_saturation] = relativePermeability_wrt_saturation;
    }
  }

  void _evaluate(Arcane::Integer size,
                 const Law::ArrayAccessor& accessor,
                 const Arcane::Integer& begin,
                 const Arcane::Integer& end) const
  {
    // Access to global values container
    auto var_saturation = accessor.values(m_signature.saturation);
    auto var_relativePermeability = accessor.values(m_signature.relativePermeability);
    // Access to global derivatives container
    auto var_deriv_relativePermeability = accessor.derivatives(m_signature.relativePermeability);
    // Resize global outputs
    var_deriv_relativePermeability.resize(size);
    // Allocate local inputs
    Arcane::Real saturation;
    // Allocate local outputs
    Arcane::Real relativePermeability;
    Arcane::Real relativePermeability_wrt_saturation;
    // Allocate local parameters
    // Create derivatives offsets
    auto ofs_saturation = 0;
    // Evaluation loop
    for(Arcane::Integer index = begin; index < end; ++index) {
      // Copy global inputs values to local values
      saturation = var_saturation[index];
      // Copy global parameters values to local values
      // Invoke user kernel
        /*
        m_invoker(
          saturation,relativePermeability,relativePermeability_wrt_saturation
        );
         */
      // Copy local outputs values to global values
      var_relativePermeability[index] = relativePermeability;
      // Copy local outputs derivatives to global derivatives
      var_deriv_relativePermeability[index][ofs_saturation] = relativePermeability_wrt_saturation;
    }
  }

  void _evaluate(Arcane::Integer size,
                 const Law::ScalarAccessor& accessor) const
  {
    // Access to global values container
    auto var_saturation = accessor.values(m_signature.saturation);
    auto var_relativePermeability = accessor.values(m_signature.relativePermeability);
    // Access to global derivatives container
    auto var_deriv_relativePermeability = accessor.derivatives(m_signature.relativePermeability);
    // Resize global outputs
    var_deriv_relativePermeability.resize(size);
    // Allocate local inputs
    Arcane::Real saturation;
    // Allocate local outputs
    Arcane::Real relativePermeability;
    Arcane::Real relativePermeability_wrt_saturation;
    // Allocate local parameters
    // Create derivatives offsets
    auto ofs_saturation = 0;
    {
      // Copy global inputs values to local values
      saturation = var_saturation();
      // Copy global parameters values to local values
      // Invoke user kernel
        /*
        m_invoker(
          saturation,relativePermeability,relativePermeability_wrt_saturation
        );
         */
      // Copy local outputs values to global values
      var_relativePermeability = relativePermeability;
      // Copy local outputs derivatives to global derivatives
      var_deriv_relativePermeability[ofs_saturation] = relativePermeability_wrt_saturation;
    }
  }

//
// split and pass private

public:

  void derivativesCorrection(const Law::VariableAccessor& accessor,
                             const Arcane::ItemGroup& group,
                             Law::PropertyVector graph_dependencies,
                             std::map<Law::Property, Law::PropertyVector> in_composed_derivative_ofs,
                             Arcane::Integer nb_unknown_resize) const
  {
   
    // Derivatives dependencies sizes
    const Arcane::Integer nb_graph_prop = graph_dependencies.size();
    const Arcane::Integer nb_direct_prop = in().size();
    // Access to global derivatives container
    auto var_deriv_relativePermeability = accessor.derivatives(m_signature.relativePermeability);
    // Re order derivatives and nullify before correction
    // Could be done directly in _evaluate method with offset as argument
    {
      Arcane::IntegerUniqueArray static_ofs(nb_direct_prop);
      Arcane::Integer graph_composed_ofs = nb_graph_prop;
      auto in_prop = in();
      Arcane::Integer nb_root_prop = 0;
      for(Arcane::Integer static_index = 0; static_index<nb_direct_prop;++static_index)
      {
        auto prop = in_prop[static_index];
        // Move composed derivatives to the end
        if(in_composed_derivative_ofs.find(prop) != in_composed_derivative_ofs.end())
          static_ofs[static_index] = graph_composed_ofs++;
        // Move root properties to the consistent graph index
        else
        {
          static_ofs[static_index]=graph_dependencies[prop];
          nb_root_prop++;
        }
      }
      // Non root graph derivatives equals zero before correction
      const Arcane::Integer nb_inherited_prop = nb_graph_prop - nb_root_prop;
      Arcane::IntegerUniqueArray inherited_deriv_ofs(nb_inherited_prop);
      Arcane::Integer inherited_index = 0;
      for(Arcane::Integer graph_index = 0; graph_index<nb_graph_prop;++graph_index)
      {
        if(!in_prop.contains(graph_dependencies[graph_index]))
          inherited_deriv_ofs[inherited_index++]=graph_index;
      }
      //
      // Evaluation loop over items
      ENUMERATE_ITEM(iitem, group) {
        Arcane::RealUniqueArray var_deriv_relativePermeability_ini(var_deriv_relativePermeability[iitem].constView());
        for(Arcane::Integer static_index=0;static_index<nb_direct_prop;++static_index)
        {
          var_deriv_relativePermeability[iitem][static_ofs[static_index]] = var_deriv_relativePermeability_ini[static_index];
        }
        for(Arcane::Integer inherited_index=0;inherited_index<nb_inherited_prop;++inherited_index)
        {
          var_deriv_relativePermeability[iitem][inherited_deriv_ofs[inherited_index]]=0;
       }
      }
    }
    //
    // Derivatives correction
    Arcane::Integer direct_composed_index = nb_graph_prop - 1;
    for(auto iter_composed : in_composed_derivative_ofs)
    {
      direct_composed_index++;
      // Derivatives correction through in derivatives properties
      Law::PropertyVector composed_prop_deriv = iter_composed.second;
      Arcane::Integer nb_composed_prop_deriv = composed_prop_deriv.size();
      Arcane::IntegerUniqueArray composed_prop_deriv_ofs(nb_composed_prop_deriv);
      for(Arcane::Integer composed_deriv_index=0;composed_deriv_index<nb_composed_prop_deriv;++composed_deriv_index){
        auto current_in_derived_prop = composed_prop_deriv[composed_deriv_index];
        composed_prop_deriv_ofs[composed_deriv_index] = graph_dependencies[current_in_derived_prop];
      }
      // Only real scalar avalaible in this vesrion (external check)
      Law::Property composed_prop = iter_composed.first;
      Law::ScalarRealProperty& scalar_composed_prop = static_cast<Law::ScalarRealProperty&>(composed_prop);
      // In proproperties has derivatives (external check)
      auto deriv_composed = accessor.derivatives(scalar_composed_prop);
      //
      // Evaluation loop over items
      ENUMERATE_ITEM(iitem, group) {
        auto direct_derivative_relativePermeability = var_deriv_relativePermeability[iitem][direct_composed_index];
        for(auto derived_index = 0; derived_index < nb_composed_prop_deriv; ++derived_index)
        {
          var_deriv_relativePermeability[iitem][composed_prop_deriv_ofs[derived_index]] += direct_derivative_relativePermeability*deriv_composed[iitem][derived_index];
        }
      }
    }
    //
    // Resize to root prop 
    const Arcane::Integer size = nb_unknown_resize;
    // Resize global outputs
    var_deriv_relativePermeability.resize(size);
  }
 

  void derivativesCorrection(const Law::PartialVariableAccessor& accessor,
                             const Arcane::ItemGroup& group,
                             Law::PropertyVector graph_dependencies,
                             std::map<Law::Property, Law::PropertyVector> in_composed_derivative_ofs,
                             Arcane::Integer nb_unknown_resize) const
  {
   
    // Derivatives dependencies sizes
    const Arcane::Integer nb_graph_prop = graph_dependencies.size();
    const Arcane::Integer nb_direct_prop = in().size();
    // Access to global derivatives container
    auto var_deriv_relativePermeability = accessor.derivatives(m_signature.relativePermeability);
    // Re order derivatives and nullify before correction
    // Could be done directly in _evaluate method with offset as argument
    {
      Arcane::IntegerUniqueArray static_ofs(nb_direct_prop);
      Arcane::Integer graph_composed_ofs = nb_graph_prop;
      auto in_prop = in();
      Arcane::Integer nb_root_prop = 0;
      for(Arcane::Integer static_index = 0; static_index<nb_direct_prop;++static_index)
      {
        auto prop = in_prop[static_index];
        // Move composed derivatives to the end
        if(in_composed_derivative_ofs.find(prop) != in_composed_derivative_ofs.end())
          static_ofs[static_index] = graph_composed_ofs++;
        // Move root properties to the consistent graph index
        else
        {
          static_ofs[static_index]=graph_dependencies[prop];
          nb_root_prop++;
        }
      }
      // Non root graph derivatives equals zero before correction
      const Arcane::Integer nb_inherited_prop = nb_graph_prop - nb_root_prop;
      Arcane::IntegerUniqueArray inherited_deriv_ofs(nb_inherited_prop);
      Arcane::Integer inherited_index = 0;
      for(Arcane::Integer graph_index = 0; graph_index<nb_graph_prop;++graph_index)
      {
        if(!in_prop.contains(graph_dependencies[graph_index]))
          inherited_deriv_ofs[inherited_index++]=graph_index;
      }
      //
      // Evaluation loop over items
      ENUMERATE_ITEM(iitem, group) {
        Arcane::RealUniqueArray var_deriv_relativePermeability_ini(var_deriv_relativePermeability[iitem].constView());
        for(Arcane::Integer static_index=0;static_index<nb_direct_prop;++static_index)
        {
          var_deriv_relativePermeability[iitem][static_ofs[static_index]] = var_deriv_relativePermeability_ini[static_index];
        }
        for(Arcane::Integer inherited_index=0;inherited_index<nb_inherited_prop;++inherited_index)
        {
          var_deriv_relativePermeability[iitem][inherited_deriv_ofs[inherited_index]]=0;
       }
      }
    }
    //
    // Derivatives correction
    Arcane::Integer direct_composed_index = nb_graph_prop - 1;
    for(auto iter_composed : in_composed_derivative_ofs)
    {
      direct_composed_index++;
      // Derivatives correction through in derivatives properties
      Law::PropertyVector composed_prop_deriv = iter_composed.second;
      Arcane::Integer nb_composed_prop_deriv = composed_prop_deriv.size();
      Arcane::IntegerUniqueArray composed_prop_deriv_ofs(nb_composed_prop_deriv);
      for(Arcane::Integer composed_deriv_index=0;composed_deriv_index<nb_composed_prop_deriv;++composed_deriv_index){
        auto current_in_derived_prop = composed_prop_deriv[composed_deriv_index];
        composed_prop_deriv_ofs[composed_deriv_index] = graph_dependencies[current_in_derived_prop];
      }
      // Only real scalar avalaible in this vesrion (external check)
      Law::Property composed_prop = iter_composed.first;
      Law::ScalarRealProperty& scalar_composed_prop = static_cast<Law::ScalarRealProperty&>(composed_prop);
      // In proproperties has derivatives (external check)
      auto deriv_composed = accessor.derivatives(scalar_composed_prop);
      //
      // Evaluation loop over items
      ENUMERATE_ITEM(iitem, group) {
        auto direct_derivative_relativePermeability = var_deriv_relativePermeability[iitem][direct_composed_index];
        for(auto derived_index = 0; derived_index < nb_composed_prop_deriv; ++derived_index)
        {
          var_deriv_relativePermeability[iitem][composed_prop_deriv_ofs[derived_index]] += direct_derivative_relativePermeability*deriv_composed[iitem][derived_index];
        }
      }
    }
    //
    // Resize to root prop 
    const Arcane::Integer size = nb_unknown_resize;
    // Resize global outputs
    var_deriv_relativePermeability.resize(size);
  }
 

  void derivativesCorrection(const Law::ArrayAccessor& accessor,
                             const Arcane::Integer& begin,
                             const Arcane::Integer& end,
                             Law::PropertyVector graph_dependencies,
                             std::map<Law::Property, Law::PropertyVector> in_composed_derivative_ofs,
                             Arcane::Integer nb_unknown_resize) const
   {
   
    // Derivatives dependencies sizes
    const Arcane::Integer nb_graph_prop = graph_dependencies.size();
    const Arcane::Integer nb_direct_prop = in().size();
    // Access to global derivatives container
    auto var_deriv_relativePermeability = accessor.derivatives(m_signature.relativePermeability);
    // Re order derivatives and nullify before correction
    // Could be done directly in _evaluate method with offset as argument
    {
      Arcane::IntegerUniqueArray static_ofs(nb_direct_prop);
      Arcane::Integer graph_composed_ofs = nb_graph_prop;
      auto in_prop = in();
      Arcane::Integer nb_root_prop = 0;
      for(Arcane::Integer static_index = 0; static_index<nb_direct_prop;++static_index)
      {
        auto prop = in_prop[static_index];
        // Move composed derivatives to the end
        if(in_composed_derivative_ofs.find(prop) != in_composed_derivative_ofs.end())
          static_ofs[static_index] = graph_composed_ofs++;
        // Move root properties to the consistent graph index
        else
        {
          static_ofs[static_index]=graph_dependencies[prop];
          nb_root_prop++;
        }
      }
      // Non root graph derivatives equals zero before correction
      const Arcane::Integer nb_inherited_prop = nb_graph_prop - nb_root_prop;
      Arcane::IntegerUniqueArray inherited_deriv_ofs(nb_inherited_prop);
      Arcane::Integer inherited_index = 0;
      for(Arcane::Integer graph_index = 0; graph_index<nb_graph_prop;++graph_index)
      {
        if(!in_prop.contains(graph_dependencies[graph_index]))
          inherited_deriv_ofs[inherited_index++]=graph_index;
      }
      //
      // Evaluation loop
      for(Arcane::Integer i = begin; i < end; ++i) {
        Arcane::RealUniqueArray var_deriv_relativePermeability_ini(var_deriv_relativePermeability[i].constView());
        for(Arcane::Integer static_index=0;static_index<nb_direct_prop;++static_index)
        {
          var_deriv_relativePermeability[i][static_ofs[static_index]] = var_deriv_relativePermeability_ini[static_index];
        }
        for(Arcane::Integer inherited_index=0;inherited_index<nb_inherited_prop;++inherited_index)
        {
          var_deriv_relativePermeability[i][inherited_deriv_ofs[inherited_index]]=0;
       }
      }
    }
    //
    // Derivatives correction
    Arcane::Integer direct_composed_index = nb_graph_prop - 1;
    for(auto iter_composed : in_composed_derivative_ofs)
    {
      direct_composed_index++;
      // Derivatives correction through in derivatives properties
      Law::PropertyVector composed_prop_deriv = iter_composed.second;
      Arcane::Integer nb_composed_prop_deriv = composed_prop_deriv.size();
      Arcane::IntegerUniqueArray composed_prop_deriv_ofs(nb_composed_prop_deriv);
      for(Arcane::Integer composed_deriv_index=0;composed_deriv_index<nb_composed_prop_deriv;++composed_deriv_index){
        auto current_in_derived_prop = composed_prop_deriv[composed_deriv_index];
        composed_prop_deriv_ofs[composed_deriv_index] = graph_dependencies[current_in_derived_prop];
      }
      // Only real scalar avalaible in this vesrion (external check)
      Law::Property composed_prop = iter_composed.first;
      Law::ScalarRealProperty& scalar_composed_prop = static_cast<Law::ScalarRealProperty&>(composed_prop);
      // In proproperties has derivatives (external check)
      auto deriv_composed = accessor.derivatives(scalar_composed_prop);
      //
      // Evaluation loop
      for(Arcane::Integer i = begin; i < end; ++i) {
        auto direct_derivative_relativePermeability = var_deriv_relativePermeability[i][direct_composed_index];
        for(auto derived_index = 0; derived_index < nb_composed_prop_deriv; ++derived_index)
        {
          var_deriv_relativePermeability[i][composed_prop_deriv_ofs[derived_index]] += direct_derivative_relativePermeability*deriv_composed[i][derived_index];
        }
      }
    }  
    //
    // Resize to root prop 
    const Arcane::Integer size = nb_unknown_resize;
    // Resize global outputs
    var_deriv_relativePermeability.resize(size);
  }
 

  void derivativesCorrection(const Law::ScalarAccessor& accessor,
                             Law::PropertyVector graph_dependencies,
                             std::map<Law::Property, Law::PropertyVector> in_composed_derivative_ofs,
                             Arcane::Integer nb_unknown_resize) const
  {
   
    // Derivatives dependencies sizes
    const Arcane::Integer nb_graph_prop = graph_dependencies.size();
    const Arcane::Integer nb_direct_prop = in().size();
    // Access to global derivatives container
    auto var_deriv_relativePermeability = accessor.derivatives(m_signature.relativePermeability);
    // Re order derivatives and nullify before correction
    // Could be done directly in _evaluate method with offset as argument
    {
      Arcane::IntegerUniqueArray static_ofs(nb_direct_prop);
      Arcane::Integer graph_composed_ofs = nb_graph_prop;
      auto in_prop = in();
      Arcane::Integer nb_root_prop = 0;
      for(Arcane::Integer static_index = 0; static_index<nb_direct_prop;++static_index)
      {
        auto prop = in_prop[static_index];
        // Move composed derivatives to the end
        if(in_composed_derivative_ofs.find(prop) != in_composed_derivative_ofs.end())
          static_ofs[static_index] = graph_composed_ofs++;
        // Move root properties to the consistent graph index
        else
        {
          static_ofs[static_index]=graph_dependencies[prop];
          nb_root_prop++;
        }
      }
      // Non root graph derivatives equals zero before correction
      const Arcane::Integer nb_inherited_prop = nb_graph_prop - nb_root_prop;
      Arcane::IntegerUniqueArray inherited_deriv_ofs(nb_inherited_prop);
      Arcane::Integer inherited_index = 0;
      for(Arcane::Integer graph_index = 0; graph_index<nb_graph_prop;++graph_index)
      {
        if(!in_prop.contains(graph_dependencies[graph_index]))
          inherited_deriv_ofs[inherited_index++]=graph_index;
      }
      //
      //
      {
        Arcane::RealUniqueArray var_deriv_relativePermeability_ini(var_deriv_relativePermeability.constView());
        for(Arcane::Integer static_index=0;static_index<nb_direct_prop;++static_index)
        {
          var_deriv_relativePermeability[static_ofs[static_index]] = var_deriv_relativePermeability_ini[static_index];
        }
        for(Arcane::Integer inherited_index=0;inherited_index<nb_inherited_prop;++inherited_index)
        {
          var_deriv_relativePermeability[inherited_deriv_ofs[inherited_index]]=0;
       }
      }
    }
    //
    // Derivatives correction
    Arcane::Integer direct_composed_index = nb_graph_prop - 1;
    for(auto iter_composed : in_composed_derivative_ofs)
    {
      direct_composed_index++;
      // Derivatives correction through in derivatives properties
      Law::PropertyVector composed_prop_deriv = iter_composed.second;
      Arcane::Integer nb_composed_prop_deriv = composed_prop_deriv.size();
      Arcane::IntegerUniqueArray composed_prop_deriv_ofs(nb_composed_prop_deriv);
      for(Arcane::Integer composed_deriv_index=0;composed_deriv_index<nb_composed_prop_deriv;++composed_deriv_index){
        auto current_in_derived_prop = composed_prop_deriv[composed_deriv_index];
        composed_prop_deriv_ofs[composed_deriv_index] = graph_dependencies[current_in_derived_prop];
      }
      // Only real scalar avalaible in this vesrion (external check)
      Law::Property composed_prop = iter_composed.first;
      Law::ScalarRealProperty& scalar_composed_prop = static_cast<Law::ScalarRealProperty&>(composed_prop);
      // In proproperties has derivatives (external check)
      auto deriv_composed = accessor.derivatives(scalar_composed_prop);
      //
      // 
      {
        auto direct_derivative_relativePermeability = var_deriv_relativePermeability[direct_composed_index];
        for(auto derived_index = 0; derived_index < nb_composed_prop_deriv; ++derived_index)
        {
          var_deriv_relativePermeability[composed_prop_deriv_ofs[derived_index]] += direct_derivative_relativePermeability*deriv_composed[derived_index];
        }
      }
    }
    //
    // Resize to root prop 
    const Arcane::Integer size = nb_unknown_resize;
    // Resize global outputs
    var_deriv_relativePermeability.resize(size);
  }
 

protected:

  template<typename... T>
  void _evaluate(const Law::EvaluationMode mode, Arcane::Integer static_size, const T&... args) const
  {
    switch(mode)
    {
    case Law::eWithoutDerivative :
      _evaluateOnlyValues(args...);
      break;
    case Law::eWithDerivative :
      if(static_size != 0) {
        _evaluate(static_size, args...);
      } else {
        _evaluate(in().dataSize(), args...);
      }
      break;
    default:
      throw Arcane::FatalErrorException("evaluation case default error");
    }
  }

protected:

  Signature m_signature;

  std::function<
    void(mipp::Reg<Arcane::Real>,mipp::Reg<Arcane::Real>&,mipp::Reg<Arcane::Real>&)
  > m_invoker;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

}

#endif

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
